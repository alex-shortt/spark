import * as e from "three";
import { Loader as Yt, FileLoader as dt, Quaternion as xI, Vector3 as uA, Color as KI, Matrix4 as sI } from "three";
let oA;
function ut(Q) {
  const A = oA.__externref_table_alloc();
  return oA.__wbindgen_export_2.set(A, Q), A;
}
function Ut(Q, A) {
  try {
    return Q.apply(this, A);
  } catch (I) {
    const g = ut(I);
    oA.__wbindgen_exn_store(g);
  }
}
function cI(Q) {
  const A = typeof Q;
  if (A == "number" || A == "boolean" || Q == null)
    return `${Q}`;
  if (A == "string")
    return `"${Q}"`;
  if (A == "symbol") {
    const B = Q.description;
    return B == null ? "Symbol" : `Symbol(${B})`;
  }
  if (A == "function") {
    const B = Q.name;
    return typeof B == "string" && B.length > 0 ? `Function(${B})` : "Function";
  }
  if (Array.isArray(Q)) {
    const B = Q.length;
    let C = "[";
    B > 0 && (C += cI(Q[0]));
    for (let E = 1; E < B; E++)
      C += ", " + cI(Q[E]);
    return C += "]", C;
  }
  const I = /\[object ([^\]]+)\]/.exec(toString.call(Q));
  let g;
  if (I && I.length > 1)
    g = I[1];
  else
    return toString.call(Q);
  if (g == "Object")
    try {
      return "Object(" + JSON.stringify(Q) + ")";
    } catch {
      return "Object";
    }
  return Q instanceof Error ? `${Q.name}: ${Q.message}
${Q.stack}` : g;
}
let wI = 0, MQ = null;
function VQ() {
  return (MQ === null || MQ.byteLength === 0) && (MQ = new Uint8Array(oA.memory.buffer)), MQ;
}
const vQ = typeof TextEncoder < "u" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} }, St = typeof vQ.encodeInto == "function" ? function(Q, A) {
  return vQ.encodeInto(Q, A);
} : function(Q, A) {
  const I = vQ.encode(Q);
  return A.set(I), {
    read: Q.length,
    written: I.length
  };
};
function Lt(Q, A, I) {
  if (I === void 0) {
    const t = vQ.encode(Q), s = A(t.length, 1) >>> 0;
    return VQ().subarray(s, s + t.length).set(t), wI = t.length, s;
  }
  let g = Q.length, B = A(g, 1) >>> 0;
  const C = VQ();
  let E = 0;
  for (; E < g; E++) {
    const t = Q.charCodeAt(E);
    if (t > 127) break;
    C[B + E] = t;
  }
  if (E !== g) {
    E !== 0 && (Q = Q.slice(E)), B = I(B, g, g = E + Q.length * 3, 1) >>> 0;
    const t = VQ().subarray(B + E, B + g), s = St(Q, t);
    E += s.written, B = I(B, g, E, 1) >>> 0;
  }
  return wI = E, B;
}
let _A = null;
function ZI() {
  return (_A === null || _A.buffer.detached === !0 || _A.buffer.detached === void 0 && _A.buffer !== oA.memory.buffer) && (_A = new DataView(oA.memory.buffer)), _A;
}
const PI = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && PI.decode();
function qI(Q, A) {
  return Q = Q >>> 0, PI.decode(VQ().subarray(Q, Q + A));
}
function pt(Q, A, I, g, B, C, E, t, s, o, a) {
  return oA.raycast_splats(Q, A, I, g, B, C, E, t, s, o, a);
}
async function Ht(Q, A) {
  if (typeof Response == "function" && Q instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(Q, A);
      } catch (g) {
        if (Q.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", g);
        else
          throw g;
      }
    const I = await Q.arrayBuffer();
    return await WebAssembly.instantiate(I, A);
  } else {
    const I = await WebAssembly.instantiate(Q, A);
    return I instanceof WebAssembly.Instance ? { instance: I, module: Q } : I;
  }
}
function ft() {
  const Q = {};
  return Q.wbg = {}, Q.wbg.__wbg_buffer_09165b52af8c5237 = function(A) {
    return A.buffer;
  }, Q.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, Q.wbg.__wbg_get_b9b93047fe3cf45b = function(A, I) {
    return A[I >>> 0];
  }, Q.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9 = function(A) {
    let I;
    try {
      I = A instanceof Uint8Array;
    } catch {
      I = !1;
    }
    return I;
  }, Q.wbg.__wbg_length_3b4f022188ae8db6 = function(A) {
    return A.length;
  }, Q.wbg.__wbg_length_6ca527665d89694d = function(A) {
    return A.length;
  }, Q.wbg.__wbg_length_8cfd2c6409af88ad = function(A) {
    return A.length;
  }, Q.wbg.__wbg_length_a446193dc22c12f8 = function(A) {
    return A.length;
  }, Q.wbg.__wbg_length_e2d2a49132c1b256 = function(A) {
    return A.length;
  }, Q.wbg.__wbg_new_405e22f390576ce2 = function() {
    return new Object();
  }, Q.wbg.__wbg_new_9fee97a409b32b68 = function(A) {
    return new Uint16Array(A);
  }, Q.wbg.__wbg_new_a12002a7f91c75be = function(A) {
    return new Uint8Array(A);
  }, Q.wbg.__wbg_new_e3b321dcfef89fc7 = function(A) {
    return new Uint32Array(A);
  }, Q.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(A, I, g) {
    return new Float32Array(A, I >>> 0, g >>> 0);
  }, Q.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(A, I, g) {
    return new Uint32Array(A, I >>> 0, g >>> 0);
  }, Q.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(A) {
    return new Float32Array(A >>> 0);
  }, Q.wbg.__wbg_newwithlength_bd3de93688d68fbc = function(A) {
    return new Uint32Array(A >>> 0);
  }, Q.wbg.__wbg_set_10bad9bee0e9c58b = function(A, I, g) {
    A.set(I, g >>> 0);
  }, Q.wbg.__wbg_set_65595bdd868b3009 = function(A, I, g) {
    A.set(I, g >>> 0);
  }, Q.wbg.__wbg_set_bb8cecf6a62b9f46 = function() {
    return Ut(function(A, I, g) {
      return Reflect.set(A, I, g);
    }, arguments);
  }, Q.wbg.__wbg_set_d23661d19148b229 = function(A, I, g) {
    A.set(I, g >>> 0);
  }, Q.wbg.__wbg_set_f4f1f0daa30696fc = function(A, I, g) {
    A.set(I, g >>> 0);
  }, Q.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(A, I, g) {
    return A.subarray(I >>> 0, g >>> 0);
  }, Q.wbg.__wbg_subarray_769e1e0f81bb259b = function(A, I, g) {
    return A.subarray(I >>> 0, g >>> 0);
  }, Q.wbg.__wbindgen_debug_string = function(A, I) {
    const g = cI(I), B = Lt(g, oA.__wbindgen_malloc, oA.__wbindgen_realloc), C = wI;
    ZI().setInt32(A + 4 * 1, C, !0), ZI().setInt32(A + 4 * 0, B, !0);
  }, Q.wbg.__wbindgen_init_externref_table = function() {
    const A = oA.__wbindgen_export_2, I = A.grow(4);
    A.set(0, void 0), A.set(I + 0, void 0), A.set(I + 1, null), A.set(I + 2, !0), A.set(I + 3, !1);
  }, Q.wbg.__wbindgen_memory = function() {
    return oA.memory;
  }, Q.wbg.__wbindgen_number_new = function(A) {
    return A;
  }, Q.wbg.__wbindgen_string_new = function(A, I) {
    return qI(A, I);
  }, Q.wbg.__wbindgen_throw = function(A, I) {
    throw new Error(qI(A, I));
  }, Q;
}
function mt(Q, A) {
  return oA = Q.exports, _I.__wbindgen_wasm_module = A, _A = null, MQ = null, oA.__wbindgen_start(), oA;
}
async function _I(Q) {
  if (oA !== void 0) return oA;
  typeof Q < "u" && (Object.getPrototypeOf(Q) === Object.prototype ? { module_or_path: Q } = Q : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof Q > "u" && (Q = new URL("data:application/wasm;base64,AGFzbQEAAAABtgItYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AGABfwF/YAN/f38AYAV/f39/fwBgBH9/f38AYAFvAX9gAW8Bb2ADb39/AW9gBX9/f39/AX9gA29vfwBgAABgA39+fgBgA39+fgF/YAd/f39/f39/AX9gBn9/f39/fwBgAX0BfWAEf39/fwF/YAABb2ABfwFvYAZ/f39/f38Bf2AAAX9gC39/f39/f39/f39/AX9gAn9/AW9gAXwBb2ACb38Bb2ADb29vAX9gAn9vAGAHf39/f39/fwBgAn9/AX5gAn9+AX9gAn9+AGALfX19fX19fX1/b38Bb2ABfwF9YAV/f35/fwBgBH9+f38AYAV/f31/fwBgBH99f38AYAV/f3x/fwBgBH98f38AYAR/f29vAX9gA39vbwF/YAJ9fQF9ArcIHgN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ABkDd2JnFV9fd2JpbmRnZW5fbnVtYmVyX25ldwAaA3diZxpfX3diZ19nZXRfYjliOTMwNDdmZTNjZjQ1YgAbA3diZx1fX3diZ19sZW5ndGhfZTJkMmE0OTEzMmMxYjI1NgAIA3diZxpfX3diZ19uZXdfNDA1ZTIyZjM5MDU3NmNlMgAUA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZQAJA3diZxpfX3diZ19zZXRfNjU1OTViZGQ4NjhiMzAwOQAMA3diZx1fX3diZ19sZW5ndGhfYTQ0NjE5M2RjMjJjMTJmOAAIA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAMA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAAIA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAoDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAwDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAgDd2JnMV9fd2JnX25ld3dpdGhi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CwJAIAAoAhAiAkUNAEGousIAQQggAhDVBEUNAEEBDAILIAFBATsBJCABIAQ2AiAgAUEANgIcIAFBAToAGCABQd8ANgIUIAEgBDYCECABQQA2AgwgASAENgIIIAEgAzYCBCABQd8ANgIAIAFBKGogARBQAn8gASgCKEUEQAJAIAEtACUNACABQQE6ACUCQCABLQAkQQFGBEAgASgCICEFIAEoAhwhBAwBCyABKAIgIgUgASgCHCIERg0BCyABKAIEIARqIQMgBSAEawwCC0GwusIAEK4EAAsgASgCHCEEIAEgASgCMDYCHCADIARqIQMgASgCLCAEawshBAJAIAIEQCADIAQgAhDVBA0BCyABQcgAaiABQSBqKQIANwMAIAFBQGsgAUEYaikCADcDACABQThqIAFBEGopAgA3AwAgAUEwaiABQQhqKQIANwMAIAEgASkCADcDKAJAIAEtAE0NACACIQMDQCABKAIsIQUgAUHUAGogAUEoahBQAn8gASgCVEUEQCABLQBNDQMgAUEBOgBNAkAgAS0ATEEBRgRAIAEoAkghBSABKAJEIQQMAQsgASgCSCIFIAEoAkQiBEYNBAsgASgCLCAEaiEGIAUgBGsMAQsgASgCRCEEIAEgASgCXDYCRCAEIAVqIQYgASgCWCAEawshBAJAIANFBEBBACEDDAELQbm2wgBBASADENUEDQMgACgCECICRQRAQQAhAkEAIQMMAQsgAiEDIAYgBCACENUEDQMLIAEtAE1FDQALCyACRQ0BQcC6wgBBAiACENUERQ0BC0EBDAELAkAgACgCECICRQ0AQcK6wgBBAyACENUERQ0AQQEMAQsCQAJAAkAgACgCACIDRQRAQQAhAwwBC0EAIQIDQAJAIAAoAggiBCAAKAIETw0AIAMgBGotAABBxQBHDQAgACAEQQFqNgIIDAILAkAgAkUNACAAKAIQIgNFDQBB9bnCAEECIAMQ1QRFDQBBAQwFCyAAECcNAiACQQFrIQIgACgCACIDDQALQQAhAwsgACgCECIEBEBBAUH1s8IAQQEgBBDVBA0DGiAAKAIAIQMLIANFDQEgACgCCCICIAAoAgRPDQEgAiADai0AAEH1AEcNASAAIAJBAWo2AghBAAwCC0EBDAELAkAgACgCECICRQ0AQcW6wgBBBCACENUERQ0AQQEMAQsgABAnCyAB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AWogBiARGyADa2whAwwDCyABIApBjIHCABCtAgALQZyBwgBBKUHIgcIAEO0CAAtBoP/BAEEXQZyAwgAQ7QIACyAPIAZBAWo2AgAgAkEEaiAJOgAAIAIgAzYCACACQQhqIQIgBCAFQQFqIgVHDQALCyAAQYWAgIB4NgIADwsgBUEBaiEFIAMoAgAhCSADQQRqIQMgCUEATA0ACyAFQQFrIQxBACEDA0ACQCACIAZJBEAgA0EBaiEDIAsgAkEDdGogDDoABQNAIAIgDWogDnEiAiAETw0ACwwBCyACIAZB2IHCABCtAgALIAMgCUcNAAsMAAsAC9IHAQN/AkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAOCgAHBwECAwQHBwUHCwJAAkACQAJAAkACQCAALQAEDgcADAEMAgMEDAsgAC0ACEEDRw0LIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQQgASADIAIoAggQpwQMBAsgAC0ACEEDRw0KIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQMgASADIAIoAggQpwQMAwsgAC0ACEEDRw0JIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQIgASADIAIoAggQpwQMAgsgAC0ACEEDRw0IIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQEgASADIAIoAggQpwQMAQsgAC0ACEEDRw0HIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQAgASADIAIoAggQpwQLIABBDEEEEKcEDwsCQAJAIAAtAAQOAgcBAAsgACgCCCIBQfv///8HaiICQQ1NIAJBAkdxDQYgAUGEgICAeEoNBSABQYOAgIB4Rw0GDAULIAAoAggiAUGEgICAeEogAUGDgICAeEZyDQQMBQsgAC0ABEEDRw0EDAULAkACQEEDIAAoAgQiAUEHayICIAJBA08bQQJrDgIBAAULAkACQAJAIAEOBgAHAQcHAgcLIAAtAAhBA0cNBgwICyAAKAIIIgFB7f///wdqIgJBCk0gAkEDR3ENBSABRSABQfv///8H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wQA2AgggAkIBNwIUIAIgAkEEaq1CgICAgJA4hDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwICyACIAA2AgQgAkEBNgIMIAJB8KfBADYCCCACQgE3AhQgAiACQQRqrUKAgICAoDeENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAcLIAIgAEEEajYCBCACQQE2AgwgAkHwp8EANgIIIAJCATcCFCACIAJBBGqtQoCAgICgOIQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEUMBgsgASgCHEHFusEAQTkgASgCICgCDBECAAwFCyACIABBBGo2AgQgAkECNgIMIAJBqLvBADYCCCACQgE3AhQgAiACQQRqrUKAgICA8DWENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAQLIAIgAEEEajYCACACIABBCGo2AgQgAkEDNgIMIAJB6LvBADYCCCACQgI3AhQgAkKAgICA8DUiBCACrYQ3AyggAiAEIAJBBGqthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwDCyACIABBBGo2AgQgAkECNgIMIAJB8LzBADYCCCACQgE3AhQgAiACQQRqrUKAgICAsDiENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAILIAIgAEEEajYCACACIABBCGo2AgQgAkECNgIMIAJBsL3BADYCCCACQgI3AhQgAkKAgICAwDgiBCACQQRqrYQ3AyggAiAEIAKthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwBCyACIABBBGo2AgAgAiAAQQhqNgIEIAJBAjYCDCACQfS9wQA2AgggAkICNwIUIAJCgICAgPA1IgQgAkEEaq2ENwMoIAIgBCACrYQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEULIAJBMGokAAuXBgEIfyMAQTBrIgEkAAJAAn8CQAJAAkAgACgCACIFBEAgACgCCCIEIAQgACgCBCIHIAQgB0sbayEIIAUhAwNAIAIgCGpFDQMgACACIARqQQFqNgIIIAJBAWohAiADIARqIANBAWohAy0AACIGQTBrQf8BcUEKSSAGQeEAa0H/AXFBBklyDQALIAZB3wBHDQIgAiAEakEBayEGAkAgBARA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IABBABAgDAELIAAQJwsgBEEQaiQAC5QDAQR/AkAgAkEQSQRAIAAhAwwBCwJAIABBACAAa0EDcSIFaiIEIABNDQAgACEDIAUEQCAFIQYDQCADIAE6AAAgA0EBaiEDIAZBAWsiBg0ACwsgBUEBa0EHSQ0AA0AgAyABOgAAIANBB2ogAToAACADQQZqIAE6AAAgA0EFaiABOgAAIANBBGogAToAACADQQNqIAE6AAAgA0ECaiABOgAAIANBAWogAToAACADQQhqIgMgBEcNAAsLIAQgAiAFayICQXxxaiIDIARLBEAgAUH/AXFBgYKECGwhBQNAIAQgBTYCACAEQQRqIgQgA0kNAAsLIAJBA3EhAgsCQCADIAIgA2oiBU8NACACQQdxIgQEQANAIAMgAToAACADQQFqIQMgBEEBayIEDQALCyACQQFrQQdJDQADQCADIAE6AAAgA0EHaiABOgAAIANBBmogAToAACADQQVqIAE6AAAgA0EEaiABOgAAIANBA2ogAToAACADQQJqIAE6AAAgA0EBaiABOgAAIANBCGoiAyAFRw0ACwsgAAudAwIGfwF+QTggAUH/AXEiASABQThPGyECAkAgACgCECIEIAAtABQiAWoiA0EASgRAIAIgA0sNAQJAIARBAEwgASACT3INAANAIARBAWsiBUEDdiEGQcAAIAFBB2oiB0F4cWshAwJAIAVBP00EQCAAIAYgAxCIASAAKAIQIQQgAC0AFCEBDAELAkAgACgCBCIFIAYgB0H4AXFBA3ZqQQdrIgZPBEAgBSAGayIFQQdLDQFBCCAFQcTewQAQqwQACyAGIAVB1N7BABCqBAALIAAgASADaiIBOgAUIAAgBCADQf8BcWsiBDYCECAAIAAoAgAgBmopAAA3AwgLIAFB/wFxIAJPDQEgBEEASg0ACwsgACABIAJrIgE6ABRCfyACrYZCf4UgACkDCCABQT9xrYiDDwsgACAEIAJrNgIQQgAPCyACIANrIQICQCADQf8BcSABSwRAIAAgAxBbIQggACgCECEEDAELIAAgASADayIBOgAUQn8gA62GQn+FIAApAwggAUE/ca2IgyEICyAAIAQgAms2AhAgCCACQT9xrYYLnAMBBX8CQEERQQAgAEGvsARPGyIBIAFBCHIiASAAQQt0IgIgAUECdEH82sIAaigCAEELdEkbIgEg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AEEEaiACKAIEIAIoAggQPUHcoMIAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARDaASAAQRBqJAALZgAjAEEwayIAJABBhOXCAC0AAARAIABBAjYCDCAAQYyhwgA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIAQhDcDICAAIABBIGo2AhAgAEEIakG0ocIAEKQDAAsgAEEwaiQAC2EBAX8jAEEwayICJAAgAiAANgIMIAJBAjYCFCACQZymwQA2AhAgAkIBNwIcIAIgAkEMaq1CgICAgOA0hDcDKCACIAJBKGo2AhggASgCHCABKAIgIAJBEGoQRSACQTBqJAALYQEBfyMAQTBrIgIkACACIAA2AgwgAkECNgIUIAJB5K7BADYCECACQgE3AhwgAiACQQxqrUKAgICA4DSENwMoIAIgAkEoajYCGCABKAIcIAEoAiAgAkEQahBFIAJBMGokAAthAQF/IwBBMGsiAiQAIAIgADYCDCACQQE2AhQgAkHwp8EANgIQIAJCATcCHCACIAJBDGqtQoCAgICQOIQ3AyggAiACQShqNgIYIAEoAhwgASgCICACQRBqEEUgAkEwaiQAC18BAn8CQCAAKAIAIgFB7f///wdqIgJBCk0gAkEDR3ENACABRSABQfv///8HaiICQQ1NIAJBAkdxIAFBg4CAgHhHIAFBhICAgHhMcXJyDQAgACgCBCABQQJ0QQQQpwQLC1wBA38gAC0AACIBQQNLIAFBA0dyRQRAIAAoAgQiACgCACEBIABBBGooAgAiAygCACICBEAgASACEQMACyADKAIEIgIEQCABIAIgAygCCBCnBAsgAEEMQQQQpwQLC2sBAn9BqJbAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EEa0H/AXFBA0kbQQFrDgMAAQIDC0EAIQEMAgsgAUEBaiEBQdStwAAhAgwBCyABQQRqIQFBkK7AACECCyAAIAI2AgQgACABNgIAC2gBA38CQAJAAkACQEEDIAEoAgBB7f///wdqIgQgBEELTxtBAmsOAwABAgMLIAFBBGohAkGcm8AAIQMMAgtB2LPAACEDIAEhAgwBCyABQQRqIQJBjLXAACEDCyAAIAM2AgQgACACNgIAC2sBAn9B1LfAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EE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AX8jAEEQayICJAAgAiAANgIMIAFB8b3AAEEWQYe+wABBAyACQQxqQay7wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBic7AAEEbQcC8wABBAyACQQxqQay7wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBrODAAEERQb3gwABBBCACQQxqQZzgwAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBweDAAEEWQdfgwABBAyACQQxqQfjawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8fDAAEEbQZDfwABBAyACQQxqQfjawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8IjBAEERQYGJwQBBBCACQQxqQeCIwQAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBhYnBAEEWQZuJwQBBAyACQQxqQcCGwQAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBhZfBAEEbQdSHwQBBAyACQQxqQcCGwQAQyQEgAkEQaiQACzwBAX8jAEEQayICJAAgAkGQksIANgIMIAIgADYCCCACQQhqQZSSwgAgAkEMakGUksIAIAFB5J/CABBrAAs4AQF/IwBBEGsiAiQAIAIgADYCDCABQeywwgBBDUH5sMIAQQQgAkEMakHcsMIAEMkBIAJBEGokAAs5AQF/IwBBEGsiAyQAIAMgATYCDCADIAA2AgggA0EIakGswsIAIANBDGpBrMLCACACQeyOwgAQawALMAEBfyMAQRBrIgIkACACQQhqIAAQ8wIgAigCCCABIAIoAgwoAhARAAAgAkEQaiQACzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEMUBDwsgACABEPwBDwsgACABEP0BCzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEK0EDwsgACABEIQCDwsgACABEIMCCzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEKkDDwsgACABEIQCDwsgACABEIMCCzMBAX8jAEEQayICJAAgAiAAKAIANgIMIAFB7IfBAEEMIAJBDGpB3IfBABB/IAJBEGokAAszAQF/IwBBEGsiAiQAIAIgACgCADYCDCABQejUwQBBDCACQQxqQdjUwQAQfyACQRBqJAALLQACQCAAIAEQrANFDQAgAARAQYXlwgAtAAAaIAAgARD1AyIBRQ0BCyABDwsACzcBAX8jAEEgayIBJAAgAUEANgIYIAFBATYCDCABQdzZwgA2AgggAUIENwIQIAFBCGogABCkAwALMwEBfyAAKAIAIgFBhICAgHhMIAFBg4CAgHhHcSABRXJFBEAgACgCBCABQQJ0QQQQpwQLCzABAX8jAEEQayICJAAgAiAANgIMIAFBxJnAAEEMIAJBDGpBtJnAABB/IAJBEGokAAsvACAAQZybwAA2AgQgACABIAFBACABLQAAQQJrQf8BcSIAQQFGGyAAQQJLGzYCAAswAQF/IwBBEGsiAiQAIAIgADYCDCABQdi8wABBDCACQQxqQci8wAAQfyACQRBqJAALLwAgAEGwvsAANgIEIAAgASABQQAgAS0AAEECa0H/AXEiAEEBRhsgAEECSxs2AgALMAEBfyMAQRBrIgIkACACIAA2AgwgAUGo38AAQQwgAkEMakGY38AAEH8gAkEQaiQACy8AIABBgOHAADYCBCAAIAEgAUEAIAEtAABBAmtB/wFxIgBBAUYbIABBAksbNgIACy8AIABBxInBADYCBCAAIAEgAUEAIAEtAABBAmtB/wFxIgBBAUYbIABBAksbNgIACzABAX8jAEEQayICJAAgAiAANgIMIAFB7IfBAEEMIAJBDGpB3IfBABB/IAJBEGokAAssAQF/IwBBEGsiACQAIABBCGoiAiABQfyVwgBBCxCmAyACEK4CIABBEGokAAuEAQEDfyMAQSBrIgQkACAEQQhqIgMQ8AECf0GF5cIALQAAGkEkQQQQ9QMiAgRAIAJB5LrAADYCACACIAE2AiAgAiAANgIcIAIgAykCADcCBCACQQxqIANBCGopAgA3AgAgAkEUaiADQRBqKQIANwIAIAIMAQtBBEEkENMEAAsgBEEgaiQACzgBAX9BASEBIAAtAARFBEAgACgCACIBKAIcQY7EwgBBASABKAIgKAIMEQIAIQELIAAgAToABCABC5ABAQN/IwBBIGsiAyQAIANBCGoiAhDwAQJ/QYXlwgAtAAAaQShBBBD1AyIBBEAgAUGcgsAANgIAIAEgAikCADcCBCABIAApAgA3AhwgAUEMaiACQQhq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NgIMIABBhKLCACABKAIEIAEoAggiAC0ACCAALQAJEMEBAAsgACADNgIEIAAgAjYCACAAQeihwgAgASgCBCABKAIIIgAtAAggAC0ACRDBAQALKgAgAEH/AXFFBEBDAAAAAA8LIABBAWtB/wFxs0NFIpE9lEMAABDBkhBSCy0AIAEoAhwgAiADIAEoAiAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAsyAQF/IAEoAhxBvMHCAEEBIAEoAiAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAshAAJAIAEgAxCsAwRAIAAgASADIAIQ3wMiAA0BCwALIAALIgEBfyAAKAIAIgAgAEEfdSICcyACayAAQX9zQR92IAEQbAslACAARQRAQfiPwgBBMhDIBAALIAAgAiADIAQgBSABKAIQEQsACygAIAEgACgCAC0AAEECdCIAQeC8wgBqKAIAIABBzLzCAGooAgAQ5QMLGQEBf0GAgICAeCABayAATyACIAFpQQFGGwslACABIAAtAABBAnQiAEH8tcAAaigCACAAQey1wABqKAIAEOUDCyUAIABBnJvAADYCBCAAIAFBBGpBACABKAIAQYKAgIB4Rhs2AgALIQAgAEHwosAANgIEIAAgAUEBakEAIAEtAABBAkYbNgIACyUAIAEgAC0AAEECdCIAQZDZwABqKAIAIABBgNnAAGooAgAQ5QMLJQAgAEGwvsAANgIEIAAgAUEEakEAIAEoAgBBgoCAgHhGGzYCAAshACAAQYTGwAA2AgQgACABQQFqQQAgAS0AAEECRhs2AgALJQAgASAALQAAQQJ0IgBB+PvAAGooAgAgAEHo+8AAaigCABDlAwslACAAQYDhwAA2AgQgACABQQRqQQAgASgCAEGCgICAeEYbNgIACyEAIABBsOjAADYCBCAAIAFBAWpBACABLQAAQQJGGzYCAAshACAAQbSOwQA2AgQgACABQQFqQQAgAS0AAEECRhs2AgALJQAgAEHEicEANgIEIAAgAUEEakEAIAEoAgBBgoCAgHhGGzYCAAslACABIAAtAABBAnQiAEGMosEAaigCACAAQfyhwQBqKAIAEOUDCyMAIABFBEBB+I/CAEEyEMgEAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBB+I/CAEEyEMgEAAsgACACIAMgBCAB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BBD1AyILBEACQEGF5cIALQAAGkGACEEEEPUDIghFDQJBheXCAC0AABpBgAhBBBD1AyIERQ0AQYXlwgAtAAAaQYAIQQQQ9QMiDkUNAkGF5cIALQAAGkGACEEEEPUDIgxFDQBBheXCAC0AABpBgAhBBBD1AyISRQ0CIANCADcDqAIgA0EBNgLoASADQQA6AOQBIANBADoA4gEgA0EAOgDgASADQTQ7AdwBIANBADYC2AEgAyASNgLUASADQoCAgICAIDcCzAEgAyAMNgLIASADQoCAgICAIDcDwAEgA0KAgICAwAA3A7gBIANBIzsBtAEgA0EANgKwASADIA42AqwBIANCgICAgIAgNwKkASADIAQ2AqABIANCgICAgIAgNwOYASADQoCAgIDAADcDkAEgA0EfOwGMASADQQA2AogBIAMgCDYChAEgA0KAgICAgCA3AnwgAyALNgJ4IANCgICAgIAgNwNwIANCgICAgMAANwNoIANBwAJqQgA3AwAgA0G4AmpCADcDACADQbACakIANwMAIANB/AFqQQA2AgAgA0H0AWpCADcCACADQgA3AuwBIANC1uuC7ur9ifXgADcDgAIgA0LP1tO+0ser2UI3A4gCIANCADcDkAIgA0L56tDQ58mh5OEANwOYAiADQgA3A6ACIANBADYCyAIgA0IANwPQAiADIAY2AtgCIANBADYC5AIgA0EINgKUAyADQoCAgIAQNwLcAiADQoGAgIDAADcCjAMgA0EANgKIAyADQoCAgIAQNwPoAiADQgA3A/ACIANCBDcD+AIgA0KAgICAEDcDgAMMAwsLQQRBgAhBzIDCABDXAwALQQRBgAhB3IDCABDXAwALIAdBADYCqAcgB0EANgKwByAHQQA6ANwKIAdBADYC2AogByAjNwPQCiAHKQOoByEgIAcpA7AHISMgB0HoA2oiBiADQagDEDsaIAdBCGoQSSAHICM3AyggByAgNwMgIAcgITcDGCAHIA02AgwgByAiPgIQIAcgIkIgiD4CFCAHIAU2AgggB0EwaiAGQagDEDshCCAFQQFxBEBBDCEQIAcoAtgDIhJFDQEgBygC3AMhFwNAIBJB1AFrIQQgEkEEaiEGIBIvAd4WIgNBAnQhC0F/IQUCQAJAA0AgC0UEQCADIQUMAgsgBigCACEOIAVBAWohBSAEQYQCaiEEIAtBBGsh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EwAgAEHMuMAANgIEIAAgATYCAAsTACAAQYi5wAA2AgQgACABNgIACxMAIABBxLnAADYCBCAAIAE2AgALEwAgAEGAusAANgIEIAAgATYCAAsTACAAQbC+wAA2AgQgACABNgIACxMAIABBKDYCBCAAQYjbwAA2AgALEwAgAEGA4cAANgIEIAAgATYCAAshACAAQqTFo/yfjvDjADcDCCAAQqqooLmusOaw6QA3AwALEAAgACgCACAAKAIEIAEQMAsRACAAKAIAIAAoAgQgARDVBAsiACAAQsuH6/rgqLu20AA3AwggAELEr9zF2tKv9bh/NwMACxMAIABBKDYCBCAAQcCFwQA2AgALEwAgAEHEicEANgIEIAAgATYCAAsgACAAQrz8k7Ko16DsTDcDCCAAQuuYqJm2gbKefzcDAAshACAAQriynYTMrpfUQjcDCCAAQu/Dv6KOjcrEoH83AwALIAAgAEKcnaLxgrvwoHU3AwggAELRqsqvpcqt8kA3AwALIQAgAEL7wqCWlfy/yHo3AwggAELmsfLlkYe/ybF/NwMACyIAIABC9auQ77TsvKaWfzcDCCAAQrHh7P30uYbLwgA3AwALIAAgAELNnq77nqC2sEE3AwggAELxps+Y0aSn/gE3AwALIAAgAEK3v8ue+N2SoEM3AwggAEKvuaX0x5vV+zA3AwALIQAgAEKWl7rs79nZo3Q3AwggAEKH+OXLhuPSwtQANwMACyEAIABC/O6Qyq7osdU1NwMIIABC2OvVj+a1zN2OfzcDAAshACAAQrzprN2Y1v7ui383AwggAEKk3Nqt0/nNwEU3AwALIQAgAELl6obQ6cP/7Xk3AwggAEL30OLk1cPQ6ad/NwMACyEAIABC5sHsgPKk3YtlNwMIIABChu7u8+efmIeefzcDAAshACAAQs7Is8mT6a+2pX83AwggAELt66KMv7HLkg83AwALIgAgAEKcrtGn56WAwMIANwMIIABC16rLiaf+wYLHADcDAAsiACAAQt3+weC9o+rogn83AwggAEKX2/aYrfP7zY5/NwMACyEAIABCgsDc4LCv07mnfzcDCCAAQpbk17fDtcOKAzcDAAshACAAQrvV0cb1jfDEkH83AwggAELVi9bpuKS4kXk3AwALIQAgAEKynOer2rGju98ANwMIIABCvfif/8L+hsNVNwMACyIAIABC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ZXJFcnJvcgAAAAAEAAAABAAAAE4AAABGcmFtZUhlYWRlckVycm9yV2luZG93U2l6ZVRvb0JpZwAAAAAEAAAABAAAAE8AAABEaWN0aW9uYXJ5RGVjb2RlRXJyb3IAAAAAAAAABAAAAAQAAABQAAAARmFpbGVkVG9SZWFkQmxvY2tIZWFkZXIAAAAAAAQAAAAEAAAAUQAAAEZhaWxlZFRvUmVhZEJsb2NrQm9keQAAAAAAAAAEAAAABAAAAFIAAABGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAAAAQAAAAEAAAAUwAAAEZTRURlY29kZXJFcnJvcgAAAAAABAAAAAQAAABUAAAARlNFVGFibGVFcnJvclNvdXJjZUlzRW1wdHlOb3RFbm91Z2hCeXRlc0ZvcldlaWdodHNnb3RfYnl0ZXNleHBlY3RlZF9ieXRlcwAAAAAAAAAEAAAABAAAAFUAAABFeHRyYVBhZGRpbmdza2lwcGVkX2JpdHNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c2hhdmVGU0VUYWJsZVVzZWRUb29NYW55Qnl0ZXN1c2VkYXZhaWxhYmxlX2J5dGVzTm90RW5vdWdoQnl0ZXNJblNvdXJjZVdlaWdodEJpZ2dlclRoYW5NYXhOdW1CaXRzTWF4Qml0c1Rvb0hpZ2gAAAAAAQAAAAEAAABWAAAAAAAAAAEAAAABAAAAVwAAAFYAAABgERAAWAAAAFkAAABaAAAAWwAAAFwAAABVbnN1cHBvcnRlZE9mZnNldG9mZnNldF9jb2RlWmVyb09mZnNldE5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzAAAAAAAEAAAABAAAAF0AAABFeHRyYUJpdHNiaXRzX3JlbWFpbmluZ01pc3NpbmdDb21wcmVzc2lvbk1vZGVNaXNzaW5nQnl0ZUZvclJsZUxsVGFibGVNaXNz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ZXJFcnJvcgAAAAAEAAAABAAAAE4AAABGcmFtZUhlYWRlckVycm9yV2luZG93U2l6ZVRvb0JpZwAAAAAEAAAABAAAAE8AAABEaWN0aW9uYXJ5RGVjb2RlRXJyb3IAAAAAAAAABAAAAAQAAABQAAAARmFpbGVkVG9SZWFkQmxvY2tIZWFkZXIAAAAAAAQAAAAEAAAAUQAAAEZhaWxlZFRvUmVhZEJsb2NrQm9keQAAAAAAAAAEAAAABAAAAFIAAABGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAAAAQAAAAEAAAAUwAAAEZTRURlY29kZXJFcnJvcgAAAAAABAAAAAQAAABUAAAARlNFVGFibGVFcnJvclNvdXJjZUlzRW1wdHlOb3RFbm91Z2hCeXRlc0ZvcldlaWdodHNnb3RfYnl0ZXNleHBlY3RlZF9ieXRlcwAAAAAAAAAEAAAABAAAAFUAAABFeHRyYVBhZGRpbmdza2lwcGVkX2JpdHNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c2hhdmVGU0VUYWJsZVVzZWRUb29NYW55Qnl0ZXN1c2VkYXZhaWxhYmxlX2J5dGVzTm90RW5vdWdoQnl0ZXNJblNvdXJjZVdlaWdodEJpZ2dlclRoYW5NYXhOdW1CaXRzTWF4Qml0c1Rvb0hpZ2gAAAAAAQAAAAEAAABWAAAAAAAAAAEAAAABAAAA/wAAAFYAAAD0IhAAAAEAAFkAAAABAQAAWwAAAAIBAABVbnN1cHBvcnRlZE9mZnNldG9mZnNldF9jb2RlWmVyb09mZnNldE5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzAAAAAAAEAAAABAAAAF0AAABFeHRyYUJpdHNiaXRzX3JlbWFpbmluZ01pc3NpbmdDb21wcmVzc2lvbk1vZGVNaXNzaW5nQnl0ZUZvclJsZUxsVGFibGVNaXNz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bEVuY29kaW5nSW52YWxpZENoYXJFbmNvZGluZwAAAAAAAAAEAAAABAAAAEEAAABJbnZhbGlkVGFnRW5jb2RpbmdEZXNlcmlhbGl6ZUFueU5vdFN1cHBvcnRlZFNpemVMaW1pdFNlcXVlbmNlTXVzdEhhdmVMZW5ndGgAAAAAAAQAAAAEAAAANQEAAEN1c3RvbU5vbmVTb21lUmF3UkxFQ29tcHJlc3NlZFJlc2VydmVkAAAAAAAABAAAAAQAAAA2AQAAVG9vTWFueUJpdHNudW1fcmVxdWVzdGVkX2JpdHNsaW1pdE5vdEVub3VnaFJlbWFpbmluZ0JpdHNyZXF1ZXN0ZWRyZW1haW5pbmdBY2NMb2dJc1plcm8AAAAAAAABAAAAAQAAADcBAABBY2NMb2dUb29CaWdnb3RtYXgAAAAAAAAEAAAABAAAAEMAAABHZXRCaXRzRXJyb3IAAAAABAAAAAQAAAA4AQAAAAAAAAQAAAAEAAAARQAAAFByb2JhYmlsaXR5Q291bnRlck1pc21hdGNoZXhwZWN0ZWRfc3Vtc3ltYm9sX3Byb2JhYmlsaXRpZXNUb29NYW55U3ltYm9scwAAAAAEAAAABAAAAEYAAABCbG9ja1NpemVUb29MYXJnZXNpemVJbnZhbGlkQmxvY2t0eXBlTnVtYmVybnVtVGFibGVJc1VuaW5pdGlhbGl6ZWQAAAAAAAAMAAAABAAAAEcAAAAAAAAADAAAAAQAAAA5AQAARwAAAHAwEAA6AQAASQAAADsBAABKAAAAPAEAAAAAAAAEAAAABAAAAEsAAABXaW5kb3dUb29CaWdXaW5kb3dUb29TbWFsbAAAAAAAAAQAAAAEAAAATAAAAEZyYW1lRGVzY3JpcHRvckVycm9yRGljdElkVG9vU21hbGxleHBlY3RlZE1pc21hdGNoZWRGcmFtZVNpemVGcmFtZVNpemVJc1plcm9JbnZhbGlkRnJhbWVTaXplTm90RW5vdWdoQnl0ZXNJbkRpY3Rpb25hcnluZWVkT2Zmc2V0VG9vQmlnb2Zmc2V0YnVmX2xlbgAAAAAABAAAAAQAAABNAAAAUmVhZEZyYW1lSGVhZGVyRXJyb3IAAAAABAAAAAQAAABOAAAARnJhbWVIZWFkZXJFcnJvcldpbmRvd1NpemVUb29CaWcAAAAABAAAAAQAAABPAAAARGljdGlvbmFyeURlY29kZUVycm9yAAAAAAAAAAQAAAAEAAAAUAAAAEZhaWxlZFRvUmVhZEJsb2NrSGVhZGVyAAAAAAAEAAAABAAAAFEAAABGYWlsZWRUb1JlYWRCbG9ja0JvZHlGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAABAAAAAQAAABTAAAARlNFRGVjb2RlckVycm9yAAAAAAAEAAAABAAAAFQAAABGU0VUYWJsZUVycm9yU291cmNlSXNFbXB0eU5vdEVub3VnaEJ5dGVzRm9yV2VpZ2h0c2dvdF9ieXRlc2V4cGVjdGVkX2J5dGVzRXh0cmFQYWRkaW5nc2tpcHBlZF9iaXRzVG9vTWFueVdlaWdodHNNaXNzaW5nV2VpZ2h0c0xlZnRvdmVySXNOb3RBUG93ZXJPZjJOb3RFbm91Z2hCeXRlc1RvRGVjb21wcmVzc1dlaWdodHNoYXZlRlNFVGFibGVVc2VkVG9vTWFueUJ5dGVzdXNlZGF2YWlsYWJsZV9ieXRlc05vdEVub3VnaEJ5dGVzSW5Tb3VyY2VXZWlnaHRCaWdnZXJUaGFuTWF4TnVtQml0c01heEJpdHNUb29IaWdoAAAAAAAAAAEAAAABAAAAVgAAAAAAAAABAAAAAQAAAD0BAABWAAAAIDQQAD4BAABZAAAAPwEAAFsAAABAAQAAVW5zdXBwb3J0ZWRPZmZzZXRvZmZzZXRfY29kZVplcm9PZmZzZXROb3RFbm91Z2hCeXRlc0Zvck51bVNlcXVlbmNlcwAAAAAABAAAAAQAAABdAAAARXh0cmFCaXRzYml0c19yZW1haW5pbmdNaXNzaW5nQ29tcHJlc3Npb25Nb2RlTWlzc2luZ0J5dGVGb3JSbGVMbFRhYmxlTWlzc2luZ0J5dGVGb3JSbGVPZlRhYmxlTWlzc2luZ0J5dGVGb3JSbGVNbFRhYmxlAAAAQQEAAAwAAAAEAAAAXwAAAEEBAAAMAAAABAAAAEIBAABfAAAAKDUQAEMBAABiAAAAOwEAAGMAAAA8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YWxzbmVlZGVkAAAAAAAABAAAAAQAAABjAQAAQml0c3RyZWFtUmVhZE1pc21hdGNocmVhZF90aWxEZWNvZGVkTGl0ZXJhbENvdW50TWlzbWF0Y2hkZWNvZGVkAGQBAAAUAAAABAAAALQAAABkAQAAFAAAAAQAAABlAQAAtAAAAMQ8EABmAQAAtwAAADsBAAC4AAAAPAEAAAAAAAAMAAAABAAAALkAAAAAAAAADAAAAAQAAABnAQAAuQAAAAA9EAA6AQAAuwAAADsBAABKAAAAPAEAAGgBAAAYAAAABAAAAL0AAABoAQAAGAAAAAQAAABpAQAAvQAAADw9EABqAQAAwAAAADsBAADBAAAAPAEAAAAAAAAMAAAABAAAAMIAAAAAAAAADAAAAAQAAABrAQAAwgAAAHg9EABsAQAAxQAAADsBAADGAAAAPAEAAElsbGVnYWxMaXRlcmFsU2VjdGlvblR5cGVOb3RFbm91Z2hCeXRlc25lZWRfYXRfbGVhc3QDAAAAAwAAAAoAAAAIAAAA8i4QAPUuEAD4LhAAAi8QAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMAAAAIPhAAbQAAACoCAAARAAAAYW4gYXJyYXkgb2YgbGVuZ3RoIDQAAAAAAAAAAAEAAABtAQBBtP3AAAv1KAEAAABtAQAAAAAAAAgAAAAEAAAAbgEAAHN0cnVjdCBXbGcwSGVhZGVyIHdpdGggNyBlbGVtZW50cwAAAMw+EAAhAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogaW52YWxpZCBPbmNlIHN0YXRl+D4QADwAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvb25jZS9ub190aHJlYWRzLnJzPD8QAHwAAAA1AAAAEgAAAGZhaWxlZCB0byBmaWxsIHdob2xlIGJ1ZmZlcgDIPxAAGwAAACUAAAACAAAA5D8QAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZGVjb2RpbmcvYmxvY2tfZGVjb2Rlci5yc0J1ZyBpbiB0aGlzIGxpYnJhcnkA+D8QAGwAAACYAAAAFgAAAFdyb25nIG51bWJlciBvZiBsaXRlcmFsczogLCBTaG91bGQgaGF2ZSBiZWVuOiAAAIhAEAAaAAAAokAQABQAAAD4PxAAbAAAAK0AAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogYnl0ZXNfdXNlZF9pbl9saXRlcmFsc19zZWN0aW9uID09IHVwcGVyX2xpbWl0X2Zvcl9saXRlcmFscyBhcyB1MzIA+D8QAGwAAACzAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHUzMjo6ZnJvbShieXRlc19pbl9saXRlcmFsc19oZWFkZXIpICsgYnl0ZXNfdXNlZF9pbl9saXRlcmFsc19zZWN0aW9uICsKICAgICAgICAgICAgdTMyOjpmcm9tKGJ5dGVzX2luX3NlcXVlbmNlX2hlYWRlcikgKyByYXcubGVuKCkgYXMgdTMyID09CiAgICBoZWFkZXIuY29udGVudF9zaXplAAD4PxAAbAAAAMEAAAAJAAAA+D8QAGwAAAC6AAAAFwAAAPg/EABsAAAAiwAAABcAAABIb3cgZGlkIHlvdSBldmVuIGdldCB0aGlzLiBUaGUgZGVjb2RlciBzaG91bGQgZXJyb3Igb3V0IGlmIGl0IGRldGVjdHMgYSByZXNlcnZlZC10eXBlIGJsb2NrAPg/EABsAAAAcAAAABEAAABmYWlsZWQgdG8gZmlsbCB3aG9sZSBidWZmZXIAkEIQABsAAAAlAAAAAgAAAKxCEABkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5AAAAAAQAAAAEAAAAbwEAAAAAAAAEAAAABAAAAHABAABVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlblJhd1JMRUNvbXByZXNzZWRSZXNlcnZlZAAAAAAAAAAEAAAABAAAAEAAAABUb29NYW55Qml0c251bV9yZXF1ZXN0ZWRfYml0c2xpbWl0AAAAAAAABAAAAAQAAABBAAAATm90RW5vdWdoUmVtYWluaW5nQml0c3JlcXVlc3RlZHJlbWFpbmluZ0FjY0xvZ0lzWmVybwAAAAABAAAAAQAAAHEBAABBY2NMb2dUb29CaWdnb3RtYXgAAAAAAAAEAAAABAAAAEMAAABHZXRCaXRzRXJyb3IAAAAABAAAAAQAAAByAQAAAAAAAAQAAAAEAAAARQAAAFByb2JhYmlsaXR5Q291bnRlck1pc21hdGNoZXhwZWN0ZWRfc3Vtc3ltYm9sX3Byb2JhYmlsaXRpZXNUb29NYW55U3ltYm9scwAAAAAEAAAABAAAAEYAAABCbG9ja1NpemVUb29MYXJnZXNpemVJbnZhbGlkQmxvY2t0eXBlTnVtYmVybnVtVGFibGVJc1VuaW5pdGlhbGl6ZWQAAAAAAAAMAAAABAAAAEcAAAAAAAAADAAAAAQAAABzAQAARwAAALREEABKAAAASQAAAHQBAABKAAAAdQEAAAAAAAAEAAAABAAAAEsAAABXaW5kb3dUb29CaWdXaW5kb3dUb29TbWFsbAAAAAAAAAQAAAAEAAAATAAAAEZyYW1lRGVzY3JpcHRvckVycm9yRGljdElkVG9vU21hbGxleHBlY3RlZE1pc21hdGNoZWRGcmFtZVNpemVGcmFtZVNpemVJc1plcm9JbnZhbGlkRnJhbWVTaXplTm90RW5vdWdoQnl0ZXNJbkRpY3Rpb25hcnluZWVkT2Zmc2V0VG9vQmlnb2Zmc2V0YnVmX2xlbgAAAAAABAAAAAQAAABTAAAARlNFRGVjb2RlckVycm9yAAAAAAAEAAAABAAAAFQAAABGU0VUYWJsZUVycm9yU291cmNlSXNFbXB0eU5vdEVub3VnaEJ5dGVzRm9yV2VpZ2h0c2dvdF9ieXRlc2V4cGVjdGVkX2J5dGVzAAAAAAAAAAQAAAAEAAAAVQAAAEV4dHJhUGFkZGluZ3NraXBwZWRfYml0c1Rvb01hbnlXZWlnaHRzTWlzc2luZ1dlaWdodHNMZWZ0b3ZlcklzTm90QVBvd2VyT2YyTm90RW5vdWdoQnl0ZXNUb0RlY29tcHJlc3NXZWlnaHRzaGF2ZUZTRVRhYmxlVXNlZFRvb01hbnlCeXRlc3VzZWRhdmFpbGFibGVfYnl0ZXNOb3RFbm91Z2hCeXRlc0luU291cmNlV2VpZ2h0QmlnZ2VyVGhhbk1heE51bUJpdHNNYXhCaXRzVG9vSGlnaAAAAAABAAAAAQAAAFYAAAAAAAAAAQAAAAEAAAB2AQAAVgAAACRHEABbAAAAWQAAAHcBAABbAAAAeAEAAFVuc3VwcG9ydGVkT2Zmc2V0b2Zmc2V0X2NvZGVaZXJvT2Zmc2V0Tm90RW5vdWdoQnl0ZXNGb3JOdW1TZXF1ZW5jZXMAAAAAAAQAAAAEAAAAXQAAAEV4dHJhQml0c2JpdHNfcmVtYWluaW5nTWlzc2luZ0NvbXByZXNzaW9uTW9kZU1pc3NpbmdCeXRlRm9yUmxlTGxUYWJsZU1pc3NpbmdCeXRlRm9yUmxlT2ZUYWJsZU1pc3NpbmdCeXRlRm9yUmxlTWxUYWJsZQAAAHkBAAAMAAAABAAAAF8AAAB5AQAADAAAAAQAAAB6AQAAXwAAACxIEAB7AQAAYgAAAHQBAABjAAAAdQEAAAAAAAAQAAAACAAAAGQAAAAAAAAAEAAAAAgAAAB8AQAAZAAAAGhIEAB9AQAAZwAAAH4BAABoAAAAfwEAAIABAAAYAAAABAAAAGoAAACAAQAAGAAAAAQAAACBAQAAagAAAKRIEACCAQAAbQAAAHQBAABuAAAAdQEAAIMBAAAIAAAABAAAAHAAAACDAQAACAAAAAQAAACEAQAAcAAAAOBIEACFAQAAcwAAAHQBAAB0AAAAdQEAAIYBAAAYAAAABAAAAHYAAACGAQAAGAAAAAQAAACHAQAAdgAAABxJEACIAQAAeQAAAHQBAAB6AAAAdQEAAIkBAAAIAAAABAAAACUAAACJAQAACAAAAAQAAAAmAAAAJQAAAFhJEAAnAAAAKAAAACkAAAAqAAAAdQEAAAAAAAAMAAAABAAAAHsAAAAAAAAADAAAAAQAAACKAQAAewAAAJRJEACLAQAAfgAAAHQBAAB/AAAAdQEAAIwBAAAUAAAABAAAAIEAAACMAQAAFAAAAAQAAACNAQAAgQAAANBJEACOAQAAhAAAAHQBAACFAAAAdQEAAAAAAAAEAAAABAAAAFIAAABSZWFkRXJyb3JGb3VuZFJlc2VydmVkQmxvY2sAAAAAAAQAAAAEAAAAhgAAAEJsb2NrVHlwZUVycm9yAAAAAAAABAAAAAQAAACHAAAAQmxvY2tTaXplRXJyb3JCbG9ja0NvbnRlbnRSZWFkRXJyb3JNYWxmb3JtZWRTZWN0aW9uSGVhZGVyZXhwZWN0ZWRfbGVucmVtYWluaW5nX2J5dGVzAAAAAAQAAAAEAAAAiAAAAERlY29tcHJlc3NMaXRlcmFsc0Vycm9yAAAAAAAEAAAABAAAAIkAAABMaXRlcmFsc1NlY3Rpb25QYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAigAAAFNlcXVlbmNlc0hlYWRlclBhcnNlRXJyb3IAAAAAAAAABAAAAAQAAACLAAAARGVjb2RlU2VxdWVuY2VFcnJvcgAAAAAABAAAAAQAAACMAAAARXhlY3V0ZVNlcXVlbmNlc0Vycm9ySW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnTWFnaWNOdW1iZXJSZWFkRXJyb3JCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvclNraXBGcmFtZW1hZ2ljX251bWJlcmxlbmd0aAAAAAAAAAQAAAAEAAAAjQAAAEJhZE1hZ2ljTnVtAAAAAAAEAAAABAAAAI4AAABIdWZmbWFuVGFibGVFcnJvcgAAAAAAAAAEAAAABAAAAI8AAABEZWNvZGVidWZmZXJFcnJvck5vdEVub3VnaEJ5dGVzRm9yU2VxdWVuY2V3YW50ZWQAAAAAAQAAAAEAAACQAAAAAAAAAAEAAAABAAAAjwEAAJAAAADUTBAAWwAAAJIAAAB3AQAAWwAAAHgBAAAAAAAABAAAAAQAAACTAAAAAAAAAAQAAAAEAAAAkAEAAJMAAAAQTRAASgAAAJUAAAB0AQAASgAAAHUBAACRAQAAFAAAAAQAAACXAAAAkQEAABQAAAAEAAAAkgEAAJcAAABMTRAAkwEAAJoAAAB0AQAAmwAAAHUBAAAAAAAADAAAAAQAAACcAAAAAAAAAAwAAAAEAAAAlAEAAJwAAACITRAAlQEAAJ8AAAB0AQAAoAAAAHUBAAAAAAAACAAAAAQAAAChAAAAAAAAAAgAAAAEAAAAlgEAAKEAAADETRAASgAAAKMAAAB0AQAASgAAAHUBAACXAQAAFAAAAAQAAAClAAAAlwEAABQAAAAEAAAAmAEAAKUAAAAAThAAmQEAAKgAAAB0AQAAqQAAAHUBAAAAAAAADAAAAAQAAACqAAAAAAAAAAwAAAAEAAAAmgEAAKoAAAA8ThAAmwEAAK0AAAB0AQAArgAAAHUBAABEZWNvZGVyU3RhdGVJc0ZhaWxlZEV4cGVjdGVkSGVhZGVyT2ZQcmV2aW91c0Jsb2NrAAAAAAAAAAEAAAABAAAAnAEAAHN0ZXBzb3VyY2UAAAAAAAAEAAAABAAAALAAAABEZWNvbXByZXNzQmxvY2tFcnJvck1pc3NpbmdDb21wcmVzc2VkU2l6ZU1pc3NpbmdOdW1TdHJlYW1zAAAAAAAABAAAAAQAAACxAAAASHVmZm1hbkRlY29kZXJFcnJvclVuaW5pdGlhbGl6ZWRIdWZmbWFuVGFibGVNaXNzaW5nQnl0ZXNGb3JKdW1wSGVhZGVyTWlzc2luZ0J5dGVzRm9yTGl0ZXJhbHNuZWVkZWQAAAAAAAAEAAAABAAAAJ0BAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAngEAABQAAAAEAAAAtAAAAJ4BAAAUAAAABAAAAJ8BAAC0AAAA2E8QAKABAAC3AAAAdAEAALgAAAB1AQAAAAAAAAwAAAAEAAAAuQAAAAAAAAAMAAAABAAAAKEBAAC5AAAAFFAQAEoAAAC7AAAAdAEAAEoAAAB1AQAAogEAABgAAAAEAAAAvQAAAKIBAAAYAAAABAAAAKMBAAC9AAAAUFAQAKQBAADAAAAAdAEAAMEAAAB1AQAAAAAAAAwAAAAEAAAAwgAAAAAAAAAMAAAABAAAAKUBAADCAAAAjFAQAMYAAADFAAAAdAEAAMYAAAB1AQAASWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzbmVlZF9hdF9sZWFzdAMAAAADAAAACgAAAAgAAAAlQxAAKEMQACtDEAA1QxAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL2lvL21vZC5ycwAAHFEQAGoAAACyAQAAMQAAAGFzc2VydGlvbiBmYWlsZWQ6IGZpbGxlZCA8PSBzZWxmLmJ1Zi5pbml0L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9pby9ib3Jyb3dlZF9idWYucnMAAADBURAAdAAAAB0BAAAJAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnNIUhAAgAAAAFgCAAAwAAAASW52YWxpZCBGcmFtZV9Db250ZW50X1NpemVfRmxhZzsgSXM6ICwgU2hvdWxkIGJlIG9uZSBvZjogMCwgMSwgMiwgMwDYUhAAJQAAAP1SEAAeAEG0psEAC8piwAMAAHdpbmRvd19zaXplIGJpZ2dlciB0aGFuIGFsbG93ZWQgbWF4aW11bS4gSXM6ICwgU2hvdWxkIGJlIGxvd2VyIHRoYW46IAAAADhTEAAtAAAAZVMQABgAAAAABAAAAAAAAHdpbmRvd19zaXplIHNtYWxsZXIgdGhhbiBhbGxvd2VkIG1pbmltdW0uIElzOiAsIFNob3VsZCBiZSBncmVhdGVyIHRoYW46IJhTEAAuAAAAxlMQABoAAAABAAAAAAAAAE5vdCBlbm91Z2ggYnl0ZXMgaW4gZGljdF9pZC4gSXM6ICwgU2hvdWxkIGJlOiAAAPhTEAAhAAAAGVQQAA0AAABmcmFtZV9jb250ZW50X3NpemUgZG9lcyBub3QgaGF2ZSB0aGUgcmlnaHQgbGVuZ3RoLiBJczogADhUEAA3AAAAGVQQAA0AAABmcmFtZV9jb250ZW50X3NpemUgd2FzIHplcm9JbnZhbGlkIGZyYW1lX2NvbnRlbnRfc2l6ZS4gSXM6ICwgU2hvdWxkIGJlIG9uZSBvZiAxLCAyLCA0LCA4IGJ5dGVzAACbVBAAIAAAALtUEAAjAAAARXJyb3Igd2hpbGUgcmVhZGluZyBtYWdpYyBudW1iZXI6IAAA8FQQACIAAABSZWFkIHdyb25nIG1hZ2ljIG51bWJlcjogMHgAHFUQABsAAABFcnJvciB3aGlsZSByZWFkaW5nIGZyYW1lIGRlc2NyaXB0b3I6IAAAQFUQACYAAABFcnJvciB3aGlsZSByZWFkaW5nIHdpbmRvdyBkZXNjcmlwdG9yOiAAcFUQACcAAABFcnJvciB3aGlsZSByZWFkaW5nIGRpY3Rpb25hcnkgaWQ6IACgVRAAIwAAAEVycm9yIHdoaWxlIHJlYWRpbmcgZnJhbWUgY29udGVudCBzaXplOiDMVRAAKAAAAFNraXBwYWJsZUZyYW1lIGVuY291bnRlcmVkIHdpdGggTWFnaWNOdW1iZXIgMHggYW5kIGxlbmd0aCAgYnl0ZXP8VRAALgAAACpWEAAMAAAANlYQAAYAAABFcnJvciB3aGlsZSByZWFkaW5nIHRoZSBibG9jayBoZWFkZXJSZXNlcnZlZCBibG9jayBvY2N1cmVkLiBUaGlzIGlzIGNvbnNpZGVyZWQgY29ycnVwdGlvbiBieSB0aGUgZG9jdW1lbnRhdGlvbkVycm9yIGdldHRpbmcgYmxvY2sgdHlwZTogwlYQABoAAABFcnJvciBnZXR0aW5nIGJsb2NrIGNvbnRlbnQgc2l6ZTogAADkVhAAIgAAAEludmFsaWQgQmxvY2t0eXBlIG51bWJlci4gSXM6ICBTaG91bGQgYmUgb25lIG9mOiAwLCAxLCAyLCAzICgzIGlzIHJlc2VydmVkIHRob3VnaAAAABBXEAAeAAAALlcQADMAAAAAAAIAQmxvY2tzaXplIHdhcyBiaWdnZXIgdGhhbiB0aGUgYWJzb2x1dGUgbWF4aW11bSAgKDEyOGtiKS4gSXM6IAAAAHhXEAAvAAAAp1cQAA4AAABFcnJvciB3aGlsZSByZWFkaW5nIHRoZSBibG9jayBjb250ZW50OiAAyFcQACcAAABNYWxmb3JtZWQgc2VjdGlvbiBoZWFkZXIuIFNheXMgbGl0ZXJhbHMgd291bGQgYmUgdGhpcyBsb25nOiAgYnV0IHRoZXJlIGFyZSBvbmx5ICBieXRlcyBsZWZ0APhXEAA8AAAANFgQABQAAABIWBAACwAAAENhbid0IGRlY29kZSBuZXh0IGJsb2NrIGlmIGZhaWxlZCBhbG9uZyB0aGUgd2F5LiBSZXN1bHRzIHdpbGwgYmUgbm9uc2Vuc2VDYW4ndCBkZWNvZGUgbmV4dCBibG9jayBib2R5LCB3aGlsZSBleHBlY3RpbmcgdG8gZGVjb2RlIHRoZSBoZWFkZXIgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBSZXN1bHRzIHdpbGwgYmUgbm9uc2Vuc2VFcnJvciB3aGlsZSByZWFkaW5nIGJ5dGVzIGZvciA6IAAnWRAAHgAAAEVZEAACAAAATmVlZCAgYnl0ZXMgZnJvbSB0aGUgZGljdGlvbmFyeSBidXQgaXQgaXMgb25seSAgYnl0ZXMgbG9uZwAAWFkQAAUAAABdWRAAKgAAAIdZEAALAAAAb2Zmc2V0OiAgYmlnZ2VyIHRoYW4gYnVmZmVyOiAAAACsWRAACAAAALRZEAAVAAAAQmFkIG1hZ2ljX251bSBhdCBzdGFydCBvZiB0aGUgZGljdGlvbmFyeTsgR290OiAsIEV4cGVjdGVkOiAA3FkQAC8AAAALWhAADAAAADekMOxTcGVjaWZpZWQgd2luZG93X3NpemUgaXMgdG9vIGJpZzsgUmVxdWVzdGVkOiAsIE1heDogLFoQAC0AAABZWhAABwAAAEZhaWxlZCB0byBwYXJzZS9kZWNvZGUgYmxvY2sgYm9keTogAHBaEAAjAAAARmFpbGVkIHRvIHBhcnNlIGJsb2NrIGhlYWRlcjogAACcWhAAHgAAAEZhaWxlZCB0byByZWFkIGNoZWNrc3VtOiAAAADEWhAAGQAAAERlY29kZXIgbXVzdCBpbml0aWFsaXplZCBvciByZXNldCBiZWZvcmUgdXNpbmcgaXREZWNvZGVyIGVuY291bnRlcmVkIGVycm9yIHdoaWxlIGluaXRpYWxpemluZzogABlbEAAuAAAARGVjb2RlciBlbmNvdW50ZXJlZCBlcnJvciB3aGlsZSBkcmFpbmluZyB0aGUgZGVjb2RlYnVmZmVyOiAAUFsQADsAAABGYWlsZWQgdG8gc2tpcCBieXRlcyBmb3IgdGhlIGxlbmd0aCBnaXZlbiBpbiB0aGUgZnJhbWUgaGVhZGVyVGFyZ2V0IG11c3QgaGF2ZSBhdCBsZWFzdCBhcyBtYW55IGJ5dGVzIGFzIHRoZSBjb250ZW50c2l6ZSBvZiB0aGUgZnJhbWUgcmVwb3J0c0ZyYW1lIGhlYWRlciBzcGVjaWZpZWQgZGljdGlvbmFyeSBpZCAweCB0aGF0IHdhc250IHByb3ZpZGVkIGJ5IGFkZF9kaWN0KCkgb3IgcmVzZXRfd2l0aF9kaWN0KCkAACBcEAAnAAAAR1wQADcAAABjb21wcmVzc2VkIHNpemUgd2FzIG5vbmUgZXZlbiB0aG91Z2ggaXQgbXVzdCBiZSBzZXQgdG8gc29tZXRoaW5nIGZvciBjb21wcmVzc2VkIGxpdGVyYWxzbnVtX3N0cmVhbXMgd2FzIG5vbmUgZXZlbiB0aG91Z2ggaXQgbXVzdCBiZSBzZXQgdG8gc29tZXRoaW5nICgxIG9yIDQpIGZvciBjb21wcmVzc2VkIGxpdGVyYWxzVHJpZWQgdG8gcmV1c2UgaHVmZm1hbiB0YWJsZSBidXQgaXQgd2FzIG5ldmVyIGluaXRpYWxpemVkTmVlZCA2IGJ5dGVzIHRvIGRlY29kZSBqdW1wIGhlYWRlciwgZ290IAAAfl0QACgAAAA2VhAABgAAAE5lZWQgYXQgbGVhc3QgIGJ5dGVzIHRvIGRlY29kZSBsaXRlcmFscy4gSGF2ZTogALhdEAAOAAAAxl0QACEAAAA2VhAABgAAAFBhZGRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2Vfc2VjdGlvbiB3YXMgbW9yZSB0aGFuIGEgYnl0ZSBsb25nOiAgYml0cy4gUHJvYmFibHkgY2F1c2VkIGJ5IGRhdGEgY29ycnVwdGlvbgAAXhAARgAAAEZeEAApAAAAQml0c3RyZWFtIHdhcyByZWFkIHRpbGw6ICwgc2hvdWxkIGhhdmUgYmVlbjogAAAAgF4QABkAAACZXhAAFAAAAERpZCBub3QgZGVjb2RlIGVub3VnaCBsaXRlcmFsczogLCBTaG91bGQgaGF2ZSBiZWVuOiDAXhAAIAAAAOBeEAAUAAAAU2VxdWVuY2Ugd2FudHMgdG8gY29weSB1cCB0byBieXRlIC4gQnl0ZXMgaW4gbGl0ZXJhbHNidWZmZXI6IAAAAARfEAAiAAAAJl8QABsAAABJbGxlZ2FsIG9mZnNldDogMCBmb3VuZERvIG5vdCBzdXBwb3J0IG9mZnNldHMgYmlnZ2VyIHRoYW4gMTw8MzI7IGdvdDogAABrXxAALwAAAFJlYWQgYW4gb2Zmc2V0ID09IDAuIFRoYXQgaXMgYW4gaWxsZWdhbCB2YWx1ZSBmb3Igb2Zmc2V0c0J5dGVzdHJlYW0gZGlkIG5vdCBjb250YWluIGVub3VnaCBieXRlcyB0byBkZWNvZGUgbnVtX3NlcXVlbmNlc2NvbXByZXNzaW9uIG1vZGVzIGFyZSBub25lIGJ1dCB0aGV5IG11c3QgYmUgc2V0IHRvIHNvbWV0aGluZ05lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBsbCB0YWJsZU5lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBvZiB0YWJsZU5lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBtbCB0YWJsZUlsbGVnYWwgbGl0ZXJhbHNzZWN0aW9udHlwZS4gSXM6ICwgbXVzdCBiZSBpbjogMCwgMSwgMiwgMwAAAMRgEAAhAAAA5WAQABgAAABOb3QgZW5vdWdoIGJ5dGUgdG8gcGFyc2UgdGhlIGxpdGVyYWxzIHNlY3Rpb24gaGVhZGVyLiBIYXZlOiAsIE5lZWQ6IBBhEAA8AAAATGEQAAgAAABzb3VyY2UgbXVzdCBoYXZlIGF0IGxlYXN0ICBieXRlcyB0byBwYXJzZSBoZWFkZXI7IGdvdCAAAGRhEAAaAAAAfmEQABwAAAA2VhAABgAAAEFjY2xvZyBtdXN0IGJlIGF0IGxlYXN0IDFGb3VuZCBGU0UgYWNjX2xvZzogIGJpZ2dlciB0aGFuIGFsbG93ZWQgbWF4aW11bSBpbiB0aGlzIGNhc2U6IADNYRAAEwAAAOBhEAArAAAAVGhlIGNvdW50ZXIgKCkgZXhjZWVkZWQgdGhlIGV4cGVjdGVkIHN1bTogLiBUaGlzIG1lYW5zIGFuIGVycm9yIG9yIGNvcnJ1cHRlZCBkYXRhIAogHGIQAA0AAAApYhAAHQAAAEZiEAAqAAAAVGhlcmUgYXJlIHRvbyBtYW55IHN5bWJvbHMgaW4gdGhpcyBkaXN0cmlidXRpb246IC4gTWF4OiAyNTYAiGIQADEAAAC5YhAACgAAAFRyaWVkIHRvIHVzZSBhbiB1bmluaXRpYWxpemVkIHRhYmxlIVNvdXJjZSBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBieXRlSGVhZGVyIHNheXMgdGhlcmUgc2hvdWxkIGJlICBieXRlcyBmb3IgdGhlIHdlaWdodHMgYnV0IHRoZXJlIGFyZSBvbmx5ICBieXRlcyBpbiB0aGUgc3RyZWFtHmMQABwAAAA6YxAAKgAAAGRjEAAUAAAATW9yZSB0aGFuIDI1NSB3ZWlnaHRzIGRlY29kZWQgKGdvdCAgd2VpZ2h0cykuIFN0cmVhbSBpcyBwcm9iYWJseSBjb3JydXB0ZWQAAJBjEAAjAAAAs2MQACcAAABDYW4ndCBidWlsZCBodWZmbWFuIHRhYmxlIHdpdGhvdXQgYW55IHdlaWdodHNMZWZ0b3ZlciBtdXN0IGJlIHBvd2VyIG9mIHR3byBidXQgaXM6IAAZZBAAJgAAAE5vdCBlbm91Z2ggYnl0ZXMgaW4gc3RyZWFtIHRvIGRlY29tcHJlc3Mgd2VpZ2h0cy4gSXM6IAAASGQQADYAAAAZVBAADQAAAEZTRSB0YWJsZSB1c2VkIG1vcmUgYnl0ZXM6ICB0aGFuIHdlcmUgbWVhbnQgdG8gYmUgdXNlZCBmb3IgdGhlIHdob2xlIHN0cmVhbSBvZiBodWZmbWFuIHdlaWdodHMgKCkAAACQZBAAGwAAAKtkEABFAAAA8GQQAAEAAABTb3VyY2UgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCAgYnl0ZXMsIGdvdDogAAxlEAAeAAAAKmUQAA0AAAALQ2FudCBoYXZlIHdlaWdodDogIGJpZ2dlciB0aGFuIG1heF9udW1fYml0czogAABJZRAAEgAAAFtlEAAbAAAAbWF4X2JpdHMgZGVyaXZlZCBmcm9tIHdlaWdodHMgaXM6ICBzaG91bGQgYmUgbG93ZXIgdGhhbjogAAAAiGUQACIAAACqZRAAFwAAAENhbnQgc2VydmUgdGhpcyByZXF1ZXN0LiBUaGUgcmVhZGVyIGlzIGxpbWl0ZWQgdG8gIGJpdHMsIHJlcXVlc3RlZCAgYml0c9RlEAAyAAAABmYQABEAAAAXZhAABQAAAENhbid0IHJlYWQgIGJpdHMsIG9ubHkgaGF2ZSAgYml0cyBsZWZ0AAA0ZhAACwAAAD9mEAARAAAAUGYQAAoAAAAAAAAABAAAAAQAAADJAQAAAAAAAAQAAAAEAAAAygEAAFRvb01hbnlCaXRzbnVtX3JlcXVlc3RlZF9iaXRzbGltaXQAAAAAAAAEAAAABAAAAMsBAABOb3RFbm91Z2hSZW1haW5pbmdCaXRzcmVxdWVzdGVkcmVtYWluaW5nSW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnZ290AAAAAAAABAAAAAQAAADMAQAAV2luZG93VG9vQmlnV2luZG93VG9vU21hbGwAAAAAAAAEAAAABAAAAK4BAABGcmFtZURlc2NyaXB0b3JFcnJvckRpY3RJZFRvb1NtYWxsZXhwZWN0ZWRNaXNtYXRjaGVkRnJhbWVTaXplRnJhbWVTaXplSXNaZXJvSW52YWxpZEZyYW1lU2l6ZQAAAAAEAAAABAAAAM0BAABNYWdpY051bWJlclJlYWRFcnJvcgAAAAAEAAAABAAAAM4BAABCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvcgAAAAAABAAAAAQAAADPAQAAU2tpcEZyYW1lbWFnaWNfbnVtYmVybGVuZ3RoQmxvY2tDb250ZW50UmVhZEVycm9yTWFsZm9ybWVkU2VjdGlvbkhlYWRlcmV4cGVjdGVkX2xlbnJlbWFpbmluZ19ieXRlcwAAAAAAAAAEAAAABAAAALIBAABEZWNvbXByZXNzTGl0ZXJhbHNFcnJvcgAAAAAABAAAAAQAAACzAQAATGl0ZXJhbHNTZWN0aW9uUGFyc2VFcnJvcgAAAAAAAAAEAAAABAAAALQBAABTZXF1ZW5jZXNIZWFkZXJQYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAtQEAAERlY29kZVNlcXVlbmNlRXJyb3IAAAAAAAQAAAAEAAAAtgEAAEV4ZWN1dGVTZXF1ZW5jZXNFcnJvck5vdEVub3VnaEJ5dGVzSW5EaWN0aW9uYXJ5bmVlZE9mZnNldFRvb0JpZ29mZnNldGJ1Zl9sZW4AAAAABAAAAAQAAAC4AQAAQmFkTWFnaWNOdW0AAAAAAAQAAAAEAAAAuQEAAEZTRVRhYmxlRXJyb3IAAAAAAAAABAAAAAQAAAC6AQAASHVmZm1hblRhYmxlRXJyb3JNaXNzaW5nQ29tcHJlc3NlZFNpemVNaXNzaW5nTnVtU3RyZWFtcwAAAAAABAAAAAQAAADBAQAAR2V0Qml0c0Vycm9yAAAAAAQAAAAEAAAAwgEAAEh1ZmZtYW5EZWNvZGVyRXJyb3JVbmluaXRpYWxpemVkSHVmZm1hblRhYmxlTWlzc2luZ0J5dGVzRm9ySnVtcEhlYWRlck1pc3NpbmdCeXRlc0ZvckxpdGVyYWxzbmVlZGVkAAAAAAAABAAAAAQAAADQAQAARXh0cmFQYWRkaW5nc2tpcHBlZF9iaXRzAAAAAAQAAAAEAAAA0QEAAAAAAAAEAAAABAAAANIBAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAAAAAAAQAAAAEAAAAxQEAAERlY29kZWJ1ZmZlckVycm9yTm90RW5vdWdoQnl0ZXNGb3JTZXF1ZW5jZXdhbnRlZGhhdmVaZXJvT2Zmc2V0AAAAAAAABAAAAAQAAADGAQAARlNFRGVjb2RlckVycm9yVW5zdXBwb3J0ZWRPZmZzZXRvZmZzZXRfY29kZU5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzRXh0cmFCaXRzYml0c19yZW1haW5pbmdNaXNzaW5nQ29tcHJlc3Npb25Nb2RlTWlzc2luZ0J5dGVGb3JSbGVMbFRhYmxlTWlzc2luZ0J5dGVGb3JSbGVPZlRhYmxlTWlzc2luZ0J5dGVGb3JSbGVNbFRhYmxlSWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzAAAAAAEAAAABAAAA0wEAAG5lZWRfYXRfbGVhc3RBY2NMb2dJc1plcm9BY2NMb2dUb29CaWdtYXgAAAAABAAAAAQAAADHAQAAUHJvYmFiaWxpdHlDb3VudGVyTWlzbWF0Y2hleHBlY3RlZF9zdW1zeW1ib2xfcHJvYmFiaWxpdGllc1Rvb01hbnlTeW1ib2xzVGFibGVJc1VuaW5pdGlhbGl6ZWRTb3VyY2VJc0VtcHR5Tm90RW5vdWdoQnl0ZXNGb3JXZWlnaHRzZ290X2J5dGVzZXhwZWN0ZWRfYnl0ZXNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c0ZTRVRhYmxlVXNlZFRvb01hbnlCeXRlc3VzZWRhdmFpbGFibGVfYnl0ZXNOb3RFbm91Z2hCeXRlc0luU291cmNlV2VpZ2h0QmlnZ2VyVGhhbk1heE51bUJpdHNNYXhCaXRzVG9vSGlnaC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMAAABQbhAAbQAAACoCAAARAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9iaXRfcmVhZGVyX3JldmVyc2UucnMAAADQbhAAcQAAADcAAABFAAAA0G4QAHEAAAA3AAAALwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGXQbhAAcQAAAEYAAAANAAAA0G4QAHEAAABKAAAAHgAAAFRoaXMgaXMgYSBidWcgaW4gdGhlIHByb2dyYW0uIFRoZXJlIHNob3VsZCBvbmx5IGJlIHZhbHVlcyBiZXR3ZWVuIDAuLjMvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2Jsb2Nrcy9saXRlcmFsc19zZWN0aW9uLnJzAPJvEABtAAAAewAAADQAAADybxAAbQAAAJAAAABXAAAA8m8QAG0AAACXAAAAKgAAAPJvEABtAAAAmAAAACoAAADybxAAbQAAAJsAAAAaAAAA8m8QAG0AAACoAAAAGgAAAPJvEABtAAAAtAAAAEQAAADybxAAbQAAALgAAABGAAAA8m8QAG0AAADAAAAAKgAAAPJvEABtAAAAwQAAACsAAADybxAAbQAAAMUAAABIAAAA8m8QAG0AAADNAAAAKgAAAPJvEABtAAAAzgAAACsAAADybxAAbQAAANMAAAAuAAAA8m8QAG0AAADUAAAALgAAAENhbnQgcmV0dXJuIHRoaXMgbWFueSBiaXRzL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9iaXRfcmVhZGVyLnJzAGpxEABpAAAANgAAAA0AAABqcRAAaQAAAE8AAAAjAAAAYXNzZXJ0aW9uIGZhaWxlZDogbiAtIGJpdF9zaGlmdCA9PSBiaXRzX2luX2xhc3RfYnl0ZV9uZWVkZWQAanEQAGkAAABtAAAADQAAAGpxEABpAAAAcQAAAB8AAABqcRAAaQAAAGgAAAAkAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pZHggJSA4ID09IDAAanEQAGkAAABkAAAADQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaWR4ID09IG9sZF9pZHggKyBuAAAAanEQAGkAAAB3AAAACQAAAFNlcV9zdW06ICBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZGlmZmVyZW5jZSBpbiBidWZmZXJzaXplOiAAANByEAAJAAAA2XIQADEAAAAvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2RlY29kaW5nL3NlcXVlbmNlX2V4ZWN1dGlvbi5ycwAAABxzEABxAAAALwAAAAUAAAAccxAAcQAAAAsAAAAkAAAAHHMQAHEAAAAVAAAANAAAAEFsbG9jYXRpbmcgbmV3IHNwYWNlIGZvciB0aGUgcmluZ2J1ZmZlciBmYWlsZWQvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2RlY29kaW5nL3JpbmdidWZmZXIucnMA7nMQAGkAAABhAAAAIwAAAENvdWxkIG5vdCBjcmVhdGUgbGF5b3V0IGZvciB1OCBhcnJheSBvZiBzaXplIAAAAGh0EAAtAAAA7nMQAGkAAABaAAAAIQAAAO5zEABpAAAAtAAAABUAAADucxAAaQAAAL4AAAAVAAAA7nMQAGkAAAB3AQAAHQAAAO5zEABpAAAAzgEAABUAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwDwdBAAawAAAKIAAAAZAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9saXRlcmFsc19zZWN0aW9uX2RlY29kZXIucnMAbHUQAHcAAAAUAAAAIgAAAGx1EAB3AAAAGAAAAE0AAABsdRAAdwAAADQAAAAZAAAAbHUQAHcAAAByAAAAGAAAAGx1EAB3AAAAkQAAABQAAABhc3NlcnRpb24gZmFpbGVkOiBudW1fc3RyZWFtcyA9PSAxAABsdRAAdwAAAIAAAAAJAAAAbHUQAHcAAABFAAAAGQAAAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZGVjb2Rpbmcvc2VxdWVuY2Vfc2VjdGlvbl9kZWNvZGVyLnJzAHh2EAB3AAAAGAAAAB0AAAB4dhAAdwAAAHUAAAAQAAAAeHYQAHcAAADAAAAAEAAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IElsbGVnYWwgbGl0ZXJhbCBsZW5ndGggY29kZSB3YXM6IAAgdxAASwAAAHh2EAB3AAAA+gAAAA4AAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBJbGxlZ2FsIG1hdGNoIGxlbmd0aCBjb2RlIHdhczogAAAAhHcQAEkAAAB4dhAAdwAAABoBAAAOAAAABAAAAAMAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAMAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAD/////////////////////AQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA//////////////////////////8BAAAABAAAAAMAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA/////////////////////////////////////3h2EAB3AAAAdgEAABwAAAB4dhAAdwAAAFMBAAAcAAAAAQEBAQICAwMEBgcICQoLDA0ODxAQAAAAEgAAABQAAAAWAAAAGAAAABwAAAAgAAAAKAAAADAAAABAAAAAgAAAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAAABAAEBAQECAgMDBAQFBwgJCgsMDQ4PEAAAACMAAAAlAAAAJwAAACkAAAArAAAALwAAADMAAAA7AAAAQwAAAFMAAABjAAAAgwAAAAMBAAADAgAAAwQAAAMIAAADEAAAAyAAAANAAAADgAAAAwABAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3R3b3gtaGFzaC0yLjEuMC9zcmMveHhoYXNoNjQucnMAAACwehAAYQAAAFQAAAAfAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9kZWNvZGVidWZmZXIucnMAJHsQAGsAAAAaAAAAHgAAACR7EABrAAAAnQAAADQAAAAkexAAawAAAOoAAAAeAAAAUmF3UkxFQ29tcHJlc3NlZFJlc2VydmVyZAAAAAAAAAAEAAAABAAAAMoBAAAAAAAABAAAAAQAAADQAQAAYXNzZXJ0aW9uIGZhaWxlZDogeCA+IDAvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2h1ZmYwL2h1ZmYwX2RlY29kZXIucnMTfBAAaQAAADEAAAAFAAAAE3wQAGkAAAA+AAAAGgAAABN8EABpAAAAUAAAACkAAAATfBAAaQAAAGgAAAAWAAAAE3wQAGkAAABqAAAAEwAAABN8EABpAAAAawAAABgAAAATfBAAaQAAAGwAAAAbAAAAE3wQAGkAAAAdAQAANgAAABN8EABpAAAAHQEAACUAAAATfBAAaQAAAB8BAAA2AAAAE3wQAGkAAAAfAQAAJQAAABN8EABpAAAA6AAAACIAAAATfBAAaQAAAPIAAAAiAAAAE3wQAGkAAAD3AAAAJgAAABN8EABpAAAA7QAAACYAAAATfBAAaQAAAFcBAAASAAAAE3wQAGkAAABfAQAAGAAAABN8EABpAAAAZQEAABUAAAATfBAAaQAAAG8BAAAbAAAAE3wQAGkAAABxAQAAGgAAABN8EABpAAAAeAEAAB4AAAByYW5rX2lkeFswXTogIHNob3VsZCBiZTogAAAAzH0QAA0AAADZfRAADAAAABN8EABpAAAAdwEAAAkAAAATfBAAaQAAAH8BAAAsAAAAE3wQAGkAAACEAQAAMQAAABN8EABpAAAAiAEAACAAAAATfBAAaQAAAIkBAAAgAAAAE3wQAGkAAABzAQAARQAAABN8EABpAAAAdAEAACEAAAATfBAAaQAAAHMBAAAeAAAAE3wQAGkAAABhAQAAGwAAABN8EABpAAAATwEAACcAAAATfBAAaQAAAFQBAAAWAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAqH4QAGsAAACiAAAAGQAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzACR/EABrAAAAogAAABkAAABhc3NlcnRpb24gZmFpbGVkOiB4ID4gMC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZnNlL2ZzZV9kZWNvZGVyLnJzt38QAGUAAAA9AAAABQAAALd/EABlAAAAWgAAACcAAAC3fxAAZQAAAGUAAAAnAAAAt38QAGUAAABwAAAAIwAAALd/EABlAAAAcQAAAB0AAAC3fxAAZQAAAOIAAAApAAAAt38QAGUAAADkAAAAMQAAALd/EABlAAAA5gAAADMAAABhc3NlcnRpb24gZmFpbGVkOiBuYiA8PSBzZWxmLmFjY3VyYWN5X2xvZwAAALd/EABlAAAA6wAAAA0AAAC3fxAAZQAAANIAAAAtAAAAt38QAGUAAADAAAAALQAAALd/EABlAAAAOQEAAEEAAAC3fxAAZQAAAB4BAAAnAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHJvYiA9PSAtMbd/EABlAAAAJAEAABUAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJzAAAARIEQAG0AAAA9CgAAJAAAAAAAAAAQAAAABAAAANQBAADVAQAA1gEAACAgICA6IAAAAQAAAAAAAADggRAAAgAAACAgICAgICAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3B0ci9tb2QucnMA+4EQAGwAAAALAgAAAQAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc2xpY2UvaW5kZXgucnN4ghAAcAAAAEwDAAA0AAAAeIIQAHAAAABTAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAMoMQAGwAAAD7BwAAHQAAADKDEABsAAAAAwgAAB0AAAAygxAAbAAAAI0FAAAbAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5ycwAAANCDEABtAAAAKgIAABEAAADXAQAADAAAAAQAAADYAQAA2QEAANoBAADdAQAADAAAAAQAAADeAQAA3wEAANoBAEGIicIAC4UJAQAAAOABAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAMeEEABsAAAA3woAAA4AAABFcnJvcgAAAMeEEABsAAAAjQUAABsAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbinHhBAAbAAAAMAFAAANAAAAAAAAABAAAAAEAAAA1AEAANUBAADWAQAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYW55aG93LTEuMC45OC9zcmMvZXJyb3IucnPMhRAAXAAAAGcEAAAOAAAAAQAAAAAAAAA6IAAAQIYQAAIAAAAKCkNhdXNlZCBieToKCgpzdGFjayBiYWNrdHJhY2U6U3RhY2sgYmFja3RyYWNlOgprhhAAEQAAAFMvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzAACFhhAAeQAAALMHAAAJAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAAAQhxAAWgAAAPsYAAABAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvd2FzbS1iaW5kZ2VuLTAuMi4xMDAvc3JjL2NvbnZlcnQvc2xpY2VzLnJzfIcQAGwAAAAkAQAADgAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkSnNWYWx1ZSgpACqIEAAIAAAAMogQAAEAAABMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAESIEAAqAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAeIgQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADoiBAADgAAAHiIEABdAAAAegIAAA0AQZiSwgALlSMEAAAABAAAAPYBAAAvcnVzdGMvMDVmOTg0NmY4OTNiMDlhMWJlMWZjODU2MGUzM2ZjM2M4MTVjZmVjYi9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAJIkQAEoAAACiAAAAGQAAAC9ydXN0Yy8wNWY5ODQ2Zjg5M2IwOWExYmUxZmM4NTYwZTMzZmMzYzgxNWNmZWNiL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwCAiRAASwAAAI0FAAAbAAAAL3J1c3RjLzA1Zjk4NDZmODkzYjA5YTFiZTFmYzg1NjBlMzNmYzNjODE1Y2ZlY2IvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc9yJEABMAAAAKgIAABEAAAA6AAAA9wEAAAwAAAAEAAAA+AEAAPkBAAD6AQAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNy9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAFSKEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAABUihAAKQAAAK4EAAANAAAAQWNjZXNzRXJyb3JjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiAAB4sQAEgAAABsaWJyYXJ5L3N0ZC9zcmMvYmFja3RyYWNlLnJzb3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybXSLEAAoAAAAJAAAAAIAAACcixAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAFiLEAAcAAAAigEAAB0AAAD7AQAAEAAAAAQAAAD8AQAA/QEAAAEAAAAAAAAAZW50aXR5IG5vdCBmb3VuZHBlcm1pc3Npb24gZGVuaWVkY29ubmVjdGlvbiByZWZ1c2VkY29ubmVjdGlvbiByZXNldGhvc3QgdW5yZWFjaGFibGVuZXR3b3JrIHVucmVhY2hhYmxlY29ubmVjdGlvbiBhYm9ydGVkbm90IGNvbm5lY3RlZGFkZHJlc3MgaW4gdXNlYWRkcmVzcyBub3QgYXZhaWxhYmxlbmV0d29yayBkb3duYnJva2VuIHBpcGVlbnRpdHkgYWxyZWFkeSBleGlzdHNvcGVyYXRpb24gd291bGQgYmxvY2tub3QgYSBkaXJlY3RvcnlpcyBhIGRpcmVjdG9yeWRpcmVjdG9yeSBub3QgZW1wdHlyZWFkLW9ubHkgZmlsZXN5c3RlbSBvciBzdG9yYWdlIG1lZGl1bWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3Apc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb25vIHN0b3JhZ2Ugc3BhY2VzZWVrIG9uIHVuc2Vla2FibGUgZmlsZXF1b3RhIGV4Y2VlZGVkZmlsZSB0b28gbGFyZ2VyZXNvdXJjZSBidXN5ZXhlY3V0YWJsZSBmaWxlIGJ1c3lkZWFkbG9ja2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZXRvbyBtYW55IGxpbmtzaW52YWxpZCBmaWxlbmFtZWFyZ3VtZW50IGxpc3QgdG9vIGxvbmdvcGVyYXRpb24gaW50ZXJydXB0ZWR1bnN1cHBvcnRlZHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdXQgb2YgbWVtb3J5aW4gcHJvZ3Jlc3NvdGhlciBlcnJvcnVuY2F0ZWdvcml6ZWQgZXJyb3JPcwAAAAAABAAAAAQAAAD+AQAAY29kZQAAAAABAAAAAQAAAP8BAABraW5k9wEAAAwAAAAEAAAAAAIAAG1lc3NhZ2VLaW5kRXJyb3IAAAAACAAAAAQAAAABAgAAAAAAAAQAAAAEAAAAAgIAAEN1c3RvbWVycm9yIChvcyBlcnJvciApAAEAAAAAAAAAZ48QAAsAAAByjxAAAQAAADogY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXgAAI6PEAAgAAAAbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL211dGV4L25vX3RocmVhZHMucnO4jxAALAAAABMAAAAJAAAAbGlicmFyeS9zdGQvc3JjL3N5bmMvcG9pc29uL29uY2UucnMA9I8QACMAAACbAAAAMgAAAGxpYnJhcnkvc3RkL3NyYy9zeW5jL2xhenlfbG9jay5ycwAAACiQEAAhAAAA0QAAABMAAAA8dW5rbm93bj7vv71tZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAABokBAAFQAAAH2QEAANAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJznJAQABgAAABjAQAACQAAAAoAAAD3AQAADAAAAAQAAAADAgAAAAAAAAgAAAAEAAAABAIAAAAAAAAIAAAABAAAAAUCAAAGAgAABwIAAAgCAAAJAgAAEAAAAAQAAAAKAgAACwIAAAwCAAANAgAAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5ycyCREAA0AAAAZwEAADAAAAABAAAAAAAAAIyPEAACAAAAIC0gAAEAAAAAAAAAdJEQAAMAAAAgICAgICAgICAgICAgICAgICAgYXQgAAA4ihAAAQAAAE5vdEZvdW5kUGVybWlzc2lvbkRlbmllZENvbm5lY3Rpb25SZWZ1c2VkQ29ubmVjdGlvblJlc2V0SG9zdFVucmVhY2hhYmxlTmV0d29ya1VucmVhY2hhYmxlQ29ubmVjdGlvbkFib3J0ZWROb3RDb25uZWN0ZWRBZGRySW5Vc2VBZGRyTm90QXZhaWxhYmxlTmV0d29ya0Rvd25Ccm9rZW5QaXBlQWxyZWFkeUV4aXN0c1dvdWxkQmxvY2tOb3RBRGlyZWN0b3J5SXNBRGlyZWN0b3J5RGlyZWN0b3J5Tm90RW1wdHlSZWFkT25seUZpbGVzeXN0ZW1GaWxlc3lzdGVtTG9vcFN0YWxlTmV0d29ya0ZpbGVIYW5kbGVJbnZhbGlkSW5wdXRJbnZhbGlkRGF0YVRpbWVkT3V0V3JpdGVaZXJvU3RvcmFnZUZ1bGxOb3RTZWVrYWJsZVF1b3RhRXhjZWVkZWRGaWxlVG9vTGFyZ2VSZXNvdXJjZUJ1c3lFeGVjdXRhYmxlRmlsZUJ1c3lEZWFkbG9ja0Nyb3NzZXNEZXZpY2VzVG9vTWFueUxpbmtzSW52YWxpZEZpbGVuYW1lQXJndW1lbnRMaXN0VG9vTG9uZ0ludGVycnVwdGVkVW5zdXBwb3J0ZWRVbmV4cGVjdGVkRW9mT3V0T2ZNZW1vcnlJblByb2dyZXNzT3RoZXJVbmNhdGVnb3JpemVkb3BlcmF0aW9uIHN1Y2Nlc3NmdWxPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWTakxAAKgAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5DJQQADgAAAAQAAAAEQAA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", import.meta.url));
  const A = ft();
  (typeof Q == "string" || typeof Request == "function" && Q instanceof Request || typeof URL == "function" && Q instanceof URL) && (Q = fetch(Q));
  const { instance: I, module: g } = await Ht(await Q, A);
  return mt(I, g);
}
const pA = -9, bt = 9, KA = (bt - pA) / 254, xt = 11, Kt = 11, Z = 1 << xt, IQ = 1 << Kt, Zt = 1;
function tQ(Q) {
  return Q === "bool" || Q === "bvec2" || Q === "bvec3" || Q === "bvec4";
}
function iQ(Q) {
  return Q === "int" || Q === "uint" || Q === "float";
}
function EA(Q) {
  return Q === "int" || Q === "ivec2" || Q === "ivec3" || Q === "ivec4";
}
function tA(Q) {
  return Q === "uint" || Q === "uvec2" || Q === "uvec3" || Q === "uvec4";
}
function SQ(Q) {
  return Q === "float" || Q === "vec2" || Q === "vec3" || Q === "vec4";
}
function $I(Q) {
  return Q === "mat2" || Q === "mat2x2" || Q === "mat2x3" || Q === "mat2x4" || Q === "mat3" || Q === "mat3x2" || Q === "mat3x3" || Q === "mat3x4" || Q === "mat4" || Q === "mat4x2" || Q === "mat4x3" || Q === "mat4x4";
}
function zA(Q) {
  return SQ(Q) || $I(Q);
}
function yQ(Q) {
  return Q === "vec2" || Q === "ivec2" || Q === "uvec2";
}
function GQ(Q) {
  return Q === "vec3" || Q === "ivec3" || Q === "uvec3";
}
function LQ(Q) {
  return Q === "vec4" || Q === "ivec4" || Q === "uvec4";
}
function qt(Q) {
  return yQ(Q) || GQ(Q) || LQ(Q);
}
function $A(Q) {
  return Q === "mat2" || Q === "mat2x2";
}
function AQ(Q) {
  return Q === "mat3" || Q === "mat3x3";
}
function QQ(Q) {
  return Q === "mat4" || Q === "mat4x4";
}
function Ag(Q) {
  switch (Q) {
    case "vec2":
      return "float";
    case "vec3":
      return "float";
    case "vec4":
      return "float";
    case "ivec2":
      return "int";
    case "ivec3":
      return "int";
    case "ivec4":
      return "int";
    case "uvec2":
      return "uint";
    case "uvec3":
      return "uint";
    case "uvec4":
      return "uint";
    default:
      throw new Error(`Invalid vector type: ${Q}`);
  }
}
function Qg(Q) {
  switch (Q) {
    case "vec2":
    case "ivec2":
    case "uvec2":
      return 2;
    case "vec3":
    case "ivec3":
    case "uvec3":
      return 3;
    case "vec4":
    case "ivec4":
    case "uvec4":
      return 4;
    default:
      throw new Error(`Invalid vector type: ${Q}`);
  }
}
function Wt(Q) {
  if (iQ(Q))
    return "float";
  if (yQ(Q))
    return "vec2";
  if (GQ(Q))
    return "vec3";
  if (LQ(Q))
    return "vec4";
  throw new Error(`Invalid vector type: ${Q}`);
}
function Ig(Q) {
  if (iQ(Q))
    return "uint";
  if (yQ(Q))
    return "uvec2";
  if (GQ(Q))
    return "uvec3";
  if (LQ(Q))
    return "uvec4";
  throw new Error(`Invalid vector type: ${Q}`);
}
function Vt(Q) {
  if (iQ(Q))
    return "int";
  if (yQ(Q))
    return "ivec2";
  if (GQ(Q))
    return "ivec3";
  if (LQ(Q))
    return "ivec4";
  throw new Error(`Invalid vector type: ${Q}`);
}
function gg(Q) {
  if (typeof Q == "string")
    return Q;
  if (typeof Q == "object" && Q.type)
    return Q.type;
  throw new Error(`Invalid DynoType: ${String(Q)}`);
}
function j(Q) {
  return Math.trunc(Q).toString();
}
function z(Q) {
  return `${Math.max(0, Math.trunc(Q)).toString()}u`;
}
function u(Q) {
  return Q === Number.POSITIVE_INFINITY ? "INFINITY" : Q === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(Q) ? Q.toFixed(1) : Q.toString();
}
function p(Q) {
  return Q instanceof jA ? Q.type : Q.dynoOut().type;
}
class jA {
  constructor(A) {
    this.__isDynoValue = !0, this.type = A;
  }
}
class H extends jA {
  constructor(A, I) {
    super(A.outTypes[I]), this.dyno = A, this.key = I;
  }
}
class wQ extends jA {
  constructor(A, I) {
    super(A), this.literal = I;
  }
  getLiteral() {
    return this.literal;
  }
}
function OQ(Q, A) {
  return new wQ(Q, A);
}
class Bg extends wQ {
  constructor(A, I) {
    super(A, ""), this.value = I;
  }
  getLiteral() {
    const { type: A, value: I } = this;
    switch (A) {
      case "bool":
        return I ? "true" : "false";
      case "uint":
        return z(I);
      case "int":
        return j(I);
      case "float":
        return u(I);
      case "bvec2": {
        const g = I;
        return `bvec2(${g[0]}, ${g[1]})`;
      }
      case "uvec2": {
        if (I instanceof e.Vector2)
          return `uvec2(${z(I.x)}, ${z(I.y)})`;
        const g = I;
        return `uvec2(${z(g[0])}, ${z(g[1])})`;
      }
      case "ivec2": {
        if (I instanceof e.Vector2)
          return `ivec2(${j(I.x)}, ${j(I.y)})`;
        const g = I;
        return `ivec2(${j(g[0])}, ${j(g[1])})`;
      }
      case "vec2": {
        if (I instanceof e.Vector2)
          return `vec2(${u(I.x)}, ${u(I.y)})`;
        const g = I;
        return `vec2(${u(g[0])}, ${u(g[1])})`;
      }
      case "bvec3": {
        const g = I;
        return `bvec3(${g[0]}, ${g[1]}, ${g[2]})`;
      }
      case "uvec3": {
        if (I instanceof e.Vector3)
          return `uvec3(${z(I.x)}, ${z(I.y)}, ${z(I.z)})`;
        const g = I;
        return `uvec3(${z(g[0])}, ${z(g[1])}, ${z(g[2])})`;
      }
      case "ivec3": {
        if (I instanceof e.Vector3)
          return `ivec3(${j(I.x)}, ${j(I.y)}, ${j(I.z)})`;
        const g = I;
        return `ivec3(${j(g[0])}, ${j(g[1])}, ${j(g[2])})`;
      }
      case "vec3": {
        if (I instanceof e.Vector3)
          return `vec3(${u(I.x)}, ${u(I.y)}, ${u(I.z)})`;
        const g = I;
        return `vec3(${u(g[0])}, ${u(g[1])}, ${u(g[2])})`;
      }
      case "bvec4": {
        const g = I;
        return `bvec4(${g[0]}, ${g[1]}, ${g[2]}, ${g[3]})`;
      }
      case "uvec4": {
        if (I instanceof e.Vector4)
          return `uvec4(${z(I.x)}, ${z(I.y)}, ${z(I.z)}, ${z(I.w)})`;
        const g = I;
        return `uvec4(${z(g[0])}, ${z(g[1])}, ${z(g[2])}, ${z(g[3])})`;
      }
      case "ivec4": {
        if (I instanceof e.Vector4)
          return `ivec4(${j(I.x)}, ${j(I.y)}, ${j(I.z)}, ${j(I.w)})`;
        const g = I;
        return `ivec4(${j(g[0])}, ${j(g[1])}, ${j(g[2])}, ${j(g[3])})`;
      }
      case "vec4": {
        if (I instanceof e.Vector4)
          return `vec4(${u(I.x)}, ${u(I.y)}, ${u(I.z)}, ${u(I.w)})`;
        if (I instanceof e.Quaternion)
          return `vec4(${u(I.x)}, ${u(I.y)}, ${u(I.z)}, ${u(I.w)})`;
        const g = I;
        return `vec4(${u(g[0])}, ${u(g[1])}, ${u(g[2])}, ${u(g[3])})`;
      }
      case "mat2":
      case "mat2x2": {
        const g = I, B = g instanceof e.Matrix2 ? g.elements : I, C = new Array(4).fill(0).map((E, t) => u(B[t]));
        return `${A}(${C.join(", ")})`;
      }
      case "mat2x3": {
        const g = I, B = new Array(6).fill(0).map((C, E) => u(g[E]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat2x4": {
        const g = I, B = new Array(8).fill(0).map((C, E) => u(g[E]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat3":
      case "mat3x3": {
        const g = I, B = g instanceof e.Matrix3 ? g.elements : I, C = new Array(9).fill(0).map((E, t) => u(B[t]));
        return `${A}(${C.join(", ")})`;
      }
      case "mat3x2": {
        const g = I, B = new Array(6).fill(0).map((C, E) => u(g[E]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat3x4": {
        const g = I, B = new Array(12).fill(0).map((C, E) => u(g[E]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat4":
      case "mat4x4": {
        const g = I, B = g instanceof e.Matrix4 ? g.elements : I, C = new Array(16).fill(0).map((E, t) => u(B[t]));
        return `${A}(${C.join(", ")})`;
      }
      case "mat4x2": {
        const g = I, B = new Array(8).fill(0).map((C, E) => u(g[E]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat4x3": {
        const g = I, B = new Array(12).fill(0).map((C, E) => u(g[E]));
        return `${A}(${B.join(", ")})`;
      }
      default:
        throw new Error(`Type not implemented: ${String(A)}`);
    }
  }
}
function q(Q, A) {
  return new Bg(Q, A);
}
function NQ(Q) {
  const A = String(Q);
  if (tQ(Q))
    return `${A}(false)`;
  if (zA(Q))
    return `${A}(0.0)`;
  if (EA(Q))
    return `${A}(0)`;
  if (tA(Q))
    return `${A}(0u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function vt(Q) {
  const A = String(Q);
  if (tQ(Q))
    return `${A}(true)`;
  if (zA(Q))
    return `${A}(1.0)`;
  if (EA(Q))
    return `${A}(1)`;
  if (tA(Q))
    return `${A}(1u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function Tt(Q) {
  const A = String(Q);
  if (tQ(Q))
    return `${A}(true)`;
  if (zA(Q))
    return `${A}(-1.0)`;
  if (EA(Q))
    return `${A}(-1)`;
  if (tA(Q))
    return `${A}(0xFFFFFFFFu)`;
  throw new Error(`Type not implemented: ${A}`);
}
const WI = "    ";
class Cg {
  constructor({ indent: A } = {}) {
    this.globals = /* @__PURE__ */ new Set(), this.statements = [], this.uniforms = {}, this.declares = /* @__PURE__ */ new Set(), this.updaters = [], this.sequence = 0, this.indent = WI, this.indent = A ?? WI;
  }
  nextSequence() {
    return this.sequence++;
  }
}
class f {
  constructor({
    inTypes: A,
    outTypes: I,
    inputs: g,
    update: B,
    globals: C,
    statements: E,
    generate: t
  }) {
    this.inTypes = A ?? {}, this.outTypes = I ?? {}, this.inputs = g ?? {}, this.update = B, this.globals = C, this.statements = E, this.generate = t ?? (({ inputs: s, outputs: o, compile: a }) => {
      var i, D;
      return {
        globals: (i = this.globals) == null ? void 0 : i.call(this, { inputs: s, outputs: o, compile: a }),
        statements: (D = this.statements) == null ? void 0 : D.call(this, { inputs: s, outputs: o, compile: a })
      };
    });
  }
  get outputs() {
    const A = {};
    for (const I in this.outTypes)
      A[I] = new H(this, I);
    return A;
  }
  apply(A) {
    return Object.assign(this.inputs, A), this.outputs;
  }
  compile({
    inputs: A,
    outputs: I,
    compile: g
  }) {
    const B = [
      `// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(I).join(", ")})`
    ], C = [];
    for (const o in I) {
      const a = I[o];
      a && !g.declares.has(a) && (g.declares.add(a), C.push(o));
    }
    const { globals: E, statements: t, uniforms: s } = this.generate({
      inputs: A,
      outputs: I,
      compile: g
    });
    for (const o of E ?? [])
      g.globals.add(o);
    for (const o in s)
      g.uniforms[o] = s[o];
    this.update && g.updaters.push(this.update);
    for (const o of C) {
      const a = I[o];
      a && (g.uniforms[a] || B.push(`${uI(a, this.outTypes[o])};`));
    }
    return t != null && t.length && (B.push("{"), B.push(...t.map((o) => g.indent + o)), B.push("}")), B;
  }
}
class mA extends f {
  constructor({
    inTypes: A,
    outTypes: I,
    inputs: g,
    update: B,
    globals: C,
    construct: E
  }) {
    super({
      inTypes: A,
      outTypes: I,
      inputs: g,
      update: B,
      globals: C,
      generate: (t) => this.generateBlock(t)
    }), this.construct = E;
  }
  generateBlock({
    inputs: A,
    outputs: I,
    compile: g
  }) {
    var w, c;
    const B = {}, C = {};
    for (const r in A)
      A[r] != null && (B[r] = new wQ(this.inTypes[r], A[r]));
    for (const r in I)
      I[r] != null && (C[r] = new jA(this.outTypes[r]));
    const E = { roots: [] }, t = this.construct(B, C, E);
    for (const r of ((w = this.globals) == null ? void 0 : w.call(this, { inputs: A, outputs: I, compile: g })) ?? [])
      g.globals.add(r);
    const s = [], o = /* @__PURE__ */ new Map();
    function a(r, y, G) {
      let h = o.get(r);
      if (!h) {
        h = {
          sequence: g.nextSequence(),
          outNames: /* @__PURE__ */ new Map(),
          newOuts: /* @__PURE__ */ new Set()
        }, o.set(r, h);
        for (const M in r.inputs) {
          let l = r.inputs[M];
          for (; l; ) {
            if (l instanceof jA) {
              l instanceof H && a(l.dyno, l.key);
              break;
            }
            l = l.dynoOut();
          }
        }
        s.push(r);
      }
      y && (G || h.newOuts.add(y), h.outNames.set(y, G ?? `${y}_${h.sequence}`));
    }
    for (const r of E.roots)
      a(r);
    for (const r in C) {
      let y = (t == null ? void 0 : t[r]) ?? C[r];
      for (; y; ) {
        if (y instanceof jA) {
          y instanceof H && a(y.dyno, y.key, I[r]);
          break;
        }
        y = y.dynoOut();
      }
      C[r] = y;
    }
    const i = [];
    for (const r of s) {
      const y = {}, G = {};
      for (const l in r.inputs) {
        let k = r.inputs[l];
        for (; k; ) {
          if (k instanceof jA) {
            if (k instanceof wQ)
              y[l] = k.getLiteral();
            else if (k instanceof H) {
              const R = (c = o.get(k.dyno)) == null ? void 0 : c.outNames.get(k.key);
              if (!R)
                throw new Error(
                  `Source not found for ${k.dyno.constructor.name}.${k.key}`
                );
              y[l] = R;
            }
            break;
          }
          k = k.dynoOut();
        }
      }
      const h = o.get(r) ?? { outNames: /* @__PURE__ */ new Map() };
      for (const [l, k] of h.outNames.entries())
        G[l] = k;
      const M = r.compile({ inputs: y, outputs: G, compile: g });
      i.push(M);
    }
    const D = [];
    for (const r in I)
      C[r] instanceof wQ && D.push(
        `${I[r]} = ${C[r].getLiteral()};`
      );
    return D.length > 0 && i.push(D), { statements: i.flatMap((r, y) => y === 0 ? r : ["", ...r]) };
  }
}
function UA(Q, A, I, { update: g, globals: B } = {}) {
  return new mA({ inTypes: Q, outTypes: A, construct: I, update: g, globals: B });
}
function pQ({
  inTypes: Q,
  outTypes: A,
  inputs: I,
  update: g,
  globals: B,
  statements: C,
  generate: E
}) {
  return new f({
    inTypes: Q,
    outTypes: A,
    inputs: I,
    update: g,
    globals: B,
    statements: C,
    generate: E
  });
}
function uI(Q, A, I) {
  const g = typeof A == "string" ? A : A.type;
  if (!g)
    throw new Error(`Invalid DynoType: ${String(A)}`);
  return `${g} ${Q}${I != null ? `[${I}]` : ""}`;
}
function JA(Q) {
  var C;
  let A = !1;
  const I = Q.split(`
`).map((E) => {
    const t = E.trimEnd();
    return A ? t : t.length > 0 ? (A = !0, t) : null;
  }).filter((E) => E != null);
  for (; I.length > 0 && I[I.length - 1].length === 0; )
    I.pop();
  if (I.length === 0)
    return [];
  const g = (C = I[0].match(/^\s*/)) == null ? void 0 : C[0];
  if (!g)
    return I;
  const B = new RegExp(`^${g}`);
  return I.map((E) => E.replace(B, ""));
}
function IA(Q) {
  return JA(Q).join(`
`);
}
class N extends f {
  constructor({
    a: A,
    outKey: I,
    outTypeFunc: g
  }) {
    const B = { a: p(A) }, C = g(p(A)), E = { [I]: C };
    super({ inTypes: B, outTypes: E, inputs: { a: A } }), this.outKey = I;
  }
  dynoOut() {
    return new H(this, this.outKey);
  }
}
class b extends f {
  constructor({
    a: A,
    b: I,
    outKey: g,
    outTypeFunc: B
  }) {
    const C = { a: p(A), b: p(I) }, E = B(p(A), p(I)), t = { [g]: E };
    super({ inTypes: C, outTypes: t, inputs: { a: A, b: I } }), this.outKey = g;
  }
  dynoOut() {
    return new H(this, this.outKey);
  }
}
class sQ extends f {
  constructor({
    a: A,
    b: I,
    c: g,
    outKey: B,
    outTypeFunc: C
  }) {
    const E = { a: p(A), b: p(I), c: p(g) }, t = C(p(A), p(I), p(g)), s = { [B]: t };
    super({ inTypes: E, outTypes: s, inputs: { a: A, b: I, c: g } }), this.outKey = B;
  }
  dynoOut() {
    return new H(this, this.outKey);
  }
}
const v = { type: "Gsplat" }, HQ = { type: "PackedSplats" }, Xt = (Q) => new tg({ packedSplats: Q }), dQ = (Q, A) => new sg({ packedSplats: Q, index: A }), Eg = (Q, A, I, g) => new og({ packedSplats: Q, index: A, base: I, count: g }), kQ = (Q) => new ag({ gsplat: Q }), rQ = ({
  gsplat: Q,
  flags: A,
  index: I,
  center: g,
  scales: B,
  quaternion: C,
  rgba: E,
  rgb: t,
  opacity: s,
  x: o,
  y: a,
  z: i,
  r: D,
  g: n,
  b: w
}) => new eg({
  gsplat: Q,
  flags: A,
  index: I,
  center: g,
  scales: B,
  quaternion: C,
  rgba: E,
  rgb: t,
  opacity: s,
  x: o,
  y: a,
  z: i,
  r: D,
  g: n,
  b: w
}), jt = (Q) => new ng({ gsplat: Q }), UI = (Q, {
  scale: A,
  rotate: I,
  translate: g,
  recolor: B
}) => new cg({ gsplat: Q, scale: A, rotate: I, translate: g, recolor: B }), rA = IA(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`), CI = IA(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
  };
`);
class tg extends N {
  constructor({
    packedSplats: A
  }) {
    super({ a: A, outKey: "numSplats", outTypeFunc: () => "int" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.numSplats} = ${I.a}.numSplats;`
    ];
  }
}
const ig = IA(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);
      return true;
    } else {
      return false;
    }
  }
`);
class sg extends f {
  constructor({
    packedSplats: A,
    index: I
  }) {
    super({
      inTypes: { packedSplats: HQ, index: "int" },
      outTypes: { gsplat: v },
      inputs: { packedSplats: A, index: I },
      globals: () => [rA, CI, ig],
      statements: ({ inputs: g, outputs: B }) => {
        const { gsplat: C } = B;
        if (!C)
          return [];
        const { packedSplats: E, index: t } = g;
        let s;
        return E && t ? s = JA(`
            if (readPackedSplat(${E}.texture, ${E}.numSplats, ${t}, ${C})) {
              bool zeroSize = all(equal(${C}.scales, vec3(0.0, 0.0, 0.0)));
              ${C}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${C}.flags = 0u;
            }
          `) : s = [`${C}.flags = 0u;`], s.push(`${C}.index = ${t ?? "0"};`), s;
      }
    });
  }
  dynoOut() {
    return new H(this, "gsplat");
  }
}
class og extends f {
  constructor({
    packedSplats: A,
    index: I,
    base: g,
    count: B
  }) {
    super({
      inTypes: {
        packedSplats: HQ,
        index: "int",
        base: "int",
        count: "int"
      },
      outTypes: { gsplat: v },
      inputs: { packedSplats: A, index: I, base: g, count: B },
      globals: () => [rA, CI, ig],
      statements: ({ inputs: C, outputs: E }) => {
        const { gsplat: t } = E;
        if (!t)
          return [];
        const { packedSplats: s, index: o, base: a, count: i } = C;
        let D;
        return s && o && a && i ? D = JA(`
            ${t}.flags = 0u;
            if ((${o} >= ${a}) && (${o} < (${a} + ${i}))) {
              if (readPackedSplat(${s}.texture, ${s}.numSplats, ${o}, ${t})) {
                bool zeroSize = all(equal(${t}.scales, vec3(0.0, 0.0, 0.0)));
                ${t}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `) : D = [`${t}.flags = 0u;`], D.push(`${t}.index = ${o ?? "0"};`), D;
      }
    });
  }
  dynoOut() {
    return new H(this, "gsplat");
  }
}
class ag extends f {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: v },
      outTypes: {
        flags: "uint",
        active: "bool",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      inputs: { gsplat: A },
      globals: () => [rA],
      statements: ({ inputs: I, outputs: g }) => {
        const { gsplat: B } = I, {
          flags: C,
          active: E,
          index: t,
          center: s,
          scales: o,
          quaternion: a,
          rgba: i,
          rgb: D,
          opacity: n,
          x: w,
          y: c,
          z: r,
          r: y,
          g: G,
          b: h
        } = g;
        return [
          C ? `${C} = ${B ? `${B}.flags` : "0u"};` : null,
          E ? `${E} = isGsplatActive(${B ? `${B}.flags` : "0u"});` : null,
          t ? `${t} = ${B ? `${B}.index` : "0"};` : null,
          s ? `${s} = ${B ? `${B}.center` : "vec3(0.0, 0.0, 0.0)"};` : null,
          o ? `${o} = ${B ? `${B}.scales` : "vec3(0.0, 0.0, 0.0)"};` : null,
          a ? `${a} = ${B ? `${B}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};` : null,
          i ? `${i} = ${B ? `${B}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};` : null,
          D ? `${D} = ${B ? `${B}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};` : null,
          n ? `${n} = ${B ? `${B}.rgba.a` : "0.0"};` : null,
          w ? `${w} = ${B ? `${B}.center.x` : "0.0"};` : null,
          c ? `${c} = ${B ? `${B}.center.y` : "0.0"};` : null,
          r ? `${r} = ${B ? `${B}.center.z` : "0.0"};` : null,
          y ? `${y} = ${B ? `${B}.rgba.r` : "0.0"};` : null,
          G ? `${G} = ${B ? `${B}.rgba.g` : "0.0"};` : null,
          h ? `${h} = ${B ? `${B}.rgba.b` : "0.0"};` : null
        ].filter(Boolean);
      }
    });
  }
}
class eg extends f {
  constructor({
    gsplat: A,
    flags: I,
    index: g,
    center: B,
    scales: C,
    quaternion: E,
    rgba: t,
    rgb: s,
    opacity: o,
    x: a,
    y: i,
    z: D,
    r: n,
    g: w,
    b: c
  }) {
    super({
      inTypes: {
        gsplat: v,
        flags: "uint",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      outTypes: { gsplat: v },
      inputs: {
        gsplat: A,
        flags: I,
        index: g,
        center: B,
        scales: C,
        quaternion: E,
        rgba: t,
        rgb: s,
        opacity: o,
        x: a,
        y: i,
        z: D,
        r: n,
        g: w,
        b: c
      },
      globals: () => [rA],
      statements: ({ inputs: r, outputs: y }) => {
        const { gsplat: G } = y;
        if (!G)
          return [];
        const {
          gsplat: h,
          flags: M,
          index: l,
          center: k,
          scales: R,
          quaternion: Y,
          rgba: d,
          rgb: m,
          opacity: J,
          x,
          y: U,
          z: S,
          r: T,
          g: V,
          b: P
        } = r;
        return [
          `${G}.flags = ${M ?? (h ? `${h}.flags` : "0u")};`,
          `${G}.index = ${l ?? (h ? `${h}.index` : "0")};`,
          `${G}.center = ${k ?? (h ? `${h}.center` : "vec3(0.0, 0.0, 0.0)")};`,
          `${G}.scales = ${R ?? (h ? `${h}.scales` : "vec3(0.0, 0.0, 0.0)")};`,
          `${G}.quaternion = ${Y ?? (h ? `${h}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,
          `${G}.rgba = ${d ?? (h ? `${h}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,
          m ? `${G}.rgba.rgb = ${m};` : null,
          J ? `${G}.rgba.a = ${J};` : null,
          x ? `${G}.center.x = ${x};` : null,
          U ? `${G}.center.y = ${U};` : null,
          S ? `${G}.center.z = ${S};` : null,
          T ? `${G}.rgba.r = ${T};` : null,
          V ? `${G}.rgba.g = ${V};` : null,
          P ? `${G}.rgba.b = ${P};` : null
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new H(this, "gsplat");
  }
}
const Dg = IA(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);
class ng extends N {
  constructor({ gsplat: A }) {
    super({ a: A, outKey: "normal", outTypeFunc: () => "vec3" }), this.globals = () => [rA, Dg], this.statements = ({ inputs: I, outputs: g }) => [
      `${g.normal} = gsplatNormal(${I.a}.scales, ${I.a}.quaternion);`
    ];
  }
}
class cg extends f {
  constructor({
    gsplat: A,
    scale: I,
    rotate: g,
    translate: B,
    recolor: C
  }) {
    super({
      inTypes: {
        gsplat: v,
        scale: "float",
        rotate: "vec4",
        translate: "vec3",
        recolor: "vec4"
      },
      outTypes: { gsplat: v },
      inputs: { gsplat: A, scale: I, rotate: g, translate: B, recolor: C },
      globals: () => [rA],
      statements: ({ inputs: E, outputs: t, compile: s }) => {
        const { gsplat: o } = t;
        if (!o || !E.gsplat)
          return [];
        const { scale: a, rotate: i, translate: D, recolor: n } = E, w = s.indent;
        return [
          `${o} = ${E.gsplat};`,
          `if (isGsplatActive(${o}.flags)) {`,
          a ? `${w}${o}.center *= ${a};` : null,
          i ? `${w}${o}.center = quatVec(${i}, ${o}.center);` : null,
          D ? `${w}${o}.center += ${D};` : null,
          a ? `${w}${o}.scales *= ${a};` : null,
          i ? `${w}${o}.quaternion = quatQuat(${i}, ${o}.quaternion);` : null,
          n ? `${w}${o}.rgba *= ${n};` : null,
          "}"
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new H(this, "gsplat");
  }
}
const wg = (Q) => new rg({ gsplat: Q }), zt = (Q) => new SI({ rgba8: Q });
class rg extends f {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: v },
      inputs: { gsplat: A },
      globals: () => [rA],
      statements: ({ inputs: I, outputs: g }) => {
        const { output: B } = g;
        if (!B)
          return [];
        const { gsplat: C } = I;
        return C ? JA(`
            if (isGsplatActive(${C}.flags)) {
              ${B} = packSplat(${C}.center, ${C}.scales, ${C}.quaternion, ${C}.rgba);
            } else {
              ${B} = uvec4(0u, 0u, 0u, 0u);
            }
          `) : [`${B} = uvec4(0u, 0u, 0u, 0u);`];
      }
    });
  }
  dynoOut() {
    return new H(this, "output");
  }
}
class SI extends f {
  constructor({ rgba8: A }) {
    super({
      inTypes: { rgba8: "vec4" },
      inputs: { rgba8: A },
      statements: ({ inputs: I, outputs: g }) => [
        `target = ${I.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`
      ]
    });
  }
  dynoOut() {
    return new H(this, "rgba8");
  }
}
const Ot = (Q, A, I) => new F({ key: Q, type: A, value: I }), Pt = (Q = !1, A) => new PQ({ key: A, value: Q }), _t = (Q = 0, A) => new hg({ key: A, value: Q }), $t = (Q = 0, A) => new uQ({ key: A, value: Q }), LA = (Q = 0, A) => new gQ({ key: A, value: Q }), Ai = (Q, A) => new yg({ key: A, value: Q }), Qi = (Q, A) => new Gg({ key: A, value: Q }), Ii = (Q, A) => new lg({ key: A, value: Q }), gi = (Q, A) => new Mg({ key: A, value: Q }), Bi = (Q, A) => new Ng({ key: A, value: Q }), Ci = (Q, A) => new kg({ key: A, value: Q }), Ei = (Q, A) => new Fg({ key: A, value: Q }), vA = (Q, A) => new hQ({ key: A, value: Q }), ti = (Q, A) => new Rg({ key: A, value: Q }), ii = (Q, A) => new Jg({ key: A, value: Q }), si = (Q, A) => new Yg({ key: A, value: Q }), oi = (Q, A) => new fQ({ key: A, value: Q }), ai = (Q, A) => new dg({ key: A, value: Q }), ei = (Q, A) => new ug({ key: A, value: Q }), Di = (Q, A) => new Ug({ key: A, value: Q }), ni = (Q, A) => new Sg({ key: A, value: Q }), ci = (Q, A) => new Lg({ key: A, value: Q }), wi = (Q, A) => new pg({ key: A, value: Q }), ri = (Q, A) => new Hg({ key: A, value: Q }), hi = (Q, A) => new fg({ key: A, value: Q }), yi = (Q, A) => new mg({ key: A, value: Q }), Gi = (Q, A) => new bg({ key: A, value: Q }), li = (Q, A) => new xg({ key: A, value: Q }), Mi = (Q, A) => new Kg({ key: A, value: Q }), Ni = (Q, A) => new Zg({ key: A, value: Q }), ki = (Q, A) => new qg({ key: A, value: Q }), Fi = (Q, A) => new Wg({ key: A, value: Q }), Ri = (Q, A) => new FQ({ key: A, value: Q }), Ji = (Q, A) => new Vg({ key: Q, value: A }), Yi = (Q, A) => new vg({ key: A, value: Q }), di = (Q, A) => new Tg({ key: A, value: Q }), ui = (Q, A) => new Xg({ key: A, value: Q }), Ui = (Q, A) => new jg({ key: A, value: Q }), Si = (Q, A) => new zg({ key: A, value: Q }), Li = (Q, A) => new Og({ key: A, value: Q }), pi = (Q, A) => new Pg({ key: A, value: Q }), Hi = (Q, A) => new _g({ key: A, value: Q }), fi = (Q, A) => new $g({ key: A, value: Q }), mi = (Q, A) => new AB({ key: A, value: Q });
class F extends f {
  constructor({
    key: A,
    type: I,
    count: g,
    value: B,
    update: C,
    globals: E
  }) {
    A = A ?? "value", super({
      outTypes: { [A]: I },
      update: () => {
        if (C) {
          const t = C(this.value);
          t !== void 0 && (this.value = t);
        }
        this.uniform.value = this.value;
      },
      generate: ({ inputs: t, outputs: s }) => {
        const o = (E == null ? void 0 : E({ inputs: t, outputs: s })) ?? [], a = {}, i = s[A];
        return i && (o.push(`uniform ${uI(i, I, g)};`), a[i] = this.uniform), { globals: o, uniforms: a };
      }
    }), this.type = I, this.count = g, this.value = B, this.uniform = { value: B }, this.outKey = A;
  }
  dynoOut() {
    return new H(this, this.outKey);
  }
}
class PQ extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "bool", value: I, update: g });
  }
}
class hg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "uint", value: I, update: g });
  }
}
class uQ extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "int", value: I, update: g });
  }
}
class gQ extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "float", value: I, update: g });
  }
}
class yg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "bvec2", value: I, update: g });
  }
}
class Gg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "uvec2", value: I, update: g });
  }
}
class lg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "ivec2", value: I, update: g });
  }
}
class Mg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "vec2", value: I, update: g });
  }
}
class Ng extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "bvec3", value: I, update: g });
  }
}
class kg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "uvec3", value: I, update: g });
  }
}
class Fg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "ivec3", value: I, update: g });
  }
}
class hQ extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "vec3", value: I, update: g });
  }
}
class Rg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "bvec4", value: I, update: g });
  }
}
class Jg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "uvec4", value: I, update: g });
  }
}
class Yg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "ivec4", value: I, update: g });
  }
}
class fQ extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "vec4", value: I, update: g });
  }
}
class dg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat2", value: I, update: g });
  }
}
class ug extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat2x2", value: I, update: g });
  }
}
class Ug extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat2x3", value: I, update: g });
  }
}
class Sg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat2x4", value: I, update: g });
  }
}
class Lg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat3", value: I, update: g });
  }
}
class pg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat3x2", value: I, update: g });
  }
}
class Hg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat3x3", value: I, update: g });
  }
}
class fg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat3x4", value: I, update: g });
  }
}
class mg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat4", value: I, update: g });
  }
}
class bg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat4x2", value: I, update: g });
  }
}
class xg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat4x3", value: I, update: g });
  }
}
class Kg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat4x4", value: I, update: g });
  }
}
class Zg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "usampler2D", value: I, update: g });
  }
}
class qg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "isampler2D", value: I, update: g });
  }
}
class Wg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler2D", value: I, update: g });
  }
}
class FQ extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "usampler2DArray", value: I, update: g });
  }
}
class Vg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "isampler2DArray", value: I, update: g });
  }
}
class vg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler2DArray", value: I, update: g });
  }
}
class Tg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "usampler3D", value: I, update: g });
  }
}
class Xg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "isampler3D", value: I, update: g });
  }
}
class jg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler3D", value: I, update: g });
  }
}
class zg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "usamplerCube", value: I, update: g });
  }
}
class Og extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "isamplerCube", value: I, update: g });
  }
}
class Pg extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "samplerCube", value: I, update: g });
  }
}
class _g extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler2DShadow", value: I, update: g });
  }
}
class $g extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler2DArrayShadow", value: I, update: g });
  }
}
class AB extends F {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "samplerCubeShadow", value: I, update: g });
  }
}
var CA = Uint8Array, DQ = Uint16Array, bi = Int32Array, QB = new CA([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), IB = new CA([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), xi = new CA([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), gB = function(Q, A) {
  for (var I = new DQ(31), g = 0; g < 31; ++g)
    I[g] = A += 1 << Q[g - 1];
  for (var B = new bi(I[30]), g = 1; g < 30; ++g)
    for (var C = I[g]; C < I[g + 1]; ++C)
      B[C] = C - I[g] << 5 | g;
  return { b: I, r: B };
}, BB = gB(QB, 2), CB = BB.b, Ki = BB.r;
CB[28] = 258, Ki[258] = 28;
var Zi = gB(IB, 0), qi = Zi.b, rI = new DQ(32768);
for (var W = 0; W < 32768; ++W) {
  var VA = (W & 43690) >> 1 | (W & 21845) << 1;
  VA = (VA & 52428) >> 2 | (VA & 13107) << 2, VA = (VA & 61680) >> 4 | (VA & 3855) << 4, rI[W] = ((VA & 65280) >> 8 | (VA & 255) << 8) >> 1;
}
var RQ = function(Q, A, I) {
  for (var g = Q.length, B = 0, C = new DQ(A); B < g; ++B)
    Q[B] && ++C[Q[B] - 1];
  var E = new DQ(A);
  for (B = 1; B < A; ++B)
    E[B] = E[B - 1] + C[B - 1] << 1;
  var t;
  if (I) {
    t = new DQ(1 << A);
    var s = 15 - A;
    for (B = 0; B < g; ++B)
      if (Q[B])
        for (var o = B << 4 | Q[B], a = A - Q[B], i = E[Q[B] - 1]++ << a, D = i | (1 << a) - 1; i <= D; ++i)
          t[rI[i] >> s] = o;
  } else
    for (t = new DQ(g), B = 0; B < g; ++B)
      Q[B] && (t[B] = rI[E[Q[B] - 1]++] >> 15 - Q[B]);
  return t;
}, mQ = new CA(288);
for (var W = 0; W < 144; ++W)
  mQ[W] = 8;
for (var W = 144; W < 256; ++W)
  mQ[W] = 9;
for (var W = 256; W < 280; ++W)
  mQ[W] = 7;
for (var W = 280; W < 288; ++W)
  mQ[W] = 8;
var EB = new CA(32);
for (var W = 0; W < 32; ++W)
  EB[W] = 5;
var Wi = /* @__PURE__ */ RQ(mQ, 9, 1), Vi = /* @__PURE__ */ RQ(EB, 5, 1), oI = function(Q) {
  for (var A = Q[0], I = 1; I < Q.length; ++I)
    Q[I] > A && (A = Q[I]);
  return A;
}, dA = function(Q, A, I) {
  var g = A / 8 | 0;
  return (Q[g] | Q[g + 1] << 8) >> (A & 7) & I;
}, aI = function(Q, A) {
  var I = A / 8 | 0;
  return (Q[I] | Q[I + 1] << 8 | Q[I + 2] << 16) >> (A & 7);
}, tB = function(Q) {
  return (Q + 7) / 8 | 0;
}, TQ = function(Q, A, I) {
  return (A == null || A < 0) && (A = 0), (I == null || I > Q.length) && (I = Q.length), new CA(Q.subarray(A, I));
}, vi = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], kA = function(Q, A, I) {
  var g = new Error(A || vi[Q]);
  if (g.code = Q, Error.captureStackTrace && Error.captureStackTrace(g, kA), !I)
    throw g;
  return g;
}, Ti = function(Q, A, I, g) {
  var B = Q.length, C = 0;
  if (!B || A.f && !A.l)
    return I || new CA(0);
  var E = !I, t = E || A.i != 2, s = A.i;
  E && (I = new CA(B * 3));
  var o = function(lA) {
    var SA = I.length;
    if (lA > SA) {
      var MA = new CA(Math.max(SA * 2, lA));
      MA.set(I), I = MA;
    }
  }, a = A.f || 0, i = A.p || 0, D = A.b || 0, n = A.l, w = A.d, c = A.m, r = A.n, y = B * 8;
  do {
    if (!n) {
      a = dA(Q, i, 1);
      var G = dA(Q, i + 1, 3);
      if (i += 3, G)
        if (G == 1)
          n = Wi, w = Vi, c = 9, r = 5;
        else if (G == 2) {
          var k = dA(Q, i, 31) + 257, R = dA(Q, i + 10, 15) + 4, Y = k + dA(Q, i + 5, 31) + 1;
          i += 14;
          for (var d = new CA(Y), m = new CA(19), J = 0; J < R; ++J)
            m[xi[J]] = dA(Q, i + J * 3, 7);
          i += R * 3;
          for (var x = oI(m), U = (1 << x) - 1, S = RQ(m, x, 1), J = 0; J < Y; ) {
            var T = S[dA(Q, i, U)];
            i += T & 15;
            var h = T >> 4;
            if (h < 16)
              d[J++] = h;
            else {
              var V = 0, P = 0;
              for (h == 16 ? (P = 3 + dA(Q, i, 3), i += 2, V = d[J - 1]) : h == 17 ? (P = 3 + dA(Q, i, 7), i += 3) : h == 18 && (P = 11 + dA(Q, i, 127), i += 7); P--; )
                d[J++] = V;
            }
          }
          var _ = d.subarray(0, k), X = d.subarray(k);
          c = oI(_), r = oI(X), n = RQ(_, c, 1), w = RQ(X, r, 1);
        } else
          kA(1);
      else {
        var h = tB(i) + 4, M = Q[h - 4] | Q[h - 3] << 8, l = h + M;
        if (l > B) {
          s && kA(0);
          break;
        }
        t && o(D + M), I.set(Q.subarray(h, l), D), A.b = D += M, A.p = i = l * 8, A.f = a;
        continue;
      }
      if (i > y) {
        s && kA(0);
        break;
      }
    }
    t && o(D + 131072);
    for (var aA = (1 << c) - 1, $ = (1 << r) - 1, iA = i; ; iA = i) {
      var V = n[aI(Q, i) & aA], eA = V >> 4;
      if (i += V & 15, i > y) {
        s && kA(0);
        break;
      }
      if (V || kA(2), eA < 256)
        I[D++] = eA;
      else if (eA == 256) {
        iA = i, n = null;
        break;
      } else {
        var YA = eA - 254;
        if (eA > 264) {
          var J = eA - 257, hA = QB[J];
          YA = dA(Q, i, (1 << hA) - 1) + CB[J], i += hA;
        }
        var DA = w[aI(Q, i) & $], L = DA >> 4;
        DA || kA(3), i += DA & 15;
        var X = qi[L];
        if (L > 3) {
          var hA = IB[L];
          X += aI(Q, i) & (1 << hA) - 1, i += hA;
        }
        if (i > y) {
          s && kA(0);
          break;
        }
        t && o(D + 131072);
        var yA = D + YA;
        if (D < X) {
          var gA = C - X, GA = Math.min(X, yA);
          for (gA + D < 0 && kA(3); D < GA; ++D)
            I[D] = g[gA + D];
        }
        for (; D < yA; ++D)
          I[D] = I[D - X];
      }
    }
    A.l = n, A.p = iA, A.b = D, A.f = a, n && (a = 1, A.m = c, A.d = w, A.n = r);
  } while (!a);
  return D != I.length && E ? TQ(I, 0, D) : I.subarray(0, D);
}, Xi = /* @__PURE__ */ new CA(0), ji = function(Q) {
  (Q[0] != 31 || Q[1] != 139 || Q[2] != 8) && kA(6, "invalid gzip data");
  var A = Q[3], I = 10;
  A & 4 && (I += (Q[10] | Q[11] << 8) + 2);
  for (var g = (A >> 3 & 1) + (A >> 4 & 1); g > 0; g -= !Q[I++])
    ;
  return I + (A & 2);
}, eI = /* @__PURE__ */ function() {
  function Q(A, I) {
    typeof A == "function" && (I = A, A = {}), this.ondata = I;
    var g = A && A.dictionary && A.dictionary.subarray(-32768);
    this.s = { i: 0, b: g ? g.length : 0 }, this.o = new CA(32768), this.p = new CA(0), g && this.o.set(g);
  }
  return Q.prototype.e = function(A) {
    if (this.ondata || kA(5), this.d && kA(4), !this.p.length)
      this.p = A;
    else if (A.length) {
      var I = new CA(this.p.length + A.length);
      I.set(this.p), I.set(A, this.p.length), this.p = I;
    }
  }, Q.prototype.c = function(A) {
    this.s.i = +(this.d = A || !1);
    var I = this.s.b, g = Ti(this.p, this.s, this.o);
    this.ondata(TQ(g, I, this.s.b), this.d), this.o = TQ(g, this.s.b - 32768), this.s.b = this.o.length, this.p = TQ(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, Q.prototype.push = function(A, I) {
    this.e(A), this.c(I);
  }, Q;
}(), iB = /* @__PURE__ */ function() {
  function Q(A, I) {
    this.v = 1, this.r = 0, eI.call(this, A, I);
  }
  return Q.prototype.push = function(A, I) {
    if (eI.prototype.e.call(this, A), this.r += A.length, this.v) {
      var g = this.p.subarray(this.v - 1), B = g.length > 3 ? ji(g) : 4;
      if (B > g.length) {
        if (!I)
          return;
      } else this.v > 1 && this.onmember && this.onmember(this.r - g.length);
      this.p = g.subarray(B), this.v = 0;
    }
    eI.prototype.c.call(this, I), this.s.f && !this.s.l && !I && (this.v = tB(this.s.p) + 9, this.s = { i: 0 }, this.o = new CA(0), this.push(new CA(0), I));
  }, Q;
}(), zi = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Oi = 0;
try {
  zi.decode(Xi, { stream: !0 }), Oi = 1;
} catch {
}
const bQ = new Float32Array(1), EI = new Uint32Array(bQ.buffer);
function Pi(Q) {
  return bQ[0] = Q, EI[0];
}
function _i(Q) {
  return EI[0] = Q, bQ[0];
}
function BQ(Q) {
  bQ[0] = Q;
  const A = EI[0], I = A >> 31 & 1, g = A >> 23 & 255, B = A & 8388607, C = I << 15;
  if (g === 255)
    return B !== 0 ? C | 32767 : C | 31744;
  const E = g - 127 + 15;
  if (E >= 31)
    return C | 31744;
  if (E <= 0) {
    if (E < -10)
      return C;
    const s = (B | 8388608) >> 1 - E + 13;
    return C | s;
  }
  const t = B >> 13;
  return C | E << 10 | t;
}
function CQ(Q) {
  const A = Q >> 15 & 1, I = Q >> 10 & 31, g = Q & 1023;
  let B;
  if (I === 0)
    if (g === 0)
      B = A << 31;
    else {
      let C = g, E = -14;
      for (; (C & 1024) === 0; )
        C <<= 1, E--;
      C &= 1023;
      const t = E + 127, s = C << 13;
      B = A << 31 | t << 23 | s;
    }
  else if (I === 31)
    g === 0 ? B = A << 31 | 2139095040 : B = A << 31 | 2143289344;
  else {
    const C = I - 15 + 127, E = g << 13;
    B = A << 31 | C << 23 | E;
  }
  return EI[0] = B, bQ[0];
}
function xA(Q) {
  return Math.max(0, Math.min(255, Math.round(Q * 255)));
}
function XQ(Q) {
  return Math.max(-127, Math.min(127, Math.round(Q * 127)));
}
function $i(Q) {
  return Q / 255;
}
function As(Q) {
  return Q / 127;
}
class Qs {
  // Create a DataCache with a given function that fetches data not in the cache.
  constructor({
    asyncFetch: A,
    maxItems: I = 5
  }) {
    this.asyncFetch = A, this.maxItems = I, this.items = [];
  }
  // Fetch data for the key, returning cached data if available.
  async getFetch(A) {
    const I = this.items.findIndex((B) => B.key === A);
    if (I >= 0) {
      const B = this.items.splice(I, 1)[0];
      return this.items.push(B), B.data;
    }
    const g = await this.asyncFetch(A);
    for (this.items.push({ key: A, data: g }); this.items.length > this.maxItems; )
      this.items.shift();
    return g;
  }
}
function Is(Q, A) {
  const I = Object.entries(Q).map(([g, B]) => [
    g,
    A(B, g)
  ]);
  return Object.fromEntries(I);
}
function gs(Q, A) {
  const I = Object.entries(Q).map(([g, B]) => [g, A(B, g)]).filter(([g, B]) => B !== void 0);
  return Object.fromEntries(I);
}
function sB(Q) {
  const A = [], I = /* @__PURE__ */ new Set();
  function g(B) {
    B && typeof B == "object" && !I.has(B) && (I.add(B), B instanceof ArrayBuffer ? A.push(B) : ArrayBuffer.isView(B) ? A.push(B.buffer) : Array.isArray(B) ? B.forEach(g) : Object.values(B).forEach(g));
  }
  return g(Q), A;
}
function Bs(Q, A) {
  return new Array(Q).fill(null).map((I, g) => A(g));
}
class oB {
  constructor({
    // Allocate a new item with the given args
    allocate: A,
    // Dispose of an item (optional, if GC is enough)
    dispose: I,
    // Check if an existing item in the list is valid for the given args,
    // allowing you to store heterogeneous items in the list.
    valid: g
  }) {
    this.items = [], this.allocate = A, this.dispose = I, this.valid = g;
  }
  // Allocate a new item from the free list, first checking if a existing item
  // on the freelist is valid for the given args.
  alloc(A) {
    for (; ; ) {
      const I = this.items.pop();
      if (!I)
        break;
      if (this.valid(I, A))
        return I;
      this.dispose && this.dispose(I);
    }
    return this.allocate(A);
  }
  free(A) {
    this.items.push(A);
  }
  disposeAll() {
    let A;
    for (A = this.items.pop(); A; )
      this.dispose && this.dispose(A), A = this.items.pop();
  }
}
function hI(Q, A, I, g, B, C, E, t, s, o, a, i, D, n, w, c) {
  const r = xA(n), y = xA(w), G = xA(c), h = xA(D), M = LI(
    new e.Quaternion(s, o, a, i)
  ), l = M & 255, k = M >>> 8 & 255, R = M >>> 16 & 255, Y = C === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(C) - pA) / KA) + 1
    )
  ), d = E === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(E) - pA) / KA) + 1
    )
  ), m = t === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(t) - pA) / KA) + 1
    )
  ), J = BQ(I), x = BQ(g), U = BQ(B), S = A * 4;
  Q[S] = r | y << 8 | G << 16 | h << 24, Q[S + 1] = J | x << 16, Q[S + 2] = U | l << 16 | k << 24, Q[S + 3] = Y | d << 8 | m << 16 | R << 24;
}
function Cs(Q, A, I, g, B) {
  const C = BQ(I), E = BQ(g), t = BQ(B), s = A * 4;
  Q[s + 1] = C | E << 16, Q[s + 2] = t | Q[s + 2] & 4294901760;
}
function Es(Q, A, I, g, B) {
  const C = I === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(I) - pA) / KA) + 1
    )
  ), E = g === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(g) - pA) / KA) + 1
    )
  ), t = B === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(B) - pA) / KA) + 1
    )
  ), s = A * 4;
  Q[s + 3] = C | E << 8 | t << 16 | Q[s + 3] & 4278190080;
}
function ts(Q, A, I, g, B, C) {
  const E = LI(
    new e.Quaternion(I, g, B, C)
  ), t = E & 255, s = E >>> 8 & 255, o = E >>> 16 & 255, a = A * 4;
  Q[a + 2] = Q[a + 2] & 65535 | t << 16 | s << 24, Q[a + 3] = Q[a + 3] & 16777215 | o << 24;
}
function is(Q, A, I, g, B) {
  const C = xA(I), E = xA(g), t = xA(B), s = A * 4;
  Q[s] = C | E << 8 | t << 16 | Q[s] & 4278190080;
}
function ss(Q, A, I) {
  const g = xA(I), B = A * 4;
  Q[B] = Q[B] & 16777215 | g << 24;
}
const os = new e.Vector3(), as = new e.Vector3(), es = new e.Quaternion(), Ds = new e.Color(), ns = {
  center: os,
  scales: as,
  quaternion: es,
  color: Ds,
  opacity: 0
};
function yI(Q, A) {
  const I = ns, g = A * 4, B = Q[g], C = Q[g + 1], E = Q[g + 2], t = Q[g + 3];
  I.color.set(
    (B & 255) / 255,
    (B >>> 8 & 255) / 255,
    (B >>> 16 & 255) / 255
  ), I.opacity = (B >>> 24 & 255) / 255, I.center.set(
    CQ(C & 65535),
    CQ(C >>> 16 & 65535),
    CQ(E & 65535)
  );
  const s = t & 255;
  I.scales.x = s === 0 ? 0 : Math.exp(pA + (s - 1) * KA);
  const o = t >>> 8 & 255;
  I.scales.y = o === 0 ? 0 : Math.exp(pA + (o - 1) * KA);
  const a = t >>> 16 & 255;
  I.scales.z = a === 0 ? 0 : Math.exp(pA + (a - 1) * KA);
  const i = E >>> 16 & 65535 | t >>> 8 & 16711680;
  return rB(i, I.quaternion), I;
}
function wA(Q) {
  const A = Z, I = Math.max(
    Zt,
    Math.min(IQ, Math.ceil(Q / A))
  ), g = Math.ceil(Q / (A * I)), B = A * I * g;
  return { width: A, height: I, depth: g, maxSplats: B };
}
function cs() {
  return navigator.maxTouchPoints > 0 ? !0 : /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(
    navigator.userAgent
  );
}
function ws() {
  return /Android/.test(navigator.userAgent);
}
function rs() {
  return /Oculus/.test(navigator.userAgent);
}
function hs(Q, A, I) {
  const g = new Uint8Array(A * 4);
  for (let B = 0; B < I / 2; B++) {
    const C = B * A * 4, E = (I - 1 - B) * A * 4;
    g.set(Q.subarray(C, C + A * 4)), Q.set(
      Q.subarray(E, E + A * 4),
      C
    ), Q.set(g, E);
  }
  return Q;
}
function ys(Q, A, I) {
  const g = document.createElement("canvas");
  g.width = A, g.height = I;
  const B = g.getContext("2d");
  if (!B)
    throw new Error("Can't get 2d context");
  const C = B.createImageData(A, I);
  return C.data.set(Q), B.putImageData(C, 0, 0), g.toDataURL("image/png");
}
function aB(Q) {
  const A = new e.Clock(Q.autoStart);
  return A.startTime = Q.startTime, A.oldTime = Q.oldTime, A.elapsedTime = Q.elapsedTime, A.running = Q.running, A;
}
function Gs(Q) {
  return Object.fromEntries(
    Object.entries(Q).filter(([A, I]) => I !== void 0)
  );
}
const eB = IA(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);
function DB(Q) {
  const A = new e.Vector3();
  for (const I of Q)
    A.add(I);
  return A.divideScalar(Q.length);
}
function nB(Q) {
  if (Q.length === 0)
    return new e.Quaternion();
  const A = Q[0].clone();
  for (let I = 1; I < Q.length; I++)
    Q[I].dot(Q[0]) < 0 ? (A.x -= Q[I].x, A.y -= Q[I].y, A.z -= Q[I].z, A.w -= Q[I].w) : (A.x += Q[I].x, A.y += Q[I].y, A.z += Q[I].z, A.w += Q[I].w);
  return A.normalize();
}
function cB(Q, A) {
  const I = new e.Vector3(0, 0, 0).applyMatrix4(Q), g = new e.Vector3(0, 0, 0).applyMatrix4(A), B = new e.Vector3(0, 0, -1).applyMatrix4(Q).sub(I).normalize(), C = new e.Vector3(0, 0, -1).applyMatrix4(A).sub(g).normalize(), E = I.distanceTo(g), t = B.dot(C);
  return { distance: E, coincidence: t };
}
function ls({
  matrix1: Q,
  matrix2: A,
  maxDistance: I
}) {
  const g = new e.Vector3(0, 0, 0).applyMatrix4(Q), B = new e.Vector3(0, 0, 0).applyMatrix4(A);
  return g.distanceTo(B) <= I;
}
function Ms({
  matrix1: Q,
  matrix2: A,
  maxDistance: I,
  minCoincidence: g
}) {
  const { distance: B, coincidence: C } = cB(Q, A);
  return B <= I && (g == null || C >= g);
}
function wB(Q, A) {
  const [I, g] = [new e.Vector3(), new e.Quaternion()], [B, C] = [new e.Vector3(), new e.Quaternion()];
  Q.decompose(I, g, new e.Vector3()), A.decompose(B, C, new e.Vector3());
  const E = I.distanceTo(B), t = Math.abs(g.dot(C));
  return { distance: E, coorient: t };
}
function _Q({
  matrix1: Q,
  matrix2: A,
  maxDistance: I,
  minCoorient: g
}) {
  const { distance: B, coorient: C } = wB(Q, A);
  return B <= I && (g == null || C >= g);
}
function Ns(Q, A = 1e-3) {
  return Math.abs(Q) < A ? 0 : Math.sign(Q);
}
function ks(Q) {
  const A = Q.w < 0, I = XQ(A ? -Q.x : Q.x), g = XQ(A ? -Q.y : Q.y), B = XQ(A ? -Q.z : Q.z), C = I & 255, E = g & 255, t = B & 255;
  return C | E << 8 | t << 16;
}
function Fs(Q, A) {
  const I = Q << 24 >> 24, g = Q << 16 >> 24, B = Q << 8 >> 24;
  A.set(I / 127, g / 127, B / 127, 0);
  const C = A.x * A.x + A.y * A.y + A.z * A.z;
  return A.w = Math.sqrt(Math.max(0, 1 - C)), A;
}
function LI(Q) {
  const A = Q.clone().normalize();
  A.w < 0 && A.set(-A.x, -A.y, -A.z, -A.w);
  const I = 2 * Math.acos(A.w), g = Math.sqrt(
    A.x * A.x + A.y * A.y + A.z * A.z
  ), B = g < 1e-6 ? new e.Vector3(1, 0, 0) : new e.Vector3(A.x, A.y, A.z).divideScalar(g), C = Math.abs(B.x) + Math.abs(B.y) + Math.abs(B.z);
  let E = B.x / C, t = B.y / C;
  if (B.z < 0) {
    const n = E;
    E = (1 - Math.abs(t)) * (E >= 0 ? 1 : -1), t = (1 - Math.abs(n)) * (t >= 0 ? 1 : -1);
  }
  const s = E * 0.5 + 0.5, o = t * 0.5 + 0.5, a = Math.round(s * 255), i = Math.round(o * 255);
  return Math.round(I * (255 / Math.PI)) << 16 | i << 8 | a;
}
function rB(Q, A) {
  const I = Q & 255, g = Q >>> 8 & 255, B = Q >>> 16 & 255, C = I / 255, E = g / 255;
  let t = (C - 0.5) * 2, s = (E - 0.5) * 2;
  const o = 1 - (Math.abs(t) + Math.abs(s)), a = Math.max(-o, 0);
  t += t >= 0 ? -a : a, s += s >= 0 ? -a : a;
  const i = new e.Vector3(t, s, o).normalize(), n = B / 255 * Math.PI * 0.5, w = Math.sin(n), c = Math.cos(n);
  return A.set(i.x * w, i.y * w, i.z * w, c), A;
}
function Rs(Q) {
  const A = Q.clone().normalize(), I = 2 * (A.w * A.x + A.y * A.z), g = 1 - 2 * (A.x * A.x + A.y * A.y), B = Math.atan2(I, g), C = 2 * (A.w * A.y - A.z * A.x), E = Math.abs(C) >= 1 ? Math.sign(C) * (Math.PI / 2) : Math.asin(C), t = 2 * (A.w * A.z + A.x * A.y), s = 1 - 2 * (A.y * A.y + A.z * A.z), o = Math.atan2(t, s), a = (B + Math.PI) / (2 * Math.PI), i = (E + Math.PI) / (2 * Math.PI), D = (o + Math.PI) / (2 * Math.PI), n = Math.round(a * 255), w = Math.round(i * 255);
  return Math.round(D * 255) << 16 | w << 8 | n;
}
function Js(Q, A) {
  const I = Q & 255, g = Q >>> 8 & 255, B = Q >>> 16 & 255, C = I / 255, E = g / 255, t = B / 255, s = C * (2 * Math.PI) - Math.PI, o = E * (2 * Math.PI) - Math.PI, a = t * (2 * Math.PI) - Math.PI, i = Math.cos(s * 0.5), D = Math.sin(s * 0.5), n = Math.cos(o * 0.5), w = Math.sin(o * 0.5), c = Math.cos(a * 0.5), r = Math.sin(a * 0.5);
  return A.w = i * n * c + D * w * r, A.x = D * n * c - i * w * r, A.y = i * w * c + D * n * r, A.z = i * n * r - D * w * c, A.normalize(), A;
}
function xQ(Q, A, I, g) {
  const B = Math.max(-127, Math.min(127, Q * 127)), C = Math.max(-127, Math.min(127, A * 127)), E = Math.max(-127, Math.min(127, I * 127)), t = Math.max(-127, Math.min(127, g * 127));
  return B & 255 | (C & 255) << 8 | (E & 255) << 16 | (t & 255) << 24;
}
function Ys(Q, A, I) {
  const g = A * 2;
  for (let B = 0; B < 9; ++B) {
    const C = Math.max(-63, Math.min(63, I[B] * 63)) & 127, E = B * 7, t = E + 7, s = Math.floor(E / 32), o = E - s * 32, a = C << o & 4294967295;
    if (Q[g + s] |= a, t > s * 32 + 32) {
      const i = C >>> 32 - o & 4294967295;
      Q[g + s + 1] |= i;
    }
  }
}
function ds(Q, A, I) {
  Q[A * 4 + 0] = xQ(
    I[0],
    I[1],
    I[2],
    I[3]
  ), Q[A * 4 + 1] = xQ(
    I[4],
    I[5],
    I[6],
    I[7]
  ), Q[A * 4 + 2] = xQ(
    I[8],
    I[9],
    I[10],
    I[11]
  ), Q[A * 4 + 3] = xQ(
    I[12],
    I[13],
    I[14],
    0
  );
}
function us(Q, A, I) {
  const g = A * 4;
  for (let B = 0; B < 21; ++B) {
    const C = Math.max(-31, Math.min(31, I[B] * 31)) & 63, E = B * 6, t = E + 6, s = Math.floor(E / 32), o = E - s * 32, a = C << o & 4294967295;
    if (Q[g + s] |= a, t > s * 32 + 32) {
      const i = C >>> 32 - o & 4294967295;
      Q[g + s + 1] |= i;
    }
  }
}
function hB(Q, A) {
  const I = [];
  let g = 0, B = null;
  const C = new iB((s, o) => {
    if (I.push(s), g += s.length, o || g >= A) {
      const a = new Uint8Array(g);
      let i = 0;
      for (const D of I)
        a.set(D, i), i += D.length;
      B = a.slice(0, A);
    }
  }), E = 1024;
  let t = 0;
  for (; B == null && t < Q.length; ) {
    const s = Q.slice(t, t + E);
    C.push(s, !1), t += E;
  }
  if (B == null && (C.push(new Uint8Array(), !0), B == null))
    throw new Error("Failed to decompress partial gzip");
  return B;
}
class yB {
  constructor({
    fileBytes: A,
    chunkBytes: I = 64 * 1024
  }) {
    this.fileBytes = A, this.chunkBytes = I, this.offset = 0, this.chunks = [], this.totalBytes = 0, this.gunzip = new iB((g, B) => {
      this.chunks.push(g), this.totalBytes += g.length;
    });
  }
  read(A) {
    for (; this.totalBytes < A && this.offset < this.fileBytes.length; ) {
      const C = Math.min(
        this.offset + this.chunkBytes,
        this.fileBytes.length
      );
      this.gunzip.push(this.fileBytes.subarray(this.offset, C), !1), this.offset = C;
    }
    if (this.totalBytes < A && this.offset >= this.fileBytes.length && this.gunzip.push(new Uint8Array(0), !0), this.totalBytes < A)
      throw new Error(
        `Unexpected EOF: needed ${A}, got ${this.totalBytes}`
      );
    const I = new Uint8Array(this.totalBytes);
    let g = 0;
    for (const C of this.chunks)
      I.set(C, g), g += C.length;
    const B = I.subarray(0, A);
    return this.chunks = [I.subarray(A)], this.totalBytes -= A, B;
  }
}
const FD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataCache: Qs,
  FreeList: oB,
  GunzipReader: yB,
  IDENT_VERTEX_SHADER: eB,
  Sint8ToFloat: As,
  Uint8ToFloat: $i,
  averagePositions: DB,
  averageQuaternions: nB,
  cloneClock: aB,
  coinciDist: cB,
  coorientDist: wB,
  decodeQuatEulerXyz888: Js,
  decodeQuatOctXy88R8: rB,
  decodeQuatXyz888: Fs,
  decompressPartialGzip: hB,
  encodeQuatEulerXyz888: Rs,
  encodeQuatOctXy88R8: LI,
  encodeQuatXyz888: ks,
  encodeSh1Rgb: Ys,
  encodeSh2Rgb: ds,
  encodeSh3Rgb: us,
  epsilonSign: Ns,
  flipPixels: hs,
  floatBitsToUint: Pi,
  floatToSint8: XQ,
  floatToUint8: xA,
  fromHalf: CQ,
  getArrayBuffers: sB,
  getTextureSize: wA,
  isAndroid: ws,
  isMobile: cs,
  isOculus: rs,
  mapFilterObject: gs,
  mapObject: Is,
  newArray: Bs,
  omitUndefined: Gs,
  pixelsToPngUrl: ys,
  setPackedSplat: hI,
  setPackedSplatCenter: Cs,
  setPackedSplatOpacity: ss,
  setPackedSplatQuat: ts,
  setPackedSplatRgb: is,
  setPackedSplatScales: Es,
  toHalf: BQ,
  uintBitsToFloat: _i,
  unpackSplat: yI,
  withinCoinciDist: Ms,
  withinCoorientDist: _Q,
  withinDist: ls
}, Symbol.toStringTag, { value: "Module" }));
class pI {
  constructor({
    graph: A,
    inputs: I,
    outputs: g,
    template: B
  }) {
    this.graph = A, this.template = B, this.inputs = I ?? {}, this.outputs = g ?? {};
    const C = new Cg({ indent: this.template.indent });
    for (const t in this.outputs)
      this.outputs[t] && C.declares.add(this.outputs[t]);
    const E = A.compile({
      inputs: this.inputs,
      outputs: this.outputs,
      compile: C
    });
    this.shader = B.generate({ globals: C.globals, statements: E }), this.uniforms = C.uniforms, this.updaters = C.updaters;
  }
  prepareMaterial() {
    return Us(this);
  }
  update() {
    for (const A of this.updaters)
      A();
  }
}
class HI {
  constructor(A) {
    const I = A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m), g = A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);
    if (!I || !g)
      throw new Error(
        "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
      );
    this.before = A.substring(0, I.index), this.between = A.substring(
      I.index + I[0].length,
      g.index
    ), this.after = A.substring(
      g.index + g[0].length
    ), this.indent = g[1];
  }
  generate({
    globals: A,
    statements: I
  }) {
    return this.before + Array.from(A).join(`

`) + this.between + I.map((g) => this.indent + g).join(`
`) + this.after;
  }
}
const VI = /* @__PURE__ */ new Map();
function Us(Q) {
  let A = VI.get(Q);
  return A || (A = new e.RawShaderMaterial({
    glslVersion: e.GLSL3,
    vertexShader: eB,
    fragmentShader: Q.shader,
    uniforms: Q.uniforms
  }), VI.set(Q, A), A);
}
function fI(Q, A, I = "add") {
  const g = () => {
    throw new Error(`Invalid ${I} types: ${Q}, ${A}`);
  };
  if (Q === A) return Q;
  if (Q === "int") {
    if (EA(A)) return A;
    g();
  }
  if (A === "int") {
    if (EA(Q)) return Q;
    g();
  }
  if (Q === "uint") {
    if (tA(A)) return A;
    g();
  }
  if (A === "uint") {
    if (tA(Q)) return Q;
    g();
  }
  if (Q === "float") {
    if (zA(A)) return A;
    g();
  }
  if (A === "float") {
    if (zA(Q)) return Q;
    g();
  }
  throw new Error(`Invalid ${I} types: ${Q}, ${A}`);
}
function Ss(Q, A) {
  return fI(Q, A, "sub");
}
function Ls(Q, A) {
  const I = () => {
    throw new Error(`Invalid mul types: ${Q}, ${A}`);
  }, g = (B) => B;
  if (Q === "int") {
    if (EA(A)) return g(A);
    I();
  }
  if (A === "int") {
    if (EA(Q)) return g(Q);
    I();
  }
  if (Q === "uint") {
    if (tA(A)) return g(A);
    I();
  }
  if (A === "uint") {
    if (tA(Q)) return g(Q);
    I();
  }
  if (Q === "float") {
    if (zA(A)) return g(A);
    I();
  }
  if (A === "float") {
    if (zA(Q)) return g(Q);
    I();
  }
  if (EA(Q) || tA(Q) || EA(A) || tA(A)) {
    if (Q === A) return g(Q);
    I();
  }
  if (Q === "vec2") {
    if (A === "vec2" || $A(A)) return g("vec2");
    if (A === "mat3x2") return g("vec3");
    if (A === "mat4x2") return g("vec4");
    I();
  }
  if (Q === "vec3") {
    if (A === "mat2x3") return g("vec2");
    if (A === "vec3" || AQ(A)) return g("vec3");
    if (A === "mat4x3") return g("vec4");
    I();
  }
  if (Q === "vec4") {
    if (A === "mat2x4") return g("vec2");
    if (A === "mat3x4") return g("vec3");
    if (A === "vec4" || QQ(A)) return g("vec4");
    I();
  }
  if (A === "vec2") {
    if ($A(Q)) return g("vec2");
    if (Q === "mat2x3") return g("vec3");
    if (Q === "mat2x4") return g("vec4");
    I();
  }
  if (A === "vec3") {
    if (Q === "mat3x2") return g("vec2");
    if (AQ(Q)) return g("vec3");
    if (Q === "mat3x4") return g("vec4");
    I();
  }
  if (A === "vec4") {
    if (Q === "mat4x2") return g("vec2");
    if (Q === "mat4x3") return g("vec3");
    if (QQ(Q)) return g("vec4");
    I();
  }
  if ($A(Q)) {
    if ($A(A)) return g("mat2");
    if (A === "mat3x2") return g("mat3x2");
    if (A === "mat4x2") return g("mat4x2");
    I();
  }
  if (Q === "mat2x3") {
    if ($A(A)) return g("mat2x3");
    if (A === "mat3x2") return g("mat3");
    if (A === "mat4x2") return g("mat4x3");
    I();
  }
  if (Q === "mat2x4") {
    if ($A(A)) return g("mat2x4");
    if (A === "mat3x2") return g("mat3x4");
    if (A === "mat4x2") return g("mat4");
    I();
  }
  if (Q === "mat3x2") {
    if (A === "mat2x3") return g("mat2");
    if (AQ(A)) return g("mat3x2");
    if (A === "mat4x3") return g("mat4x2");
    I();
  }
  if (AQ(Q)) {
    if (A === "mat2x3") return g("mat2x3");
    if (AQ(A)) return g("mat3");
    if (A === "mat4x3") return g("mat4x3");
    I();
  }
  if (Q === "mat3x4") {
    if (A === "mat2x3") return g("mat2x4");
    if (AQ(A)) return g("mat3x4");
    if (A === "mat4x3") return g("mat4");
    I();
  }
  if (Q === "mat4x2") {
    if (A === "mat2x4") return g("mat2");
    if (A === "mat3x4") return g("mat3x2");
    if (QQ(A)) return g("mat4x2");
    I();
  }
  if (Q === "mat4x3") {
    if (A === "mat2x4") return g("mat2x3");
    if (A === "mat3x4") return g("mat3");
    if (QQ(A)) return g("mat4x3");
    I();
  }
  if (QQ(Q)) {
    if (A === "mat2x4") return g("mat2x4");
    if (A === "mat3x4") return g("mat3x4");
    if (QQ(A)) return g("mat4");
    I();
  }
  throw new Error(`Invalid mul types: ${Q}, ${A}`);
}
function ps(Q, A) {
  return fI(Q, A, "div");
}
function Hs(Q, A) {
  if (Q === A) return Q;
  if (Q === "int") {
    if (EA(A)) return A;
  } else if (A === "int") {
    if (EA(Q)) return Q;
  } else if (Q === "uint") {
    if (tA(A)) return A;
  } else if (A === "uint" && tA(Q))
    return Q;
  throw new Error(`Invalid imod types: ${Q}, ${A}`);
}
function fs(Q, A) {
  if (Q === A || A === "float") return Q;
  throw new Error(`Invalid mod types: ${Q}, ${A}`);
}
function ms(Q) {
  return Q;
}
function bs(Q) {
  return Q;
}
function xs(Q) {
  return Q;
}
function Ks(Q) {
  return Q;
}
function Zs(Q) {
  return Q;
}
function qs(Q) {
  return Q;
}
function Ws(Q) {
  return Q;
}
function Vs(Q) {
  return Q;
}
function vs(Q) {
  return Q;
}
function Ts(Q) {
  return Q;
}
function Xs(Q) {
  return Q;
}
function js(Q) {
  return Q;
}
function zs(Q) {
  return Q;
}
function Os(Q) {
  return Q;
}
function Ps(Q) {
  return Q;
}
function _s(Q) {
  return Q;
}
function GB(Q, A, I = "min") {
  if (Q === A) return Q;
  if (A === "float") {
    if (SQ(Q)) return Q;
  } else if (A === "int") {
    if (EA(Q)) return Q;
  } else if (A === "uint" && tA(Q))
    return Q;
  throw new Error(`Invalid ${I} types: ${Q}, ${A}`);
}
function $s(Q, A) {
  return GB(Q, A, "max");
}
function Ao(Q, A, I) {
  if (A === "float") {
    if (SQ(Q)) return Q;
  } else if (A === "int") {
    if (EA(Q)) return Q;
  } else if (A === "uint" && tA(Q))
    return Q;
  throw new Error(`Invalid clamp types: ${Q}, ${A}`);
}
function Qo(Q, A, I) {
  if (I === Q || I === "float" || I === "bool" && Q === "float" || I === "bvec2" && Q === "vec2" || I === "bvec3" && Q === "vec3" || I === "bvec4" && Q === "vec4") return Q;
  throw new Error(`Invalid mix types: ${Q}, ${A}, ${I}`);
}
function Io(Q, A) {
  if (Q === A || A === "float") return A;
  throw new Error(`Invalid step types: ${Q}, ${A}`);
}
function go(Q, A, I) {
  if (Q === A && (Q === I || Q === "float"))
    return I;
  throw new Error(`Invalid smoothstep types: ${Q}, ${A}, ${I}`);
}
function lB(Q, A = "isNan") {
  if (Q === "float") return "bool";
  if (Q === "vec2") return "bvec2";
  if (Q === "vec3") return "bvec3";
  if (Q === "vec4") return "bvec4";
  throw new Error(`Invalid ${A} types: ${Q}`);
}
function Bo(Q) {
  return lB(Q, "isInf");
}
const cA = (Q, A) => new FB({ a: Q, b: A }), UQ = (Q, A) => new RB({ a: Q, b: A }), BA = (Q, A) => new JB({ a: Q, b: A }), jQ = (Q, A) => new YB({ a: Q, b: A }), GI = (Q, A) => new dB({ a: Q, b: A }), MB = (Q, A) => new uB({ a: Q, b: A }), Co = (Q) => new UB({ a: Q }).outputs, Eo = (Q) => new SB({ a: Q }), to = (Q) => new LB({ a: Q }), io = (Q) => new pB({ a: Q }), so = (Q) => new HB({ a: Q }), oo = (Q) => new fB({ a: Q }), ao = (Q) => new mB({ a: Q }), eo = (Q) => new bB({ a: Q }), zQ = (Q) => new xB({ a: Q }), Do = (Q, A) => new KB({ a: Q, b: A }), no = (Q) => new ZB({ a: Q }), co = (Q) => new qB({ a: Q }), wo = (Q) => new WB({ a: Q }), ro = (Q) => new VB({ a: Q }), ho = (Q) => new vB({ a: Q }), yo = (Q) => new TB({ a: Q }), Go = (Q) => new XB({ a: Q }), lo = (Q, A) => new jB({ a: Q, b: A }), NB = (Q, A) => new zB({ a: Q, b: A }), Mo = (Q, A, I) => new OB({ a: Q, min: A, max: I }), kB = (Q, A, I) => new PB({ a: Q, b: A, t: I }), No = (Q, A) => new _B({ edge: Q, x: A }), ko = (Q, A, I) => new $B({ edge0: Q, edge1: A, x: I }), Fo = (Q) => new AC({ a: Q }), Ro = (Q) => new QC({ a: Q });
class FB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "sum", outTypeFunc: fI }), this.statements = ({ inputs: g, outputs: B }) => [`${B.sum} = ${g.a} + ${g.b};`];
  }
}
class RB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "difference", outTypeFunc: Ss }), this.statements = ({ inputs: g, outputs: B }) => [`${B.difference} = ${g.a} - ${g.b};`];
  }
}
class JB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "product", outTypeFunc: Ls }), this.statements = ({ inputs: g, outputs: B }) => [`${B.product} = ${g.a} * ${g.b};`];
  }
}
class YB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "quotient", outTypeFunc: ps }), this.statements = ({ inputs: g, outputs: B }) => [`${B.quotient} = ${g.a} / ${g.b};`];
  }
}
class dB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "remainder", outTypeFunc: Hs }), this.statements = ({ inputs: g, outputs: B }) => [`${B.remainder} = ${g.a} % ${g.b};`];
  }
}
class uB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "remainder", outTypeFunc: fs }), this.statements = ({ inputs: g, outputs: B }) => [`${B.remainder} = mod(${g.a}, ${g.b});`];
  }
}
class UB extends f {
  constructor({ a: A }) {
    const I = { a: p(A) }, g = I.a, B = {
      fract: g,
      integer: g
    };
    super({ inTypes: I, outTypes: B, inputs: { a: A } }), this.statements = ({ inputs: C, outputs: E }) => [`${E.fract} = modf(${C.a}, ${E.integer});`];
  }
}
class SB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "neg", outTypeFunc: ms }), this.statements = ({ inputs: I, outputs: g }) => [`${g.neg} = -${I.a};`];
  }
}
class LB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "abs", outTypeFunc: bs }), this.statements = ({ inputs: I, outputs: g }) => [`${g.abs} = abs(${I.a});`];
  }
}
class pB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "sign", outTypeFunc: xs }), this.statements = ({ inputs: I, outputs: g }) => [`${g.sign} = sign(${I.a});`];
  }
}
class HB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "floor", outTypeFunc: Ks }), this.statements = ({ inputs: I, outputs: g }) => [`${g.floor} = floor(${I.a});`];
  }
}
class fB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "ceil", outTypeFunc: Zs }), this.statements = ({ inputs: I, outputs: g }) => [`${g.ceil} = ceil(${I.a});`];
  }
}
class mB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "trunc", outTypeFunc: qs }), this.statements = ({ inputs: I, outputs: g }) => [`${g.trunc} = trunc(${I.a});`];
  }
}
class bB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "round", outTypeFunc: Ws }), this.statements = ({ inputs: I, outputs: g }) => [`${g.round} = round(${I.a});`];
  }
}
class xB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "fract", outTypeFunc: Vs }), this.statements = ({ inputs: I, outputs: g }) => [`${g.fract} = fract(${I.a});`];
  }
}
class KB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "power", outTypeFunc: vs }), this.statements = ({ inputs: g, outputs: B }) => [`${B.power} = pow(${g.a}, ${g.b});`];
  }
}
class ZB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp", outTypeFunc: Ts }), this.statements = ({ inputs: I, outputs: g }) => [`${g.exp} = exp(${I.a});`];
  }
}
class qB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp2", outTypeFunc: Xs }), this.statements = ({ inputs: I, outputs: g }) => [`${g.exp2} = exp2(${I.a});`];
  }
}
class WB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "log", outTypeFunc: js }), this.statements = ({ inputs: I, outputs: g }) => [`${g.log} = log(${I.a});`];
  }
}
class VB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "log2", outTypeFunc: zs }), this.statements = ({ inputs: I, outputs: g }) => [`${g.log2} = log2(${I.a});`];
  }
}
class vB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqr", outTypeFunc: Os }), this.statements = ({ inputs: I, outputs: g }) => [`${g.sqr} = ${I.a} * ${I.a};`];
  }
}
class TB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqrt", outTypeFunc: Ps }), this.statements = ({ inputs: I, outputs: g }) => [`${g.sqrt} = sqrt(${I.a});`];
  }
}
class XB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "inversesqrt", outTypeFunc: _s }), this.statements = ({ inputs: I, outputs: g }) => [`${g.inversesqrt} = inversesqrt(${I.a});`];
  }
}
class jB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "min", outTypeFunc: GB }), this.statements = ({ inputs: g, outputs: B }) => [`${B.min} = min(${g.a}, ${g.b});`];
  }
}
class zB extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "max", outTypeFunc: $s }), this.statements = ({ inputs: g, outputs: B }) => [`${B.max} = max(${g.a}, ${g.b});`];
  }
}
class OB extends sQ {
  constructor({
    a: A,
    min: I,
    max: g
  }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "clamp",
      outTypeFunc: Ao
    }), this.statements = ({ inputs: B, outputs: C }) => {
      const { a: E, b: t, c: s } = B;
      return [`${C.clamp} = clamp(${E}, ${t}, ${s});`];
    };
  }
}
class PB extends sQ {
  constructor({ a: A, b: I, t: g }) {
    super({ a: A, b: I, c: g, outKey: "mix", outTypeFunc: Qo }), this.statements = ({ inputs: B, outputs: C }) => {
      const { a: E, b: t, c: s } = B;
      return [`${C.mix} = mix(${E}, ${t}, ${s});`];
    };
  }
}
class _B extends b {
  constructor({ edge: A, x: I }) {
    super({
      a: A,
      b: I,
      outKey: "step",
      outTypeFunc: Io
    }), this.statements = ({ inputs: g, outputs: B }) => {
      const { a: C, b: E } = g;
      return [`${B.step} = step(${C}, ${E});`];
    };
  }
}
class $B extends sQ {
  constructor({
    edge0: A,
    edge1: I,
    x: g
  }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "smoothstep",
      outTypeFunc: go
    }), this.statements = ({ inputs: B, outputs: C }) => {
      const { a: E, b: t, c: s } = B;
      return [`${C.smoothstep} = smoothstep(${E}, ${t}, ${s});`];
    };
  }
}
class AC extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "isNan", outTypeFunc: lB }), this.statements = ({ inputs: I, outputs: g }) => [`${g.isNan} = isNan(${I.a});`];
  }
}
class QC extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "isInf", outTypeFunc: Bo }), this.statements = ({ inputs: I, outputs: g }) => [`${g.isInf} = isInf(${I.a});`];
  }
}
const Jo = (Q, A) => new IC({ a: Q, b: A }), Yo = (Q, A) => new gC({ a: Q, b: A }), uo = (Q, A) => new BC({ a: Q, b: A }), Uo = (Q) => new CC({ a: Q }), So = (Q, A) => new EC({ a: Q, b: A }), Lo = (Q, A) => new tC({ a: Q, b: A }), po = (Q, A) => new iC({ a: Q, b: A }), Ho = (Q, A) => new sC({ a: Q, b: A }), fo = (Q, A) => new oC({ a: Q, b: A }), mo = (Q, A) => new aC({ a: Q, b: A }), bo = (Q) => new eC({ a: Q }), xo = (Q) => new DC({ a: Q }), Ko = (Q, A, I) => new nC({ cond: Q, t: A, f: I }), Zo = (Q) => new wC({ a: Q });
class IC extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (g, B) => g, outKey: "and" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.and === "bool" ? [`${B.and} = ${g.a} && ${g.b};`] : [`${B.and} = ${g.a} & ${g.b};`];
  }
}
class gC extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (g, B) => g, outKey: "or" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.or === "bool" ? [`${B.or} = ${g.a} || ${g.b};`] : [`${B.or} = ${g.a} | ${g.b};`];
  }
}
class BC extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (g, B) => g, outKey: "xor" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.xor === "bool" ? [`${B.xor} = ${g.a} ^^ ${g.b};`] : [`${B.xor} = ${g.a} ^ ${g.b};`];
  }
}
class CC extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "not" }), this.statements = ({ inputs: I, outputs: g }) => this.outTypes.not === "bool" ? [`${g.not} = !${I.a};`] : [`${g.not} = not(${I.a});`];
  }
}
class EC extends b {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => tI(g, "lessThan"),
      outKey: "lessThan"
    }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.lessThan === "bool" ? [`${B.lessThan} = ${g.a} < ${g.b};`] : [`${B.lessThan} = lessThan(${g.a}, ${g.b});`];
  }
}
class tC extends b {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => tI(g, "lessThanEqual"),
      outKey: "lessThanEqual"
    }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.lessThanEqual === "bool" ? [`${B.lessThanEqual} = ${g.a} <= ${g.b};`] : [
      `${B.lessThanEqual} = lessThanEqual(${g.a}, ${g.b});`
    ];
  }
}
class iC extends b {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => tI(g, "greaterThan"),
      outKey: "greaterThan"
    }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.greaterThan === "bool" ? [`${B.greaterThan} = ${g.a} > ${g.b};`] : [
      `${B.greaterThan} = greaterThan(${g.a}, ${g.b});`
    ];
  }
}
class sC extends b {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => tI(g, "greaterThanEqual"),
      outKey: "greaterThanEqual"
    }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.greaterThanEqual === "bool" ? [`${B.greaterThanEqual} = ${g.a} >= ${g.b};`] : [
      `${B.greaterThanEqual} = greaterThanEqual(${g.a}, ${g.b});`
    ];
  }
}
class oC extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: cC, outKey: "equal" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.equal === "bool" ? [`${B.equal} = ${g.a} == ${g.b};`] : [`${B.equal} = equal(${g.a}, ${g.b});`];
  }
}
class aC extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: qo, outKey: "notEqual" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.notEqual === "bool" ? [`${B.notEqual} = ${g.a} != ${g.b};`] : [`${B.notEqual} = notEqual(${g.a}, ${g.b});`];
  }
}
class eC extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "bool", outKey: "any" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.any} = any(${I.a});`];
  }
}
class DC extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "bool", outKey: "all" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.all} = all(${I.a});`];
  }
}
class nC extends sQ {
  constructor({
    cond: A,
    t: I,
    f: g
  }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "select",
      outTypeFunc: (B, C, E) => C
    }), this.statements = ({ inputs: B, outputs: C }) => {
      const { a: E, b: t, c: s } = B;
      return [`${C.select} = (${E}) ? (${t}) : (${s});`];
    };
  }
}
function tI(Q, A) {
  if (iQ(Q))
    return "bool";
  if (Q === "ivec2" || Q === "uvec2" || Q === "vec2")
    return "bvec2";
  if (Q === "ivec3" || Q === "uvec3" || Q === "vec3")
    return "bvec3";
  if (Q === "ivec4" || Q === "uvec4" || Q === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${Q}`);
}
function cC(Q, A = "equal") {
  if (iQ(Q))
    return "bool";
  if (tQ(Q))
    return Q;
  if (Q === "ivec2" || Q === "uvec2" || Q === "vec2")
    return "bvec2";
  if (Q === "ivec3" || Q === "uvec3" || Q === "vec3")
    return "bvec3";
  if (Q === "ivec4" || Q === "uvec4" || Q === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${Q}`);
}
function qo(Q) {
  return cC(Q, "notEqual");
}
function Wo(Q) {
  if (tQ(Q))
    return "bool";
  if (EA(Q))
    return "int";
  if (tA(Q))
    return "uint";
  throw new Error(`Invalid compXor type: ${Q}`);
}
class wC extends N {
  constructor({ a: A }) {
    const I = Wo(p(A));
    super({ a: A, outTypeFunc: (g) => I, outKey: "compXor" }), this.statements = ({ inputs: g, outputs: B }) => {
      if (iQ(this.outTypes.compXor))
        return [`${B.compXor} = ${g.a};`];
      const E = (yQ(I) ? ["x", "y"] : GQ(I) ? ["x", "y", "z"] : ["x", "y", "z", "w"]).map((s) => `${g.a}.${s}`), t = tQ(I) ? "^^" : "^";
      return [`${B.compXor} = ${E.join(` ${t} `)};`];
    };
  }
}
const Vo = (Q) => new NC({ value: Q }), vo = (Q) => new kC({ value: Q }), To = (Q) => new FC({ value: Q }), rC = (Q) => new RC({ value: Q }), Xo = (Q) => new JC({ value: Q }), jo = (Q) => new YC({ value: Q }), zo = (Q) => new dC({ value: Q }), Oo = (Q) => new uC({ value: Q }), Po = (Q) => new UC({ value: Q }), _o = (Q) => new SC({ value: Q }), $o = (Q) => new LC({ value: Q }), Aa = (Q) => new pC({ value: Q }), Qa = (Q) => new HC({ value: Q }), hC = (Q) => new fC({ value: Q }), EQ = (Q) => new mC({ value: Q }), yC = (Q) => new bC({ value: Q }), Ia = (Q) => new xC({ value: Q }), ga = (Q) => new KC({ value: Q }), Ba = (Q) => new ZC({ value: Q }), GC = (Q) => new qC({ value: Q }), Ca = (Q) => new WC({ value: Q }), Ea = (Q) => new VC({ value: Q }), ta = (Q) => new vC({ value: Q }), ia = (Q) => new TC({ value: Q }), sa = (Q) => new XC({ value: Q }), oa = (Q) => new jC({ value: Q }), aa = (Q) => new zC({ value: Q }), lC = (Q) => new OC({ value: Q }), ea = (Q) => new PC({ value: Q }), MC = (Q) => new _C({ value: Q });
class O extends N {
  constructor({
    value: A,
    outType: I,
    outKey: g
  }) {
    super({ a: A, outTypeFunc: () => I, outKey: g }), this.statements = ({ inputs: B, outputs: C }) => [
      `${C[g]} = ${gg(I)}(${B.a});`
    ];
  }
}
class NC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bool", outKey: "bool" });
  }
}
class kC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "int", outKey: "int" });
  }
}
class FC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uint", outKey: "uint" });
  }
}
class RC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "float", outKey: "float" });
  }
}
class JC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec2", outKey: "bvec2" });
  }
}
class YC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec3", outKey: "bvec3" });
  }
}
class dC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec4", outKey: "bvec4" });
  }
}
class uC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec2", outKey: "ivec2" });
  }
}
class UC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec3", outKey: "ivec3" });
  }
}
class SC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec4", outKey: "ivec4" });
  }
}
class LC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec2", outKey: "uvec2" });
  }
}
class pC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec3", outKey: "uvec3" });
  }
}
class HC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec4", outKey: "uvec4" });
  }
}
class fC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec2", outKey: "vec2" });
  }
}
class mC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec3", outKey: "vec3" });
  }
}
class bC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec4", outKey: "vec4" });
  }
}
class xC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat2", outKey: "mat2" });
  }
}
class KC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat3", outKey: "mat3" });
  }
}
class ZC extends O {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat4", outKey: "mat4" });
  }
}
class qC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "int", outTypeFunc: () => "int" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.int} = floatBitsToInt(${I.a});`];
  }
}
class WC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.uint} = floatBitsToUint(${I.a});`];
  }
}
class VC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.float} = intBitsToFloat(${I.a});`];
  }
}
class vC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.float} = uintBitsToFloat(${I.a});`];
  }
}
class TC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.uint} = packSnorm2x16(${I.a});`];
  }
}
class XC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.vec2} = unpackSnorm2x16(${I.a});`];
  }
}
class jC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.uint} = packUnorm2x16(${I.a});`];
  }
}
class zC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.vec2} = unpackUnorm2x16(${I.a});`];
  }
}
class OC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.uint} = packHalf2x16(${I.a});`];
  }
}
class PC extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.vec2} = unpackHalf2x16(${I.a});`];
  }
}
class _C extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "rgba8", outTypeFunc: () => "vec4" }), this.statements = ({ inputs: I, outputs: g }) => [
      `uvec4 uRgba = uvec4(${I.a} & 0xffu, (${I.a} >> 8u) & 0xffu, (${I.a} >> 16u) & 0xffu, (${I.a} >> 24u) & 0xffu);`,
      `${g.rgba8} = vec4(uRgba) / 255.0;`
    ];
  }
}
const Da = (Q) => new QE({ a: Q }), na = (Q, A) => new IE({ a: Q, b: A }), ca = (Q, A) => new gE({ a: Q, b: A }), wa = (Q, A) => new BE({ a: Q, b: A }), $C = (Q) => new CE({ a: Q }), ra = (Q, A, I) => new iE({ a: Q, b: A, c: I }), ha = (Q, A) => new sE({ incident: Q, normal: A }), ya = (Q, A, I) => new oE({ incident: Q, normal: A, eta: I }), JQ = (Q) => new wE({ vector: Q }), HA = ({
  vector: Q,
  vectorType: A,
  x: I,
  y: g,
  z: B,
  w: C,
  r: E,
  g: t,
  b: s,
  a: o
}) => new rE({ vector: Q, vectorType: A, x: I, y: g, z: B, w: C, r: E, g: t, b: s, a: o }), Ga = (Q) => new EE({ a: Q }), AE = (Q, A) => new tE({ a: Q, b: A }), la = (Q, A) => new hE({ vector: Q, select: A }), Ma = (Q, A) => new aE({ a: Q, b: A }), Na = (Q, A) => new eE({ a: Q, b: A }), ka = (Q) => new DE({ a: Q }), Fa = (Q) => new nE({ a: Q }), Ra = (Q) => new cE({ a: Q });
class QE extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "float", outKey: "length" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.length} = length(${I.a});`
    ];
  }
}
class IE extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "distance", outTypeFunc: (g, B) => "float" }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.distance} = distance(${g.a}, ${g.b});`
    ];
  }
}
class gE extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "dot", outTypeFunc: (g, B) => "float" }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.dot} = dot(${g.a}, ${g.b});`
    ];
  }
}
class BE extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "cross", outTypeFunc: (g, B) => "vec3" }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.cross} = cross(${g.a}, ${g.b});`
    ];
  }
}
class CE extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "normalize" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.normalize} = normalize(${I.a});`
    ];
  }
}
function Ja(Q) {
  if (Q === "vec3")
    return "vec2";
  if (Q === "vec4")
    return "vec3";
  throw new Error("Invalid type");
}
class EE extends N {
  constructor({ a: A }) {
    super({
      a: A,
      outTypeFunc: (I) => Ja(I),
      outKey: "projected"
    }), this.statements = ({ inputs: I, outputs: g }) => {
      if (this.inTypes.a === "vec3")
        return [`${g.projected} = ${I.a}.xy / ${I.a}.z;`];
      if (this.inTypes.a === "vec4")
        return [`${g.projected} = ${I.a}.xyz / ${I.a}.w;`];
      throw new Error("Invalid type");
    };
  }
}
function Ya(Q) {
  if (Q === "float") return "vec2";
  if (Q === "vec2") return "vec3";
  if (Q === "vec3") return "vec4";
  throw new Error("Invalid type");
}
class tE extends b {
  constructor({ a: A, b: I }) {
    const g = p(A), B = Ya(g);
    super({ a: A, b: I, outKey: "extend", outTypeFunc: () => B }), this.statements = ({ inputs: C, outputs: E }) => [
      `${E.extend} = ${B}(${C.a}, ${C.b});`
    ];
  }
}
class iE extends sQ {
  constructor({ a: A, b: I, c: g }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "forward",
      outTypeFunc: (B, C, E) => B
    }), this.statements = ({ inputs: B, outputs: C }) => [
      `${C.forward} = faceforward(${B.a}, ${B.b}, ${B.c});`
    ];
  }
}
class sE extends b {
  constructor({
    incident: A,
    normal: I
  }) {
    super({
      a: A,
      b: I,
      outKey: "reflection",
      outTypeFunc: (g, B) => g
    }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.reflection} = reflect(${g.a}, ${g.b});`
    ];
  }
}
class oE extends sQ {
  constructor({
    incident: A,
    normal: I,
    eta: g
  }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "refraction",
      outTypeFunc: (B, C, E) => B
    }), this.statements = ({ inputs: B, outputs: C }) => [
      `${C.refraction} = refract(${B.a}, ${B.b}, ${B.c});`
    ];
  }
}
class aE extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "product", outTypeFunc: (g, B) => g }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.product} = matrixCompMult(${A}, ${I});`
    ];
  }
}
function da(Q, A) {
  if (Q === "vec2") {
    if (A === "vec2") return "mat2";
    if (A === "vec3") return "mat3x2";
    if (A === "vec4") return "mat4x2";
  }
  if (Q === "vec3") {
    if (A === "vec2") return "mat2x3";
    if (A === "vec3") return "mat3";
    if (A === "vec4") return "mat4x3";
  }
  if (Q === "vec4") {
    if (A === "vec2") return "mat2x4";
    if (A === "vec3") return "mat3x4";
    if (A === "vec4") return "mat4";
  }
  throw new Error(`Invalid outer type: ${Q}, ${A}`);
}
class eE extends b {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "outer", outTypeFunc: da }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.outer} = outerProduct(${g.a}, ${g.b});`
    ];
  }
}
function ua(Q) {
  if (Q === "mat2") return "mat2";
  if (Q === "mat3") return "mat3";
  if (Q === "mat4") return "mat4";
  if (Q === "mat2x2") return "mat2x2";
  if (Q === "mat2x3") return "mat3x2";
  if (Q === "mat2x4") return "mat4x2";
  if (Q === "mat3x2") return "mat2x3";
  if (Q === "mat3x3") return "mat3x3";
  if (Q === "mat3x4") return "mat4x3";
  if (Q === "mat4x2") return "mat2x4";
  if (Q === "mat4x3") return "mat3x4";
  if (Q === "mat4x4") return "mat4x4";
  throw new Error(`Invalid transpose type: ${Q}`);
}
class DE extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "transpose", outTypeFunc: ua }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.transpose} = transpose(${I.a});`
    ];
  }
}
class nE extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "det", outTypeFunc: (I) => "float" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.det} = determinant(${I.a});`
    ];
  }
}
class cE extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "inverse", outTypeFunc: (I) => I }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.inverse} = inverse(${A});`
    ];
  }
}
function Ua(Q) {
  const A = (I) => I;
  switch (Q) {
    case "vec2":
      return A({ x: "float", y: "float", r: "float", g: "float" });
    case "vec3":
      return A({
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      });
    case "vec4":
      return A({
        x: "float",
        y: "float",
        z: "float",
        w: "float",
        r: "float",
        g: "float",
        b: "float",
        a: "float"
      });
    case "ivec2":
      return A({ x: "int", y: "int", r: "int", g: "int" });
    case "ivec3":
      return A({
        x: "int",
        y: "int",
        z: "int",
        r: "int",
        g: "int",
        b: "int"
      });
    case "ivec4":
      return A({
        x: "int",
        y: "int",
        z: "int",
        w: "int",
        r: "int",
        g: "int",
        b: "int",
        a: "int"
      });
    case "uvec2":
      return A({ x: "uint", y: "uint", r: "uint", g: "uint" });
    case "uvec3":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        r: "uint",
        g: "uint",
        b: "uint"
      });
    case "uvec4":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        w: "uint",
        r: "uint",
        g: "uint",
        b: "uint",
        a: "uint"
      });
    default:
      throw new Error(`Invalid vector type: ${Q}`);
  }
}
class wE extends f {
  constructor({ vector: A }) {
    const g = { vector: p(A) }, B = Ua(g.vector);
    super({ inTypes: g, outTypes: B, inputs: { vector: A } }), this.statements = ({ inputs: C, outputs: E }) => {
      const { x: t, y: s, z: o, w: a, r: i, g: D, b: n, a: w } = E, { vector: c } = C;
      return [
        t ? `${t} = ${c}.x;` : null,
        s ? `${s} = ${c}.y;` : null,
        o ? `${o} = ${c}.z;` : null,
        a ? `${a} = ${c}.w;` : null,
        i ? `${i} = ${c}.r;` : null,
        D ? `${D} = ${c}.g;` : null,
        n ? `${n} = ${c}.b;` : null,
        w ? `${w} = ${c}.a;` : null
      ].filter(Boolean);
    };
  }
}
class rE extends f {
  constructor({
    vector: A,
    vectorType: I,
    x: g,
    y: B,
    z: C,
    w: E,
    r: t,
    g: s,
    b: o,
    a
  }) {
    if (!A && !I)
      throw new Error("Either vector or vectorType must be provided");
    const i = I ?? p(A), D = Ag(i), n = Qg(i), w = {
      vector: i,
      x: D,
      y: D,
      r: D,
      g: D
    }, c = { vector: A, x: g, y: B, r: t, g: s };
    n >= 3 && (Object.assign(w, { z: D, b: D }), Object.assign(c, { z: C, b: o })), n >= 4 && (Object.assign(w, { w: D, a: D }), Object.assign(c, { w: E, a })), super({ inTypes: w, outTypes: { vector: i }, inputs: c }), this.statements = ({ inputs: r, outputs: y }) => {
      const { vector: G } = y, {
        vector: h,
        x: M,
        y: l,
        z: k,
        w: R,
        r: Y,
        g: d,
        b: m,
        a: J
      } = r, x = [
        `${G}.x = ${M ?? Y ?? (h ? `${h}.x` : NQ(D))};`,
        `${G}.y = ${l ?? d ?? (h ? `${h}.y` : NQ(D))};`
      ];
      return n >= 3 && x.push(
        `${G}.z = ${k ?? m ?? (h ? `${h}.z` : NQ(D))};`
      ), n >= 4 && x.push(
        `${G}.w = ${R ?? J ?? (h ? `${h}.w` : NQ(D))};`
      ), x;
    };
  }
  dynoOut() {
    return new H(
      this,
      "vector"
    );
  }
}
function Sa(Q, A) {
  let I = null;
  if (SQ(Q) ? I = A.length === 1 ? "float" : A.length === 2 ? "vec2" : A.length === 3 ? "vec3" : A.length === 4 ? "vec4" : null : EA(Q) ? I = A.length === 1 ? "int" : A.length === 2 ? "ivec2" : A.length === 3 ? "ivec3" : A.length === 4 ? "ivec4" : null : tA(Q) && (I = A.length === 1 ? "uint" : A.length === 2 ? "uvec2" : A.length === 3 ? "uvec3" : A.length === 4 ? "uvec4" : null), I == null)
    throw new Error(`Invalid swizzle: ${A}`);
  return I;
}
class hE extends N {
  constructor({ vector: A, select: I }) {
    super({
      a: A,
      outKey: "swizzle",
      outTypeFunc: (g) => Sa(g, I)
    }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.swizzle} = ${g.a}.${I};`
    ];
  }
}
const La = (Q, A, I) => new kE({ index: Q, from: A, to: I }), pa = (Q) => new lQ({ value: Q }), Ha = (Q) => new FA({ state: Q }), fa = (Q) => new RA({ state: Q }), yE = (Q) => new FE({ value: Q }), GE = (Q) => new RE({ value: Q }), lE = (Q) => new JE({ value: Q }), ME = (Q) => new YE({ value: Q }), ma = (Q) => new dE({ value: Q }), ba = (Q) => new uE({ value: Q }), NE = (Q) => new UE({ value: Q }), lI = (Q) => new SE({ value: Q });
class kE extends f {
  constructor({
    from: A,
    to: I,
    index: g
  }) {
    super({
      inTypes: { from: "int", to: "int", index: "int" },
      outTypes: { index: "int" },
      inputs: { from: A, to: I, index: g },
      statements: ({ inputs: B, outputs: C }) => [
        `${C.index} = ${B.index} - ${B.from} + ${B.to};`
      ]
    });
  }
  dynoOut() {
    return new H(this, "index");
  }
}
class FA extends f {
  constructor({ state: A }) {
    const I = p(A);
    super({
      inTypes: { state: I },
      outTypes: { state: "uint" },
      inputs: { state: A },
      globals: () => [
        IA(`
          uint pcg_next(uint state) {
            return state * 747796405u + 2891336453u;
          }
        `)
      ],
      statements: ({ inputs: g, outputs: B }) => {
        const C = I === "uint" ? `${g.state}` : I === "int" ? `uint(${g.state})` : `floatBitsToUint(${g.state})`;
        return [`${B.state} = pcg_next(${C});`];
      }
    });
  }
  dynoOut() {
    return new H(this, "state");
  }
}
class RA extends f {
  constructor({ state: A }) {
    super({
      inTypes: { state: "uint" },
      outTypes: { hash: "uint" },
      inputs: { state: A },
      globals: () => [
        IA(`
          uint pcg_hash(uint state) {
            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
            return (hash >> 22u) ^ hash;
          }
        `)
      ],
      statements: ({ inputs: I, outputs: g }) => [
        `${g.hash} = pcg_hash(${I.state});`
      ]
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
class lQ extends f {
  constructor({ value: A }) {
    const I = p(A), g = Ig(I);
    super({
      inTypes: { value: I },
      outTypes: { state: "uint" },
      inputs: { value: A },
      globals: () => [
        IA(`
          uint pcg_mix(uint value) {
            return value;
          }
          uint pcg_mix(uvec2 value) {
            return value.x + 0x9e3779b9u * value.y;
          }
          uint pcg_mix(uvec3 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;
          }
          uint pcg_mix(uvec4 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;
          }
        `)
      ],
      statements: ({ inputs: B, outputs: C }) => {
        const E = tA(I) ? `${B.value}` : EA(I) ? `${g}(${B.value})` : `floatBitsToUint(${B.value})`;
        return [
          `${g} bits = ${E};`,
          `${C.state} = pcg_mix(bits);`
        ];
      }
    });
  }
  dynoOut() {
    return new H(this, "state");
  }
}
class FE extends mA {
  constructor({ value: A }) {
    super({
      inTypes: { value: p(A) },
      outTypes: { hash: "uint" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let g = new lQ({ value: I }).outputs.state;
        return g = new FA({ state: g }).outputs.state, new RA({ state: g }).outputs;
      }
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
class RE extends mA {
  constructor({ value: A }) {
    super({
      inTypes: { value: p(A) },
      outTypes: { hash: "uvec2" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let g = new lQ({ value: I }).outputs.state;
        g = new FA({ state: g }).outputs.state;
        const B = new RA({ state: g }).outputs.hash;
        g = new FA({ state: g }).outputs.state;
        const C = new RA({ state: g }).outputs.hash;
        return { hash: HA({ vectorType: "uvec2", x: B, y: C }) };
      }
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
class JE extends mA {
  constructor({ value: A }) {
    super({
      inTypes: { value: p(A) },
      outTypes: { hash: "uvec3" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let g = new lQ({ value: I }).outputs.state;
        g = new FA({ state: g }).outputs.state;
        const B = new RA({ state: g }).outputs.hash;
        g = new FA({ state: g }).outputs.state;
        const C = new RA({ state: g }).outputs.hash;
        g = new FA({ state: g }).outputs.state;
        const E = new RA({ state: g }).outputs.hash;
        return { hash: HA({ vectorType: "uvec3", x: B, y: C, z: E }) };
      }
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
class YE extends mA {
  constructor({ value: A }) {
    super({
      inTypes: { value: p(A) },
      outTypes: { hash: "uvec4" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let g = new lQ({ value: I }).outputs.state;
        g = new FA({ state: g }).outputs.state;
        const B = new RA({ state: g }).outputs.hash;
        g = new FA({ state: g }).outputs.state;
        const C = new RA({ state: g }).outputs.hash;
        g = new FA({ state: g }).outputs.state;
        const E = new RA({ state: g }).outputs.hash;
        g = new FA({ state: g }).outputs.state;
        const t = new RA({ state: g }).outputs.hash;
        return { hash: HA({ vectorType: "uvec4", x: B, y: C, z: E, w: t }) };
      }
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
class dE extends mA {
  constructor({ value: A }) {
    super({
      inTypes: { value: p(A) },
      outTypes: { hash: "float" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const g = yE(I);
        return { hash: BA(rC(g), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
class uE extends mA {
  constructor({ value: A }) {
    super({
      inTypes: { value: p(A) },
      outTypes: { hash: "vec2" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const g = GE(I);
        return { hash: BA(hC(g), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
class UE extends mA {
  constructor({ value: A }) {
    super({
      inTypes: { value: p(A) },
      outTypes: { hash: "vec3" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const g = lE(I);
        return { hash: BA(EQ(g), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
class SE extends mA {
  constructor({ value: A }) {
    super({
      inTypes: { value: p(A) },
      outTypes: { hash: "vec4" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const g = ME(I);
        return { hash: BA(yC(g), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new H(this, "hash");
  }
}
const xa = (Q, {
  scale: A,
  scales: I,
  rotate: g,
  translate: B
}) => new LE({ position: Q, scale: A, scales: I, rotate: g, translate: B }).outputs.position, Ka = (Q, {
  scale: A,
  scales: I,
  rotate: g
}) => new pE({ ray: Q, scale: A, scales: I, rotate: g }).outputs.ray, Za = (Q, { rotate: A }) => new HE({ quaternion: Q, rotate: A }).outputs.quaternion;
class LE extends f {
  constructor({
    position: A,
    scale: I,
    scales: g,
    rotate: B,
    translate: C
  }) {
    super({
      inTypes: {
        position: "vec3",
        scale: "float",
        scales: "vec3",
        rotate: "vec4",
        translate: "vec3"
      },
      outTypes: { position: "vec3" },
      inputs: { position: A, scale: I, scales: g, rotate: B, translate: C },
      statements: ({ inputs: E, outputs: t }) => {
        const { position: s } = t;
        if (!s)
          return [];
        const { scale: o, scales: a, rotate: i, translate: D } = E;
        return [
          `${s} = ${E.position ?? "vec3(0.0, 0.0, 0.0)"};`,
          o ? `${s} *= ${o};` : null,
          a ? `${s} *= ${a};` : null,
          i ? `${s} = quatVec(${i}, ${s});` : null,
          D ? `${s} += ${D};` : null
        ].filter(Boolean);
      }
    });
  }
}
class pE extends f {
  constructor({
    ray: A,
    scale: I,
    scales: g,
    rotate: B
  }) {
    super({
      inTypes: { ray: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
      outTypes: { ray: "vec3" },
      inputs: { ray: A, scale: I, scales: g, rotate: B },
      statements: ({ inputs: C, outputs: E }) => {
        const { ray: t } = E;
        if (!t)
          return [];
        const { scale: s, scales: o, rotate: a } = C;
        return [
          `${t} = ${C.ray ?? "vec3(0.0, 0.0, 0.0)"};`,
          s ? `${t} *= ${s};` : null,
          o ? `${t} *= ${o};` : null,
          a ? `${t} = quatVec(${a}, ${t});` : null
        ].filter(Boolean);
      }
    });
  }
}
class HE extends f {
  constructor({
    quaternion: A,
    rotate: I
  }) {
    super({
      inTypes: { quaternion: "vec4", rotate: "vec4" },
      outTypes: { quaternion: "vec4" },
      inputs: { quaternion: A, rotate: I },
      statements: ({ inputs: g, outputs: B }) => {
        const { quaternion: C } = B;
        return C ? [
          `${C} = ${g.quaternion ?? "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          I ? `${C} = quatQuat(${g.rotate}, ${C});` : null
        ].filter(Boolean) : [];
      }
    });
  }
}
const qa = () => {
  throw new Error("Not implemented");
}, Wa = () => {
  throw new Error("Not implemented");
}, Va = () => {
  throw new Error("Not implemented");
}, va = () => {
  throw new Error("Not implemented");
}, Ta = () => {
  throw new Error("Not implemented");
}, Xa = () => {
  throw new Error("Not implemented");
}, ja = (Q, A) => new fE({ texture: Q, lod: A }), za = (Q, A, I) => new mE({ texture: Q, coord: A, bias: I }), Oa = (Q, A, I) => new bE({ texture: Q, coord: A, lod: I });
class fE extends f {
  constructor({ texture: A, lod: I }) {
    const g = p(A);
    super({
      inTypes: { texture: g, lod: "int" },
      outTypes: { size: xE(g) },
      inputs: { texture: A, lod: I },
      statements: ({ inputs: B, outputs: C }) => [
        `${C.size} = textureSize(${B.texture}, ${B.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new H(this, "size");
  }
}
class mE extends f {
  constructor({
    texture: A,
    coord: I,
    bias: g
  }) {
    const B = p(A);
    super({
      inTypes: {
        texture: B,
        coord: Pa(B),
        bias: "float"
      },
      outTypes: { sample: KE(B) },
      inputs: { texture: A, coord: I, bias: g },
      statements: ({ inputs: C, outputs: E }) => [
        `${E.sample} = texture(${C.texture}, ${C.coord}${C.bias ? `, ${C.bias}` : ""});`
      ]
    });
  }
  dynoOut() {
    return new H(this, "sample");
  }
}
class bE extends f {
  constructor({
    texture: A,
    coord: I,
    lod: g
  }) {
    const B = p(A);
    super({
      inTypes: {
        texture: B,
        coord: xE(B),
        lod: "int"
      },
      outTypes: { texel: KE(B) },
      inputs: { texture: A, coord: I, lod: g },
      statements: ({ inputs: C, outputs: E }) => [
        `${E.texel} = texelFetch(${C.texture}, ${C.coord}, ${C.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new H(this, "texel");
  }
}
function xE(Q) {
  switch (Q) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DShadow":
    case "samplerCubeShadow":
      return "ivec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DArrayShadow":
      return "ivec3";
    default:
      throw new Error(`Invalid texture type: ${Q}`);
  }
}
function Pa(Q) {
  switch (Q) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
      return "vec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DShadow":
      return "vec3";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "vec4";
    default:
      throw new Error(`Invalid texture type: ${Q}`);
  }
}
function KE(Q) {
  switch (Q) {
    case "sampler2D":
    case "sampler2DArray":
    case "sampler3D":
    case "samplerCube":
    case "sampler2DShadow":
      return "vec4";
    case "usampler2D":
    case "usampler2DArray":
    case "usampler3D":
    case "usamplerCube":
      return "uvec4";
    case "isampler2D":
    case "isampler2DArray":
    case "isampler3D":
    case "isamplerCube":
      return "ivec4";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "float";
    default:
      throw new Error(`Invalid texture type: ${Q}`);
  }
}
const _a = (Q) => new ZE({ degrees: Q }), $a = (Q) => new qE({ radians: Q }), MI = (Q) => new WE({ radians: Q }), Ae = (Q) => new VE({ radians: Q }), Qe = (Q) => new vE({ radians: Q }), Ie = (Q) => new TE({ sin: Q }), ge = (Q) => new XE({ cos: Q }), Be = (Q) => new jE({ tan: Q }), Ce = (Q, A) => new zE({ y: Q, x: A }), Ee = (Q) => new OE({ x: Q }), te = (Q) => new PE({ x: Q }), ie = (Q) => new _E({ x: Q }), se = (Q) => new $E({ x: Q }), oe = (Q) => new At({ x: Q }), ae = (Q) => new Qt({ x: Q });
class ZE extends N {
  constructor({ degrees: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "radians" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.radians} = radians(${I.a});`
    ];
  }
}
class qE extends N {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "degrees" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.degrees} = degrees(${I.a});`
    ];
  }
}
class WE extends N {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "sin" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.sin} = sin(${I.a});`
    ];
  }
}
class VE extends N {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "cos" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.cos} = cos(${I.a});`
    ];
  }
}
class vE extends N {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "tan" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.tan} = tan(${I.a});`
    ];
  }
}
class TE extends N {
  constructor({ sin: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "asin" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.asin} = asin(${I.a});`
    ];
  }
}
class XE extends N {
  constructor({ cos: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "acos" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.acos} = acos(${I.a});`
    ];
  }
}
class jE extends N {
  constructor({ tan: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "atan" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.atan} = atan(${I.a});`
    ];
  }
}
class zE extends b {
  constructor({ y: A, x: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => g,
      outKey: "atan2"
    }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.atan2} = atan2(${g.a}, ${g.b});`
    ];
  }
}
class OE extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "sinh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.sinh} = sinh(${I.a});`
    ];
  }
}
class PE extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "cosh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.cosh} = cosh(${I.a});`
    ];
  }
}
class _E extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "tanh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.tanh} = tanh(${I.a});`
    ];
  }
}
class $E extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "asinh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.asinh} = asinh(${I.a});`
    ];
  }
}
class At extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "acosh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.acosh} = acosh(${I.a});`
    ];
  }
}
class Qt extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "atanh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.atanh} = atanh(${I.a});`
    ];
  }
}
const RD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs: LB,
  Acos: XE,
  Acosh: At,
  Add: FB,
  All: DC,
  And: IC,
  Any: eC,
  Asin: TE,
  Asinh: $E,
  Atan: jE,
  Atan2: zE,
  Atanh: Qt,
  BVec2: JC,
  BVec3: YC,
  BVec4: dC,
  BinaryOp: b,
  Bool: NC,
  Ceil: fB,
  Clamp: OB,
  Combine: rE,
  CombineGsplat: eg,
  CompMult: aE,
  CompXor: wC,
  Compilation: Cg,
  Cos: VE,
  Cosh: PE,
  Cross: BE,
  Degrees: qE,
  Determinant: nE,
  Distance: IE,
  Div: YB,
  Dot: gE,
  Dyno: f,
  DynoBlock: mA,
  DynoBool: PQ,
  DynoBvec2: yg,
  DynoBvec3: Ng,
  DynoBvec4: Rg,
  DynoConst: Bg,
  DynoFloat: gQ,
  DynoInt: uQ,
  DynoIsampler2D: qg,
  DynoIsampler2DArray: Vg,
  DynoIsampler3D: Xg,
  DynoIsamplerCube: Og,
  DynoIvec2: lg,
  DynoIvec3: Fg,
  DynoIvec4: Yg,
  DynoLiteral: wQ,
  DynoMat2: dg,
  DynoMat2x2: ug,
  DynoMat2x3: Ug,
  DynoMat2x4: Sg,
  DynoMat3: Lg,
  DynoMat3x2: pg,
  DynoMat3x3: Hg,
  DynoMat3x4: fg,
  DynoMat4: mg,
  DynoMat4x2: bg,
  DynoMat4x3: xg,
  DynoMat4x4: Kg,
  DynoOutput: H,
  DynoProgram: pI,
  DynoProgramTemplate: HI,
  DynoRemapIndex: kE,
  DynoSampler2D: Wg,
  DynoSampler2DArray: vg,
  DynoSampler2DArrayShadow: $g,
  DynoSampler2DShadow: _g,
  DynoSampler3D: jg,
  DynoSamplerCube: Pg,
  DynoSamplerCubeShadow: AB,
  DynoUint: hg,
  DynoUniform: F,
  DynoUsampler2D: Zg,
  DynoUsampler2DArray: FQ,
  DynoUsampler3D: Tg,
  DynoUsamplerCube: zg,
  DynoUvec2: Gg,
  DynoUvec3: kg,
  DynoUvec4: Jg,
  DynoValue: jA,
  DynoVec2: Mg,
  DynoVec3: hQ,
  DynoVec4: fQ,
  Equal: oC,
  Exp: ZB,
  Exp2: qB,
  ExtendVec: tE,
  FaceForward: iE,
  Float: RC,
  FloatBitsToInt: qC,
  FloatBitsToUint: WC,
  Floor: HB,
  Fract: xB,
  GreaterThan: iC,
  GreaterThanEqual: sC,
  Gsplat: v,
  GsplatNormal: ng,
  Hash: FE,
  Hash2: RE,
  Hash3: JE,
  Hash4: YE,
  HashFloat: dE,
  HashVec2: uE,
  HashVec3: UE,
  HashVec4: SE,
  IMod: dB,
  IVec2: uC,
  IVec3: UC,
  IVec4: SC,
  Int: kC,
  IntBitsToFloat: VC,
  Inverse: cE,
  InverseSqrt: XB,
  IsInf: QC,
  IsNan: AC,
  Length: QE,
  LessThan: EC,
  LessThanEqual: tC,
  Log: WB,
  Log2: VB,
  Mat2: xC,
  Mat3: KC,
  Mat4: ZC,
  Max: zB,
  Min: jB,
  Mix: PB,
  Mod: uB,
  Modf: UB,
  Mul: JB,
  Neg: SB,
  Normalize: CE,
  Not: CC,
  NotEqual: aC,
  NumPackedSplats: tg,
  Or: gC,
  Outer: eE,
  OutputPackedSplat: rg,
  OutputRgba8: SI,
  PackHalf2x16: OC,
  PackSnorm2x16: TC,
  PackUnorm2x16: jC,
  PcgHash: RA,
  PcgMix: lQ,
  PcgNext: FA,
  Pow: KB,
  ProjectH: EE,
  Radians: ZE,
  ReadPackedSplat: sg,
  ReadPackedSplatRange: og,
  ReflectVec: sE,
  RefractVec: oE,
  Round: bB,
  Select: nC,
  Sign: pB,
  SimpleCast: O,
  Sin: WE,
  Sinh: OE,
  Smoothstep: $B,
  Split: wE,
  SplitGsplat: ag,
  Sqr: vB,
  Sqrt: TB,
  Step: _B,
  Sub: RB,
  Swizzle: hE,
  TPackedSplats: HQ,
  Tan: vE,
  Tanh: _E,
  TexelFetch: bE,
  Texture: mE,
  TextureSize: fE,
  TransformGsplat: cg,
  TransformPosition: LE,
  TransformQuaternion: HE,
  TransformRay: pE,
  Transpose: DE,
  TrinaryOp: sQ,
  Trunc: mB,
  UVec2: LC,
  UVec3: pC,
  UVec4: HC,
  Uint: FC,
  UintBitsToFloat: vC,
  UintToRgba8: _C,
  UnaryOp: N,
  UnpackHalf2x16: PC,
  UnpackSnorm2x16: XC,
  UnpackUnorm2x16: zC,
  Vec2: fC,
  Vec3: mC,
  Vec4: bC,
  Xor: BC,
  abs: to,
  acos: ge,
  acosh: oe,
  add: cA,
  all: xo,
  and: Jo,
  any: bo,
  arrayIndex: Ta,
  arrayLength: Xa,
  asin: Ie,
  asinh: se,
  atan: Be,
  atan2: Ce,
  atanh: ae,
  bool: Vo,
  bvec2: Xo,
  bvec3: jo,
  bvec4: zo,
  ceil: oo,
  clamp: Mo,
  combine: HA,
  combineGsplat: rQ,
  comment: va,
  compMult: Ma,
  compXor: Zo,
  cos: Ae,
  cosh: te,
  cross: wa,
  defineGsplat: rA,
  defineGsplatNormal: Dg,
  definePackedSplats: CI,
  degrees: $a,
  determinant: Fa,
  distance: na,
  div: jQ,
  dot: ca,
  dyno: pQ,
  dynoBlock: UA,
  dynoBool: Pt,
  dynoBvec2: Ai,
  dynoBvec3: Bi,
  dynoBvec4: ti,
  dynoConst: q,
  dynoDeclare: uI,
  dynoFloat: LA,
  dynoFor: Va,
  dynoIf: qa,
  dynoInt: $t,
  dynoIsampler2D: ki,
  dynoIsampler2DArray: Ji,
  dynoIsampler3D: ui,
  dynoIsamplerCube: Li,
  dynoIvec2: Ii,
  dynoIvec3: Ei,
  dynoIvec4: si,
  dynoLiteral: OQ,
  dynoMat2: ai,
  dynoMat2x2: ei,
  dynoMat2x3: Di,
  dynoMat2x4: ni,
  dynoMat3: ci,
  dynoMat3x2: wi,
  dynoMat3x3: ri,
  dynoMat3x4: hi,
  dynoMat4: yi,
  dynoMat4x2: Gi,
  dynoMat4x3: li,
  dynoMat4x4: Mi,
  dynoSampler2D: Fi,
  dynoSampler2DArray: Yi,
  dynoSampler2DArrayShadow: fi,
  dynoSampler2DShadow: Hi,
  dynoSampler3D: Ui,
  dynoSamplerCube: pi,
  dynoSamplerCubeShadow: mi,
  dynoSwitch: Wa,
  dynoUint: _t,
  dynoUsampler2D: Ni,
  dynoUsampler2DArray: Ri,
  dynoUsampler3D: di,
  dynoUsamplerCube: Si,
  dynoUvec2: Qi,
  dynoUvec3: Ci,
  dynoUvec4: ii,
  dynoVec2: gi,
  dynoVec3: vA,
  dynoVec4: oi,
  equal: fo,
  exp: no,
  exp2: co,
  extendVec: AE,
  faceforward: ra,
  float: rC,
  floatBitsToInt: GC,
  floatBitsToUint: Ca,
  floor: so,
  fract: zQ,
  greaterThan: po,
  greaterThanEqual: Ho,
  gsplatNormal: jt,
  hash: yE,
  hash2: GE,
  hash3: lE,
  hash4: ME,
  hashFloat: ma,
  hashVec2: ba,
  hashVec3: NE,
  hashVec4: lI,
  imod: GI,
  int: vo,
  intBitsToFloat: Ea,
  inverse: Ra,
  inversesqrt: Go,
  isAllFloatType: zA,
  isBoolType: tQ,
  isFloatType: SQ,
  isInf: Ro,
  isIntType: EA,
  isMat2: $A,
  isMat3: AQ,
  isMat4: QQ,
  isMatFloatType: $I,
  isNan: Fo,
  isScalarType: iQ,
  isUintType: tA,
  isVector2Type: yQ,
  isVector3Type: GQ,
  isVector4Type: LQ,
  isVectorType: qt,
  ivec2: Oo,
  ivec3: Po,
  ivec4: _o,
  length: Da,
  lessThan: So,
  lessThanEqual: Lo,
  literalNegOne: Tt,
  literalOne: vt,
  literalZero: NQ,
  log: wo,
  log2: ro,
  mat2: Ia,
  mat3: ga,
  mat4: Ba,
  max: NB,
  min: lo,
  mix: kB,
  mod: MB,
  modf: Co,
  mul: BA,
  neg: Eo,
  normalize: $C,
  not: Uo,
  notEqual: mo,
  numPackedSplats: Xt,
  numberAsFloat: u,
  numberAsInt: j,
  numberAsUint: z,
  or: Yo,
  outer: Na,
  outputPackedSplat: wg,
  outputRgba8: zt,
  packHalf2x16: lC,
  packSnorm2x16: ia,
  packUnorm2x16: oa,
  pcgHash: fa,
  pcgMix: pa,
  pcgNext: Ha,
  pow: Do,
  projectH: Ga,
  radians: _a,
  readPackedSplat: dQ,
  readPackedSplatRange: Eg,
  reflectVec: ha,
  refractVec: ya,
  remapIndex: La,
  round: eo,
  sameSizeIvec: Vt,
  sameSizeUvec: Ig,
  sameSizeVec: Wt,
  select: Ko,
  sign: io,
  sin: MI,
  sinh: Ee,
  smoothstep: ko,
  split: JQ,
  splitGsplat: kQ,
  sqr: ho,
  sqrt: yo,
  step: No,
  sub: UQ,
  swizzle: la,
  tan: Qe,
  tanh: ie,
  texelFetch: Oa,
  texture: za,
  textureSize: ja,
  transformGsplat: UI,
  transformPos: xa,
  transformQuat: Za,
  transformRay: Ka,
  transpose: ka,
  trunc: ao,
  typeLiteral: gg,
  uint: To,
  uintBitsToFloat: ta,
  uintToRgba8: MC,
  uniform: Ot,
  unindent: IA,
  unindentLines: JA,
  unpackHalf2x16: ea,
  unpackSnorm2x16: sa,
  unpackUnorm2x16: aa,
  uvec2: $o,
  uvec3: Aa,
  uvec4: Qa,
  valType: p,
  vec2: hC,
  vec3: EQ,
  vec4: yC,
  vectorDim: Qg,
  vectorElementType: Ag,
  xor: uo
}, Symbol.toStringTag, { value: "Module" }));
var ee = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;
const AA = class AA {
  constructor({ renderer: A } = {}) {
    this.renderer = A, this.capacity = 0, this.count = 0;
  }
  dispose() {
    this.target && (this.target.dispose(), this.target = void 0);
  }
  // Ensure we have a buffer large enough for the readback of count indices.
  // Pass in previous bufer of the desired type.
  ensureBuffer(A, I) {
    const B = Math.ceil(Math.max(1, A) / Z) * Z * 4;
    if (I.byteLength >= B)
      return I;
    const C = new ArrayBuffer(B);
    if (I instanceof ArrayBuffer)
      return C;
    const E = I.constructor;
    return new E(C);
  }
  // Ensure our render target is large enough for the readback of capacity indices.
  ensureCapacity(A) {
    const { width: I, height: g, depth: B, maxSplats: C } = wA(A);
    (!this.target || C > this.capacity) && (this.dispose(), this.capacity = C, this.target = new e.WebGLArrayRenderTarget(I, g, B, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: e.NearestFilter,
      minFilter: e.NearestFilter
    }), this.target.texture.format = e.RGBAFormat, this.target.texture.type = e.UnsignedByteType, this.target.texture.internalFormat = "RGBA8");
  }
  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let I = AA.readbackProgram.get(A);
    if (!I) {
      const B = UA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: C }) => (A.inputs.index = C, { rgba8: new SI({ rgba8: A.outputs.rgba8 }) })
      );
      AA.programTemplate || (AA.programTemplate = new HI(ee)), I = new pI({
        graph: B,
        inputs: { index: "index" },
        outputs: { rgba8: "target" },
        template: AA.programTemplate
      }), Object.assign(I.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), AA.readbackProgram.set(A, I);
    }
    const g = I.prepareMaterial();
    return AA.mesh.material = g, { program: I, material: g };
  }
  saveRenderState(A) {
    return {
      xrPresenting: A.xr.isPresenting,
      autoClear: A.autoClear,
      scissorTest: A.getScissorTest()
    };
  }
  resetRenderState(A, I) {
    A.setRenderTarget(null), A.xr.isPresenting = I.xrPresenting, A.autoClear = I.autoClear, A.setScissorTest(I.scissorTest);
  }
  process({
    count: A,
    material: I
  }) {
    const g = this.renderer;
    if (!g)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const B = Z * IQ;
    I.uniforms.targetBase.value = 0, I.uniforms.targetCount.value = A;
    let C = 0;
    for (; C < A; ) {
      const E = Math.floor(C / B), t = E * B, s = Math.min(
        IQ,
        Math.ceil((A - t) / Z)
      );
      I.uniforms.targetLayer.value = E, g.setRenderTarget(this.target, E), g.xr.isPresenting = !1, g.autoClear = !1, g.setScissorTest(!0), g.setScissor(0, 0, Z, s), g.render(AA.scene, AA.camera), C += Z * s;
    }
    this.count = A;
  }
  async read({
    readback: A
  }) {
    const I = this.renderer;
    if (!I)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const g = Math.ceil(this.count / Z) * Z;
    if (A.byteLength < g * 4)
      throw new Error(
        `Readback buffer too small: ${A.byteLength} < ${g * 4}`
      );
    const B = new Uint8Array(
      A instanceof ArrayBuffer ? A : A.buffer
    ), C = Z * IQ;
    let E = 0;
    const t = [];
    for (; E < this.count; ) {
      const s = Math.floor(E / C), o = s * C, a = Math.min(
        IQ,
        Math.ceil((this.count - o) / Z)
      );
      I.setRenderTarget(this.target, s);
      const i = Z * a * 4, D = B.subarray(
        o * 4,
        o * 4 + i
      ), n = I == null ? void 0 : I.readRenderTargetPixelsAsync(
        this.target,
        0,
        0,
        Z,
        a,
        D
      );
      t.push(n), E += Z * a;
    }
    return Promise.all(t).then(() => A);
  }
  // Perform render operation to run the Rgba8Readback program
  // but don't perform the readback yet.
  render({
    reader: A,
    count: I,
    renderer: g
  }) {
    if (this.renderer = g || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(I);
    const { program: B, material: C } = this.prepareProgramMaterial(A);
    B.update();
    const E = this.saveRenderState(this.renderer);
    this.process({ count: I, material: C }), this.resetRenderState(this.renderer, E);
  }
  // Perform a readback of the render target, returning a buffer of the
  // given type.
  async readback({
    readback: A
  }) {
    if (!this.renderer)
      throw new Error("No renderer");
    const I = this.saveRenderState(this.renderer), g = this.read({ readback: A });
    return this.resetRenderState(this.renderer, I), g;
  }
  // Perform a render and readback operation for the given Rgba8Readback,
  // and readback buffer (call ensureBuffer first).
  async renderReadback({
    reader: A,
    count: I,
    renderer: g,
    readback: B
  }) {
    if (this.renderer = g || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(I);
    const { program: C, material: E } = this.prepareProgramMaterial(A);
    C.update();
    const t = this.saveRenderState(this.renderer);
    this.process({ count: I, material: E });
    const s = this.read({ readback: B });
    return this.resetRenderState(this.renderer, t), s;
  }
  getTexture() {
    var A;
    return (A = this.target) == null ? void 0 : A.texture;
  }
};
AA.programTemplate = null, AA.readbackProgram = /* @__PURE__ */ new Map(), AA.geometry = new e.PlaneGeometry(2, 2), AA.mesh = new e.Mesh(
  AA.geometry,
  new e.RawShaderMaterial({ visible: !1 })
), AA.scene = new e.Scene().add(AA.mesh), AA.camera = new e.Camera();
let $Q = AA;
const QA = class QA {
  constructor(A = {}) {
    this.capacity = 0, this.count = 0, this.array = null, this.readback = null, this.source = null, this.needsUpdate = !0, this.dyno = new F({
      key: "rgbaArray",
      type: It,
      globals: () => [gt],
      value: {
        texture: QA.getEmpty(),
        count: 0
      },
      update: (I) => {
        var g;
        return I.texture = ((g = this.readback) == null ? void 0 : g.getTexture()) ?? this.source ?? QA.getEmpty(), I.count = this.count, I;
      }
    }), A.array ? (this.array = A.array, this.capacity = Math.floor(this.array.length / 4), this.capacity = Math.floor(this.capacity / Z) * Z, this.count = Math.min(
      this.capacity,
      A.count ?? Number.POSITIVE_INFINITY
    )) : (this.capacity = A.capacity ?? 0, this.count = 0);
  }
  // Free up resources
  dispose() {
    this.readback && (this.readback.dispose(), this.readback = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensure that our array is large enough to hold capacity RGBA8 values.
  ensureCapacity(A) {
    var I;
    if (!this.array || A > (((I = this.array) == null ? void 0 : I.length) ?? 0) / 4) {
      this.capacity = wA(A).maxSplats;
      const g = new Uint8Array(this.capacity * 4);
      this.array && g.set(this.array), this.array = g;
    }
    return this.array;
  }
  // Get the THREE.DataArrayTexture from either the readback or the source.
  getTexture() {
    var I;
    let A = (I = this.readback) == null ? void 0 : I.getTexture();
    return (this.source || this.array) && (A = this.maybeUpdateSource()), A ?? QA.getEmpty();
  }
  // Create or get a THREE.DataArrayTexture from the data array.
  maybeUpdateSource() {
    if (!this.array)
      throw new Error("No array");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: I, depth: g } = this.source.image;
        this.capacity !== A * I * g && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.array.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.array.buffer));
      else {
        const { width: A, height: I, depth: g } = wA(this.capacity);
        this.source = new e.DataArrayTexture(
          this.array,
          A,
          I,
          g
        ), this.source.format = e.RGBAFormat, this.source.type = e.UnsignedByteType, this.source.internalFormat = "RGBA8", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Generate the RGBA8 values from a Rgba8Readback dyno program.
  render({
    reader: A,
    count: I,
    renderer: g
  }) {
    this.readback || (this.readback = new $Q({ renderer: g })), this.readback.render({ reader: A, count: I, renderer: g }), this.capacity = this.readback.capacity, this.count = this.readback.count;
  }
  // Extract the RGBA8 values from a PackedSplats collection.
  fromPackedSplats({
    packedSplats: A,
    base: I,
    count: g,
    renderer: B
  }) {
    const { dynoSplats: C, dynoBase: E, dynoCount: t, reader: s } = QA.makeDynos();
    return C.packedSplats = A, E.value = I, t.value = g, this.render({ reader: s, count: g, renderer: B }), this;
  }
  // Read back the RGBA8 values from the readback buffer.
  async read() {
    if (!this.readback)
      throw new Error("No readback");
    return (!this.array || this.array.length < this.count * 4) && (this.array = new Uint8Array(this.capacity * 4)), (await this.readback.readback({ readback: this.array })).subarray(0, this.count * 4);
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!QA.emptySource) {
      const A = new Uint8Array(4);
      QA.emptySource = new e.DataArrayTexture(A, 1, 1, 1), QA.emptySource.format = e.RGBAFormat, QA.emptySource.type = e.UnsignedByteType, QA.emptySource.internalFormat = "RGBA8", QA.emptySource.needsUpdate = !0;
    }
    return QA.emptySource;
  }
  // Create a dyno program that can extract RGBA8 values from a PackedSplats
  static makeDynos() {
    if (!QA.dynos) {
      const A = new mI(), I = new uQ({ value: 0 }), g = new uQ({ value: 0 }), B = UA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: C }) => {
          if (!C)
            throw new Error("index is undefined");
          C = cA(C, I);
          const E = Eg(
            A,
            C,
            I,
            g
          );
          return { rgba8: kQ(E).outputs.rgba };
        }
      );
      QA.dynos = { dynoSplats: A, dynoBase: I, dynoCount: g, reader: B };
    }
    return QA.dynos;
  }
};
QA.emptySource = null, QA.dynos = null;
let NI = QA;
const It = { type: "RgbaArray" }, gt = IA(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);
function De(Q, A) {
  return new f({
    inTypes: { rgba: It, index: "int" },
    outTypes: { rgba: "vec4" },
    inputs: { rgba: Q, index: A },
    globals: () => [gt],
    statements: ({ inputs: g, outputs: B }) => JA(`
        if ((index >= 0) && (index < ${g.rgba}.count)) {
          ${B.rgba} = texelFetch(${g.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${B.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)
  }).outputs.rgba;
}
var ne = /* @__PURE__ */ ((Q) => (Q.ALL = "all", Q.PLANE = "plane", Q.SPHERE = "sphere", Q.BOX = "box", Q.ELLIPSOID = "ellipsoid", Q.CYLINDER = "cylinder", Q.CAPSULE = "capsule", Q.INFINITE_CONE = "infinite_cone", Q))(ne || {});
function ce(Q) {
  switch (Q) {
    case "all":
      return 0;
    case "plane":
      return 1;
    case "sphere":
      return 2;
    case "box":
      return 3;
    case "ellipsoid":
      return 4;
    case "cylinder":
      return 5;
    case "capsule":
      return 6;
    case "infinite_cone":
      return 7;
    default:
      throw new Error(`Unknown SDF type: ${Q}`);
  }
}
var we = /* @__PURE__ */ ((Q) => (Q.MULTIPLY = "multiply", Q.SET_RGB = "set_rgb", Q.ADD_RGBA = "add_rgba", Q))(we || {});
function re(Q) {
  switch (Q) {
    case "multiply":
      return 0;
    case "set_rgb":
      return 1;
    case "add_rgba":
      return 2;
    default:
      throw new Error(`Unknown blend mode: ${Q}`);
  }
}
class he extends e.Object3D {
  constructor(A = {}) {
    super();
    const { type: I, invert: g, opacity: B, color: C, displace: E, radius: t } = A;
    this.type = I ?? "sphere", this.invert = g ?? !1, this.opacity = B ?? 1, this.color = C ?? new e.Color(1, 1, 1), this.displace = E ?? new e.Vector3(0, 0, 0), this.radius = t ?? 0;
  }
}
const BI = class BI extends e.Object3D {
  constructor(A = {}) {
    const {
      name: I,
      rgbaBlendMode: g = "multiply",
      sdfSmooth: B = 0,
      softEdge: C = 0,
      invert: E = !1,
      sdfs: t = null
    } = A;
    super(), this.rgbaBlendMode = g, this.sdfSmooth = B, this.softEdge = C, this.invert = E, this.sdfs = t, this.ordering = BI.nextOrdering++, this.name = I ?? `Edit ${this.ordering}`;
  }
  addSdf(A) {
    this.sdfs == null && (this.sdfs = []), this.sdfs.push(A);
  }
  removeSdf(A) {
    this.sdfs != null && (this.sdfs = this.sdfs.filter((I) => I !== A));
  }
};
BI.nextOrdering = 1;
let AI = BI;
class ye {
  constructor({ maxSdfs: A, maxEdits: I }) {
    this.maxSdfs = Math.max(16, A ?? 0), this.numSdfs = 0, this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs), this.dynoSdfArray = new F({
      key: "sdfArray",
      type: Bt,
      globals: () => [Ct],
      value: {
        numSdfs: 0,
        sdfTexture: this.sdfTexture
      },
      update: (g) => (g.numSdfs = this.numSdfs, g.sdfTexture = this.sdfTexture, g)
    }), this.maxEdits = Math.max(16, I ?? 0), this.numEdits = 0, this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoNumEdits = new uQ({ value: 0 }), this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
  }
  newSdfTexture(A, I) {
    const g = new e.DataTexture(
      A,
      8,
      I,
      e.RGBAIntegerFormat,
      e.UnsignedIntType
    );
    return g.internalFormat = "RGBA32UI", g.needsUpdate = !0, g;
  }
  newEdits(A, I) {
    return new F({
      key: "edits",
      type: "uvec4",
      count: I,
      globals: () => [Et],
      value: A
    });
  }
  // Ensure our SDF texture and edits uniform array have enough capacity.
  // Reallocate if not.
  ensureCapacity({
    maxSdfs: A,
    maxEdits: I
  }) {
    let g = !1;
    return A > this.sdfTexture.image.height && (this.sdfTexture.dispose(), this.maxSdfs = Math.max(this.maxSdfs * 2, A), this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs)), I > (this.dynoEdits.count ?? 0) && (this.maxEdits = Math.max(this.maxEdits * 2, I), this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoEdits = this.newEdits(this.editData, this.maxEdits), g = !0), g;
  }
  updateEditData(A, I) {
    const g = this.editData[A] !== I;
    return this.editData[A] = I, g;
  }
  updateEditFloatData(A, I) {
    oQ[0] = I;
    const g = this.editFloatData[A] !== oQ[0];
    return g && (this.editFloatData[A] = oQ[0]), g;
  }
  encodeEdit(A, {
    sdfFirst: I,
    sdfCount: g,
    invert: B,
    rgbaBlendMode: C,
    softEdge: E,
    sdfSmooth: t
  }) {
    const s = A * 4;
    let o = !1;
    return o = this.updateEditData(s + 0, C | (B ? 256 : 0)) || o, o = this.updateEditData(s + 1, I | g << 16) || o, o = this.updateEditFloatData(s + 2, E) || o, o = this.updateEditFloatData(s + 3, t) || o, o;
  }
  updateSdfData(A, I) {
    const g = this.sdfData[A] !== I;
    return this.sdfData[A] = I, g;
  }
  updateSdfFloatData(A, I) {
    oQ[0] = I;
    const g = this.sdfFloatData[A] !== oQ[0];
    return g && (this.sdfFloatData[A] = oQ[0]), g;
  }
  encodeSdf(A, {
    sdfType: I,
    invert: g,
    center: B,
    quaternion: C,
    scale: E,
    sizes: t
  }, s) {
    const o = A * 32, a = I | (g ? 256 : 0);
    let i = !1;
    i = this.updateSdfFloatData(o + 0, (B == null ? void 0 : B.x) ?? 0) || i, i = this.updateSdfFloatData(o + 1, (B == null ? void 0 : B.y) ?? 0) || i, i = this.updateSdfFloatData(o + 2, (B == null ? void 0 : B.z) ?? 0) || i, i = this.updateSdfData(o + 3, a) || i, i = this.updateSdfFloatData(o + 4, (C == null ? void 0 : C.x) ?? 0) || i, i = this.updateSdfFloatData(o + 5, (C == null ? void 0 : C.y) ?? 0) || i, i = this.updateSdfFloatData(o + 6, (C == null ? void 0 : C.z) ?? 0) || i, i = this.updateSdfFloatData(o + 7, (C == null ? void 0 : C.w) ?? 0) || i, i = this.updateSdfFloatData(o + 8, (E == null ? void 0 : E.x) ?? 0) || i, i = this.updateSdfFloatData(o + 9, (E == null ? void 0 : E.y) ?? 0) || i, i = this.updateSdfFloatData(o + 10, (E == null ? void 0 : E.z) ?? 0) || i, i = this.updateSdfData(o + 11, 0) || i, i = this.updateSdfFloatData(o + 12, (t == null ? void 0 : t.x) ?? 0) || i, i = this.updateSdfFloatData(o + 13, (t == null ? void 0 : t.y) ?? 0) || i, i = this.updateSdfFloatData(o + 14, (t == null ? void 0 : t.z) ?? 0) || i, i = this.updateSdfFloatData(o + 15, (t == null ? void 0 : t.w) ?? 0) || i;
    const D = Math.min(4, s.length);
    for (let n = 0; n < D; ++n) {
      const w = o + 16 + n * 4;
      i = this.updateSdfFloatData(w + 0, s[n].x) || i, i = this.updateSdfFloatData(w + 1, s[n].y) || i, i = this.updateSdfFloatData(w + 2, s[n].z) || i, i = this.updateSdfFloatData(w + 3, s[n].w) || i;
    }
    return i;
  }
  // Update the SDFs and edits from an array of SplatEdits and their
  // associated SplatEditSdfs, updating it for the dyno shader program.
  update(A) {
    const I = A.reduce((i, { sdfs: D }) => i + D.length, 0), g = this.ensureCapacity({
      maxEdits: A.length,
      maxSdfs: I
    }), B = [new e.Vector4(), new e.Vector4()], C = new e.Vector3(), E = new e.Quaternion(), t = new e.Vector3(), s = new e.Vector4();
    let o = 0, a = g;
    A.length !== this.dynoNumEdits.value && (this.dynoNumEdits.value = A.length, this.numEdits = A.length, a = !0);
    for (const [i, { edit: D, sdfs: n }] of A.entries()) {
      a = this.encodeEdit(i, {
        sdfFirst: o,
        sdfCount: n.length,
        invert: D.invert,
        rgbaBlendMode: re(D.rgbaBlendMode),
        softEdge: D.softEdge,
        sdfSmooth: D.sdfSmooth
      }) || a;
      let w = !1;
      for (const c of n)
        s.set(c.scale.x, c.scale.y, c.scale.z, c.radius), c.scale.setScalar(1), c.updateMatrixWorld(), c.matrixWorld.clone().invert().decompose(C, E, t), c.scale.set(s.x, s.y, s.z), c.updateMatrixWorld(), B[0].set(c.color.r, c.color.g, c.color.b, c.opacity), B[1].set(c.displace.x, c.displace.y, c.displace.z, 1), w = this.encodeSdf(
          o,
          {
            sdfType: ce(c.type),
            invert: c.invert,
            center: C,
            quaternion: E,
            scale: t,
            sizes: s
          },
          B
        ) || w, o += 1;
      this.numSdfs = o, w && (this.sdfTexture.needsUpdate = !0), a || (a = w);
    }
    return { updated: a, dynoUpdated: g };
  }
  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
  modify(A) {
    return Ge(
      A,
      this.dynoSdfArray,
      this.dynoNumEdits,
      this.dynoEdits
    );
  }
}
const Bt = { type: "SdfArray" }, Ct = IA(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`), Et = IA(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);
function Ge(Q, A, I, g) {
  return new f({
    inTypes: {
      gsplat: v,
      sdfArray: Bt,
      numEdits: "int",
      rgbaDisplaceEdits: "uvec4"
    },
    outTypes: { gsplat: v },
    globals: () => [Ct, Et],
    inputs: { gsplat: Q, sdfArray: A, numEdits: I, rgbaDisplaceEdits: g },
    statements: ({ inputs: C, outputs: E }) => {
      const { sdfArray: t, numEdits: s, rgbaDisplaceEdits: o } = C, { gsplat: a } = E;
      return JA(`
        ${a} = ${C.gsplat};
        if (isGsplatActive(${a}.flags)) {
          for (int editIndex = 0; editIndex < ${s}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${o}[editIndex], ${t}.sdfTexture, ${t}.numSdfs,
              ${a}.center, ${a}.rgba
            );
          }
        }
      `);
    }
  }).outputs.gsplat;
}
const oQ = new Float32Array(1);
class le {
  constructor(A) {
    this.modifier = A, this.cache = /* @__PURE__ */ new Map();
  }
  apply(A) {
    let I = this.cache.get(A);
    return I || (I = UA(
      { index: "int" },
      { gsplat: v },
      ({ index: g }) => {
        const { gsplat: B } = A.apply({ index: g });
        return this.modifier.apply({ gsplat: B });
      }
    ), this.cache.set(A, I)), I;
  }
}
class nQ {
  // Create the dyno uniforms that parameterize the transform, setting them
  // to initial values that are different from any valid transform.
  constructor() {
    this.scale = new gQ({ value: Number.NEGATIVE_INFINITY }), this.rotate = new fQ({
      value: new e.Quaternion(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    }), this.translate = new hQ({
      value: new e.Vector3(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
  }
  // Apply the transform to a Gsplat in a dyno program.
  modify(A) {
    return UI(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  // Update the uniforms to match the given transform matrix.
  updateFromMatrix(A) {
    const I = new e.Vector3(), g = new e.Quaternion(), B = new e.Vector3();
    A.decompose(B, g, I);
    const C = (I.x + I.y + I.z) / 3;
    let E = !1;
    return C !== this.scale.value && (this.scale.value = C, E = !0), B.equals(this.translate.value) || (this.translate.value.copy(B), E = !0), g.equals(this.rotate.value) || (this.rotate.value.copy(g), E = !0), E;
  }
  // Update this transform to match the object's to-world transform.
  update(A) {
    return this.updateFromMatrix(A.matrixWorld);
  }
}
class iI extends e.Object3D {
  constructor({
    numSplats: A,
    generator: I,
    construct: g,
    update: B
  }) {
    if (super(), this.numSplats = A ?? 0, this.generator = I, this.frameUpdate = B, this.version = 0, g) {
      const C = g(this);
      Object.assign(this, C);
    }
  }
  updateVersion() {
    this.version += 1;
  }
  set needsUpdate(A) {
    A && this.updateVersion();
  }
}
const TA = class TA extends iI {
  constructor(A = {}) {
    const I = new nQ(), g = new nQ(), B = new nQ(), C = new nQ(), E = new fQ({
      value: new e.Vector4(
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      )
    }), t = new gQ({ value: 0 }), s = new gQ({ value: 0 }), o = {
      transform: I,
      viewToWorld: g,
      worldToView: B,
      viewToObject: C,
      recolor: E,
      time: t,
      deltaTime: s
    };
    if (super({
      update: ({ time: a, deltaTime: i, viewToWorld: D, globalEdits: n }) => this.update({ time: a, deltaTime: i, viewToWorld: D, globalEdits: n })
    }), this.isInitialized = !1, this.recolor = new e.Color(1, 1, 1), this.opacity = 1, this.enableViewToObject = !1, this.enableViewToWorld = !1, this.enableWorldToView = !1, this.skinning = null, this.edits = null, this.rgbaDisplaceEdits = null, this.splatRgba = null, this.maxSh = 3, this.packedSplats = A.packedSplats ?? new fA(), this.numSplats = this.packedSplats.numSplats, this.editable = A.editable ?? !0, this.onFrame = A.onFrame, this.context = o, this.objectModifier = A.objectModifier, this.worldModifier = A.worldModifier, this.updateGenerator(), A.url || A.fileBytes || A.constructSplats || A.packedSplats && !A.packedSplats.isInitialized)
      this.initialized = this.asyncInitialize(A).then(async () => {
        if (this.updateGenerator(), this.isInitialized = !0, A.onLoad) {
          const a = A.onLoad(this);
          a instanceof Promise && await a;
        }
        return this;
      });
    else if (this.isInitialized = !0, this.initialized = Promise.resolve(this), A.onLoad) {
      const a = A.onLoad(this);
      a instanceof Promise && (this.initialized = a.then(() => this));
    }
  }
  async asyncInitialize(A) {
    const { url: I, fileBytes: g, fileType: B, maxSplats: C, constructSplats: E } = A;
    if (I || g || E) {
      const t = {
        url: I,
        fileBytes: g,
        fileType: B,
        maxSplats: C,
        construct: E
      };
      this.packedSplats.reinitialize(t), this.updateGenerator();
    }
    this.packedSplats && (await this.packedSplats.initialized, this.numSplats = this.packedSplats.numSplats);
  }
  static async staticInitialize() {
    await _I(), TA.isStaticInitialized = !0;
  }
  // Creates a new Gsplat with the provided parameters (all values in "float" space,
  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
  // doubling strategy to fit the new data, so it's fairly efficient to just
  // pushSplat(...) each Gsplat you want to create in a loop.
  pushSplat(A, I, g, B, C) {
    this.packedSplats.pushSplat(A, I, g, B, C);
  }
  // This method iterates over all Gsplats in this instance's packedSplats,
  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
  // Note that the objects passed in as center etc. are the same for every callback
  // invocation: these objects are reused for efficiency. Changing these values has
  // no effect as they are decoded/unpacked copies of the underlying data. To update
  // the packedSplats, call .packedSplats.setSplat(index, center, scales,
  // quaternion, opacity, color).
  forEachSplat(A) {
    this.packedSplats.forEachSplat(A);
  }
  // Call this when you are finished with the SplatMesh and want to free
  // any buffers it holds (via packedSplats).
  dispose() {
    this.packedSplats.dispose();
  }
  constructGenerator({ transform: A, viewToObject: I, recolor: g }) {
    const B = UA(
      { index: "int" },
      { gsplat: v },
      ({ index: C }) => {
        if (!C)
          throw new Error("index is undefined");
        let E = dQ(this.packedSplats.dyno, C);
        if (this.maxSh >= 1) {
          const { sh1Texture: s, sh2Texture: o, sh3Texture: a } = this.ensureShTextures();
          if (s) {
            const i = I.translate, { center: D } = kQ(E).outputs, n = $C(UQ(D, i));
            let w = Fe(E, s, n);
            this.maxSh >= 2 && o && (w = cA(w, Re(E, o, n))), this.maxSh >= 3 && a && (w = cA(w, Je(E, a, n)));
            let { rgba: c } = kQ(E).outputs;
            c = cA(c, AE(w, q("float", 0))), E = rQ({ gsplat: E, rgba: c });
          }
        }
        if (this.splatRgba) {
          const s = De(this.splatRgba.dyno, C);
          E = rQ({ gsplat: E, rgba: s });
        }
        this.skinning && (E = this.skinning.modify(E)), this.objectModifier && (E = this.objectModifier.apply({ gsplat: E }).gsplat), E = A.modify(E);
        const t = BA(g, kQ(E).outputs.rgba);
        return E = rQ({ gsplat: E, rgba: t }), this.rgbaDisplaceEdits && (E = this.rgbaDisplaceEdits.modify(E)), this.worldModifier && (E = this.worldModifier.apply({ gsplat: E }).gsplat), { gsplat: E };
      }
    );
    this.generator = B;
  }
  // Call this whenever something changes in the Gsplat processing pipeline,
  // for example changing maxSh or updating objectModifier or worldModifier.
  // Compiled generators are cached for efficiency and re-use when the same
  // pipeline structure emerges after successive changes.
  updateGenerator() {
    this.constructGenerator(this.context);
  }
  // This is called automatically by ForgeRenderer and you should not have to
  // call it. It updates parameters for the generated pipeline and calls
  // updateGenerator() if the pipeline needs to change.
  update({
    time: A,
    viewToWorld: I,
    deltaTime: g,
    globalEdits: B
  }) {
    var r;
    this.numSplats = this.packedSplats.numSplats, this.context.time.value = A, this.context.deltaTime.value = g, TA.dynoTime.value = A;
    const { transform: C, viewToObject: E, recolor: t } = this.context;
    let s = C.update(this);
    this.context.viewToWorld.updateFromMatrix(I) && this.enableViewToWorld && (s = !0);
    const o = I.clone().invert();
    this.context.worldToView.updateFromMatrix(o) && this.enableWorldToView && (s = !0);
    const D = new e.Matrix4().compose(
      C.translate.value,
      C.rotate.value,
      new e.Vector3().setScalar(C.scale.value)
    ).invert().multiply(I);
    E.updateFromMatrix(D) && (this.enableViewToObject || this.packedSplats.extra.sh1) && (s = !0);
    const n = new e.Vector4(
      this.recolor.r,
      this.recolor.g,
      this.recolor.b,
      this.opacity
    );
    n.equals(t.value) || (t.value.copy(n), s = !0);
    const w = this.editable ? (this.edits ?? []).concat(B) : [];
    this.editable && !this.edits && this.traverseVisible((y) => {
      y instanceof AI && w.push(y);
    }), w.sort((y, G) => y.ordering - G.ordering);
    const c = w.map((y) => {
      if (y.sdfs != null)
        return { edit: y, sdfs: y.sdfs };
      const G = [];
      return y.traverseVisible((h) => {
        h instanceof he && G.push(h);
      }), { edit: y, sdfs: G };
    });
    if (c.length > 0 && !this.rgbaDisplaceEdits) {
      const y = c.length, G = c.reduce(
        (h, M) => h + M.sdfs.length,
        0
      );
      this.rgbaDisplaceEdits = new ye({
        maxEdits: y,
        maxSdfs: G
      }), this.updateGenerator();
    }
    if (this.rgbaDisplaceEdits) {
      const y = this.rgbaDisplaceEdits.update(c);
      s || (s = y.updated), y.dynoUpdated && this.updateGenerator();
    }
    s && this.updateVersion(), (r = this.onFrame) == null || r.call(this, { mesh: this, time: A, deltaTime: g });
  }
  // This method conforms to the standard THREE.Raycaster API, performing object-ray
  // intersections using this method to populate the provided intersects[] array
  // with each intersection point.
  raycast(A, I) {
    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats)
      return;
    const { near: g, far: B, ray: C } = A, E = this.matrixWorld.clone().invert(), t = new e.Matrix3().setFromMatrix4(E), s = C.origin.clone().applyMatrix4(E), o = C.direction.clone().applyMatrix3(t), a = new e.Vector3();
    E.decompose(new e.Vector3(), new e.Quaternion(), a), (a.x * a.y * a.z) ** (1 / 3);
    const D = pt(
      s.x,
      s.y,
      s.z,
      o.x,
      o.y,
      o.z,
      g,
      B,
      this.packedSplats.numSplats,
      this.packedSplats.packedArray,
      !0
    );
    for (const n of D) {
      const w = C.direction.clone().multiplyScalar(n).add(C.origin);
      I.push({
        distance: n,
        point: w,
        object: this
      });
    }
  }
  ensureShTextures() {
    if (!this.packedSplats.extra.sh1)
      return {};
    const A = this.packedSplats.extra.sh1Texture;
    if (!A) {
      let B = this.packedSplats.extra.sh1;
      const { width: C, height: E, depth: t, maxSplats: s } = wA(
        B.length / 2
      );
      if (B.length < s * 2) {
        const i = new Uint32Array(s * 2);
        i.set(B), this.packedSplats.extra.sh1 = i, B = i;
      }
      const o = new e.DataArrayTexture(B, C, E, t);
      o.format = e.RGIntegerFormat, o.type = e.UnsignedIntType, o.internalFormat = "RG32UI", o.needsUpdate = !0;
      const a = new FQ({
        value: o,
        key: "sh1"
      });
      this.packedSplats.extra.sh1Texture = a;
    }
    if (!this.packedSplats.extra.sh2)
      return { sh1Texture: A };
    const I = this.packedSplats.extra.sh2Texture;
    if (!I) {
      let B = this.packedSplats.extra.sh2;
      const { width: C, height: E, depth: t, maxSplats: s } = wA(
        B.length / 4
      );
      if (B.length < s * 4) {
        const i = new Uint32Array(s * 4);
        i.set(B), this.packedSplats.extra.sh2 = i, B = i;
      }
      const o = new e.DataArrayTexture(B, C, E, t);
      o.format = e.RGBAIntegerFormat, o.type = e.UnsignedIntType, o.internalFormat = "RGBA32UI", o.needsUpdate = !0;
      const a = new FQ({
        value: o,
        key: "sh2"
      });
      this.packedSplats.extra.sh2Texture = a;
    }
    if (!this.packedSplats.extra.sh3)
      return { sh1Texture: A, sh2Texture: I };
    const g = this.packedSplats.extra.sh3Texture;
    if (!g) {
      let B = this.packedSplats.extra.sh3;
      const { width: C, height: E, depth: t, maxSplats: s } = wA(
        B.length / 4
      );
      if (B.length < s * 4) {
        const i = new Uint32Array(s * 4);
        i.set(B), this.packedSplats.extra.sh3 = i, B = i;
      }
      const o = new e.DataArrayTexture(B, C, E, t);
      o.format = e.RGBAIntegerFormat, o.type = e.UnsignedIntType, o.internalFormat = "RGBA32UI", o.needsUpdate = !0;
      const a = new FQ({
        value: o,
        key: "sh3"
      });
      this.packedSplats.extra.sh3Texture = a;
    }
    return { sh1Texture: A, sh2Texture: I, sh3Texture: g };
  }
};
TA.staticInitialized = TA.staticInitialize(), TA.isStaticInitialized = !1, TA.dynoTime = new gQ({ value: 0 });
let OA = TA;
const Me = IA(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`), Ne = IA(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`), ke = IA(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);
function Fe(Q, A, I) {
  return pQ({
    inTypes: { gsplat: v, sh1: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: Q, sh1: A, viewDir: I },
    globals: () => [rA, Me],
    statements: ({ inputs: g, outputs: B }) => JA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${B.rgb} = evaluateSH1(${g.gsplat}, ${g.sh1}, ${g.viewDir});
        } else {
          ${B.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function Re(Q, A, I) {
  return pQ({
    inTypes: { gsplat: v, sh2: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: Q, sh2: A, viewDir: I },
    globals: () => [rA, Ne],
    statements: ({ inputs: g, outputs: B }) => JA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${B.rgb} = evaluateSH2(${g.gsplat}, ${g.sh2}, ${g.viewDir});
        } else {
          ${B.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function Je(Q, A, I) {
  return pQ({
    inTypes: { gsplat: v, sh3: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: Q, sh3: A, viewDir: I },
    globals: () => [rA, ke],
    statements: ({ inputs: g, outputs: B }) => JA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${B.rgb} = evaluateSH3(${g.gsplat}, ${g.sh3}, ${g.viewDir});
        } else {
          ${B.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
const cQ = class cQ {
  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
  constructor({ fileBytes: A }) {
    this.header = "", this.littleEndian = !0, this.elements = {}, this.comments = [], this.data = null, this.numSplats = 0, this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A;
  }
  // Identify and parse the PLY text header (assumed to be <64KB in size).
  // this.elements will contain all the elements in the file, typically
  // "vertex" contains the Gsplat data.
  async parseHeader() {
    const I = new ReadableStream({
      start: (E) => {
        E.enqueue(this.fileBytes.slice(0, 65536)), E.close();
      }
    }).pipeThrough(new TextDecoderStream()).getReader();
    this.header = "";
    const g = `end_header
`;
    for (; ; ) {
      const { value: E, done: t } = await I.read();
      if (t)
        throw new Error("Failed to read header");
      this.header += E;
      const s = this.header.indexOf(g);
      if (s >= 0) {
        this.header = this.header.slice(0, s + g.length);
        break;
      }
    }
    const B = new TextEncoder().encode(this.header).length;
    this.data = new DataView(this.fileBytes.buffer, B), this.elements = {};
    let C = null;
    this.comments = [], this.header.trim().split(`
`).forEach((E, t) => {
      const s = E.trim();
      if (t === 0) {
        if (s !== "ply")
          throw new Error("Invalid PLY header");
        return;
      }
      if (s.length === 0)
        return;
      const o = s.split(" ");
      switch (o[0]) {
        case "format":
          if (o[1] === "binary_little_endian")
            this.littleEndian = !0;
          else if (o[1] === "binary_big_endian")
            this.littleEndian = !1;
          else
            throw new Error(`Unsupported PLY format: ${o[1]}`);
          if (o[2] !== "1.0")
            throw new Error(`Unsupported PLY version: ${o[2]}`);
          break;
        case "end_header":
          break;
        case "comment":
          this.comments.push(s.slice(8));
          break;
        case "element": {
          const a = o[1];
          C = {
            name: a,
            count: Number.parseInt(o[2]),
            properties: {}
          }, this.elements[a] = C;
          break;
        }
        case "property":
          if (C == null)
            throw new Error("Property must be inside an element");
          o[1] === "list" ? C.properties[o[4]] = {
            isList: !0,
            type: o[3],
            countType: o[2]
          } : C.properties[o[2]] = {
            isList: !1,
            type: o[1]
          };
          break;
      }
    }), this.elements.vertex && (this.numSplats = this.elements.vertex.count);
  }
  parseData(A) {
    let I = 0;
    const g = this.data;
    if (g == null)
      throw new Error("No data to parse");
    for (const B in this.elements) {
      const C = this.elements[B], { count: E, properties: t } = C, s = {}, o = [];
      for (const [i, D] of Object.entries(t))
        D.isList ? (s[i] = [], o.push(() => {
          const n = s[i];
          n.length = ZQ[D.countType](
            g,
            I,
            this.littleEndian
          ), I += aQ[D.countType];
          for (let w = 0; w < n.length; w++)
            n[w] = ZQ[D.type](
              g,
              I,
              this.littleEndian
            ), I += aQ[D.type];
        })) : (s[i] = 0, o.push(() => {
          s[i] = ZQ[D.type](
            g,
            I,
            this.littleEndian
          ), I += aQ[D.type];
        }));
      const a = A(C) ?? (() => {
      });
      for (let i = 0; i < E; i++) {
        for (const D of o)
          D();
        a(i, s);
      }
    }
  }
  // Parse all the Gsplat data in the PLY file in go, invoking the given
  // callbacks for each Gsplat.
  parseSplats(A, I) {
    if (this.elements.vertex == null)
      throw new Error("No vertex element found");
    let g = !1;
    const B = [];
    let C = 0, E = [], t = [], s = [], o, a, i;
    function D() {
      const y = de[C];
      E = new Array(3).fill(null).flatMap(
        (G, h) => [0, 1, 2].map((M, l) => `f_rest_${h + l * y / 3}`)
      ), t = new Array(5).fill(null).flatMap(
        (G, h) => [0, 1, 2].map((M, l) => `f_rest_${3 + h + l * y / 3}`)
      ), s = new Array(7).fill(null).flatMap(
        (G, h) => [0, 1, 2].map((M, l) => `f_rest_${8 + h + l * y / 3}`)
      ), o = C >= 1 ? new Float32Array(3 * 3) : void 0, a = C >= 2 ? new Float32Array(5 * 3) : void 0, i = C >= 3 ? new Float32Array(7 * 3) : void 0;
    }
    function n(y, G) {
      if (!o)
        throw new Error("Missing sh1");
      for (const [h, M] of E.entries())
        o[h] = G[M] * 8 / 255 - 4;
      if (a)
        for (const [h, M] of t.entries())
          a[h] = G[M] * 8 / 255 - 4;
      if (i)
        for (const [h, M] of s.entries())
          i[h] = G[M] * 8 / 255 - 4;
      I == null || I(y, o, a, i);
    }
    function w(y) {
      const {
        min_x: G,
        min_y: h,
        min_z: M,
        max_x: l,
        max_y: k,
        max_z: R,
        min_scale_x: Y,
        min_scale_y: d,
        min_scale_z: m,
        max_scale_x: J,
        max_scale_y: x,
        max_scale_z: U,
        min_r: S,
        min_g: T,
        min_b: V,
        max_r: P,
        max_g: _,
        max_b: X
      } = y.properties;
      if (!G || !h || !M || !l || !k || !R || !Y || !d || !m || !J || !x || !U || !S || !T || !V || !P || !_ || !X)
        throw new Error("Missing PLY chunk properties");
      return g = !0, (aA, $) => {
        const {
          min_x: iA,
          min_y: eA,
          min_z: YA,
          max_x: hA,
          max_y: DA,
          max_z: L,
          min_scale_x: yA,
          min_scale_y: gA,
          min_scale_z: GA,
          max_scale_x: lA,
          max_scale_y: SA,
          max_scale_z: MA,
          min_r: bA,
          min_g: NA,
          min_b: ZA,
          max_r: qA,
          max_g: WA,
          max_b: nA
        } = $;
        B.push({
          min_x: iA,
          min_y: eA,
          min_z: YA,
          max_x: hA,
          max_y: DA,
          max_z: L,
          min_scale_x: yA,
          min_scale_y: gA,
          min_scale_z: GA,
          max_scale_x: lA,
          max_scale_y: SA,
          max_scale_z: MA,
          min_r: bA,
          min_g: NA,
          min_b: ZA,
          max_r: qA,
          max_g: WA,
          max_b: nA
        });
      };
    }
    function c(y) {
      if (I && y.name === "sh")
        return C = TI(y.properties), D(), n;
      if (y.name !== "vertex")
        return null;
      const { packed_position: G, packed_rotation: h, packed_scale: M, packed_color: l } = y.properties;
      if (!G || !h || !M || !l)
        throw new Error(
          "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
        );
      const k = Math.sqrt(2);
      return (R, Y) => {
        const d = B[R >>> 8];
        if (d == null)
          throw new Error("Missing PLY chunk");
        const {
          min_x: m,
          min_y: J,
          min_z: x,
          max_x: U,
          max_y: S,
          max_z: T,
          min_scale_x: V,
          min_scale_y: P,
          min_scale_z: _,
          max_scale_x: X,
          max_scale_y: aA,
          max_scale_z: $,
          min_r: iA,
          min_g: eA,
          min_b: YA,
          max_r: hA,
          max_g: DA,
          max_b: L
        } = d, { packed_position: yA, packed_rotation: gA, packed_scale: GA, packed_color: lA } = Y, SA = (yA >>> 21 & 2047) / 2047 * (U - m) + m, MA = (yA >>> 11 & 1023) / 1023 * (S - J) + J, bA = (yA & 2047) / 2047 * (T - x) + x, NA = ((gA >>> 20 & 1023) / 1023 - 0.5) * k, ZA = ((gA >>> 10 & 1023) / 1023 - 0.5) * k, qA = ((gA & 1023) / 1023 - 0.5) * k, WA = Math.sqrt(Math.max(0, 1 - NA * NA - ZA * ZA - qA * qA)), nA = gA >>> 30, PA = nA === 0 ? NA : nA === 1 ? WA : ZA, ht = nA <= 1 ? ZA : nA === 2 ? WA : qA, yt = nA <= 2 ? qA : WA, Gt = nA === 0 ? WA : NA, lt = Math.exp(
          (GA >>> 21 & 2047) / 2047 * (X - V) + V
        ), Mt = Math.exp(
          (GA >>> 11 & 1023) / 1023 * (aA - P) + P
        ), Nt = Math.exp(
          (GA & 2047) / 2047 * ($ - _) + _
        ), kt = (lA >>> 24 & 255) / 255 * (hA - iA) + iA, Ft = (lA >>> 16 & 255) / 255 * (DA - eA) + eA, Rt = (lA >>> 8 & 255) / 255 * (L - YA) + YA, Jt = (lA & 255) / 255;
        A(
          R,
          SA,
          MA,
          bA,
          lt,
          Mt,
          Nt,
          PA,
          ht,
          yt,
          Gt,
          Jt,
          kt,
          Ft,
          Rt
        );
      };
    }
    const r = (y) => {
      if (y.name === "chunk" && this.comments.some(
        (DA) => DA.toLowerCase().includes("supersplat")
      ))
        return w(y);
      if (g)
        return c(y);
      if (y.name !== "vertex")
        return null;
      const {
        x: G,
        y: h,
        z: M,
        scale_0: l,
        scale_1: k,
        scale_2: R,
        rot_0: Y,
        rot_1: d,
        rot_2: m,
        rot_3: J,
        opacity: x,
        f_dc_0: U,
        f_dc_1: S,
        f_dc_2: T,
        red: V,
        green: P,
        blue: _,
        alpha: X
      } = y.properties;
      if (!G || !h || !M)
        throw new Error("Missing PLY properties: x, y, z");
      const aA = l && k && R, $ = Y && d && m && J, iA = X != null ? qQ[X.type] : 1, eA = V != null ? qQ[V.type] : 1, YA = P != null ? qQ[P.type] : 1, hA = _ != null ? qQ[_.type] : 1;
      return C = TI(y.properties), D(), (DA, L) => {
        const yA = aA ? Math.exp(L.scale_0) : cQ.defaultPointScale, gA = aA ? Math.exp(L.scale_1) : cQ.defaultPointScale, GA = aA ? Math.exp(L.scale_2) : cQ.defaultPointScale, lA = $ ? L.rot_1 : 0, SA = $ ? L.rot_2 : 0, MA = $ ? L.rot_3 : 0, bA = $ ? L.rot_0 : 1, NA = x != null ? 1 / (1 + Math.exp(-L.opacity)) : X != null ? L.alpha / iA : 1, ZA = U != null ? L.f_dc_0 * KQ + 0.5 : V != null ? L.red / eA : 1, qA = S != null ? L.f_dc_1 * KQ + 0.5 : P != null ? L.green / YA : 1, WA = T != null ? L.f_dc_2 * KQ + 0.5 : _ != null ? L.blue / hA : 1;
        if (A(
          DA,
          L.x,
          L.y,
          L.z,
          yA,
          gA,
          GA,
          lA,
          SA,
          MA,
          bA,
          NA,
          ZA,
          qA,
          WA
        ), I && o) {
          if (o)
            for (const [nA, PA] of E.entries())
              o[nA] = L[PA];
          if (a)
            for (const [nA, PA] of t.entries())
              a[nA] = L[PA];
          if (i)
            for (const [nA, PA] of s.entries())
              i[nA] = L[PA];
          I(DA, o, a, i);
        }
      };
    };
    this.parseData(r);
  }
  // Inject RGBA values into original PLY file, which can be used to modify
  // the color/opacity of the Gsplats and write out the modified PLY file.
  injectRgba(A) {
    let I = 0;
    const g = this.data;
    if (g == null)
      throw new Error("No parsed data");
    if (A.length !== this.numSplats * 4)
      throw new Error("Invalid RGBA array length");
    for (const B in this.elements) {
      const C = this.elements[B], { count: E, properties: t } = C, s = [];
      let o = 0;
      const a = B === "vertex";
      if (a) {
        for (const i of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"])
          if (!t[i] || t[i].type !== "float")
            throw new Error(`Can't injectRgba due to property: ${i}`);
      }
      for (const [i, D] of Object.entries(t))
        if (D.isList)
          s.push(() => {
            const n = ZQ[D.countType](
              g,
              I,
              this.littleEndian
            );
            I += aQ[D.countType], I += n * aQ[D.type];
          });
        else {
          if (a)
            if (i === "f_dc_0" || i === "f_dc_1" || i === "f_dc_2") {
              const n = Number.parseInt(
                i.slice(5)
              );
              s.push(() => {
                const w = (A[o + n] / 255 - 0.5) / KQ;
                vI[D.type](
                  g,
                  I,
                  this.littleEndian,
                  w
                );
              });
            } else i === "opacity" && s.push(() => {
              const n = Math.max(
                -100,
                Math.min(
                  100,
                  -Math.log(1 / (A[o + 3] / 255) - 1)
                )
              );
              vI[D.type](
                g,
                I,
                this.littleEndian,
                n
              );
            });
          s.push(() => {
            I += aQ[D.type];
          });
        }
      for (let i = 0; i < E; i++) {
        for (const D of s)
          D();
        a && (o += 4);
      }
    }
  }
};
cQ.defaultPointScale = 1e-3;
let kI = cQ;
const KQ = 0.28209479177387814, ZQ = {
  char: (Q, A, I) => Q.getInt8(A),
  uchar: (Q, A, I) => Q.getUint8(A),
  short: (Q, A, I) => Q.getInt16(A, I),
  ushort: (Q, A, I) => Q.getUint16(A, I),
  int: (Q, A, I) => Q.getInt32(A, I),
  uint: (Q, A, I) => Q.getUint32(A, I),
  float: (Q, A, I) => Q.getFloat32(A, I),
  double: (Q, A, I) => Q.getFloat64(A, I)
}, vI = {
  char: (Q, A, I, g) => {
    Q.setInt8(A, g);
  },
  uchar: (Q, A, I, g) => {
    Q.setUint8(A, g);
  },
  short: (Q, A, I, g) => {
    Q.setInt16(A, g, I);
  },
  ushort: (Q, A, I, g) => {
    Q.setUint16(A, g, I);
  },
  int: (Q, A, I, g) => {
    Q.setInt32(A, g, I);
  },
  uint: (Q, A, I, g) => {
    Q.setUint32(A, g, I);
  },
  float: (Q, A, I, g) => {
    Q.setFloat32(A, g, I);
  },
  double: (Q, A, I, g) => {
    Q.setFloat64(A, g, I);
  }
}, aQ = {
  char: 1,
  uchar: 1,
  short: 2,
  ushort: 2,
  int: 4,
  uint: 4,
  float: 4,
  double: 8
}, qQ = {
  char: 127,
  uchar: 255,
  short: 32767,
  ushort: 65535,
  int: 2147483647,
  uint: 4294967295,
  float: 1,
  double: 1
}, Ye = {
  0: 0,
  9: 1,
  24: 2,
  45: 3
}, de = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function TI(Q) {
  let A = 0;
  for (; Q[`f_rest_${A}`]; )
    A += 1;
  const I = Ye[A];
  if (I == null)
    throw new Error(`Unsupported number of SH coefficients: ${A}`);
  return I;
}
const tt = '(function(){"use strict";let S;function OQ(g){const A=S.__externref_table_alloc();return S.__wbindgen_export_2.set(A,g),A}function vQ(g,A){try{return g.apply(this,A)}catch(Q){const I=OQ(Q);S.__wbindgen_exn_store(I)}}function XA(g){const A=typeof g;if(A=="number"||A=="boolean"||g==null)return`${g}`;if(A=="string")return`"${g}"`;if(A=="symbol"){const B=g.description;return B==null?"Symbol":`Symbol(${B})`}if(A=="function"){const B=g.name;return typeof B=="string"&&B.length>0?`Function(${B})`:"Function"}if(Array.isArray(g)){const B=g.length;let C="[";B>0&&(C+=XA(g[0]));for(let E=1;E<B;E++)C+=", "+XA(g[E]);return C+="]",C}const Q=/\\[object ([^\\]]+)\\]/.exec(toString.call(g));let I;if(Q&&Q.length>1)I=Q[1];else return toString.call(g);if(I=="Object")try{return"Object("+JSON.stringify(g)+")"}catch{return"Object"}return g instanceof Error?`${g.name}: ${g.message}\n${g.stack}`:I}let jA=0,LA=null;function qA(){return(LA===null||LA.byteLength===0)&&(LA=new Uint8Array(S.memory.buffer)),LA}const xA=typeof TextEncoder<"u"?new TextEncoder("utf-8"):{encode:()=>{throw Error("TextEncoder not available")}},PQ=typeof xA.encodeInto=="function"?function(g,A){return xA.encodeInto(g,A)}:function(g,A){const Q=xA.encode(g);return A.set(Q),{read:g.length,written:Q.length}};function _Q(g,A,Q){if(Q===void 0){const i=xA.encode(g),D=A(i.length,1)>>>0;return qA().subarray(D,D+i.length).set(i),jA=i.length,D}let I=g.length,B=A(I,1)>>>0;const C=qA();let E=0;for(;E<I;E++){const i=g.charCodeAt(E);if(i>127)break;C[B+E]=i}if(E!==I){E!==0&&(g=g.slice(E)),B=Q(B,I,I=E+g.length*3,1)>>>0;const i=qA().subarray(B+E,B+I),D=PQ(g,i);E+=D.written,B=Q(B,I,E,1)>>>0}return jA=E,B}let NA=null;function kQ(){return(NA===null||NA.buffer.detached===!0||NA.buffer.detached===void 0&&NA.buffer!==S.memory.buffer)&&(NA=new DataView(S.memory.buffer)),NA}const JQ=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&JQ.decode();function RQ(g,A){return g=g>>>0,JQ.decode(qA().subarray(g,g+A))}function $Q(g,A,Q){return S.decode_wlg(g,A,Q)}function AI(g,A,Q,I){return S.old_sort_splats(g,A,Q,I)>>>0}function QI(g,A,Q){return S.sort_splats(g,A,Q)>>>0}async function II(g,A){if(typeof Response=="function"&&g instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(g,A)}catch(I){if(g.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n",I);else throw I}const Q=await g.arrayBuffer();return await WebAssembly.instantiate(Q,A)}else{const Q=await WebAssembly.instantiate(g,A);return Q instanceof WebAssembly.Instance?{instance:Q,module:g}:Q}}function BI(){const g={};return g.wbg={},g.wbg.__wbg_buffer_09165b52af8c5237=function(A){return A.buffer},g.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},g.wbg.__wbg_get_b9b93047fe3cf45b=function(A,Q){return A[Q>>>0]},g.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9=function(A){let Q;try{Q=A instanceof Uint8Array}catch{Q=!1}return Q},g.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},g.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},g.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},g.wbg.__wbg_length_a446193dc22c12f8=function(A){return A.length},g.wbg.__wbg_length_e2d2a49132c1b256=function(A){return A.length},g.wbg.__wbg_new_405e22f390576ce2=function(){return new Object},g.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},g.wbg.__wbg_new_a12002a7f91c75be=function(A){return new Uint8Array(A)},g.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},g.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,Q,I){return new Float32Array(A,Q>>>0,I>>>0)},g.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,Q,I){return new Uint32Array(A,Q>>>0,I>>>0)},g.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},g.wbg.__wbg_newwithlength_bd3de93688d68fbc=function(A){return new Uint32Array(A>>>0)},g.wbg.__wbg_set_10bad9bee0e9c58b=function(A,Q,I){A.set(Q,I>>>0)},g.wbg.__wbg_set_65595bdd868b3009=function(A,Q,I){A.set(Q,I>>>0)},g.wbg.__wbg_set_bb8cecf6a62b9f46=function(){return vQ(function(A,Q,I){return Reflect.set(A,Q,I)},arguments)},g.wbg.__wbg_set_d23661d19148b229=function(A,Q,I){A.set(Q,I>>>0)},g.wbg.__wbg_set_f4f1f0daa30696fc=function(A,Q,I){A.set(Q,I>>>0)},g.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,Q,I){return A.subarray(Q>>>0,I>>>0)},g.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,Q,I){return A.subarray(Q>>>0,I>>>0)},g.wbg.__wbindgen_debug_string=function(A,Q){const I=XA(Q),B=_Q(I,S.__wbindgen_malloc,S.__wbindgen_realloc),C=jA;kQ().setInt32(A+4*1,C,!0),kQ().setInt32(A+4*0,B,!0)},g.wbg.__wbindgen_init_externref_table=function(){const A=S.__wbindgen_export_2,Q=A.grow(4);A.set(0,void 0),A.set(Q+0,void 0),A.set(Q+1,null),A.set(Q+2,!0),A.set(Q+3,!1)},g.wbg.__wbindgen_memory=function(){return S.memory},g.wbg.__wbindgen_number_new=function(A){return A},g.wbg.__wbindgen_string_new=function(A,Q){return RQ(A,Q)},g.wbg.__wbindgen_throw=function(A,Q){throw new Error(RQ(A,Q))},g}function gI(g,A){return S=g.exports,nQ.__wbindgen_wasm_module=A,NA=null,LA=null,S.__wbindgen_start(),S}async function nQ(g){if(S!==void 0)return S;typeof g<"u"&&(Object.getPrototypeOf(g)===Object.prototype?{module_or_path:g}=g:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof g>"u"&&(g=new URL("data:application/wasm;base64,AGFzbQEAAAABtgItYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AGABfwF/YAN/f38AYAV/f39/fwBgBH9/f38AYAFvAX9gAW8Bb2ADb39/AW9gBX9/f39/AX9gA29vfwBgAABgA39+fgBgA39+fgF/YAd/f39/f39/AX9gBn9/f39/fwBgAX0BfWAEf39/fwF/YAABb2ABfwFvYAZ/f39/f38Bf2AAAX9gC39/f39/f39/f39/AX9gAn9/AW9gAXwBb2ACb38Bb2ADb29vAX9gAn9vAGAHf39/f39/fwBgAn9/AX5gAn9+AX9gAn9+AGALfX19fX19fX1/b38Bb2ABfwF9YAV/f35/fwBgBH9+f38AYAV/f31/fwBgBH99f38AYAV/f3x/fwBgBH98f38AYAR/f29vAX9gA39vbwF/YAJ9fQF9ArcIHgN3YmcVX193YmluZGdlbl9zdHJpbmdfbmV3ABkDd2JnFV9fd2JpbmRnZW5fbnVtYmVyX25ldwAaA3diZxpfX3diZ19nZXRfYjliOTMwNDdmZTNjZjQ1YgAbA3diZx1fX3diZ19sZW5ndGhfZTJkMmE0OTEzMmMxYjI1NgAIA3diZxpfX3diZ19uZXdfNDA1ZTIyZjM5MDU3NmNlMgAUA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfYTEyMDAyYTdmOTFjNzViZQAJA3diZxpfX3diZ19zZXRfNjU1OTViZGQ4NjhiMzAwOQAMA3diZx1fX3diZ19sZW5ndGhfYTQ0NjE5M2RjMjJjMTJmOAAIA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAMA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAAIA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAoDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAwDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAgDd2JnMV9fd2JnX25ld3dpdGhi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CwJAIAAoAhAiAkUNAEGousIAQQggAhDVBEUNAEEBDAILIAFBATsBJCABIAQ2AiAgAUEANgIcIAFBAToAGCABQd8ANgIUIAEgBDYCECABQQA2AgwgASAENgIIIAEgAzYCBCABQd8ANgIAIAFBKGogARBQAn8gASgCKEUEQAJAIAEtACUNACABQQE6ACUCQCABLQAkQQFGBEAgASgCICEFIAEoAhwhBAwBCyABKAIgIgUgASgCHCIERg0BCyABKAIEIARqIQMgBSAEawwCC0GwusIAEK4EAAsgASgCHCEEIAEgASgCMDYCHCADIARqIQMgASgCLCAEawshBAJAIAIEQCADIAQgAhDVBA0BCyABQcgAaiABQSBqKQIANwMAIAFBQGsgAUEYaikCADcDACABQThqIAFBEGopAgA3AwAgAUEwaiABQQhqKQIANwMAIAEgASkCADcDKAJAIAEtAE0NACACIQMDQCABKAIsIQUgAUHUAGogAUEoahBQAn8gASgCVEUEQCABLQBNDQMgAUEBOgBNAkAgAS0ATEEBRgRAIAEoAkghBSABKAJEIQQMAQsgASgCSCIFIAEoAkQiBEYNBAsgASgCLCAEaiEGIAUgBGsMAQsgASgCRCEEIAEgASgCXDYCRCAEIAVqIQYgASgCWCAEawshBAJAIANFBEBBACEDDAELQbm2wgBBASADENUEDQMgACgCECICRQRAQQAhAkEAIQMMAQsgAiEDIAYgBCACENUEDQMLIAEtAE1FDQALCyACRQ0BQcC6wgBBAiACENUERQ0BC0EBDAELAkAgACgCECICRQ0AQcK6wgBBAyACENUERQ0AQQEMAQsCQAJAAkAgACgCACIDRQRAQQAhAwwBC0EAIQIDQAJAIAAoAggiBCAAKAIETw0AIAMgBGotAABBxQBHDQAgACAEQQFqNgIIDAILAkAgAkUNACAAKAIQIgNFDQBB9bnCAEECIAMQ1QRFDQBBAQwFCyAAECcNAiACQQFrIQIgACgCACIDDQALQQAhAwsgACgCECIEBEBBAUH1s8IAQQEgBBDVBA0DGiAAKAIAIQMLIANFDQEgACgCCCICIAAoAgRPDQEgAiADai0AAEH1AEcNASAAIAJBAWo2AghBAAwCC0EBDAELAkAgACgCECICRQ0AQcW6wgBBBCACENUERQ0AQQEMAQsgABAnCyAB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AWogBiARGyADa2whAwwDCyABIApBjIHCABCtAgALQZyBwgBBKUHIgcIAEO0CAAtBoP/BAEEXQZyAwgAQ7QIACyAPIAZBAWo2AgAgAkEEaiAJOgAAIAIgAzYCACACQQhqIQIgBCAFQQFqIgVHDQALCyAAQYWAgIB4NgIADwsgBUEBaiEFIAMoAgAhCSADQQRqIQMgCUEATA0ACyAFQQFrIQxBACEDA0ACQCACIAZJBEAgA0EBaiEDIAsgAkEDdGogDDoABQNAIAIgDWogDnEiAiAETw0ACwwBCyACIAZB2IHCABCtAgALIAMgCUcNAAsMAAsAC9IHAQN/AkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAgAOCgAHBwECAwQHBwUHCwJAAkACQAJAAkACQCAALQAEDgcADAEMAgMEDAsgAC0ACEEDRw0LIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQQgASADIAIoAggQpwQMBAsgAC0ACEEDRw0KIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQMgASADIAIoAggQpwQMAwsgAC0ACEEDRw0JIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQIgASADIAIoAggQpwQMAgsgAC0ACEEDRw0IIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQEgASADIAIoAggQpwQMAQsgAC0ACEEDRw0HIAAoAgwiACgCACEBIABBBGooAgAiAigCACIDBEAgASADEQMACyACKAIEIgNFDQAgASADIAIoAggQpwQLIABBDEEEEKcEDwsCQAJAIAAtAAQOAgcBAAsgACgCCCIBQfv///8HaiICQQ1NIAJBAkdxDQYgAUGEgICAeEoNBSABQYOAgIB4Rw0GDAULIAAoAggiAUGEgICAeEogAUGDgICAeEZyDQQMBQsgAC0ABEEDRw0EDAULAkACQEEDIAAoAgQiAUEHayICIAJBA08bQQJrDgIBAAULAkACQAJAIAEOBgAHAQcHAgcLIAAtAAhBA0cNBgwICyAAKAIIIgFB7f///wdqIgJBCk0gAkEDR3ENBSABRSABQfv///8H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wQA2AgggAkIBNwIUIAIgAkEEaq1CgICAgJA4hDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwICyACIAA2AgQgAkEBNgIMIAJB8KfBADYCCCACQgE3AhQgAiACQQRqrUKAgICAoDeENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAcLIAIgAEEEajYCBCACQQE2AgwgAkHwp8EANgIIIAJCATcCFCACIAJBBGqtQoCAgICgOIQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEUMBgsgASgCHEHFusEAQTkgASgCICgCDBECAAwFCyACIABBBGo2AgQgAkECNgIMIAJBqLvBADYCCCACQgE3AhQgAiACQQRqrUKAgICA8DWENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAQLIAIgAEEEajYCACACIABBCGo2AgQgAkEDNgIMIAJB6LvBADYCCCACQgI3AhQgAkKAgICA8DUiBCACrYQ3AyggAiAEIAJBBGqthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwDCyACIABBBGo2AgQgAkECNgIMIAJB8LzBADYCCCACQgE3AhQgAiACQQRqrUKAgICAsDiENwMgIAIgAkEgajYCECABKAIcIAEoAiAgAkEIahBFDAILIAIgAEEEajYCACACIABBCGo2AgQgAkECNgIMIAJBsL3BADYCCCACQgI3AhQgAkKAgICAwDgiBCACQQRqrYQ3AyggAiAEIAKthDcDICACIAJBIGo2AhAgASgCHCABKAIgIAJBCGoQRQwBCyACIABBBGo2AgAgAiAAQQhqNgIEIAJBAjYCDCACQfS9wQA2AgggAkICNwIUIAJCgICAgPA1IgQgAkEEaq2ENwMoIAIgBCACrYQ3AyAgAiACQSBqNgIQIAEoAhwgASgCICACQQhqEEULIAJBMGokAAuXBgEIfyMAQTBrIgEkAAJAAn8CQAJAAkAgACgCACIFBEAgACgCCCIEIAQgACgCBCIHIAQgB0sbayEIIAUhAwNAIAIgCGpFDQMgACACIARqQQFqNgIIIAJBAWohAiADIARqIANBAWohAy0AACIGQTBrQf8BcUEKSSAGQeEAa0H/AXFBBklyDQALIAZB3wBHDQIgAiAEakEBayEGAkAgBARA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IABBABAgDAELIAAQJwsgBEEQaiQAC5QDAQR/AkAgAkEQSQRAIAAhAwwBCwJAIABBACAAa0EDcSIFaiIEIABNDQAgACEDIAUEQCAFIQYDQCADIAE6AAAgA0EBaiEDIAZBAWsiBg0ACwsgBUEBa0EHSQ0AA0AgAyABOgAAIANBB2ogAToAACADQQZqIAE6AAAgA0EFaiABOgAAIANBBGogAToAACADQQNqIAE6AAAgA0ECaiABOgAAIANBAWogAToAACADQQhqIgMgBEcNAAsLIAQgAiAFayICQXxxaiIDIARLBEAgAUH/AXFBgYKECGwhBQNAIAQgBTYCACAEQQRqIgQgA0kNAAsLIAJBA3EhAgsCQCADIAIgA2oiBU8NACACQQdxIgQEQANAIAMgAToAACADQQFqIQMgBEEBayIEDQALCyACQQFrQQdJDQADQCADIAE6AAAgA0EHaiABOgAAIANBBmogAToAACADQQVqIAE6AAAgA0EEaiABOgAAIANBA2ogAToAACADQQJqIAE6AAAgA0EBaiABOgAAIANBCGoiAyAFRw0ACwsgAAudAwIGfwF+QTggAUH/AXEiASABQThPGyECAkAgACgCECIEIAAtABQiAWoiA0EASgRAIAIgA0sNAQJAIARBAEwgASACT3INAANAIARBAWsiBUEDdiEGQcAAIAFBB2oiB0F4cWshAwJAIAVBP00EQCAAIAYgAxCIASAAKAIQIQQgAC0AFCEBDAELAkAgACgCBCIFIAYgB0H4AXFBA3ZqQQdrIgZPBEAgBSAGayIFQQdLDQFBCCAFQcTewQAQqwQACyAGIAVB1N7BABCqBAALIAAgASADaiIBOgAUIAAgBCADQf8BcWsiBDYCECAAIAAoAgAgBmopAAA3AwgLIAFB/wFxIAJPDQEgBEEASg0ACwsgACABIAJrIgE6ABRCfyACrYZCf4UgACkDCCABQT9xrYiDDwsgACAEIAJrNgIQQgAPCyACIANrIQICQCADQf8BcSABSwRAIAAgAxBbIQggACgCECEEDAELIAAgASADayIBOgAUQn8gA62GQn+FIAApAwggAUE/ca2IgyEICyAAIAQgAms2AhAgCCACQT9xrYYLnAMBBX8CQEERQQAgAEGvsARPGyIBIAFBCHIiASAAQQt0IgIgAUECdEH82sIAaigCAEELdEkbIgEg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AEEEaiACKAIEIAIoAggQPUHcoMIAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARDaASAAQRBqJAALZgAjAEEwayIAJABBhOXCAC0AAARAIABBAjYCDCAAQYyhwgA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIAQhDcDICAAIABBIGo2AhAgAEEIakG0ocIAEKQDAAsgAEEwaiQAC2EBAX8jAEEwayICJAAgAiAANgIMIAJBAjYCFCACQZymwQA2AhAgAkIBNwIcIAIgAkEMaq1CgICAgOA0hDcDKCACIAJBKGo2AhggASgCHCABKAIgIAJBEGoQRSACQTBqJAALYQEBfyMAQTBrIgIkACACIAA2AgwgAkECNgIUIAJB5K7BADYCECACQgE3AhwgAiACQQxqrUKAgICA4DSENwMoIAIgAkEoajYCGCABKAIcIAEoAiAgAkEQahBFIAJBMGokAAthAQF/IwBBMGsiAiQAIAIgADYCDCACQQE2AhQgAkHwp8EANgIQIAJCATcCHCACIAJBDGqtQoCAgICQOIQ3AyggAiACQShqNgIYIAEoAhwgASgCICACQRBqEEUgAkEwaiQAC18BAn8CQCAAKAIAIgFB7f///wdqIgJBCk0gAkEDR3ENACABRSABQfv///8HaiICQQ1NIAJBAkdxIAFBg4CAgHhHIAFBhICAgHhMcXJyDQAgACgCBCABQQJ0QQQQpwQLC1wBA38gAC0AACIBQQNLIAFBA0dyRQRAIAAoAgQiACgCACEBIABBBGooAgAiAygCACICBEAgASACEQMACyADKAIEIgIEQCABIAIgAygCCBCnBAsgAEEMQQQQpwQLC2sBAn9BqJbAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EEa0H/AXFBA0kbQQFrDgMAAQIDC0EAIQEMAgsgAUEBaiEBQdStwAAhAgwBCyABQQRqIQFBkK7AACECCyAAIAI2AgQgACABNgIAC2gBA38CQAJAAkACQEEDIAEoAgBB7f///wdqIgQgBEELTxtBAmsOAwABAgMLIAFBBGohAkGcm8AAIQMMAgtB2LPAACEDIAEhAgwBCyABQQRqIQJBjLXAACEDCyAAIAM2AgQgACACNgIAC2sBAn9B1LfAACECAkACQAJAAkAgAS0AACIDQQNrQQAgA0EE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AX8jAEEQayICJAAgAiAANgIMIAFB8b3AAEEWQYe+wABBAyACQQxqQay7wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBic7AAEEbQcC8wABBAyACQQxqQay7wAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBrODAAEERQb3gwABBBCACQQxqQZzgwAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBweDAAEEWQdfgwABBAyACQQxqQfjawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8fDAAEEbQZDfwABBAyACQQxqQfjawAAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFB8IjBAEERQYGJwQBBBCACQQxqQeCIwQAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBhYnBAEEWQZuJwQBBAyACQQxqQcCGwQAQyQEgAkEQaiQACzgBAX8jAEEQayICJAAgAiAANgIMIAFBhZfBAEEbQdSHwQBBAyACQQxqQcCGwQAQyQEgAkEQaiQACzwBAX8jAEEQayICJAAgAkGQksIANgIMIAIgADYCCCACQQhqQZSSwgAgAkEMakGUksIAIAFB5J/CABBrAAs4AQF/IwBBEGsiAiQAIAIgADYCDCABQeywwgBBDUH5sMIAQQQgAkEMakHcsMIAEMkBIAJBEGokAAs5AQF/IwBBEGsiAyQAIAMgATYCDCADIAA2AgggA0EIakGswsIAIANBDGpBrMLCACACQeyOwgAQawALMAEBfyMAQRBrIgIkACACQQhqIAAQ8wIgAigCCCABIAIoAgwoAhARAAAgAkEQaiQACzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEMUBDwsgACABEPwBDwsgACABEP0BCzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEK0EDwsgACABEIQCDwsgACABEIMCCzIBAX8gASgCFCICQRBxRQRAIAJBIHFFBEAgACABEKkDDwsgACABEIQCDwsgACABEIMCCzMBAX8jAEEQayICJAAgAiAAKAIANgIMIAFB7IfBAEEMIAJBDGpB3IfBABB/IAJBEGokAAszAQF/IwBBEGsiAiQAIAIgACgCADYCDCABQejUwQBBDCACQQxqQdjUwQAQfyACQRBqJAALLQACQCAAIAEQrANFDQAgAARAQYXlwgAtAAAaIAAgARD1AyIBRQ0BCyABDwsACzcBAX8jAEEgayIBJAAgAUEANgIYIAFBATYCDCABQdzZwgA2AgggAUIENwIQIAFBCGogABCkAwALMwEBfyAAKAIAIgFBhICAgHhMIAFBg4CAgHhHcSABRXJFBEAgACgCBCABQQJ0QQQQpwQLCzABAX8jAEEQayICJAAgAiAANgIMIAFBxJnAAEEMIAJBDGpBtJnAABB/IAJBEGokAAsvACAAQZybwAA2AgQgACABIAFBACABLQAAQQJrQf8BcSIAQQFGGyAAQQJLGzYCAAswAQF/IwBBEGsiAiQAIAIgADYCDCABQdi8wABBDCACQQxqQci8wAAQfyACQRBqJAALLwAgAEGwvsAANgIEIAAgASABQQAgAS0AAEECa0H/AXEiAEEBRhsgAEECSxs2AgALMAEBfyMAQRBrIgIkACACIAA2AgwgAUGo38AAQQwgAkEMakGY38AAEH8gAkEQaiQACy8AIABBgOHAADYCBCAAIAEgAUEAIAEtAABBAmtB/wFxIgBBAUYbIABBAksbNgIACy8AIABBxInBADYCBCAAIAEgAUEAIAEtAABBAmtB/wFxIgBBAUYbIABBAksbNgIACzABAX8jAEEQayICJAAgAiAANgIMIAFB7IfBAEEMIAJBDGpB3IfBABB/IAJBEGokAAssAQF/IwBBEGsiACQAIABBCGoiAiABQfyVwgBBCxCmAyACEK4CIABBEGokAAuEAQEDfyMAQSBrIgQkACAEQQhqIgMQ8AECf0GF5cIALQAAGkEkQQQQ9QMiAgRAIAJB5LrAADYCACACIAE2AiAgAiAANgIcIAIgAykCADcCBCACQQxqIANBCGopAgA3AgAgAkEUaiADQRBqKQIANwIAIAIMAQtBBEEkENMEAAsgBEEgaiQACzgBAX9BASEBIAAtAARFBEAgACgCACIBKAIcQY7EwgBBASABKAIgKAIMEQIAIQELIAAgAToABCABC5ABAQN/IwBBIGsiAyQAIANBCGoiAhDwAQJ/QYXlwgAtAAAaQShBBBD1AyIBBEAgAUGcgsAANgIAIAEgAikCADcCBCABIAApAgA3AhwgAUEMaiACQQhq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NgIMIABBhKLCACABKAIEIAEoAggiAC0ACCAALQAJEMEBAAsgACADNgIEIAAgAjYCACAAQeihwgAgASgCBCABKAIIIgAtAAggAC0ACRDBAQALKgAgAEH/AXFFBEBDAAAAAA8LIABBAWtB/wFxs0NFIpE9lEMAABDBkhBSCy0AIAEoAhwgAiADIAEoAiAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAsyAQF/IAEoAhxBvMHCAEEBIAEoAiAoAgwRAgAhAiAAQQA6AAUgACACOgAEIAAgATYCAAshAAJAIAEgAxCsAwRAIAAgASADIAIQ3wMiAA0BCwALIAALIgEBfyAAKAIAIgAgAEEfdSICcyACayAAQX9zQR92IAEQbAslACAARQRAQfiPwgBBMhDIBAALIAAgAiADIAQgBSABKAIQEQsACygAIAEgACgCAC0AAEECdCIAQeC8wgBqKAIAIABBzLzCAGooAgAQ5QMLGQEBf0GAgICAeCABayAATyACIAFpQQFGGwslACABIAAtAABBAnQiAEH8tcAAaigCACAAQey1wABqKAIAEOUDCyUAIABBnJvAADYCBCAAIAFBBGpBACABKAIAQYKAgIB4Rhs2AgALIQAgAEHwosAANgIEIAAgAUEBakEAIAEtAABBAkYbNgIACyUAIAEgAC0AAEECdCIAQZDZwABqKAIAIABBgNnAAGooAgAQ5QMLJQAgAEGwvsAANgIEIAAgAUEEakEAIAEoAgBBgoCAgHhGGzYCAAshACAAQYTGwAA2AgQgACABQQFqQQAgAS0AAEECRhs2AgALJQAgASAALQAAQQJ0IgBB+PvAAGooAgAgAEHo+8AAaigCABDlAwslACAAQYDhwAA2AgQgACABQQRqQQAgASgCAEGCgICAeEYbNgIACyEAIABBsOjAADYCBCAAIAFBAWpBACABLQAAQQJGGzYCAAshACAAQbSOwQA2AgQgACABQQFqQQAgAS0AAEECRhs2AgALJQAgAEHEicEANgIEIAAgAUEEakEAIAEoAgBBgoCAgHhGGzYCAAslACABIAAtAABBAnQiAEGMosEAaigCACAAQfyhwQBqKAIAEOUDCyMAIABFBEBB+I/CAEEyEMgEAAsgACACIAMgBCABKAIQEQcACyMAIABFBEBB+I/CAEEyEMgEAAsgACACIAMgBCAB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BBD1AyILBEACQEGF5cIALQAAGkGACEEEEPUDIghFDQJBheXCAC0AABpBgAhBBBD1AyIERQ0AQYXlwgAtAAAaQYAIQQQQ9QMiDkUNAkGF5cIALQAAGkGACEEEEPUDIgxFDQBBheXCAC0AABpBgAhBBBD1AyISRQ0CIANCADcDqAIgA0EBNgLoASADQQA6AOQBIANBADoA4gEgA0EAOgDgASADQTQ7AdwBIANBADYC2AEgAyASNgLUASADQoCAgICAIDcCzAEgAyAMNgLIASADQoCAgICAIDcDwAEgA0KAgICAwAA3A7gBIANBIzsBtAEgA0EANgKwASADIA42AqwBIANCgICAgIAgNwKkASADIAQ2AqABIANCgICAgIAgNwOYASADQoCAgIDAADcDkAEgA0EfOwGMASADQQA2AogBIAMgCDYChAEgA0KAgICAgCA3AnwgAyALNgJ4IANCgICAgIAgNwNwIANCgICAgMAANwNoIANBwAJqQgA3AwAgA0G4AmpCADcDACADQbACakIANwMAIANB/AFqQQA2AgAgA0H0AWpCADcCACADQgA3AuwBIANC1uuC7ur9ifXgADcDgAIgA0LP1tO+0ser2UI3A4gCIANCADcDkAIgA0L56tDQ58mh5OEANwOYAiADQgA3A6ACIANBADYCyAIgA0IANwPQAiADIAY2AtgCIANBADYC5AIgA0EINgKUAyADQoCAgIAQNwLcAiADQoGAgIDAADcCjAMgA0EANgKIAyADQoCAgIAQNwPoAiADQgA3A/ACIANCBDcD+AIgA0KAgICAEDcDgAMMAwsLQQRBgAhBzIDCABDXAwALQQRBgAhB3IDCABDXAwALIAdBADYCqAcgB0EANgKwByAHQQA6ANwKIAdBADYC2AogByAjNwPQCiAHKQOoByEgIAcpA7AHISMgB0HoA2oiBiADQagDEDsaIAdBCGoQSSAHICM3AyggByAgNwMgIAcgITcDGCAHIA02AgwgByAiPgIQIAcgIkIgiD4CFCAHIAU2AgggB0EwaiAGQagDEDshCCAFQQFxBEBBDCEQIAcoAtgDIhJFDQEgBygC3AMhFwNAIBJB1AFrIQQgEkEEaiEGIBIvAd4WIgNBAnQhC0F/IQUCQAJAA0AgC0UEQCADIQUMAgsgBigCACEOIAVBAWohBSAEQYQCaiEEIAtBBGsh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EwAgAEHMuMAANgIEIAAgATYCAAsTACAAQYi5wAA2AgQgACABNgIACxMAIABBxLnAADYCBCAAIAE2AgALEwAgAEGAusAANgIEIAAgATYCAAsTACAAQbC+wAA2AgQgACABNgIACxMAIABBKDYCBCAAQYjbwAA2AgALEwAgAEGA4cAANgIEIAAgATYCAAshACAAQqTFo/yfjvDjADcDCCAAQqqooLmusOaw6QA3AwALEAAgACgCACAAKAIEIAEQMAsRACAAKAIAIAAoAgQgARDVBAsiACAAQsuH6/rgqLu20AA3AwggAELEr9zF2tKv9bh/NwMACxMAIABBKDYCBCAAQcCFwQA2AgALEwAgAEHEicEANgIEIAAgATYCAAsgACAAQrz8k7Ko16DsTDcDCCAAQuuYqJm2gbKefzcDAAshACAAQriynYTMrpfUQjcDCCAAQu/Dv6KOjcrEoH83AwALIAAgAEKcnaLxgrvwoHU3AwggAELRqsqvpcqt8kA3AwALIQAgAEL7wqCWlfy/yHo3AwggAELmsfLlkYe/ybF/NwMACyIAIABC9auQ77TsvKaWfzcDCCAAQrHh7P30uYbLwgA3AwALIAAgAELNnq77nqC2sEE3AwggAELxps+Y0aSn/gE3AwALIAAgAEK3v8ue+N2SoEM3AwggAEKvuaX0x5vV+zA3AwALIQAgAEKWl7rs79nZo3Q3AwggAEKH+OXLhuPSwtQANwMACyEAIABC/O6Qyq7osdU1NwMIIABC2OvVj+a1zN2OfzcDAAshACAAQrzprN2Y1v7ui383AwggAEKk3Nqt0/nNwEU3AwALIQAgAELl6obQ6cP/7Xk3AwggAEL30OLk1cPQ6ad/NwMACyEAIABC5sHsgPKk3YtlNwMIIABChu7u8+efmIeefzcDAAshACAAQs7Is8mT6a+2pX83AwggAELt66KMv7HLkg83AwALIgAgAEKcrtGn56WAwMIANwMIIABC16rLiaf+wYLHADcDAAsiACAAQt3+weC9o+rogn83AwggAEKX2/aYrfP7zY5/NwMACyEAIABCgsDc4LCv07mnfzcDCCAAQpbk17fDtcOKAzcDAAshACAAQrvV0cb1jfDEkH83AwggAELVi9bpuKS4kXk3AwALIQAgAEKynOer2rGju98ANwMIIABCvfif/8L+hsNVNwMACyIAIABC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ZXJFcnJvcgAAAAAEAAAABAAAAE4AAABGcmFtZUhlYWRlckVycm9yV2luZG93U2l6ZVRvb0JpZwAAAAAEAAAABAAAAE8AAABEaWN0aW9uYXJ5RGVjb2RlRXJyb3IAAAAAAAAABAAAAAQAAABQAAAARmFpbGVkVG9SZWFkQmxvY2tIZWFkZXIAAAAAAAQAAAAEAAAAUQAAAEZhaWxlZFRvUmVhZEJsb2NrQm9keQAAAAAAAAAEAAAABAAAAFIAAABGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAAAAQAAAAEAAAAUwAAAEZTRURlY29kZXJFcnJvcgAAAAAABAAAAAQAAABUAAAARlNFVGFibGVFcnJvclNvdXJjZUlzRW1wdHlOb3RFbm91Z2hCeXRlc0ZvcldlaWdodHNnb3RfYnl0ZXNleHBlY3RlZF9ieXRlcwAAAAAAAAAEAAAABAAAAFUAAABFeHRyYVBhZGRpbmdza2lwcGVkX2JpdHNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c2hhdmVGU0VUYWJsZVVzZWRUb29NYW55Qnl0ZXN1c2VkYXZhaWxhYmxlX2J5dGVzTm90RW5vdWdoQnl0ZXNJblNvdXJjZVdlaWdodEJpZ2dlclRoYW5NYXhOdW1CaXRzTWF4Qml0c1Rvb0hpZ2gAAAAAAQAAAAEAAABWAAAAAAAAAAEAAAABAAAAVwAAAFYAAABgERAAWAAAAFkAAABaAAAAWwAAAFwAAABVbnN1cHBvcnRlZE9mZnNldG9mZnNldF9jb2RlWmVyb09mZnNldE5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzAAAAAAAEAAAABAAAAF0AAABFeHRyYUJpdHNiaXRzX3JlbWFpbmluZ01pc3NpbmdDb21wcmVzc2lvbk1vZGVNaXNzaW5nQnl0ZUZvclJsZUxsVGFibGVNaXNz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ZXJFcnJvcgAAAAAEAAAABAAAAE4AAABGcmFtZUhlYWRlckVycm9yV2luZG93U2l6ZVRvb0JpZwAAAAAEAAAABAAAAE8AAABEaWN0aW9uYXJ5RGVjb2RlRXJyb3IAAAAAAAAABAAAAAQAAABQAAAARmFpbGVkVG9SZWFkQmxvY2tIZWFkZXIAAAAAAAQAAAAEAAAAUQAAAEZhaWxlZFRvUmVhZEJsb2NrQm9keQAAAAAAAAAEAAAABAAAAFIAAABGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAAAAQAAAAEAAAAUwAAAEZTRURlY29kZXJFcnJvcgAAAAAABAAAAAQAAABUAAAARlNFVGFibGVFcnJvclNvdXJjZUlzRW1wdHlOb3RFbm91Z2hCeXRlc0ZvcldlaWdodHNnb3RfYnl0ZXNleHBlY3RlZF9ieXRlcwAAAAAAAAAEAAAABAAAAFUAAABFeHRyYVBhZGRpbmdza2lwcGVkX2JpdHNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c2hhdmVGU0VUYWJsZVVzZWRUb29NYW55Qnl0ZXN1c2VkYXZhaWxhYmxlX2J5dGVzTm90RW5vdWdoQnl0ZXNJblNvdXJjZVdlaWdodEJpZ2dlclRoYW5NYXhOdW1CaXRzTWF4Qml0c1Rvb0hpZ2gAAAAAAQAAAAEAAABWAAAAAAAAAAEAAAABAAAA/wAAAFYAAAD0IhAAAAEAAFkAAAABAQAAWwAAAAIBAABVbnN1cHBvcnRlZE9mZnNldG9mZnNldF9jb2RlWmVyb09mZnNldE5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzAAAAAAAEAAAABAAAAF0AAABFeHRyYUJpdHNiaXRzX3JlbWFpbmluZ01pc3NpbmdDb21wcmVzc2lvbk1vZGVNaXNzaW5nQnl0ZUZvclJsZUxsVGFibGVNaXNz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bEVuY29kaW5nSW52YWxpZENoYXJFbmNvZGluZwAAAAAAAAAEAAAABAAAAEEAAABJbnZhbGlkVGFnRW5jb2RpbmdEZXNlcmlhbGl6ZUFueU5vdFN1cHBvcnRlZFNpemVMaW1pdFNlcXVlbmNlTXVzdEhhdmVMZW5ndGgAAAAAAAQAAAAEAAAANQEAAEN1c3RvbU5vbmVTb21lUmF3UkxFQ29tcHJlc3NlZFJlc2VydmVkAAAAAAAABAAAAAQAAAA2AQAAVG9vTWFueUJpdHNudW1fcmVxdWVzdGVkX2JpdHNsaW1pdE5vdEVub3VnaFJlbWFpbmluZ0JpdHNyZXF1ZXN0ZWRyZW1haW5pbmdBY2NMb2dJc1plcm8AAAAAAAABAAAAAQAAADcBAABBY2NMb2dUb29CaWdnb3RtYXgAAAAAAAAEAAAABAAAAEMAAABHZXRCaXRzRXJyb3IAAAAABAAAAAQAAAA4AQAAAAAAAAQAAAAEAAAARQAAAFByb2JhYmlsaXR5Q291bnRlck1pc21hdGNoZXhwZWN0ZWRfc3Vtc3ltYm9sX3Byb2JhYmlsaXRpZXNUb29NYW55U3ltYm9scwAAAAAEAAAABAAAAEYAAABCbG9ja1NpemVUb29MYXJnZXNpemVJbnZhbGlkQmxvY2t0eXBlTnVtYmVybnVtVGFibGVJc1VuaW5pdGlhbGl6ZWQAAAAAAAAMAAAABAAAAEcAAAAAAAAADAAAAAQAAAA5AQAARwAAAHAwEAA6AQAASQAAADsBAABKAAAAPAEAAAAAAAAEAAAABAAAAEsAAABXaW5kb3dUb29CaWdXaW5kb3dUb29TbWFsbAAAAAAAAAQAAAAEAAAATAAAAEZyYW1lRGVzY3JpcHRvckVycm9yRGljdElkVG9vU21hbGxleHBlY3RlZE1pc21hdGNoZWRGcmFtZVNpemVGcmFtZVNpemVJc1plcm9JbnZhbGlkRnJhbWVTaXplTm90RW5vdWdoQnl0ZXNJbkRpY3Rpb25hcnluZWVkT2Zmc2V0VG9vQmlnb2Zmc2V0YnVmX2xlbgAAAAAABAAAAAQAAABNAAAAUmVhZEZyYW1lSGVhZGVyRXJyb3IAAAAABAAAAAQAAABOAAAARnJhbWVIZWFkZXJFcnJvcldpbmRvd1NpemVUb29CaWcAAAAABAAAAAQAAABPAAAARGljdGlvbmFyeURlY29kZUVycm9yAAAAAAAAAAQAAAAEAAAAUAAAAEZhaWxlZFRvUmVhZEJsb2NrSGVhZGVyAAAAAAAEAAAABAAAAFEAAABGYWlsZWRUb1JlYWRCbG9ja0JvZHlGYWlsZWRUb1JlYWRDaGVja3N1bU5vdFlldEluaXRpYWxpemVkRmFpbGVkVG9Jbml0aWFsaXplRmFpbGVkVG9EcmFpbkRlY29kZWJ1ZmZlckZhaWxlZFRvU2tpcEZyYW1lVGFyZ2V0VG9vU21hbGxEaWN0Tm90UHJvdmlkZWRkaWN0X2lkAAAAAAAABAAAAAQAAABTAAAARlNFRGVjb2RlckVycm9yAAAAAAAEAAAABAAAAFQAAABGU0VUYWJsZUVycm9yU291cmNlSXNFbXB0eU5vdEVub3VnaEJ5dGVzRm9yV2VpZ2h0c2dvdF9ieXRlc2V4cGVjdGVkX2J5dGVzRXh0cmFQYWRkaW5nc2tpcHBlZF9iaXRzVG9vTWFueVdlaWdodHNNaXNzaW5nV2VpZ2h0c0xlZnRvdmVySXNOb3RBUG93ZXJPZjJOb3RFbm91Z2hCeXRlc1RvRGVjb21wcmVzc1dlaWdodHNoYXZlRlNFVGFibGVVc2VkVG9vTWFueUJ5dGVzdXNlZGF2YWlsYWJsZV9ieXRlc05vdEVub3VnaEJ5dGVzSW5Tb3VyY2VXZWlnaHRCaWdnZXJUaGFuTWF4TnVtQml0c01heEJpdHNUb29IaWdoAAAAAAAAAAEAAAABAAAAVgAAAAAAAAABAAAAAQAAAD0BAABWAAAAIDQQAD4BAABZAAAAPwEAAFsAAABAAQAAVW5zdXBwb3J0ZWRPZmZzZXRvZmZzZXRfY29kZVplcm9PZmZzZXROb3RFbm91Z2hCeXRlc0Zvck51bVNlcXVlbmNlcwAAAAAABAAAAAQAAABdAAAARXh0cmFCaXRzYml0c19yZW1haW5pbmdNaXNzaW5nQ29tcHJlc3Npb25Nb2RlTWlzc2luZ0J5dGVGb3JSbGVMbFRhYmxlTWlzc2luZ0J5dGVGb3JSbGVPZlRhYmxlTWlzc2luZ0J5dGVGb3JSbGVNbFRhYmxlAAAAQQEAAAwAAAAEAAAAXwAAAEEBAAAMAAAABAAAAEIBAABfAAAAKDUQAEMBAABiAAAAOwEAAGMAAAA8AQAAAAAAABAAAAAIAAAAZAAAAAAAAAAQAAAACAAAAEQBAABkAAAAZDUQAEUBAABnAAAAMgEAAGgAAAAzAQAARgEAABgAAAAEAAAAagAAAEYBAAAYAAAABAAAAEcBAABqAAAAoDUQAEgBAABtAAAAOwEAAG4AAAA8AQAASQEAAAgAAAAEAAAAcAAAAEkBAAAIAAAABAAAAEoBAABwAAAA3DUQAEsBAABzAAAAOwEAAHQAAAA8AQAATAEAABgAAAAEAAAAdgAAAEwBAAAYAAAABAAAAE0BAAB2AAAAGDYQAE4BAAB5AAAAOwEAAHoAAAA8AQAATwEAAAgAAAAEAAAAJQAAAE8BAAAIAAAABAAAACYAAAAlAAAAVDYQACcAAAAoAAAAKQAAACoAAAA8AQAAAAAAAAwAAAAEAAAAewAAAAAAAAAMAAAABAAAAFABAAB7AAAAkDYQAFEBAAB+AAAAOwEAAH8AAAA8AQAAUgEAABQAAAAEAAAAgQAAAFIBAAAUAAAABAAAAFMBAACBAAAAzDYQAFQBAACEAAAAOwEAAIUAAAA8AQAAUmVhZEVycm9yRm91bmRSZXNlcnZlZEJsb2NrAAAAAAAEAAAABAAAAIYAAABCbG9ja1R5cGVFcnJvcgAAAAAAAAQAAAAEAAAAhwAAAEJsb2NrU2l6ZUVycm9yQmxvY2tDb250ZW50UmVhZEVycm9yTWFsZm9ybWVkU2VjdGlvbkhlYWRlcmV4cGVjdGVkX2xlbnJlbWFpbmluZ19ieXRlcwAAAAAEAAAABAAAAIgAAABEZWNvbXByZXNzTGl0ZXJhbHNFcnJvcgAAAAAABAAAAAQAAACJAAAATGl0ZXJhbHNTZWN0aW9uUGFyc2VFcnJvcgAAAAAAAAAEAAAABAAAAIoAAABTZXF1ZW5jZXNIZWFkZXJQYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAiwAAAERlY29kZVNlcXVlbmNlRXJyb3IAAAAAAAQAAAAEAAAAjAAAAEV4ZWN1dGVTZXF1ZW5jZXNFcnJvckludmFsaWRGcmFtZUNvbnRlbnRTaXplRmxhZ01hZ2ljTnVtYmVyUmVhZEVycm9yQmFkTWFnaWNOdW1iZXJGcmFtZURlc2NyaXB0b3JSZWFkRXJyb3JJbnZhbGlkRnJhbWVEZXNjcmlwdG9yV2luZG93RGVzY3JpcHRvclJlYWRFcnJvckRpY3Rpb25hcnlJZFJlYWRFcnJvckZyYW1lQ29udGVudFNpemVSZWFkRXJyb3JTa2lwRnJhbWVtYWdpY19udW1iZXJsZW5ndGgAAAAAAAAEAAAABAAAAI0AAABCYWRNYWdpY051bQAAAAAABAAAAAQAAACOAAAASHVmZm1hblRhYmxlRXJyb3IAAAAAAAAABAAAAAQAAACPAAAARGVjb2RlYnVmZmVyRXJyb3JOb3RFbm91Z2hCeXRlc0ZvclNlcXVlbmNld2FudGVkAAAAAAEAAAABAAAAkAAAAAAAAAABAAAAAQAAAFUBAACQAAAAwDkQAD4BAACSAAAAPwEAAFsAAABAAQAAAAAAAAQAAAAEAAAAkwAAAAAAAAAEAAAABAAAAFYBAACTAAAA/DkQADoBAACVAAAAOwEAAEoAAAA8AQAAVwEAABQAAAAEAAAAlwAAAFcBAAAUAAAABAAAAFgBAACXAAAAODoQAFkBAACaAAAAOwEAAJsAAAA8AQAAAAAAAAwAAAAEAAAAnAAAAAAAAAAMAAAABAAAAFoBAACcAAAAdDoQAFsBAACfAAAAOwEAAKAAAAA8AQAAAAAAAAgAAAAEAAAAoQAAAAAAAAAIAAAABAAAAFwBAAChAAAAsDoQADoBAACjAAAAOwEAAEoAAAA8AQAAXQEAABQAAAAEAAAApQAAAF0BAAAUAAAABAAAAF4BAAClAAAA7DoQAF8BAACoAAAAOwEAAKkAAAA8AQAAAAAAAAwAAAAEAAAAqgAAAAAAAAAMAAAABAAAAGABAACqAAAAKDsQAGEBAACtAAAAOwEAAK4AAAA8AQAARGVjb2RlclN0YXRlSXNGYWlsZWRFeHBlY3RlZEhlYWRlck9mUHJldmlvdXNCbG9jawAAAAAAAAABAAAAAQAAAGIBAABzdGVwc291cmNlAAAAAAAABAAAAAQAAACwAAAARGVjb21wcmVzc0Jsb2NrRXJyb3JNaXNzaW5nQ29tcHJlc3NlZFNpemVNaXNzaW5nTnVtU3RyZWFtcwAAAAAAAAQAAAAEAAAAsQAAAEh1ZmZtYW5EZWNvZGVyRXJyb3JVbmluaXRpYWxpemVkSHVmZm1hblRhYmxlTWlzc2luZ0J5dGVzRm9ySnVtcEhlYWRlck1pc3NpbmdCeXRlc0ZvckxpdGVyYWxzbmVlZGVkAAAAAAAABAAAAAQAAABjAQAAQml0c3RyZWFtUmVhZE1pc21hdGNocmVhZF90aWxEZWNvZGVkTGl0ZXJhbENvdW50TWlzbWF0Y2hkZWNvZGVkAGQBAAAUAAAABAAAALQAAABkAQAAFAAAAAQAAABlAQAAtAAAAMQ8EABmAQAAtwAAADsBAAC4AAAAPAEAAAAAAAAMAAAABAAAALkAAAAAAAAADAAAAAQAAABnAQAAuQAAAAA9EAA6AQAAuwAAADsBAABKAAAAPAEAAGgBAAAYAAAABAAAAL0AAABoAQAAGAAAAAQAAABpAQAAvQAAADw9EABqAQAAwAAAADsBAADBAAAAPAEAAAAAAAAMAAAABAAAAMIAAAAAAAAADAAAAAQAAABrAQAAwgAAAHg9EABsAQAAxQAAADsBAADGAAAAPAEAAElsbGVnYWxMaXRlcmFsU2VjdGlvblR5cGVOb3RFbm91Z2hCeXRlc25lZWRfYXRfbGVhc3QDAAAAAwAAAAoAAAAIAAAA8i4QAPUuEAD4LhAAAi8QAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMAAAAIPhAAbQAAACoCAAARAAAAYW4gYXJyYXkgb2YgbGVuZ3RoIDQAAAAAAAAAAAEAAABtAQBBtP3AAAv1KAEAAABtAQAAAAAAAAgAAAAEAAAAbgEAAHN0cnVjdCBXbGcwSGVhZGVyIHdpdGggNyBlbGVtZW50cwAAAMw+EAAhAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogaW52YWxpZCBPbmNlIHN0YXRl+D4QADwAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L3N0ZC9zcmMvc3lzL3N5bmMvb25jZS9ub190aHJlYWRzLnJzPD8QAHwAAAA1AAAAEgAAAGZhaWxlZCB0byBmaWxsIHdob2xlIGJ1ZmZlcgDIPxAAGwAAACUAAAACAAAA5D8QAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZGVjb2RpbmcvYmxvY2tfZGVjb2Rlci5yc0J1ZyBpbiB0aGlzIGxpYnJhcnkA+D8QAGwAAACYAAAAFgAAAFdyb25nIG51bWJlciBvZiBsaXRlcmFsczogLCBTaG91bGQgaGF2ZSBiZWVuOiAAAIhAEAAaAAAAokAQABQAAAD4PxAAbAAAAK0AAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogYnl0ZXNfdXNlZF9pbl9saXRlcmFsc19zZWN0aW9uID09IHVwcGVyX2xpbWl0X2Zvcl9saXRlcmFscyBhcyB1MzIA+D8QAGwAAACzAAAACQAAAGFzc2VydGlvbiBmYWlsZWQ6IHUzMjo6ZnJvbShieXRlc19pbl9saXRlcmFsc19oZWFkZXIpICsgYnl0ZXNfdXNlZF9pbl9saXRlcmFsc19zZWN0aW9uICsKICAgICAgICAgICAgdTMyOjpmcm9tKGJ5dGVzX2luX3NlcXVlbmNlX2hlYWRlcikgKyByYXcubGVuKCkgYXMgdTMyID09CiAgICBoZWFkZXIuY29udGVudF9zaXplAAD4PxAAbAAAAMEAAAAJAAAA+D8QAGwAAAC6AAAAFwAAAPg/EABsAAAAiwAAABcAAABIb3cgZGlkIHlvdSBldmVuIGdldCB0aGlzLiBUaGUgZGVjb2RlciBzaG91bGQgZXJyb3Igb3V0IGlmIGl0IGRldGVjdHMgYSByZXNlcnZlZC10eXBlIGJsb2NrAPg/EABsAAAAcAAAABEAAABmYWlsZWQgdG8gZmlsbCB3aG9sZSBidWZmZXIAkEIQABsAAAAlAAAAAgAAAKxCEABkZXNjcmlwdGlvbigpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBEaXNwbGF5AAAAAAQAAAAEAAAAbwEAAAAAAAAEAAAABAAAAHABAABVdGY4RXJyb3J2YWxpZF91cF90b2Vycm9yX2xlblJhd1JMRUNvbXByZXNzZWRSZXNlcnZlZAAAAAAAAAAEAAAABAAAAEAAAABUb29NYW55Qml0c251bV9yZXF1ZXN0ZWRfYml0c2xpbWl0AAAAAAAABAAAAAQAAABBAAAATm90RW5vdWdoUmVtYWluaW5nQml0c3JlcXVlc3RlZHJlbWFpbmluZ0FjY0xvZ0lzWmVybwAAAAABAAAAAQAAAHEBAABBY2NMb2dUb29CaWdnb3RtYXgAAAAAAAAEAAAABAAAAEMAAABHZXRCaXRzRXJyb3IAAAAABAAAAAQAAAByAQAAAAAAAAQAAAAEAAAARQAAAFByb2JhYmlsaXR5Q291bnRlck1pc21hdGNoZXhwZWN0ZWRfc3Vtc3ltYm9sX3Byb2JhYmlsaXRpZXNUb29NYW55U3ltYm9scwAAAAAEAAAABAAAAEYAAABCbG9ja1NpemVUb29MYXJnZXNpemVJbnZhbGlkQmxvY2t0eXBlTnVtYmVybnVtVGFibGVJc1VuaW5pdGlhbGl6ZWQAAAAAAAAMAAAABAAAAEcAAAAAAAAADAAAAAQAAABzAQAARwAAALREEABKAAAASQAAAHQBAABKAAAAdQEAAAAAAAAEAAAABAAAAEsAAABXaW5kb3dUb29CaWdXaW5kb3dUb29TbWFsbAAAAAAAAAQAAAAEAAAATAAAAEZyYW1lRGVzY3JpcHRvckVycm9yRGljdElkVG9vU21hbGxleHBlY3RlZE1pc21hdGNoZWRGcmFtZVNpemVGcmFtZVNpemVJc1plcm9JbnZhbGlkRnJhbWVTaXplTm90RW5vdWdoQnl0ZXNJbkRpY3Rpb25hcnluZWVkT2Zmc2V0VG9vQmlnb2Zmc2V0YnVmX2xlbgAAAAAABAAAAAQAAABTAAAARlNFRGVjb2RlckVycm9yAAAAAAAEAAAABAAAAFQAAABGU0VUYWJsZUVycm9yU291cmNlSXNFbXB0eU5vdEVub3VnaEJ5dGVzRm9yV2VpZ2h0c2dvdF9ieXRlc2V4cGVjdGVkX2J5dGVzAAAAAAAAAAQAAAAEAAAAVQAAAEV4dHJhUGFkZGluZ3NraXBwZWRfYml0c1Rvb01hbnlXZWlnaHRzTWlzc2luZ1dlaWdodHNMZWZ0b3ZlcklzTm90QVBvd2VyT2YyTm90RW5vdWdoQnl0ZXNUb0RlY29tcHJlc3NXZWlnaHRzaGF2ZUZTRVRhYmxlVXNlZFRvb01hbnlCeXRlc3VzZWRhdmFpbGFibGVfYnl0ZXNOb3RFbm91Z2hCeXRlc0luU291cmNlV2VpZ2h0QmlnZ2VyVGhhbk1heE51bUJpdHNNYXhCaXRzVG9vSGlnaAAAAAABAAAAAQAAAFYAAAAAAAAAAQAAAAEAAAB2AQAAVgAAACRHEABbAAAAWQAAAHcBAABbAAAAeAEAAFVuc3VwcG9ydGVkT2Zmc2V0b2Zmc2V0X2NvZGVaZXJvT2Zmc2V0Tm90RW5vdWdoQnl0ZXNGb3JOdW1TZXF1ZW5jZXMAAAAAAAQAAAAEAAAAXQAAAEV4dHJhQml0c2JpdHNfcmVtYWluaW5nTWlzc2luZ0NvbXByZXNzaW9uTW9kZU1pc3NpbmdCeXRlRm9yUmxlTGxUYWJsZU1pc3NpbmdCeXRlRm9yUmxlT2ZUYWJsZU1pc3NpbmdCeXRlRm9yUmxlTWxUYWJsZQAAAHkBAAAMAAAABAAAAF8AAAB5AQAADAAAAAQAAAB6AQAAXwAAACxIEAB7AQAAYgAAAHQBAABjAAAAdQEAAAAAAAAQAAAACAAAAGQAAAAAAAAAEAAAAAgAAAB8AQAAZAAAAGhIEAB9AQAAZwAAAH4BAABoAAAAfwEAAIABAAAYAAAABAAAAGoAAACAAQAAGAAAAAQAAACBAQAAagAAAKRIEACCAQAAbQAAAHQBAABuAAAAdQEAAIMBAAAIAAAABAAAAHAAAACDAQAACAAAAAQAAACEAQAAcAAAAOBIEACFAQAAcwAAAHQBAAB0AAAAdQEAAIYBAAAYAAAABAAAAHYAAACGAQAAGAAAAAQAAACHAQAAdgAAABxJEACIAQAAeQAAAHQBAAB6AAAAdQEAAIkBAAAIAAAABAAAACUAAACJAQAACAAAAAQAAAAmAAAAJQAAAFhJEAAnAAAAKAAAACkAAAAqAAAAdQEAAAAAAAAMAAAABAAAAHsAAAAAAAAADAAAAAQAAACKAQAAewAAAJRJEACLAQAAfgAAAHQBAAB/AAAAdQEAAIwBAAAUAAAABAAAAIEAAACMAQAAFAAAAAQAAACNAQAAgQAAANBJEACOAQAAhAAAAHQBAACFAAAAdQEAAAAAAAAEAAAABAAAAFIAAABSZWFkRXJyb3JGb3VuZFJlc2VydmVkQmxvY2sAAAAAAAQAAAAEAAAAhgAAAEJsb2NrVHlwZUVycm9yAAAAAAAABAAAAAQAAACHAAAAQmxvY2tTaXplRXJyb3JCbG9ja0NvbnRlbnRSZWFkRXJyb3JNYWxmb3JtZWRTZWN0aW9uSGVhZGVyZXhwZWN0ZWRfbGVucmVtYWluaW5nX2J5dGVzAAAAAAQAAAAEAAAAiAAAAERlY29tcHJlc3NMaXRlcmFsc0Vycm9yAAAAAAAEAAAABAAAAIkAAABMaXRlcmFsc1NlY3Rpb25QYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAigAAAFNlcXVlbmNlc0hlYWRlclBhcnNlRXJyb3IAAAAAAAAABAAAAAQAAACLAAAARGVjb2RlU2VxdWVuY2VFcnJvcgAAAAAABAAAAAQAAACMAAAARXhlY3V0ZVNlcXVlbmNlc0Vycm9ySW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnTWFnaWNOdW1iZXJSZWFkRXJyb3JCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvclNraXBGcmFtZW1hZ2ljX251bWJlcmxlbmd0aAAAAAAAAAQAAAAEAAAAjQAAAEJhZE1hZ2ljTnVtAAAAAAAEAAAABAAAAI4AAABIdWZmbWFuVGFibGVFcnJvcgAAAAAAAAAEAAAABAAAAI8AAABEZWNvZGVidWZmZXJFcnJvck5vdEVub3VnaEJ5dGVzRm9yU2VxdWVuY2V3YW50ZWQAAAAAAQAAAAEAAACQAAAAAAAAAAEAAAABAAAAjwEAAJAAAADUTBAAWwAAAJIAAAB3AQAAWwAAAHgBAAAAAAAABAAAAAQAAACTAAAAAAAAAAQAAAAEAAAAkAEAAJMAAAAQTRAASgAAAJUAAAB0AQAASgAAAHUBAACRAQAAFAAAAAQAAACXAAAAkQEAABQAAAAEAAAAkgEAAJcAAABMTRAAkwEAAJoAAAB0AQAAmwAAAHUBAAAAAAAADAAAAAQAAACcAAAAAAAAAAwAAAAEAAAAlAEAAJwAAACITRAAlQEAAJ8AAAB0AQAAoAAAAHUBAAAAAAAACAAAAAQAAAChAAAAAAAAAAgAAAAEAAAAlgEAAKEAAADETRAASgAAAKMAAAB0AQAASgAAAHUBAACXAQAAFAAAAAQAAAClAAAAlwEAABQAAAAEAAAAmAEAAKUAAAAAThAAmQEAAKgAAAB0AQAAqQAAAHUBAAAAAAAADAAAAAQAAACqAAAAAAAAAAwAAAAEAAAAmgEAAKoAAAA8ThAAmwEAAK0AAAB0AQAArgAAAHUBAABEZWNvZGVyU3RhdGVJc0ZhaWxlZEV4cGVjdGVkSGVhZGVyT2ZQcmV2aW91c0Jsb2NrAAAAAAAAAAEAAAABAAAAnAEAAHN0ZXBzb3VyY2UAAAAAAAAEAAAABAAAALAAAABEZWNvbXByZXNzQmxvY2tFcnJvck1pc3NpbmdDb21wcmVzc2VkU2l6ZU1pc3NpbmdOdW1TdHJlYW1zAAAAAAAABAAAAAQAAACxAAAASHVmZm1hbkRlY29kZXJFcnJvclVuaW5pdGlhbGl6ZWRIdWZmbWFuVGFibGVNaXNzaW5nQnl0ZXNGb3JKdW1wSGVhZGVyTWlzc2luZ0J5dGVzRm9yTGl0ZXJhbHNuZWVkZWQAAAAAAAAEAAAABAAAAJ0BAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAngEAABQAAAAEAAAAtAAAAJ4BAAAUAAAABAAAAJ8BAAC0AAAA2E8QAKABAAC3AAAAdAEAALgAAAB1AQAAAAAAAAwAAAAEAAAAuQAAAAAAAAAMAAAABAAAAKEBAAC5AAAAFFAQAEoAAAC7AAAAdAEAAEoAAAB1AQAAogEAABgAAAAEAAAAvQAAAKIBAAAYAAAABAAAAKMBAAC9AAAAUFAQAKQBAADAAAAAdAEAAMEAAAB1AQAAAAAAAAwAAAAEAAAAwgAAAAAAAAAMAAAABAAAAKUBAADCAAAAjFAQAMYAAADFAAAAdAEAAMYAAAB1AQAASWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzbmVlZF9hdF9sZWFzdAMAAAADAAAACgAAAAgAAAAlQxAAKEMQACtDEAA1QxAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9zdGQvc3JjL2lvL21vZC5ycwAAHFEQAGoAAACyAQAAMQAAAGFzc2VydGlvbiBmYWlsZWQ6IGZpbGxlZCA8PSBzZWxmLmJ1Zi5pbml0L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9jb3JlL3NyYy9pby9ib3Jyb3dlZF9idWYucnMAAADBURAAdAAAAB0BAAAJAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvY29sbGVjdGlvbnMvYnRyZWUvbmF2aWdhdGUucnNIUhAAgAAAAFgCAAAwAAAASW52YWxpZCBGcmFtZV9Db250ZW50X1NpemVfRmxhZzsgSXM6ICwgU2hvdWxkIGJlIG9uZSBvZjogMCwgMSwgMiwgMwDYUhAAJQAAAP1SEAAeAEG0psEAC8piwAMAAHdpbmRvd19zaXplIGJpZ2dlciB0aGFuIGFsbG93ZWQgbWF4aW11bS4gSXM6ICwgU2hvdWxkIGJlIGxvd2VyIHRoYW46IAAAADhTEAAtAAAAZVMQABgAAAAABAAAAAAAAHdpbmRvd19zaXplIHNtYWxsZXIgdGhhbiBhbGxvd2VkIG1pbmltdW0uIElzOiAsIFNob3VsZCBiZSBncmVhdGVyIHRoYW46IJhTEAAuAAAAxlMQABoAAAABAAAAAAAAAE5vdCBlbm91Z2ggYnl0ZXMgaW4gZGljdF9pZC4gSXM6ICwgU2hvdWxkIGJlOiAAAPhTEAAhAAAAGVQQAA0AAABmcmFtZV9jb250ZW50X3NpemUgZG9lcyBub3QgaGF2ZSB0aGUgcmlnaHQgbGVuZ3RoLiBJczogADhUEAA3AAAAGVQQAA0AAABmcmFtZV9jb250ZW50X3NpemUgd2FzIHplcm9JbnZhbGlkIGZyYW1lX2NvbnRlbnRfc2l6ZS4gSXM6ICwgU2hvdWxkIGJlIG9uZSBvZiAxLCAyLCA0LCA4IGJ5dGVzAACbVBAAIAAAALtUEAAjAAAARXJyb3Igd2hpbGUgcmVhZGluZyBtYWdpYyBudW1iZXI6IAAA8FQQACIAAABSZWFkIHdyb25nIG1hZ2ljIG51bWJlcjogMHgAHFUQABsAAABFcnJvciB3aGlsZSByZWFkaW5nIGZyYW1lIGRlc2NyaXB0b3I6IAAAQFUQACYAAABFcnJvciB3aGlsZSByZWFkaW5nIHdpbmRvdyBkZXNjcmlwdG9yOiAAcFUQACcAAABFcnJvciB3aGlsZSByZWFkaW5nIGRpY3Rpb25hcnkgaWQ6IACgVRAAIwAAAEVycm9yIHdoaWxlIHJlYWRpbmcgZnJhbWUgY29udGVudCBzaXplOiDMVRAAKAAAAFNraXBwYWJsZUZyYW1lIGVuY291bnRlcmVkIHdpdGggTWFnaWNOdW1iZXIgMHggYW5kIGxlbmd0aCAgYnl0ZXP8VRAALgAAACpWEAAMAAAANlYQAAYAAABFcnJvciB3aGlsZSByZWFkaW5nIHRoZSBibG9jayBoZWFkZXJSZXNlcnZlZCBibG9jayBvY2N1cmVkLiBUaGlzIGlzIGNvbnNpZGVyZWQgY29ycnVwdGlvbiBieSB0aGUgZG9jdW1lbnRhdGlvbkVycm9yIGdldHRpbmcgYmxvY2sgdHlwZTogwlYQABoAAABFcnJvciBnZXR0aW5nIGJsb2NrIGNvbnRlbnQgc2l6ZTogAADkVhAAIgAAAEludmFsaWQgQmxvY2t0eXBlIG51bWJlci4gSXM6ICBTaG91bGQgYmUgb25lIG9mOiAwLCAxLCAyLCAzICgzIGlzIHJlc2VydmVkIHRob3VnaAAAABBXEAAeAAAALlcQADMAAAAAAAIAQmxvY2tzaXplIHdhcyBiaWdnZXIgdGhhbiB0aGUgYWJzb2x1dGUgbWF4aW11bSAgKDEyOGtiKS4gSXM6IAAAAHhXEAAvAAAAp1cQAA4AAABFcnJvciB3aGlsZSByZWFkaW5nIHRoZSBibG9jayBjb250ZW50OiAAyFcQACcAAABNYWxmb3JtZWQgc2VjdGlvbiBoZWFkZXIuIFNheXMgbGl0ZXJhbHMgd291bGQgYmUgdGhpcyBsb25nOiAgYnV0IHRoZXJlIGFyZSBvbmx5ICBieXRlcyBsZWZ0APhXEAA8AAAANFgQABQAAABIWBAACwAAAENhbid0IGRlY29kZSBuZXh0IGJsb2NrIGlmIGZhaWxlZCBhbG9uZyB0aGUgd2F5LiBSZXN1bHRzIHdpbGwgYmUgbm9uc2Vuc2VDYW4ndCBkZWNvZGUgbmV4dCBibG9jayBib2R5LCB3aGlsZSBleHBlY3RpbmcgdG8gZGVjb2RlIHRoZSBoZWFkZXIgb2YgdGhlIHByZXZpb3VzIGJsb2NrLiBSZXN1bHRzIHdpbGwgYmUgbm9uc2Vuc2VFcnJvciB3aGlsZSByZWFkaW5nIGJ5dGVzIGZvciA6IAAnWRAAHgAAAEVZEAACAAAATmVlZCAgYnl0ZXMgZnJvbSB0aGUgZGljdGlvbmFyeSBidXQgaXQgaXMgb25seSAgYnl0ZXMgbG9uZwAAWFkQAAUAAABdWRAAKgAAAIdZEAALAAAAb2Zmc2V0OiAgYmlnZ2VyIHRoYW4gYnVmZmVyOiAAAACsWRAACAAAALRZEAAVAAAAQmFkIG1hZ2ljX251bSBhdCBzdGFydCBvZiB0aGUgZGljdGlvbmFyeTsgR290OiAsIEV4cGVjdGVkOiAA3FkQAC8AAAALWhAADAAAADekMOxTcGVjaWZpZWQgd2luZG93X3NpemUgaXMgdG9vIGJpZzsgUmVxdWVzdGVkOiAsIE1heDogLFoQAC0AAABZWhAABwAAAEZhaWxlZCB0byBwYXJzZS9kZWNvZGUgYmxvY2sgYm9keTogAHBaEAAjAAAARmFpbGVkIHRvIHBhcnNlIGJsb2NrIGhlYWRlcjogAACcWhAAHgAAAEZhaWxlZCB0byByZWFkIGNoZWNrc3VtOiAAAADEWhAAGQAAAERlY29kZXIgbXVzdCBpbml0aWFsaXplZCBvciByZXNldCBiZWZvcmUgdXNpbmcgaXREZWNvZGVyIGVuY291bnRlcmVkIGVycm9yIHdoaWxlIGluaXRpYWxpemluZzogABlbEAAuAAAARGVjb2RlciBlbmNvdW50ZXJlZCBlcnJvciB3aGlsZSBkcmFpbmluZyB0aGUgZGVjb2RlYnVmZmVyOiAAUFsQADsAAABGYWlsZWQgdG8gc2tpcCBieXRlcyBmb3IgdGhlIGxlbmd0aCBnaXZlbiBpbiB0aGUgZnJhbWUgaGVhZGVyVGFyZ2V0IG11c3QgaGF2ZSBhdCBsZWFzdCBhcyBtYW55IGJ5dGVzIGFzIHRoZSBjb250ZW50c2l6ZSBvZiB0aGUgZnJhbWUgcmVwb3J0c0ZyYW1lIGhlYWRlciBzcGVjaWZpZWQgZGljdGlvbmFyeSBpZCAweCB0aGF0IHdhc250IHByb3ZpZGVkIGJ5IGFkZF9kaWN0KCkgb3IgcmVzZXRfd2l0aF9kaWN0KCkAACBcEAAnAAAAR1wQADcAAABjb21wcmVzc2VkIHNpemUgd2FzIG5vbmUgZXZlbiB0aG91Z2ggaXQgbXVzdCBiZSBzZXQgdG8gc29tZXRoaW5nIGZvciBjb21wcmVzc2VkIGxpdGVyYWxzbnVtX3N0cmVhbXMgd2FzIG5vbmUgZXZlbiB0aG91Z2ggaXQgbXVzdCBiZSBzZXQgdG8gc29tZXRoaW5nICgxIG9yIDQpIGZvciBjb21wcmVzc2VkIGxpdGVyYWxzVHJpZWQgdG8gcmV1c2UgaHVmZm1hbiB0YWJsZSBidXQgaXQgd2FzIG5ldmVyIGluaXRpYWxpemVkTmVlZCA2IGJ5dGVzIHRvIGRlY29kZSBqdW1wIGhlYWRlciwgZ290IAAAfl0QACgAAAA2VhAABgAAAE5lZWQgYXQgbGVhc3QgIGJ5dGVzIHRvIGRlY29kZSBsaXRlcmFscy4gSGF2ZTogALhdEAAOAAAAxl0QACEAAAA2VhAABgAAAFBhZGRpbmcgYXQgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2Vfc2VjdGlvbiB3YXMgbW9yZSB0aGFuIGEgYnl0ZSBsb25nOiAgYml0cy4gUHJvYmFibHkgY2F1c2VkIGJ5IGRhdGEgY29ycnVwdGlvbgAAXhAARgAAAEZeEAApAAAAQml0c3RyZWFtIHdhcyByZWFkIHRpbGw6ICwgc2hvdWxkIGhhdmUgYmVlbjogAAAAgF4QABkAAACZXhAAFAAAAERpZCBub3QgZGVjb2RlIGVub3VnaCBsaXRlcmFsczogLCBTaG91bGQgaGF2ZSBiZWVuOiDAXhAAIAAAAOBeEAAUAAAAU2VxdWVuY2Ugd2FudHMgdG8gY29weSB1cCB0byBieXRlIC4gQnl0ZXMgaW4gbGl0ZXJhbHNidWZmZXI6IAAAAARfEAAiAAAAJl8QABsAAABJbGxlZ2FsIG9mZnNldDogMCBmb3VuZERvIG5vdCBzdXBwb3J0IG9mZnNldHMgYmlnZ2VyIHRoYW4gMTw8MzI7IGdvdDogAABrXxAALwAAAFJlYWQgYW4gb2Zmc2V0ID09IDAuIFRoYXQgaXMgYW4gaWxsZWdhbCB2YWx1ZSBmb3Igb2Zmc2V0c0J5dGVzdHJlYW0gZGlkIG5vdCBjb250YWluIGVub3VnaCBieXRlcyB0byBkZWNvZGUgbnVtX3NlcXVlbmNlc2NvbXByZXNzaW9uIG1vZGVzIGFyZSBub25lIGJ1dCB0aGV5IG11c3QgYmUgc2V0IHRvIHNvbWV0aGluZ05lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBsbCB0YWJsZU5lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBvZiB0YWJsZU5lZWQgYSBieXRlIHRvIHJlYWQgZm9yIFJMRSBtbCB0YWJsZUlsbGVnYWwgbGl0ZXJhbHNzZWN0aW9udHlwZS4gSXM6ICwgbXVzdCBiZSBpbjogMCwgMSwgMiwgMwAAAMRgEAAhAAAA5WAQABgAAABOb3QgZW5vdWdoIGJ5dGUgdG8gcGFyc2UgdGhlIGxpdGVyYWxzIHNlY3Rpb24gaGVhZGVyLiBIYXZlOiAsIE5lZWQ6IBBhEAA8AAAATGEQAAgAAABzb3VyY2UgbXVzdCBoYXZlIGF0IGxlYXN0ICBieXRlcyB0byBwYXJzZSBoZWFkZXI7IGdvdCAAAGRhEAAaAAAAfmEQABwAAAA2VhAABgAAAEFjY2xvZyBtdXN0IGJlIGF0IGxlYXN0IDFGb3VuZCBGU0UgYWNjX2xvZzogIGJpZ2dlciB0aGFuIGFsbG93ZWQgbWF4aW11bSBpbiB0aGlzIGNhc2U6IADNYRAAEwAAAOBhEAArAAAAVGhlIGNvdW50ZXIgKCkgZXhjZWVkZWQgdGhlIGV4cGVjdGVkIHN1bTogLiBUaGlzIG1lYW5zIGFuIGVycm9yIG9yIGNvcnJ1cHRlZCBkYXRhIAogHGIQAA0AAAApYhAAHQAAAEZiEAAqAAAAVGhlcmUgYXJlIHRvbyBtYW55IHN5bWJvbHMgaW4gdGhpcyBkaXN0cmlidXRpb246IC4gTWF4OiAyNTYAiGIQADEAAAC5YhAACgAAAFRyaWVkIHRvIHVzZSBhbiB1bmluaXRpYWxpemVkIHRhYmxlIVNvdXJjZSBuZWVkcyB0byBoYXZlIGF0IGxlYXN0IG9uZSBieXRlSGVhZGVyIHNheXMgdGhlcmUgc2hvdWxkIGJlICBieXRlcyBmb3IgdGhlIHdlaWdodHMgYnV0IHRoZXJlIGFyZSBvbmx5ICBieXRlcyBpbiB0aGUgc3RyZWFtHmMQABwAAAA6YxAAKgAAAGRjEAAUAAAATW9yZSB0aGFuIDI1NSB3ZWlnaHRzIGRlY29kZWQgKGdvdCAgd2VpZ2h0cykuIFN0cmVhbSBpcyBwcm9iYWJseSBjb3JydXB0ZWQAAJBjEAAjAAAAs2MQACcAAABDYW4ndCBidWlsZCBodWZmbWFuIHRhYmxlIHdpdGhvdXQgYW55IHdlaWdodHNMZWZ0b3ZlciBtdXN0IGJlIHBvd2VyIG9mIHR3byBidXQgaXM6IAAZZBAAJgAAAE5vdCBlbm91Z2ggYnl0ZXMgaW4gc3RyZWFtIHRvIGRlY29tcHJlc3Mgd2VpZ2h0cy4gSXM6IAAASGQQADYAAAAZVBAADQAAAEZTRSB0YWJsZSB1c2VkIG1vcmUgYnl0ZXM6ICB0aGFuIHdlcmUgbWVhbnQgdG8gYmUgdXNlZCBmb3IgdGhlIHdob2xlIHN0cmVhbSBvZiBodWZmbWFuIHdlaWdodHMgKCkAAACQZBAAGwAAAKtkEABFAAAA8GQQAAEAAABTb3VyY2UgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCAgYnl0ZXMsIGdvdDogAAxlEAAeAAAAKmUQAA0AAAALQ2FudCBoYXZlIHdlaWdodDogIGJpZ2dlciB0aGFuIG1heF9udW1fYml0czogAABJZRAAEgAAAFtlEAAbAAAAbWF4X2JpdHMgZGVyaXZlZCBmcm9tIHdlaWdodHMgaXM6ICBzaG91bGQgYmUgbG93ZXIgdGhhbjogAAAAiGUQACIAAACqZRAAFwAAAENhbnQgc2VydmUgdGhpcyByZXF1ZXN0LiBUaGUgcmVhZGVyIGlzIGxpbWl0ZWQgdG8gIGJpdHMsIHJlcXVlc3RlZCAgYml0c9RlEAAyAAAABmYQABEAAAAXZhAABQAAAENhbid0IHJlYWQgIGJpdHMsIG9ubHkgaGF2ZSAgYml0cyBsZWZ0AAA0ZhAACwAAAD9mEAARAAAAUGYQAAoAAAAAAAAABAAAAAQAAADJAQAAAAAAAAQAAAAEAAAAygEAAFRvb01hbnlCaXRzbnVtX3JlcXVlc3RlZF9iaXRzbGltaXQAAAAAAAAEAAAABAAAAMsBAABOb3RFbm91Z2hSZW1haW5pbmdCaXRzcmVxdWVzdGVkcmVtYWluaW5nSW52YWxpZEZyYW1lQ29udGVudFNpemVGbGFnZ290AAAAAAAABAAAAAQAAADMAQAAV2luZG93VG9vQmlnV2luZG93VG9vU21hbGwAAAAAAAAEAAAABAAAAK4BAABGcmFtZURlc2NyaXB0b3JFcnJvckRpY3RJZFRvb1NtYWxsZXhwZWN0ZWRNaXNtYXRjaGVkRnJhbWVTaXplRnJhbWVTaXplSXNaZXJvSW52YWxpZEZyYW1lU2l6ZQAAAAAEAAAABAAAAM0BAABNYWdpY051bWJlclJlYWRFcnJvcgAAAAAEAAAABAAAAM4BAABCYWRNYWdpY051bWJlckZyYW1lRGVzY3JpcHRvclJlYWRFcnJvckludmFsaWRGcmFtZURlc2NyaXB0b3JXaW5kb3dEZXNjcmlwdG9yUmVhZEVycm9yRGljdGlvbmFyeUlkUmVhZEVycm9yRnJhbWVDb250ZW50U2l6ZVJlYWRFcnJvcgAAAAAABAAAAAQAAADPAQAAU2tpcEZyYW1lbWFnaWNfbnVtYmVybGVuZ3RoQmxvY2tDb250ZW50UmVhZEVycm9yTWFsZm9ybWVkU2VjdGlvbkhlYWRlcmV4cGVjdGVkX2xlbnJlbWFpbmluZ19ieXRlcwAAAAAAAAAEAAAABAAAALIBAABEZWNvbXByZXNzTGl0ZXJhbHNFcnJvcgAAAAAABAAAAAQAAACzAQAATGl0ZXJhbHNTZWN0aW9uUGFyc2VFcnJvcgAAAAAAAAAEAAAABAAAALQBAABTZXF1ZW5jZXNIZWFkZXJQYXJzZUVycm9yAAAAAAAAAAQAAAAEAAAAtQEAAERlY29kZVNlcXVlbmNlRXJyb3IAAAAAAAQAAAAEAAAAtgEAAEV4ZWN1dGVTZXF1ZW5jZXNFcnJvck5vdEVub3VnaEJ5dGVzSW5EaWN0aW9uYXJ5bmVlZE9mZnNldFRvb0JpZ29mZnNldGJ1Zl9sZW4AAAAABAAAAAQAAAC4AQAAQmFkTWFnaWNOdW0AAAAAAAQAAAAEAAAAuQEAAEZTRVRhYmxlRXJyb3IAAAAAAAAABAAAAAQAAAC6AQAASHVmZm1hblRhYmxlRXJyb3JNaXNzaW5nQ29tcHJlc3NlZFNpemVNaXNzaW5nTnVtU3RyZWFtcwAAAAAABAAAAAQAAADBAQAAR2V0Qml0c0Vycm9yAAAAAAQAAAAEAAAAwgEAAEh1ZmZtYW5EZWNvZGVyRXJyb3JVbmluaXRpYWxpemVkSHVmZm1hblRhYmxlTWlzc2luZ0J5dGVzRm9ySnVtcEhlYWRlck1pc3NpbmdCeXRlc0ZvckxpdGVyYWxzbmVlZGVkAAAAAAAABAAAAAQAAADQAQAARXh0cmFQYWRkaW5nc2tpcHBlZF9iaXRzAAAAAAQAAAAEAAAA0QEAAAAAAAAEAAAABAAAANIBAABCaXRzdHJlYW1SZWFkTWlzbWF0Y2hyZWFkX3RpbERlY29kZWRMaXRlcmFsQ291bnRNaXNtYXRjaGRlY29kZWQAAAAAAAQAAAAEAAAAxQEAAERlY29kZWJ1ZmZlckVycm9yTm90RW5vdWdoQnl0ZXNGb3JTZXF1ZW5jZXdhbnRlZGhhdmVaZXJvT2Zmc2V0AAAAAAAABAAAAAQAAADGAQAARlNFRGVjb2RlckVycm9yVW5zdXBwb3J0ZWRPZmZzZXRvZmZzZXRfY29kZU5vdEVub3VnaEJ5dGVzRm9yTnVtU2VxdWVuY2VzRXh0cmFCaXRzYml0c19yZW1haW5pbmdNaXNzaW5nQ29tcHJlc3Npb25Nb2RlTWlzc2luZ0J5dGVGb3JSbGVMbFRhYmxlTWlzc2luZ0J5dGVGb3JSbGVPZlRhYmxlTWlzc2luZ0J5dGVGb3JSbGVNbFRhYmxlSWxsZWdhbExpdGVyYWxTZWN0aW9uVHlwZU5vdEVub3VnaEJ5dGVzAAAAAAEAAAABAAAA0wEAAG5lZWRfYXRfbGVhc3RBY2NMb2dJc1plcm9BY2NMb2dUb29CaWdtYXgAAAAABAAAAAQAAADHAQAAUHJvYmFiaWxpdHlDb3VudGVyTWlzbWF0Y2hleHBlY3RlZF9zdW1zeW1ib2xfcHJvYmFiaWxpdGllc1Rvb01hbnlTeW1ib2xzVGFibGVJc1VuaW5pdGlhbGl6ZWRTb3VyY2VJc0VtcHR5Tm90RW5vdWdoQnl0ZXNGb3JXZWlnaHRzZ290X2J5dGVzZXhwZWN0ZWRfYnl0ZXNUb29NYW55V2VpZ2h0c01pc3NpbmdXZWlnaHRzTGVmdG92ZXJJc05vdEFQb3dlck9mMk5vdEVub3VnaEJ5dGVzVG9EZWNvbXByZXNzV2VpZ2h0c0ZTRVRhYmxlVXNlZFRvb01hbnlCeXRlc3VzZWRhdmFpbGFibGVfYnl0ZXNOb3RFbm91Z2hCeXRlc0luU291cmNlV2VpZ2h0QmlnZ2VyVGhhbk1heE51bUJpdHNNYXhCaXRzVG9vSGlnaC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3Jhd192ZWMucnMAAABQbhAAbQAAACoCAAARAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9iaXRfcmVhZGVyX3JldmVyc2UucnMAAADQbhAAcQAAADcAAABFAAAA0G4QAHEAAAA3AAAALwAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGXQbhAAcQAAAEYAAAANAAAA0G4QAHEAAABKAAAAHgAAAFRoaXMgaXMgYSBidWcgaW4gdGhlIHByb2dyYW0uIFRoZXJlIHNob3VsZCBvbmx5IGJlIHZhbHVlcyBiZXR3ZWVuIDAuLjMvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2Jsb2Nrcy9saXRlcmFsc19zZWN0aW9uLnJzAPJvEABtAAAAewAAADQAAADybxAAbQAAAJAAAABXAAAA8m8QAG0AAACXAAAAKgAAAPJvEABtAAAAmAAAACoAAADybxAAbQAAAJsAAAAaAAAA8m8QAG0AAACoAAAAGgAAAPJvEABtAAAAtAAAAEQAAADybxAAbQAAALgAAABGAAAA8m8QAG0AAADAAAAAKgAAAPJvEABtAAAAwQAAACsAAADybxAAbQAAAMUAAABIAAAA8m8QAG0AAADNAAAAKgAAAPJvEABtAAAAzgAAACsAAADybxAAbQAAANMAAAAuAAAA8m8QAG0AAADUAAAALgAAAENhbnQgcmV0dXJuIHRoaXMgbWFueSBiaXRzL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9iaXRfcmVhZGVyLnJzAGpxEABpAAAANgAAAA0AAABqcRAAaQAAAE8AAAAjAAAAYXNzZXJ0aW9uIGZhaWxlZDogbiAtIGJpdF9zaGlmdCA9PSBiaXRzX2luX2xhc3RfYnl0ZV9uZWVkZWQAanEQAGkAAABtAAAADQAAAGpxEABpAAAAcQAAAB8AAABqcRAAaQAAAGgAAAAkAAAAYXNzZXJ0aW9uIGZhaWxlZDogc2VsZi5pZHggJSA4ID09IDAAanEQAGkAAABkAAAADQAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaWR4ID09IG9sZF9pZHggKyBuAAAAanEQAGkAAAB3AAAACQAAAFNlcV9zdW06ICBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgZGlmZmVyZW5jZSBpbiBidWZmZXJzaXplOiAAANByEAAJAAAA2XIQADEAAAAvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2RlY29kaW5nL3NlcXVlbmNlX2V4ZWN1dGlvbi5ycwAAABxzEABxAAAALwAAAAUAAAAccxAAcQAAAAsAAAAkAAAAHHMQAHEAAAAVAAAANAAAAEFsbG9jYXRpbmcgbmV3IHNwYWNlIGZvciB0aGUgcmluZ2J1ZmZlciBmYWlsZWQvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2RlY29kaW5nL3JpbmdidWZmZXIucnMA7nMQAGkAAABhAAAAIwAAAENvdWxkIG5vdCBjcmVhdGUgbGF5b3V0IGZvciB1OCBhcnJheSBvZiBzaXplIAAAAGh0EAAtAAAA7nMQAGkAAABaAAAAIQAAAO5zEABpAAAAtAAAABUAAADucxAAaQAAAL4AAAAVAAAA7nMQAGkAAAB3AQAAHQAAAO5zEABpAAAAzgEAABUAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwDwdBAAawAAAKIAAAAZAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9saXRlcmFsc19zZWN0aW9uX2RlY29kZXIucnMAbHUQAHcAAAAUAAAAIgAAAGx1EAB3AAAAGAAAAE0AAABsdRAAdwAAADQAAAAZAAAAbHUQAHcAAAByAAAAGAAAAGx1EAB3AAAAkQAAABQAAABhc3NlcnRpb24gZmFpbGVkOiBudW1fc3RyZWFtcyA9PSAxAABsdRAAdwAAAIAAAAAJAAAAbHUQAHcAAABFAAAAGQAAAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZGVjb2Rpbmcvc2VxdWVuY2Vfc2VjdGlvbl9kZWNvZGVyLnJzAHh2EAB3AAAAGAAAAB0AAAB4dhAAdwAAAHUAAAAQAAAAeHYQAHcAAADAAAAAEAAAAGludGVybmFsIGVycm9yOiBlbnRlcmVkIHVucmVhY2hhYmxlIGNvZGU6IElsbGVnYWwgbGl0ZXJhbCBsZW5ndGggY29kZSB3YXM6IAAgdxAASwAAAHh2EAB3AAAA+gAAAA4AAABpbnRlcm5hbCBlcnJvcjogZW50ZXJlZCB1bnJlYWNoYWJsZSBjb2RlOiBJbGxlZ2FsIG1hdGNoIGxlbmd0aCBjb2RlIHdhczogAAAAhHcQAEkAAAB4dhAAdwAAABoBAAAOAAAABAAAAAMAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAMAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAD/////////////////////AQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA//////////////////////////8BAAAABAAAAAMAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAAAQAAAAEAAAABAAAA/////////////////////////////////////3h2EAB3AAAAdgEAABwAAAB4dhAAdwAAAFMBAAAcAAAAAQEBAQICAwMEBgcICQoLDA0ODxAQAAAAEgAAABQAAAAWAAAAGAAAABwAAAAgAAAAKAAAADAAAABAAAAAgAAAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAAABAAEBAQECAgMDBAQFBwgJCgsMDQ4PEAAAACMAAAAlAAAAJwAAACkAAAArAAAALwAAADMAAAA7AAAAQwAAAFMAAABjAAAAgwAAAAMBAAADAgAAAwQAAAMIAAADEAAAAyAAAANAAAADgAAAAwABAC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3R3b3gtaGFzaC0yLjEuMC9zcmMveHhoYXNoNjQucnMAAACwehAAYQAAAFQAAAAfAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvcnV6c3RkLTAuOC4wL3NyYy9kZWNvZGluZy9kZWNvZGVidWZmZXIucnMAJHsQAGsAAAAaAAAAHgAAACR7EABrAAAAnQAAADQAAAAkexAAawAAAOoAAAAeAAAAUmF3UkxFQ29tcHJlc3NlZFJlc2VydmVyZAAAAAAAAAAEAAAABAAAAMoBAAAAAAAABAAAAAQAAADQAQAAYXNzZXJ0aW9uIGZhaWxlZDogeCA+IDAvVXNlcnMvZHlsYW4vLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tMTk0OWNmOGM2YjViNTU3Zi9ydXpzdGQtMC44LjAvc3JjL2h1ZmYwL2h1ZmYwX2RlY29kZXIucnMTfBAAaQAAADEAAAAFAAAAE3wQAGkAAAA+AAAAGgAAABN8EABpAAAAUAAAACkAAAATfBAAaQAAAGgAAAAWAAAAE3wQAGkAAABqAAAAEwAAABN8EABpAAAAawAAABgAAAATfBAAaQAAAGwAAAAbAAAAE3wQAGkAAAAdAQAANgAAABN8EABpAAAAHQEAACUAAAATfBAAaQAAAB8BAAA2AAAAE3wQAGkAAAAfAQAAJQAAABN8EABpAAAA6AAAACIAAAATfBAAaQAAAPIAAAAiAAAAE3wQAGkAAAD3AAAAJgAAABN8EABpAAAA7QAAACYAAAATfBAAaQAAAFcBAAASAAAAE3wQAGkAAABfAQAAGAAAABN8EABpAAAAZQEAABUAAAATfBAAaQAAAG8BAAAbAAAAE3wQAGkAAABxAQAAGgAAABN8EABpAAAAeAEAAB4AAAByYW5rX2lkeFswXTogIHNob3VsZCBiZTogAAAAzH0QAA0AAADZfRAADAAAABN8EABpAAAAdwEAAAkAAAATfBAAaQAAAH8BAAAsAAAAE3wQAGkAAACEAQAAMQAAABN8EABpAAAAiAEAACAAAAATfBAAaQAAAIkBAAAgAAAAE3wQAGkAAABzAQAARQAAABN8EABpAAAAdAEAACEAAAATfBAAaQAAAHMBAAAeAAAAE3wQAGkAAABhAQAAGwAAABN8EABpAAAATwEAACcAAAATfBAAaQAAAFQBAAAWAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc2xpY2UucnMAqH4QAGsAAACiAAAAGQAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3NsaWNlLnJzACR/EABrAAAAogAAABkAAABhc3NlcnRpb24gZmFpbGVkOiB4ID4gMC9Vc2Vycy9keWxhbi8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby0xOTQ5Y2Y4YzZiNWI1NTdmL3J1enN0ZC0wLjguMC9zcmMvZnNlL2ZzZV9kZWNvZGVyLnJzt38QAGUAAAA9AAAABQAAALd/EABlAAAAWgAAACcAAAC3fxAAZQAAAGUAAAAnAAAAt38QAGUAAABwAAAAIwAAALd/EABlAAAAcQAAAB0AAAC3fxAAZQAAAOIAAAApAAAAt38QAGUAAADkAAAAMQAAALd/EABlAAAA5gAAADMAAABhc3NlcnRpb24gZmFpbGVkOiBuYiA8PSBzZWxmLmFjY3VyYWN5X2xvZwAAALd/EABlAAAA6wAAAA0AAAC3fxAAZQAAANIAAAAtAAAAt38QAGUAAADAAAAALQAAALd/EABlAAAAOQEAAEEAAAC3fxAAZQAAAB4BAAAnAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHJvYiA9PSAtMbd/EABlAAAAJAEAABUAAAAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2FsbG9jL3NyYy92ZWMvbW9kLnJzAAAARIEQAG0AAAA9CgAAJAAAAAAAAAAQAAAABAAAANQBAADVAQAA1gEAACAgICA6IAAAAQAAAAAAAADggRAAAgAAACAgICAgICAvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL3B0ci9tb2QucnMA+4EQAGwAAAALAgAAAQAAAC9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvY29yZS9zcmMvc2xpY2UvaW5kZXgucnN4ghAAcAAAAEwDAAA0AAAAeIIQAHAAAABTAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9Vc2Vycy9keWxhbi8ucnVzdHVwL3Rvb2xjaGFpbnMvc3RhYmxlLWFhcmNoNjQtYXBwbGUtZGFyd2luL2xpYi9ydXN0bGliL3NyYy9ydXN0L2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAMoMQAGwAAAD7BwAAHQAAADKDEABsAAAAAwgAAB0AAAAygxAAbAAAAI0FAAAbAAAAL1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5ycwAAANCDEABtAAAAKgIAABEAAADXAQAADAAAAAQAAADYAQAA2QEAANoBAADdAQAADAAAAAQAAADeAQAA3wEAANoBAEGIicIAC4UJAQAAAOABAABhIERpc3BsYXkgaW1wbGVtZW50YXRpb24gcmV0dXJuZWQgYW4gZXJyb3IgdW5leHBlY3RlZGx5L1VzZXJzL2R5bGFuLy5ydXN0dXAvdG9vbGNoYWlucy9zdGFibGUtYWFyY2g2NC1hcHBsZS1kYXJ3aW4vbGliL3J1c3RsaWIvc3JjL3J1c3QvbGlicmFyeS9hbGxvYy9zcmMvc3RyaW5nLnJzAMeEEABsAAAA3woAAA4AAABFcnJvcgAAAMeEEABsAAAAjQUAABsAAABhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbinHhBAAbAAAAMAFAAANAAAAAAAAABAAAAAEAAAA1AEAANUBAADWAQAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvYW55aG93LTEuMC45OC9zcmMvZXJyb3IucnPMhRAAXAAAAGcEAAAOAAAAAQAAAAAAAAA6IAAAQIYQAAIAAAAKCkNhdXNlZCBieToKCgpzdGFjayBiYWNrdHJhY2U6U3RhY2sgYmFja3RyYWNlOgprhhAAEQAAAFMvVXNlcnMvZHlsYW4vLnJ1c3R1cC90b29sY2hhaW5zL3N0YWJsZS1hYXJjaDY0LWFwcGxlLWRhcndpbi9saWIvcnVzdGxpYi9zcmMvcnVzdC9saWJyYXJ5L2NvcmUvc3JjL2l0ZXIvdHJhaXRzL2l0ZXJhdG9yLnJzAACFhhAAeQAAALMHAAAJAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2YvanMtc3lzLTAuMy43Ny9zcmMvbGliLnJzAAAQhxAAWgAAAPsYAAABAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvd2FzbS1iaW5kZ2VuLTAuMi4xMDAvc3JjL2NvbnZlcnQvc2xpY2VzLnJzfIcQAGwAAAAkAQAADgAAAGNsb3N1cmUgaW52b2tlZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkSnNWYWx1ZSgpACqIEAAIAAAAMogQAAEAAABMYXp5IGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAESIEAAqAAAAL1VzZXJzL2R5bGFuLy5jYXJnby9yZWdpc3RyeS9zcmMvaW5kZXguY3JhdGVzLmlvLTE5NDljZjhjNmI1YjU1N2Yvb25jZV9jZWxsLTEuMjEuMy9zcmMvbGliLnJzAAAAeIgQAF0AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AADoiBAADgAAAHiIEABdAAAAegIAAA0AQZiSwgALlSMEAAAABAAAAPYBAAAvcnVzdGMvMDVmOTg0NmY4OTNiMDlhMWJlMWZjODU2MGUzM2ZjM2M4MTVjZmVjYi9saWJyYXJ5L2FsbG9jL3NyYy9zbGljZS5ycwAAJIkQAEoAAACiAAAAGQAAAC9ydXN0Yy8wNWY5ODQ2Zjg5M2IwOWExYmUxZmM4NTYwZTMzZmMzYzgxNWNmZWNiL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwCAiRAASwAAAI0FAAAbAAAAL3J1c3RjLzA1Zjk4NDZmODkzYjA5YTFiZTFmYzg1NjBlMzNmYzNjODE1Y2ZlY2IvbGlicmFyeS9hbGxvYy9zcmMvcmF3X3ZlYy5yc9yJEABMAAAAKgIAABEAAAA6AAAA9wEAAAwAAAAEAAAA+AEAAPkBAAD6AQAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNy9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAFSKEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAABUihAAKQAAAK4EAAANAAAAQWNjZXNzRXJyb3JjYW5ub3QgYWNjZXNzIGEgVGhyZWFkIExvY2FsIFN0b3JhZ2UgdmFsdWUgZHVyaW5nIG9yIGFmdGVyIGRlc3RydWN0aW9uOiAAB4sQAEgAAABsaWJyYXJ5L3N0ZC9zcmMvYmFja3RyYWNlLnJzb3BlcmF0aW9uIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybXSLEAAoAAAAJAAAAAIAAACcixAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAFiLEAAcAAAAigEAAB0AAAD7AQAAEAAAAAQAAAD8AQAA/QEAAAEAAAAAAAAAZW50aXR5IG5vdCBmb3VuZHBlcm1pc3Npb24gZGVuaWVkY29ubmVjdGlvbiByZWZ1c2VkY29ubmVjdGlvbiByZXNldGhvc3QgdW5yZWFjaGFibGVuZXR3b3JrIHVucmVhY2hhYmxlY29ubmVjdGlvbiBhYm9ydGVkbm90IGNvbm5lY3RlZGFkZHJlc3MgaW4gdXNlYWRkcmVzcyBub3QgYXZhaWxhYmxlbmV0d29yayBkb3duYnJva2VuIHBpcGVlbnRpdHkgYWxyZWFkeSBleGlzdHNvcGVyYXRpb24gd291bGQgYmxvY2tub3QgYSBkaXJlY3RvcnlpcyBhIGRpcmVjdG9yeWRpcmVjdG9yeSBub3QgZW1wdHlyZWFkLW9ubHkgZmlsZXN5c3RlbSBvciBzdG9yYWdlIG1lZGl1bWZpbGVzeXN0ZW0gbG9vcCBvciBpbmRpcmVjdGlvbiBsaW1pdCAoZS5nLiBzeW1saW5rIGxvb3Apc3RhbGUgbmV0d29yayBmaWxlIGhhbmRsZWludmFsaWQgaW5wdXQgcGFyYW1ldGVyaW52YWxpZCBkYXRhdGltZWQgb3V0d3JpdGUgemVyb25vIHN0b3JhZ2Ugc3BhY2VzZWVrIG9uIHVuc2Vla2FibGUgZmlsZXF1b3RhIGV4Y2VlZGVkZmlsZSB0b28gbGFyZ2VyZXNvdXJjZSBidXN5ZXhlY3V0YWJsZSBmaWxlIGJ1c3lkZWFkbG9ja2Nyb3NzLWRldmljZSBsaW5rIG9yIHJlbmFtZXRvbyBtYW55IGxpbmtzaW52YWxpZCBmaWxlbmFtZWFyZ3VtZW50IGxpc3QgdG9vIGxvbmdvcGVyYXRpb24gaW50ZXJydXB0ZWR1bnN1cHBvcnRlZHVuZXhwZWN0ZWQgZW5kIG9mIGZpbGVvdXQgb2YgbWVtb3J5aW4gcHJvZ3Jlc3NvdGhlciBlcnJvcnVuY2F0ZWdvcml6ZWQgZXJyb3JPcwAAAAAABAAAAAQAAAD+AQAAY29kZQAAAAABAAAAAQAAAP8BAABraW5k9wEAAAwAAAAEAAAAAAIAAG1lc3NhZ2VLaW5kRXJyb3IAAAAACAAAAAQAAAABAgAAAAAAAAQAAAAEAAAAAgIAAEN1c3RvbWVycm9yIChvcyBlcnJvciApAAEAAAAAAAAAZ48QAAsAAAByjxAAAQAAADogY2Fubm90IHJlY3Vyc2l2ZWx5IGFjcXVpcmUgbXV0ZXgAAI6PEAAgAAAAbGlicmFyeS9zdGQvc3JjL3N5cy9zeW5jL211dGV4L25vX3RocmVhZHMucnO4jxAALAAAABMAAAAJAAAAbGlicmFyeS9zdGQvc3JjL3N5bmMvcG9pc29uL29uY2UucnMA9I8QACMAAACbAAAAMgAAAGxpYnJhcnkvc3RkL3NyYy9zeW5jL2xhenlfbG9jay5ycwAAACiQEAAhAAAA0QAAABMAAAA8dW5rbm93bj7vv71tZW1vcnkgYWxsb2NhdGlvbiBvZiAgYnl0ZXMgZmFpbGVkAABokBAAFQAAAH2QEAANAAAAbGlicmFyeS9zdGQvc3JjL2FsbG9jLnJznJAQABgAAABjAQAACQAAAAoAAAD3AQAADAAAAAQAAAADAgAAAAAAAAgAAAAEAAAABAIAAAAAAAAIAAAABAAAAAUCAAAGAgAABwIAAAgCAAAJAgAAEAAAAAQAAAAKAgAACwIAAAwCAAANAgAAbGlicmFyeS9zdGQvc3JjLy4uLy4uL2JhY2t0cmFjZS9zcmMvc3ltYm9saXplL21vZC5ycyCREAA0AAAAZwEAADAAAAABAAAAAAAAAIyPEAACAAAAIC0gAAEAAAAAAAAAdJEQAAMAAAAgICAgICAgICAgICAgICAgICAgYXQgAAA4ihAAAQAAAE5vdEZvdW5kUGVybWlzc2lvbkRlbmllZENvbm5lY3Rpb25SZWZ1c2VkQ29ubmVjdGlvblJlc2V0SG9zdFVucmVhY2hhYmxlTmV0d29ya1VucmVhY2hhYmxlQ29ubmVjdGlvbkFib3J0ZWROb3RDb25uZWN0ZWRBZGRySW5Vc2VBZGRyTm90QXZhaWxhYmxlTmV0d29ya0Rvd25Ccm9rZW5QaXBlQWxyZWFkeUV4aXN0c1dvdWxkQmxvY2tOb3RBRGlyZWN0b3J5SXNBRGlyZWN0b3J5RGlyZWN0b3J5Tm90RW1wdHlSZWFkT25seUZpbGVzeXN0ZW1GaWxlc3lzdGVtTG9vcFN0YWxlTmV0d29ya0ZpbGVIYW5kbGVJbnZhbGlkSW5wdXRJbnZhbGlkRGF0YVRpbWVkT3V0V3JpdGVaZXJvU3RvcmFnZUZ1bGxOb3RTZWVrYWJsZVF1b3RhRXhjZWVkZWRGaWxlVG9vTGFyZ2VSZXNvdXJjZUJ1c3lFeGVjdXRhYmxlRmlsZUJ1c3lEZWFkbG9ja0Nyb3NzZXNEZXZpY2VzVG9vTWFueUxpbmtzSW52YWxpZEZpbGVuYW1lQXJndW1lbnRMaXN0VG9vTG9uZ0ludGVycnVwdGVkVW5zdXBwb3J0ZWRVbmV4cGVjdGVkRW9mT3V0T2ZNZW1vcnlJblByb2dyZXNzT3RoZXJVbmNhdGVnb3JpemVkb3BlcmF0aW9uIHN1Y2Nlc3NmdWxPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWTakxAAKgAAAG9uZS10aW1lIGluaXRpYWxpemF0aW9uIG1heSBub3QgYmUgcGVyZm9ybWVkIHJlY3Vyc2l2ZWx5DJQQADgAAAAQAAAAEQAA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",self.location.href));const A=BI();(typeof g=="string"||typeof Request=="function"&&g instanceof Request||typeof URL=="function"&&g instanceof URL)&&(g=fetch(g));const{instance:Q,module:I}=await II(await g,A);return gI(Q,I)}const GA=-9,JA=(9-GA)/254,zA=Math.exp(GA),CI=11,EI=11,YQ=1<<CI,eQ=1<<EI,iI=1,UQ=!0,lA=class lA{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const Q=new ReadableStream({start:E=>{E.enqueue(this.fileBytes.slice(0,65536)),E.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const I=`end_header\n`;for(;;){const{value:E,done:i}=await Q.read();if(i)throw new Error("Failed to read header");this.header+=E;const D=this.header.indexOf(I);if(D>=0){this.header=this.header.slice(0,D+I.length);break}}const B=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,B),this.elements={};let C=null;this.comments=[],this.header.trim().split(`\n`).forEach((E,i)=>{const D=E.trim();if(i===0){if(D!=="ply")throw new Error("Invalid PLY header");return}if(D.length===0)return;const w=D.split(" ");switch(w[0]){case"format":if(w[1]==="binary_little_endian")this.littleEndian=!0;else if(w[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${w[1]}`);if(w[2]!=="1.0")throw new Error(`Unsupported PLY version: ${w[2]}`);break;case"end_header":break;case"comment":this.comments.push(D.slice(8));break;case"element":{const o=w[1];C={name:o,count:Number.parseInt(w[2]),properties:{}},this.elements[o]=C;break}case"property":if(C==null)throw new Error("Property must be inside an element");w[1]==="list"?C.properties[w[4]]={isList:!0,type:w[3],countType:w[2]}:C.properties[w[2]]={isList:!1,type:w[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let Q=0;const I=this.data;if(I==null)throw new Error("No data to parse");for(const B in this.elements){const C=this.elements[B],{count:E,properties:i}=C,D={},w=[];for(const[s,a]of Object.entries(i))a.isList?(D[s]=[],w.push(()=>{const t=D[s];t.length=mA[a.countType](I,Q,this.littleEndian),Q+=RA[a.countType];for(let c=0;c<t.length;c++)t[c]=mA[a.type](I,Q,this.littleEndian),Q+=RA[a.type]})):(D[s]=0,w.push(()=>{D[s]=mA[a.type](I,Q,this.littleEndian),Q+=RA[a.type]}));const o=A(C)??(()=>{});for(let s=0;s<E;s++){for(const a of w)a();o(s,D)}}}parseSplats(A,Q){if(this.elements.vertex==null)throw new Error("No vertex element found");let I=!1;const B=[];let C=0,E=[],i=[],D=[],w,o,s;function a(){const M=wI[C];E=new Array(3).fill(null).flatMap((J,G)=>[0,1,2].map((h,F)=>`f_rest_${G+F*M/3}`)),i=new Array(5).fill(null).flatMap((J,G)=>[0,1,2].map((h,F)=>`f_rest_${3+G+F*M/3}`)),D=new Array(7).fill(null).flatMap((J,G)=>[0,1,2].map((h,F)=>`f_rest_${8+G+F*M/3}`)),w=C>=1?new Float32Array(3*3):void 0,o=C>=2?new Float32Array(5*3):void 0,s=C>=3?new Float32Array(7*3):void 0}function t(M,J){if(!w)throw new Error("Missing sh1");for(const[G,h]of E.entries())w[G]=J[h]*8/255-4;if(o)for(const[G,h]of i.entries())o[G]=J[h]*8/255-4;if(s)for(const[G,h]of D.entries())s[G]=J[h]*8/255-4;Q==null||Q(M,w,o,s)}function c(M){const{min_x:J,min_y:G,min_z:h,max_x:F,max_y:U,max_z:K,min_scale_x:T,min_scale_y:W,min_scale_z:X,max_scale_x:Y,max_scale_y:$,max_scale_z:AA,min_r:m,min_g:j,min_b:b,max_r:p,max_g:O,max_b:H}=M.properties;if(!J||!G||!h||!F||!U||!K||!T||!W||!X||!Y||!$||!AA||!m||!j||!b||!p||!O||!H)throw new Error("Missing PLY chunk properties");return I=!0,(oA,QA)=>{const{min_x:q,min_y:r,min_z:z,max_x:f,max_y:V,max_z:R,min_scale_x:IA,min_scale_y:v,min_scale_z:sA,max_scale_x:P,max_scale_y:BA,max_scale_z:gA,min_r:cA,min_g:CA,min_b:aA,max_r:tA,max_g:N,max_b:d}=QA;B.push({min_x:q,min_y:r,min_z:z,max_x:f,max_y:V,max_z:R,min_scale_x:IA,min_scale_y:v,min_scale_z:sA,max_scale_x:P,max_scale_y:BA,max_scale_z:gA,min_r:cA,min_g:CA,min_b:aA,max_r:tA,max_g:N,max_b:d})}}function y(M){if(Q&&M.name==="sh")return C=lQ(M.properties),a(),t;if(M.name!=="vertex")return null;const{packed_position:J,packed_rotation:G,packed_scale:h,packed_color:F}=M.properties;if(!J||!G||!h||!F)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const U=Math.sqrt(2);return(K,T)=>{const W=B[K>>>8];if(W==null)throw new Error("Missing PLY chunk");const{min_x:X,min_y:Y,min_z:$,max_x:AA,max_y:m,max_z:j,min_scale_x:b,min_scale_y:p,min_scale_z:O,max_scale_x:H,max_scale_y:oA,max_scale_z:QA,min_r:q,min_g:r,min_b:z,max_r:f,max_g:V,max_b:R}=W,{packed_position:IA,packed_rotation:v,packed_scale:sA,packed_color:P}=T,BA=(IA>>>21&2047)/2047*(AA-X)+X,gA=(IA>>>11&1023)/1023*(m-Y)+Y,cA=(IA&2047)/2047*(j-$)+$,CA=((v>>>20&1023)/1023-.5)*U,aA=((v>>>10&1023)/1023-.5)*U,tA=((v&1023)/1023-.5)*U,N=Math.sqrt(Math.max(0,1-CA*CA-aA*aA-tA*tA)),d=v>>>30,L=d===0?CA:d===1?N:aA,k=d<=1?aA:d===2?N:tA,kA=d<=2?tA:N,tQ=d===0?N:CA,cQ=Math.exp((sA>>>21&2047)/2047*(H-b)+b),GQ=Math.exp((sA>>>11&1023)/1023*(oA-p)+p),hQ=Math.exp((sA&2047)/2047*(QA-O)+O),yQ=(P>>>24&255)/255*(f-q)+q,MQ=(P>>>16&255)/255*(V-r)+r,NQ=(P>>>8&255)/255*(R-z)+z,FQ=(P&255)/255;A(K,BA,gA,cA,cQ,GQ,hQ,L,k,kA,tQ,FQ,yQ,MQ,NQ)}}const n=M=>{if(M.name==="chunk"&&this.comments.some(V=>V.toLowerCase().includes("supersplat")))return c(M);if(I)return y(M);if(M.name!=="vertex")return null;const{x:J,y:G,z:h,scale_0:F,scale_1:U,scale_2:K,rot_0:T,rot_1:W,rot_2:X,rot_3:Y,opacity:$,f_dc_0:AA,f_dc_1:m,f_dc_2:j,red:b,green:p,blue:O,alpha:H}=M.properties;if(!J||!G||!h)throw new Error("Missing PLY properties: x, y, z");const oA=F&&U&&K,QA=T&&W&&X&&Y,q=H!=null?pA[H.type]:1,r=b!=null?pA[b.type]:1,z=p!=null?pA[p.type]:1,f=O!=null?pA[O.type]:1;return C=lQ(M.properties),a(),(V,R)=>{const IA=oA?Math.exp(R.scale_0):lA.defaultPointScale,v=oA?Math.exp(R.scale_1):lA.defaultPointScale,sA=oA?Math.exp(R.scale_2):lA.defaultPointScale,P=QA?R.rot_1:0,BA=QA?R.rot_2:0,gA=QA?R.rot_3:0,cA=QA?R.rot_0:1,CA=$!=null?1/(1+Math.exp(-R.opacity)):H!=null?R.alpha/q:1,aA=AA!=null?R.f_dc_0*WA+.5:b!=null?R.red/r:1,tA=m!=null?R.f_dc_1*WA+.5:p!=null?R.green/z:1,N=j!=null?R.f_dc_2*WA+.5:O!=null?R.blue/f:1;if(A(V,R.x,R.y,R.z,IA,v,sA,P,BA,gA,cA,CA,aA,tA,N),Q&&w){if(w)for(const[d,L]of E.entries())w[d]=R[L];if(o)for(const[d,L]of i.entries())o[d]=R[L];if(s)for(const[d,L]of D.entries())s[d]=R[L];Q(V,w,o,s)}}};this.parseData(n)}injectRgba(A){let Q=0;const I=this.data;if(I==null)throw new Error("No parsed data");if(A.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const B in this.elements){const C=this.elements[B],{count:E,properties:i}=C,D=[];let w=0;const o=B==="vertex";if(o){for(const s of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!i[s]||i[s].type!=="float")throw new Error(`Can\'t injectRgba due to property: ${s}`)}for(const[s,a]of Object.entries(i))if(a.isList)D.push(()=>{const t=mA[a.countType](I,Q,this.littleEndian);Q+=RA[a.countType],Q+=t*RA[a.type]});else{if(o)if(s==="f_dc_0"||s==="f_dc_1"||s==="f_dc_2"){const t=Number.parseInt(s.slice(5));D.push(()=>{const c=(A[w+t]/255-.5)/WA;rQ[a.type](I,Q,this.littleEndian,c)})}else s==="opacity"&&D.push(()=>{const t=Math.max(-100,Math.min(100,-Math.log(1/(A[w+3]/255)-1)));rQ[a.type](I,Q,this.littleEndian,t)});D.push(()=>{Q+=RA[a.type]})}for(let s=0;s<E;s++){for(const a of D)a();o&&(w+=4)}}}};lA.defaultPointScale=.001;let TA=lA;const WA=.28209479177387814,mA={char:(g,A,Q)=>g.getInt8(A),uchar:(g,A,Q)=>g.getUint8(A),short:(g,A,Q)=>g.getInt16(A,Q),ushort:(g,A,Q)=>g.getUint16(A,Q),int:(g,A,Q)=>g.getInt32(A,Q),uint:(g,A,Q)=>g.getUint32(A,Q),float:(g,A,Q)=>g.getFloat32(A,Q),double:(g,A,Q)=>g.getFloat64(A,Q)},rQ={char:(g,A,Q,I)=>{g.setInt8(A,I)},uchar:(g,A,Q,I)=>{g.setUint8(A,I)},short:(g,A,Q,I)=>{g.setInt16(A,I,Q)},ushort:(g,A,Q,I)=>{g.setUint16(A,I,Q)},int:(g,A,Q,I)=>{g.setInt32(A,I,Q)},uint:(g,A,Q,I)=>{g.setUint32(A,I,Q)},float:(g,A,Q,I)=>{g.setFloat32(A,I,Q)},double:(g,A,Q,I)=>{g.setFloat64(A,I,Q)}},RA={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},pA={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},DI={0:0,9:1,24:2,45:3},wI={0:0,1:9,2:24,3:45};function lQ(g){let A=0;for(;g[`f_rest_${A}`];)A+=1;const Q=DI[A];if(Q==null)throw new Error(`Unsupported number of SH coefficients: ${A}`);return Q}var Z=Uint8Array,nA=Uint16Array,sI=Int32Array,LQ=new Z([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),SQ=new Z([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),oI=new Z([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),HQ=function(g,A){for(var Q=new nA(31),I=0;I<31;++I)Q[I]=A+=1<<g[I-1];for(var B=new sI(Q[30]),I=1;I<30;++I)for(var C=Q[I];C<Q[I+1];++C)B[C]=C-Q[I]<<5|I;return{b:Q,r:B}},dQ=HQ(LQ,2),ZQ=dQ.b,aI=dQ.r;ZQ[28]=258,aI[258]=28;for(var tI=HQ(SQ,0),cI=tI.b,OA=new nA(32768),e=0;e<32768;++e){var hA=(e&43690)>>1|(e&21845)<<1;hA=(hA&52428)>>2|(hA&13107)<<2,hA=(hA&61680)>>4|(hA&3855)<<4,OA[e]=((hA&65280)>>8|(hA&255)<<8)>>1}for(var SA=function(g,A,Q){for(var I=g.length,B=0,C=new nA(A);B<I;++B)g[B]&&++C[g[B]-1];var E=new nA(A);for(B=1;B<A;++B)E[B]=E[B-1]+C[B-1]<<1;var i;if(Q){i=new nA(1<<A);var D=15-A;for(B=0;B<I;++B)if(g[B])for(var w=B<<4|g[B],o=A-g[B],s=E[g[B]-1]++<<o,a=s|(1<<o)-1;s<=a;++s)i[OA[s]>>D]=w}else for(i=new nA(I),B=0;B<I;++B)g[B]&&(i[B]=OA[E[g[B]-1]++]>>15-g[B]);return i},HA=new Z(288),e=0;e<144;++e)HA[e]=8;for(var e=144;e<256;++e)HA[e]=9;for(var e=256;e<280;++e)HA[e]=7;for(var e=280;e<288;++e)HA[e]=8;for(var KQ=new Z(32),e=0;e<32;++e)KQ[e]=5;var GI=SA(HA,9,1),hI=SA(KQ,5,1),vA=function(g){for(var A=g[0],Q=1;Q<g.length;++Q)g[Q]>A&&(A=g[Q]);return A},EA=function(g,A,Q){var I=A/8|0;return(g[I]|g[I+1]<<8)>>(A&7)&Q},PA=function(g,A){var Q=A/8|0;return(g[Q]|g[Q+1]<<8|g[Q+2]<<16)>>(A&7)},bQ=function(g){return(g+7)/8|0},fA=function(g,A,Q){return(A==null||A<0)&&(A=0),(Q==null||Q>g.length)&&(Q=g.length),new Z(g.subarray(A,Q))},yI=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],_=function(g,A,Q){var I=new Error(A||yI[g]);if(I.code=g,Error.captureStackTrace&&Error.captureStackTrace(I,_),!Q)throw I;return I},MI=function(g,A,Q,I){var B=g.length,C=0;if(!B||A.f&&!A.l)return Q||new Z(0);var E=!Q,i=E||A.i!=2,D=A.i;E&&(Q=new Z(B*3));var w=function(P){var BA=Q.length;if(P>BA){var gA=new Z(Math.max(BA*2,P));gA.set(Q),Q=gA}},o=A.f||0,s=A.p||0,a=A.b||0,t=A.l,c=A.d,y=A.m,n=A.n,M=B*8;do{if(!t){o=EA(g,s,1);var J=EA(g,s+1,3);if(s+=3,J)if(J==1)t=GI,c=hI,y=9,n=5;else if(J==2){var U=EA(g,s,31)+257,K=EA(g,s+10,15)+4,T=U+EA(g,s+5,31)+1;s+=14;for(var W=new Z(T),X=new Z(19),Y=0;Y<K;++Y)X[oI[Y]]=EA(g,s+Y*3,7);s+=K*3;for(var $=vA(X),AA=(1<<$)-1,m=SA(X,$,1),Y=0;Y<T;){var j=m[EA(g,s,AA)];s+=j&15;var G=j>>4;if(G<16)W[Y++]=G;else{var b=0,p=0;for(G==16?(p=3+EA(g,s,3),s+=2,b=W[Y-1]):G==17?(p=3+EA(g,s,7),s+=3):G==18&&(p=11+EA(g,s,127),s+=7);p--;)W[Y++]=b}}var O=W.subarray(0,U),H=W.subarray(U);y=vA(O),n=vA(H),t=SA(O,y,1),c=SA(H,n,1)}else _(1);else{var G=bQ(s)+4,h=g[G-4]|g[G-3]<<8,F=G+h;if(F>B){D&&_(0);break}i&&w(a+h),Q.set(g.subarray(G,F),a),A.b=a+=h,A.p=s=F*8,A.f=o;continue}if(s>M){D&&_(0);break}}i&&w(a+131072);for(var oA=(1<<y)-1,QA=(1<<n)-1,q=s;;q=s){var b=t[PA(g,s)&oA],r=b>>4;if(s+=b&15,s>M){D&&_(0);break}if(b||_(2),r<256)Q[a++]=r;else if(r==256){q=s,t=null;break}else{var z=r-254;if(r>264){var Y=r-257,f=LQ[Y];z=EA(g,s,(1<<f)-1)+ZQ[Y],s+=f}var V=c[PA(g,s)&QA],R=V>>4;V||_(3),s+=V&15;var H=cI[R];if(R>3){var f=SQ[R];H+=PA(g,s)&(1<<f)-1,s+=f}if(s>M){D&&_(0);break}i&&w(a+131072);var IA=a+z;if(a<H){var v=C-H,sA=Math.min(H,IA);for(v+a<0&&_(3);a<sA;++a)Q[a]=I[v+a]}for(;a<IA;++a)Q[a]=Q[a-H]}}A.l=t,A.p=q,A.b=a,A.f=o,t&&(o=1,A.m=y,A.d=c,A.n=n)}while(!o);return a!=Q.length&&E?fA(Q,0,a):Q.subarray(0,a)},NI=new Z(0),FI=function(g){(g[0]!=31||g[1]!=139||g[2]!=8)&&_(6,"invalid gzip data");var A=g[3],Q=10;A&4&&(Q+=(g[10]|g[11]<<8)+2);for(var I=(A>>3&1)+(A>>4&1);I>0;I-=!g[Q++]);return Q+(A&2)},_A=function(){function g(A,Q){typeof A=="function"&&(Q=A,A={}),this.ondata=Q;var I=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:I?I.length:0},this.o=new Z(32768),this.p=new Z(0),I&&this.o.set(I)}return g.prototype.e=function(A){if(this.ondata||_(5),this.d&&_(4),!this.p.length)this.p=A;else if(A.length){var Q=new Z(this.p.length+A.length);Q.set(this.p),Q.set(A,this.p.length),this.p=Q}},g.prototype.c=function(A){this.s.i=+(this.d=A||!1);var Q=this.s.b,I=MI(this.p,this.s,this.o);this.ondata(fA(I,Q,this.s.b),this.d),this.o=fA(I,this.s.b-32768),this.s.b=this.o.length,this.p=fA(this.p,this.s.p/8|0),this.s.p&=7},g.prototype.push=function(A,Q){this.e(A),this.c(Q)},g}(),kI=function(){function g(A,Q){this.v=1,this.r=0,_A.call(this,A,Q)}return g.prototype.push=function(A,Q){if(_A.prototype.e.call(this,A),this.r+=A.length,this.v){var I=this.p.subarray(this.v-1),B=I.length>3?FI(I):4;if(B>I.length){if(!Q)return}else this.v>1&&this.onmember&&this.onmember(this.r-I.length);this.p=I.subarray(B),this.v=0}_A.prototype.c.call(this,Q),this.s.f&&!this.s.l&&!Q&&(this.v=bQ(this.s.p)+9,this.s={i:0},this.o=new Z(0),this.push(new Z(0),Q))},g}(),JI=typeof TextDecoder<"u"&&new TextDecoder,RI=0;try{JI.decode(NI,{stream:!0}),RI=1}catch{}/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */const qQ="172",nI="",iA="srgb",xQ="srgb-linear",WQ="linear",$A="srgb";function u(g,A,Q){return Math.max(A,Math.min(Q,g))}function YI(g,A){return(g%A+A)%A}function AQ(g,A,Q){return(1-Q)*g+Q*A}class dA{constructor(A,Q,I,B,C,E,i,D,w){dA.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],A!==void 0&&this.set(A,Q,I,B,C,E,i,D,w)}set(A,Q,I,B,C,E,i,D,w){const o=this.elements;return o[0]=A,o[1]=B,o[2]=i,o[3]=Q,o[4]=C,o[5]=D,o[6]=I,o[7]=E,o[8]=w,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const Q=this.elements,I=A.elements;return Q[0]=I[0],Q[1]=I[1],Q[2]=I[2],Q[3]=I[3],Q[4]=I[4],Q[5]=I[5],Q[6]=I[6],Q[7]=I[7],Q[8]=I[8],this}extractBasis(A,Q,I){return A.setFromMatrix3Column(this,0),Q.setFromMatrix3Column(this,1),I.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const Q=A.elements;return this.set(Q[0],Q[4],Q[8],Q[1],Q[5],Q[9],Q[2],Q[6],Q[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,Q){const I=A.elements,B=Q.elements,C=this.elements,E=I[0],i=I[3],D=I[6],w=I[1],o=I[4],s=I[7],a=I[2],t=I[5],c=I[8],y=B[0],n=B[3],M=B[6],J=B[1],G=B[4],h=B[7],F=B[2],U=B[5],K=B[8];return C[0]=E*y+i*J+D*F,C[3]=E*n+i*G+D*U,C[6]=E*M+i*h+D*K,C[1]=w*y+o*J+s*F,C[4]=w*n+o*G+s*U,C[7]=w*M+o*h+s*K,C[2]=a*y+t*J+c*F,C[5]=a*n+t*G+c*U,C[8]=a*M+t*h+c*K,this}multiplyScalar(A){const Q=this.elements;return Q[0]*=A,Q[3]*=A,Q[6]*=A,Q[1]*=A,Q[4]*=A,Q[7]*=A,Q[2]*=A,Q[5]*=A,Q[8]*=A,this}determinant(){const A=this.elements,Q=A[0],I=A[1],B=A[2],C=A[3],E=A[4],i=A[5],D=A[6],w=A[7],o=A[8];return Q*E*o-Q*i*w-I*C*o+I*i*D+B*C*w-B*E*D}invert(){const A=this.elements,Q=A[0],I=A[1],B=A[2],C=A[3],E=A[4],i=A[5],D=A[6],w=A[7],o=A[8],s=o*E-i*w,a=i*D-o*C,t=w*C-E*D,c=Q*s+I*a+B*t;if(c===0)return this.set(0,0,0,0,0,0,0,0,0);const y=1/c;return A[0]=s*y,A[1]=(B*w-o*I)*y,A[2]=(i*I-B*E)*y,A[3]=a*y,A[4]=(o*Q-B*D)*y,A[5]=(B*C-i*Q)*y,A[6]=t*y,A[7]=(I*D-w*Q)*y,A[8]=(E*Q-I*C)*y,this}transpose(){let A;const Q=this.elements;return A=Q[1],Q[1]=Q[3],Q[3]=A,A=Q[2],Q[2]=Q[6],Q[6]=A,A=Q[5],Q[5]=Q[7],Q[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const Q=this.elements;return A[0]=Q[0],A[1]=Q[3],A[2]=Q[6],A[3]=Q[1],A[4]=Q[4],A[5]=Q[7],A[6]=Q[2],A[7]=Q[5],A[8]=Q[8],this}setUvTransform(A,Q,I,B,C,E,i){const D=Math.cos(C),w=Math.sin(C);return this.set(I*D,I*w,-I*(D*E+w*i)+E+A,-B*w,B*D,-B*(-w*E+D*i)+i+Q,0,0,1),this}scale(A,Q){return this.premultiply(QQ.makeScale(A,Q)),this}rotate(A){return this.premultiply(QQ.makeRotation(-A)),this}translate(A,Q){return this.premultiply(QQ.makeTranslation(A,Q)),this}makeTranslation(A,Q){return A.isVector2?this.set(1,0,A.x,0,1,A.y,0,0,1):this.set(1,0,A,0,1,Q,0,0,1),this}makeRotation(A){const Q=Math.cos(A),I=Math.sin(A);return this.set(Q,-I,0,I,Q,0,0,0,1),this}makeScale(A,Q){return this.set(A,0,0,0,Q,0,0,0,1),this}equals(A){const Q=this.elements,I=A.elements;for(let B=0;B<9;B++)if(Q[B]!==I[B])return!1;return!0}fromArray(A,Q=0){for(let I=0;I<9;I++)this.elements[I]=A[I+Q];return this}toArray(A=[],Q=0){const I=this.elements;return A[Q]=I[0],A[Q+1]=I[1],A[Q+2]=I[2],A[Q+3]=I[3],A[Q+4]=I[4],A[Q+5]=I[5],A[Q+6]=I[6],A[Q+7]=I[7],A[Q+8]=I[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const QQ=new dA,mQ=new dA().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),pQ=new dA().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function eI(){const g={enabled:!0,workingColorSpace:xQ,spaces:{},convert:function(B,C,E){return this.enabled===!1||C===E||!C||!E||(this.spaces[C].transfer===$A&&(B.r=YA(B.r),B.g=YA(B.g),B.b=YA(B.b)),this.spaces[C].primaries!==this.spaces[E].primaries&&(B.applyMatrix3(this.spaces[C].toXYZ),B.applyMatrix3(this.spaces[E].fromXYZ)),this.spaces[E].transfer===$A&&(B.r=eA(B.r),B.g=eA(B.g),B.b=eA(B.b))),B},fromWorkingColorSpace:function(B,C){return this.convert(B,this.workingColorSpace,C)},toWorkingColorSpace:function(B,C){return this.convert(B,C,this.workingColorSpace)},getPrimaries:function(B){return this.spaces[B].primaries},getTransfer:function(B){return B===nI?WQ:this.spaces[B].transfer},getLuminanceCoefficients:function(B,C=this.workingColorSpace){return B.fromArray(this.spaces[C].luminanceCoefficients)},define:function(B){Object.assign(this.spaces,B)},_getMatrix:function(B,C,E){return B.copy(this.spaces[C].toXYZ).multiply(this.spaces[E].fromXYZ)},_getDrawingBufferColorSpace:function(B){return this.spaces[B].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(B=this.workingColorSpace){return this.spaces[B].workingColorSpaceConfig.unpackColorSpace}},A=[.64,.33,.3,.6,.15,.06],Q=[.2126,.7152,.0722],I=[.3127,.329];return g.define({[xQ]:{primaries:A,whitePoint:I,transfer:WQ,toXYZ:mQ,fromXYZ:pQ,luminanceCoefficients:Q,workingColorSpaceConfig:{unpackColorSpace:iA},outputColorSpaceConfig:{drawingBufferColorSpace:iA}},[iA]:{primaries:A,whitePoint:I,transfer:$A,toXYZ:mQ,fromXYZ:pQ,luminanceCoefficients:Q,outputColorSpaceConfig:{drawingBufferColorSpace:iA}}}),g}const DA=eI();function YA(g){return g<.04045?g*.0773993808:Math.pow(g*.9478672986+.0521327014,2.4)}function eA(g){return g<.0031308?g*12.92:1.055*Math.pow(g,.41666)-.055}class IQ{constructor(A=0,Q=0,I=0,B=1){this.isQuaternion=!0,this._x=A,this._y=Q,this._z=I,this._w=B}static slerpFlat(A,Q,I,B,C,E,i){let D=I[B+0],w=I[B+1],o=I[B+2],s=I[B+3];const a=C[E+0],t=C[E+1],c=C[E+2],y=C[E+3];if(i===0){A[Q+0]=D,A[Q+1]=w,A[Q+2]=o,A[Q+3]=s;return}if(i===1){A[Q+0]=a,A[Q+1]=t,A[Q+2]=c,A[Q+3]=y;return}if(s!==y||D!==a||w!==t||o!==c){let n=1-i;const M=D*a+w*t+o*c+s*y,J=M>=0?1:-1,G=1-M*M;if(G>Number.EPSILON){const F=Math.sqrt(G),U=Math.atan2(F,M*J);n=Math.sin(n*U)/F,i=Math.sin(i*U)/F}const h=i*J;if(D=D*n+a*h,w=w*n+t*h,o=o*n+c*h,s=s*n+y*h,n===1-i){const F=1/Math.sqrt(D*D+w*w+o*o+s*s);D*=F,w*=F,o*=F,s*=F}}A[Q]=D,A[Q+1]=w,A[Q+2]=o,A[Q+3]=s}static multiplyQuaternionsFlat(A,Q,I,B,C,E){const i=I[B],D=I[B+1],w=I[B+2],o=I[B+3],s=C[E],a=C[E+1],t=C[E+2],c=C[E+3];return A[Q]=i*c+o*s+D*t-w*a,A[Q+1]=D*c+o*a+w*s-i*t,A[Q+2]=w*c+o*t+i*a-D*s,A[Q+3]=o*c-i*s-D*a-w*t,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,Q,I,B){return this._x=A,this._y=Q,this._z=I,this._w=B,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,Q=!0){const I=A._x,B=A._y,C=A._z,E=A._order,i=Math.cos,D=Math.sin,w=i(I/2),o=i(B/2),s=i(C/2),a=D(I/2),t=D(B/2),c=D(C/2);switch(E){case"XYZ":this._x=a*o*s+w*t*c,this._y=w*t*s-a*o*c,this._z=w*o*c+a*t*s,this._w=w*o*s-a*t*c;break;case"YXZ":this._x=a*o*s+w*t*c,this._y=w*t*s-a*o*c,this._z=w*o*c-a*t*s,this._w=w*o*s+a*t*c;break;case"ZXY":this._x=a*o*s-w*t*c,this._y=w*t*s+a*o*c,this._z=w*o*c+a*t*s,this._w=w*o*s-a*t*c;break;case"ZYX":this._x=a*o*s-w*t*c,this._y=w*t*s+a*o*c,this._z=w*o*c-a*t*s,this._w=w*o*s+a*t*c;break;case"YZX":this._x=a*o*s+w*t*c,this._y=w*t*s+a*o*c,this._z=w*o*c-a*t*s,this._w=w*o*s-a*t*c;break;case"XZY":this._x=a*o*s-w*t*c,this._y=w*t*s-a*o*c,this._z=w*o*c+a*t*s,this._w=w*o*s+a*t*c;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+E)}return Q===!0&&this._onChangeCallback(),this}setFromAxisAngle(A,Q){const I=Q/2,B=Math.sin(I);return this._x=A.x*B,this._y=A.y*B,this._z=A.z*B,this._w=Math.cos(I),this._onChangeCallback(),this}setFromRotationMatrix(A){const Q=A.elements,I=Q[0],B=Q[4],C=Q[8],E=Q[1],i=Q[5],D=Q[9],w=Q[2],o=Q[6],s=Q[10],a=I+i+s;if(a>0){const t=.5/Math.sqrt(a+1);this._w=.25/t,this._x=(o-D)*t,this._y=(C-w)*t,this._z=(E-B)*t}else if(I>i&&I>s){const t=2*Math.sqrt(1+I-i-s);this._w=(o-D)/t,this._x=.25*t,this._y=(B+E)/t,this._z=(C+w)/t}else if(i>s){const t=2*Math.sqrt(1+i-I-s);this._w=(C-w)/t,this._x=(B+E)/t,this._y=.25*t,this._z=(D+o)/t}else{const t=2*Math.sqrt(1+s-I-i);this._w=(E-B)/t,this._x=(C+w)/t,this._y=(D+o)/t,this._z=.25*t}return this._onChangeCallback(),this}setFromUnitVectors(A,Q){let I=A.dot(Q)+1;return I<Number.EPSILON?(I=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=I):(this._x=0,this._y=-A.z,this._z=A.y,this._w=I)):(this._x=A.y*Q.z-A.z*Q.y,this._y=A.z*Q.x-A.x*Q.z,this._z=A.x*Q.y-A.y*Q.x,this._w=I),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(u(this.dot(A),-1,1)))}rotateTowards(A,Q){const I=this.angleTo(A);if(I===0)return this;const B=Math.min(1,Q/I);return this.slerp(A,B),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,Q){const I=A._x,B=A._y,C=A._z,E=A._w,i=Q._x,D=Q._y,w=Q._z,o=Q._w;return this._x=I*o+E*i+B*w-C*D,this._y=B*o+E*D+C*i-I*w,this._z=C*o+E*w+I*D-B*i,this._w=E*o-I*i-B*D-C*w,this._onChangeCallback(),this}slerp(A,Q){if(Q===0)return this;if(Q===1)return this.copy(A);const I=this._x,B=this._y,C=this._z,E=this._w;let i=E*A._w+I*A._x+B*A._y+C*A._z;if(i<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,i=-i):this.copy(A),i>=1)return this._w=E,this._x=I,this._y=B,this._z=C,this;const D=1-i*i;if(D<=Number.EPSILON){const t=1-Q;return this._w=t*E+Q*this._w,this._x=t*I+Q*this._x,this._y=t*B+Q*this._y,this._z=t*C+Q*this._z,this.normalize(),this}const w=Math.sqrt(D),o=Math.atan2(w,i),s=Math.sin((1-Q)*o)/w,a=Math.sin(Q*o)/w;return this._w=E*s+this._w*a,this._x=I*s+this._x*a,this._y=B*s+this._y*a,this._z=C*s+this._z*a,this._onChangeCallback(),this}slerpQuaternions(A,Q,I){return this.copy(A).slerp(Q,I)}random(){const A=2*Math.PI*Math.random(),Q=2*Math.PI*Math.random(),I=Math.random(),B=Math.sqrt(1-I),C=Math.sqrt(I);return this.set(B*Math.sin(A),B*Math.cos(A),C*Math.sin(Q),C*Math.cos(Q))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,Q=0){return this._x=A[Q],this._y=A[Q+1],this._z=A[Q+2],this._w=A[Q+3],this._onChangeCallback(),this}toArray(A=[],Q=0){return A[Q]=this._x,A[Q+1]=this._y,A[Q+2]=this._z,A[Q+3]=this._w,A}fromBufferAttribute(A,Q){return this._x=A.getX(Q),this._y=A.getY(Q),this._z=A.getZ(Q),this._w=A.getW(Q),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class FA{constructor(A=0,Q=0,I=0){FA.prototype.isVector3=!0,this.x=A,this.y=Q,this.z=I}set(A,Q,I){return I===void 0&&(I=this.z),this.x=A,this.y=Q,this.z=I,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,Q){switch(A){case 0:this.x=Q;break;case 1:this.y=Q;break;case 2:this.z=Q;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,Q){return this.x=A.x+Q.x,this.y=A.y+Q.y,this.z=A.z+Q.z,this}addScaledVector(A,Q){return this.x+=A.x*Q,this.y+=A.y*Q,this.z+=A.z*Q,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,Q){return this.x=A.x-Q.x,this.y=A.y-Q.y,this.z=A.z-Q.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,Q){return this.x=A.x*Q.x,this.y=A.y*Q.y,this.z=A.z*Q.z,this}applyEuler(A){return this.applyQuaternion(fQ.setFromEuler(A))}applyAxisAngle(A,Q){return this.applyQuaternion(fQ.setFromAxisAngle(A,Q))}applyMatrix3(A){const Q=this.x,I=this.y,B=this.z,C=A.elements;return this.x=C[0]*Q+C[3]*I+C[6]*B,this.y=C[1]*Q+C[4]*I+C[7]*B,this.z=C[2]*Q+C[5]*I+C[8]*B,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const Q=this.x,I=this.y,B=this.z,C=A.elements,E=1/(C[3]*Q+C[7]*I+C[11]*B+C[15]);return this.x=(C[0]*Q+C[4]*I+C[8]*B+C[12])*E,this.y=(C[1]*Q+C[5]*I+C[9]*B+C[13])*E,this.z=(C[2]*Q+C[6]*I+C[10]*B+C[14])*E,this}applyQuaternion(A){const Q=this.x,I=this.y,B=this.z,C=A.x,E=A.y,i=A.z,D=A.w,w=2*(E*B-i*I),o=2*(i*Q-C*B),s=2*(C*I-E*Q);return this.x=Q+D*w+E*s-i*o,this.y=I+D*o+i*w-C*s,this.z=B+D*s+C*o-E*w,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const Q=this.x,I=this.y,B=this.z,C=A.elements;return this.x=C[0]*Q+C[4]*I+C[8]*B,this.y=C[1]*Q+C[5]*I+C[9]*B,this.z=C[2]*Q+C[6]*I+C[10]*B,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,Q){return this.x=u(this.x,A.x,Q.x),this.y=u(this.y,A.y,Q.y),this.z=u(this.z,A.z,Q.z),this}clampScalar(A,Q){return this.x=u(this.x,A,Q),this.y=u(this.y,A,Q),this.z=u(this.z,A,Q),this}clampLength(A,Q){const I=this.length();return this.divideScalar(I||1).multiplyScalar(u(I,A,Q))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,Q){return this.x+=(A.x-this.x)*Q,this.y+=(A.y-this.y)*Q,this.z+=(A.z-this.z)*Q,this}lerpVectors(A,Q,I){return this.x=A.x+(Q.x-A.x)*I,this.y=A.y+(Q.y-A.y)*I,this.z=A.z+(Q.z-A.z)*I,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,Q){const I=A.x,B=A.y,C=A.z,E=Q.x,i=Q.y,D=Q.z;return this.x=B*D-C*i,this.y=C*E-I*D,this.z=I*i-B*E,this}projectOnVector(A){const Q=A.lengthSq();if(Q===0)return this.set(0,0,0);const I=A.dot(this)/Q;return this.copy(A).multiplyScalar(I)}projectOnPlane(A){return BQ.copy(this).projectOnVector(A),this.sub(BQ)}reflect(A){return this.sub(BQ.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const Q=Math.sqrt(this.lengthSq()*A.lengthSq());if(Q===0)return Math.PI/2;const I=this.dot(A)/Q;return Math.acos(u(I,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const Q=this.x-A.x,I=this.y-A.y,B=this.z-A.z;return Q*Q+I*I+B*B}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,Q,I){const B=Math.sin(Q)*A;return this.x=B*Math.sin(I),this.y=Math.cos(Q)*A,this.z=B*Math.cos(I),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,Q,I){return this.x=A*Math.sin(Q),this.y=I,this.z=A*Math.cos(Q),this}setFromMatrixPosition(A){const Q=A.elements;return this.x=Q[12],this.y=Q[13],this.z=Q[14],this}setFromMatrixScale(A){const Q=this.setFromMatrixColumn(A,0).length(),I=this.setFromMatrixColumn(A,1).length(),B=this.setFromMatrixColumn(A,2).length();return this.x=Q,this.y=I,this.z=B,this}setFromMatrixColumn(A,Q){return this.fromArray(A.elements,Q*4)}setFromMatrix3Column(A,Q){return this.fromArray(A.elements,Q*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}setFromColor(A){return this.x=A.r,this.y=A.g,this.z=A.b,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,Q=0){return this.x=A[Q],this.y=A[Q+1],this.z=A[Q+2],this}toArray(A=[],Q=0){return A[Q]=this.x,A[Q+1]=this.y,A[Q+2]=this.z,A}fromBufferAttribute(A,Q){return this.x=A.getX(Q),this.y=A.getY(Q),this.z=A.getZ(Q),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=Math.random()*Math.PI*2,Q=Math.random()*2-1,I=Math.sqrt(1-Q*Q);return this.x=I*Math.cos(A),this.y=Q,this.z=I*Math.sin(A),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const BQ=new FA,fQ=new IQ,VQ={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},yA={h:0,s:0,l:0},VA={h:0,s:0,l:0};function gQ(g,A,Q){return Q<0&&(Q+=1),Q>1&&(Q-=1),Q<1/6?g+(A-g)*6*Q:Q<1/2?A:Q<2/3?g+(A-g)*6*(2/3-Q):g}class CQ{constructor(A,Q,I){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(A,Q,I)}set(A,Q,I){if(Q===void 0&&I===void 0){const B=A;B&&B.isColor?this.copy(B):typeof B=="number"?this.setHex(B):typeof B=="string"&&this.setStyle(B)}else this.setRGB(A,Q,I);return this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,Q=iA){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,DA.toWorkingColorSpace(this,Q),this}setRGB(A,Q,I,B=DA.workingColorSpace){return this.r=A,this.g=Q,this.b=I,DA.toWorkingColorSpace(this,B),this}setHSL(A,Q,I,B=DA.workingColorSpace){if(A=YI(A,1),Q=u(Q,0,1),I=u(I,0,1),Q===0)this.r=this.g=this.b=I;else{const C=I<=.5?I*(1+Q):I+Q-I*Q,E=2*I-C;this.r=gQ(E,C,A+1/3),this.g=gQ(E,C,A),this.b=gQ(E,C,A-1/3)}return DA.toWorkingColorSpace(this,B),this}setStyle(A,Q=iA){function I(C){C!==void 0&&parseFloat(C)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let B;if(B=/^(\\w+)\\(([^\\)]*)\\)/.exec(A)){let C;const E=B[1],i=B[2];switch(E){case"rgb":case"rgba":if(C=/^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(i))return I(C[4]),this.setRGB(Math.min(255,parseInt(C[1],10))/255,Math.min(255,parseInt(C[2],10))/255,Math.min(255,parseInt(C[3],10))/255,Q);if(C=/^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(i))return I(C[4]),this.setRGB(Math.min(100,parseInt(C[1],10))/100,Math.min(100,parseInt(C[2],10))/100,Math.min(100,parseInt(C[3],10))/100,Q);break;case"hsl":case"hsla":if(C=/^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(i))return I(C[4]),this.setHSL(parseFloat(C[1])/360,parseFloat(C[2])/100,parseFloat(C[3])/100,Q);break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(B=/^\\#([A-Fa-f\\d]+)$/.exec(A)){const C=B[1],E=C.length;if(E===3)return this.setRGB(parseInt(C.charAt(0),16)/15,parseInt(C.charAt(1),16)/15,parseInt(C.charAt(2),16)/15,Q);if(E===6)return this.setHex(parseInt(C,16),Q);console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,Q);return this}setColorName(A,Q=iA){const I=VQ[A.toLowerCase()];return I!==void 0?this.setHex(I,Q):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=YA(A.r),this.g=YA(A.g),this.b=YA(A.b),this}copyLinearToSRGB(A){return this.r=eA(A.r),this.g=eA(A.g),this.b=eA(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=iA){return DA.fromWorkingColorSpace(x.copy(this),A),Math.round(u(x.r*255,0,255))*65536+Math.round(u(x.g*255,0,255))*256+Math.round(u(x.b*255,0,255))}getHexString(A=iA){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,Q=DA.workingColorSpace){DA.fromWorkingColorSpace(x.copy(this),Q);const I=x.r,B=x.g,C=x.b,E=Math.max(I,B,C),i=Math.min(I,B,C);let D,w;const o=(i+E)/2;if(i===E)D=0,w=0;else{const s=E-i;switch(w=o<=.5?s/(E+i):s/(2-E-i),E){case I:D=(B-C)/s+(B<C?6:0);break;case B:D=(C-I)/s+2;break;case C:D=(I-B)/s+4;break}D/=6}return A.h=D,A.s=w,A.l=o,A}getRGB(A,Q=DA.workingColorSpace){return DA.fromWorkingColorSpace(x.copy(this),Q),A.r=x.r,A.g=x.g,A.b=x.b,A}getStyle(A=iA){DA.fromWorkingColorSpace(x.copy(this),A);const Q=x.r,I=x.g,B=x.b;return A!==iA?`color(${A} ${Q.toFixed(3)} ${I.toFixed(3)} ${B.toFixed(3)})`:`rgb(${Math.round(Q*255)},${Math.round(I*255)},${Math.round(B*255)})`}offsetHSL(A,Q,I){return this.getHSL(yA),this.setHSL(yA.h+A,yA.s+Q,yA.l+I)}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,Q){return this.r=A.r+Q.r,this.g=A.g+Q.g,this.b=A.b+Q.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,Q){return this.r+=(A.r-this.r)*Q,this.g+=(A.g-this.g)*Q,this.b+=(A.b-this.b)*Q,this}lerpColors(A,Q,I){return this.r=A.r+(Q.r-A.r)*I,this.g=A.g+(Q.g-A.g)*I,this.b=A.b+(Q.b-A.b)*I,this}lerpHSL(A,Q){this.getHSL(yA),A.getHSL(VA);const I=AQ(yA.h,VA.h,Q),B=AQ(yA.s,VA.s,Q),C=AQ(yA.l,VA.l,Q);return this.setHSL(I,B,C),this}setFromVector3(A){return this.r=A.x,this.g=A.y,this.b=A.z,this}applyMatrix3(A){const Q=this.r,I=this.g,B=this.b,C=A.elements;return this.r=C[0]*Q+C[3]*I+C[6]*B,this.g=C[1]*Q+C[4]*I+C[7]*B,this.b=C[2]*Q+C[5]*I+C[8]*B,this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,Q=0){return this.r=A[Q],this.g=A[Q+1],this.b=A[Q+2],this}toArray(A=[],Q=0){return A[Q]=this.r,A[Q+1]=this.g,A[Q+2]=this.b,A}fromBufferAttribute(A,Q){return this.r=A.getX(Q),this.g=A.getY(Q),this.b=A.getZ(Q),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const x=new CQ;CQ.NAMES=VQ,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:qQ}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=qQ);function UI(g){var C;let A=!1;const Q=g.split(`\n`).map(E=>{const i=E.trimEnd();return A?i:i.length>0?(A=!0,i):null}).filter(E=>E!=null);for(;Q.length>0&&Q[Q.length-1].length===0;)Q.pop();if(Q.length===0)return[];const I=(C=Q[0].match(/^\\s*/))==null?void 0:C[0];if(!I)return Q;const B=new RegExp(`^${I}`);return Q.map(E=>E.replace(B,""))}function rI(g){return UI(g).join(`\n`)}const EQ=new Float32Array(1),uQ=new Uint32Array(EQ.buffer);function UA(g){EQ[0]=g;const A=uQ[0],Q=A>>31&1,I=A>>23&255,B=A&8388607,C=Q<<15;if(I===255)return B!==0?C|32767:C|31744;const E=I-127+15;if(E>=31)return C|31744;if(E<=0){if(E<-10)return C;const D=(B|8388608)>>1-E+13;return C|D}const i=B>>13;return C|E<<10|i}function wA(g){const A=g>>15&1,Q=g>>10&31,I=g&1023;let B;if(Q===0)if(I===0)B=A<<31;else{let C=I,E=-14;for(;(C&1024)===0;)C<<=1,E--;C&=1023;const i=E+127,D=C<<13;B=A<<31|i<<23|D}else if(Q===31)I===0?B=A<<31|2139095040:B=A<<31|2143289344;else{const C=Q-15+127,E=I<<13;B=A<<31|C<<23|E}return uQ[0]=B,EQ[0]}function MA(g){return Math.max(0,Math.min(255,Math.round(g*255)))}function lI(g){const A=[],Q=new Set;function I(B){B&&typeof B=="object"&&!Q.has(B)&&(Q.add(B),B instanceof ArrayBuffer?A.push(B):ArrayBuffer.isView(B)?A.push(B.buffer):Array.isArray(B)?B.forEach(I):Object.values(B).forEach(I))}return I(g),A}function iQ(g,A,Q,I,B,C,E,i,D,w,o,s,a,t,c,y){const n=MA(t),M=MA(c),J=MA(y),G=MA(a),h=XQ(new IQ(D,w,o,s)),F=h&255,U=h>>>8&255,K=h>>>16&255,T=C===0?0:Math.min(255,Math.max(0,Math.round((Math.log(C)-GA)/JA)+1)),W=E===0?0:Math.min(255,Math.max(0,Math.round((Math.log(E)-GA)/JA)+1)),X=i===0?0:Math.min(255,Math.max(0,Math.round((Math.log(i)-GA)/JA)+1)),Y=UA(Q),$=UA(I),AA=UA(B),m=A*4;g[m]=n|M<<8|J<<16|G<<24,g[m+1]=Y|$<<16,g[m+2]=AA|F<<16|U<<24,g[m+3]=T|W<<8|X<<16|K<<24}function LI(g,A,Q,I,B){const C=UA(Q),E=UA(I),i=UA(B),D=A*4;g[D+1]=C|E<<16,g[D+2]=i|g[D+2]&4294901760}function SI(g,A,Q,I,B){const C=Q===0?0:Math.min(255,Math.max(0,Math.round((Math.log(Q)-GA)/JA)+1)),E=I===0?0:Math.min(255,Math.max(0,Math.round((Math.log(I)-GA)/JA)+1)),i=B===0?0:Math.min(255,Math.max(0,Math.round((Math.log(B)-GA)/JA)+1)),D=A*4;g[D+3]=C|E<<8|i<<16|g[D+3]&4278190080}function HI(g,A,Q,I,B,C){const E=XQ(new IQ(Q,I,B,C)),i=E&255,D=E>>>8&255,w=E>>>16&255,o=A*4;g[o+2]=g[o+2]&65535|i<<16|D<<24,g[o+3]=g[o+3]&16777215|w<<24}function dI(g,A,Q,I,B){const C=MA(Q),E=MA(I),i=MA(B),D=A*4;g[D]=C|E<<8|i<<16|g[D]&4278190080}function ZI(g,A,Q){const I=MA(Q),B=A*4;g[B]=g[B]&16777215|I<<24}new FA,new FA,new CQ,rI(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);function XQ(g){const A=g.clone().normalize();A.w<0&&A.set(-A.x,-A.y,-A.z,-A.w);const Q=2*Math.acos(A.w),I=Math.sqrt(A.x*A.x+A.y*A.y+A.z*A.z),B=I<1e-6?new FA(1,0,0):new FA(A.x,A.y,A.z).divideScalar(I),C=Math.abs(B.x)+Math.abs(B.y)+Math.abs(B.z);let E=B.x/C,i=B.y/C;if(B.z<0){const t=E;E=(1-Math.abs(i))*(E>=0?1:-1),i=(1-Math.abs(t))*(i>=0?1:-1)}const D=E*.5+.5,w=i*.5+.5,o=Math.round(D*255),s=Math.round(w*255);return Math.round(Q*(255/Math.PI))<<16|s<<8|o}function uA(g,A,Q,I){const B=Math.max(-127,Math.min(127,g*127)),C=Math.max(-127,Math.min(127,A*127)),E=Math.max(-127,Math.min(127,Q*127)),i=Math.max(-127,Math.min(127,I*127));return B&255|(C&255)<<8|(E&255)<<16|(i&255)<<24}function DQ(g,A,Q){const I=A*2;for(let B=0;B<9;++B){const C=Math.max(-63,Math.min(63,Q[B]*63))&127,E=B*7,i=E+7,D=Math.floor(E/32),w=E-D*32,o=C<<w&4294967295;if(g[I+D]|=o,i>D*32+32){const s=C>>>32-w&4294967295;g[I+D+1]|=s}}}function wQ(g,A,Q){g[A*4+0]=uA(Q[0],Q[1],Q[2],Q[3]),g[A*4+1]=uA(Q[4],Q[5],Q[6],Q[7]),g[A*4+2]=uA(Q[8],Q[9],Q[10],Q[11]),g[A*4+3]=uA(Q[12],Q[13],Q[14],0)}function sQ(g,A,Q){const I=A*4;for(let B=0;B<21;++B){const C=Math.max(-31,Math.min(31,Q[B]*31))&63,E=B*6,i=E+6,D=Math.floor(E/32),w=E-D*32,o=C<<w&4294967295;if(g[I+D]|=o,i>D*32+32){const s=C>>>32-w&4294967295;g[I+D+1]|=s}}}class KI{constructor({fileBytes:A,chunkBytes:Q=64*1024}){this.fileBytes=A,this.chunkBytes=Q,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new kI((I,B)=>{this.chunks.push(I),this.totalBytes+=I.length})}read(A){for(;this.totalBytes<A&&this.offset<this.fileBytes.length;){const C=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,C),!1),this.offset=C}if(this.totalBytes<A&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<A)throw new Error(`Unexpected EOF: needed ${A}, got ${this.totalBytes}`);const Q=new Uint8Array(this.totalBytes);let I=0;for(const C of this.chunks)Q.set(C,I),I+=C.length;const B=Q.subarray(0,A);return this.chunks=[Q.subarray(A)],this.totalBytes-=A,B}}class bI{constructor({fileBytes:A}){this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A,this.reader=new KI({fileBytes:this.fileBytes});const Q=new DataView(this.reader.read(16).buffer);if(Q.getUint32(0,!0)!==1347635022)throw new Error("Invalid SPZ file");if(this.version=Q.getUint32(4,!0),this.version<1||this.version>2)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=Q.getUint32(8,!0),this.shDegree=Q.getUint8(12),this.fractionalBits=Q.getUint8(13),this.flags=Q.getUint8(14),this.flagAntiAlias=(this.flags&1)!==0,this.reserved=Q.getUint8(15),this.parsed=!1}parseSplats(A,Q,I,B,C,E){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,this.version===1){const i=this.reader.read(this.numSplats*3*2),D=new Uint16Array(i.buffer);for(let w=0;w<this.numSplats;w++){const o=w*3,s=wA(D[o]),a=wA(D[o+1]),t=wA(D[o+2]);A(w,s,a,t)}}else if(this.version===2){const i=1<<this.fractionalBits,D=this.reader.read(this.numSplats*3*3);for(let w=0;w<this.numSplats;w++){const o=w*9,s=((D[o+2]<<24|D[o+1]<<16|D[o]<<8)>>8)/i,a=((D[o+5]<<24|D[o+4]<<16|D[o+3]<<8)>>8)/i,t=((D[o+8]<<24|D[o+7]<<16|D[o+6]<<8)>>8)/i;A(w,s,a,t)}}else throw new Error("Unreachable");{const i=this.reader.read(this.numSplats);for(let D=0;D<this.numSplats;D++)Q(D,i[D]/255)}{const i=this.reader.read(this.numSplats*3),D=xI/.15;for(let w=0;w<this.numSplats;w++){const o=w*3,s=(i[o]/255-.5)*D+.5,a=(i[o+1]/255-.5)*D+.5,t=(i[o+2]/255-.5)*D+.5;I(w,s,a,t)}}{const i=this.reader.read(this.numSplats*3);for(let D=0;D<this.numSplats;D++){const w=D*3,o=Math.exp(i[w]/16-10),s=Math.exp(i[w+1]/16-10),a=Math.exp(i[w+2]/16-10);B(D,o,s,a)}}{const i=this.reader.read(this.numSplats*3);for(let D=0;D<this.numSplats;D++){const w=D*3,o=i[w]/127.5-1,s=i[w+1]/127.5-1,a=i[w+2]/127.5-1,t=Math.sqrt(Math.max(0,1-o*o-s*s-a*a));C(D,o,s,a,t)}}if(E&&this.shDegree>=1){const i=new Float32Array(9),D=this.shDegree>=2?new Float32Array(5*3):void 0,w=this.shDegree>=3?new Float32Array(7*3):void 0,o=this.reader.read(this.numSplats*qI[this.shDegree]*3);let s=0;for(let a=0;a<this.numSplats;a++){for(let t=0;t<9;++t)i[t]=(o[s+t]-128)/128;if(s+=9,D){for(let t=0;t<15;++t)D[t]=(o[s+t]-128)/128;s+=15}if(w){for(let t=0;t<21;++t)w[t]=(o[s+t]-128)/128;s+=21}E(a,i,D,w)}}}}const qI={1:3,2:8,3:15},xI=.28209479177387814;async function jQ(g){const{name:A,args:Q,id:I}=g.data;let B,C;try{switch(A){case"unpackPly":{const{packedArray:E,fileBytes:i}=Q,D=await WI({packedArray:E,fileBytes:i});B={id:I,numSplats:D.numSplats,packedArray:D.packedArray,extra:D.extra};break}case"decodeWlg":{const{fileBytes:E}=Q,i=$Q(E,YQ,eQ);B={id:I,numSplats:i.numSplats,packedArray:i.packedSplats};break}case"decodeSpz":{const{fileBytes:E}=Q,i=mI(E);B={id:I,numSplats:i.numSplats,packedArray:i.packedArray,extra:i.extra};break}case"decodeAntiSplat":{const{fileBytes:E}=Q,i=pI(E);B={id:I,numSplats:i.numSplats,packedArray:i.packedArray};break}case"decodeKsplat":{const{fileBytes:E}=Q,i=VI(E);B={id:I,numSplats:i.numSplats,packedArray:i.packedArray,extra:i.extra};break}case"sortSplats":{const{maxSplats:E,totalSplats:i,readback:D,ordering:w}=Q;UQ&&(B={id:I,readback:D,ordering:w,activeSplats:AI(E,i,D,w)});break}case"sortDoubleSplats":{const{numSplats:E,readback:i,ordering:D}=Q;B={id:I,readback:i,ordering:D},UQ&&(B={id:I,readback:i,ordering:D,activeSplats:QI(E,i,D)});break}default:throw new Error(`Unknown name: ${A}`)}}catch(E){C=E}self.postMessage({id:I,result:B,error:C},{transfer:lI(B)})}async function WI({packedArray:g,fileBytes:A}){const Q=new TA({fileBytes:A});await Q.parseHeader();const I=Q.numSplats,B={},C=Math.exp(-20);return Q.parseSplats((E,i,D,w,o,s,a,t,c,y,n,M,J,G,h)=>{iQ(g,E,i,D,w,o<C?0:Math.max(zA,o),s<C?0:Math.max(zA,s),a<C?0:Math.max(zA,a),t,c,y,n,M,J,G,h)},(E,i,D,w)=>{i&&(B.sh1||(B.sh1=new Uint32Array(I*2)),DQ(B.sh1,E,i)),D&&(B.sh2||(B.sh2=new Uint32Array(I*4)),wQ(B.sh2,E,D)),w&&(B.sh3||(B.sh3=new Uint32Array(I*4)),sQ(B.sh3,E,w))}),{packedArray:g,numSplats:I,extra:B}}function oQ(g){const A=YQ,Q=Math.max(iI,Math.min(eQ,Math.ceil(g/A))),I=Math.ceil(g/(A*Q));return A*Q*I}function mI(g){const A=new bI({fileBytes:g}),Q=A.numSplats,I=oQ(Q),B=new Uint32Array(I*4),C={};return A.parseSplats((E,i,D,w)=>{LI(B,E,i,D,w)},(E,i)=>{ZI(B,E,i)},(E,i,D,w)=>{dI(B,E,i,D,w)},(E,i,D,w)=>{SI(B,E,i,D,w)},(E,i,D,w,o)=>{HI(B,E,i,D,w,o)},(E,i,D,w)=>{i&&(C.sh1||(C.sh1=new Uint32Array(Q*2)),DQ(C.sh1,E,i)),D&&(C.sh2||(C.sh2=new Uint32Array(Q*4)),wQ(C.sh2,E,D)),w&&(C.sh3||(C.sh3=new Uint32Array(Q*4)),sQ(C.sh3,E,w))}),{packedArray:B,numSplats:Q,extra:C}}function pI(g){const A=Math.floor(g.length/32);if(A*32!==g.length)throw new Error("Invalid .splat file size");const Q=oQ(A),I=new Uint32Array(Q*4),B=new Float32Array(g.buffer);for(let C=0;C<A;++C){const E=C*32,i=C*8,D=B[i+0],w=B[i+1],o=B[i+2],s=B[i+3],a=B[i+4],t=B[i+5],c=g[E+24]/255,y=g[E+25]/255,n=g[E+26]/255,M=g[E+27]/255,J=(g[E+28]-128)/128,G=(g[E+29]-128)/128,h=(g[E+30]-128)/128,F=(g[E+31]-128)/128;iQ(I,C,D,w,o,s,a,t,G,h,F,J,M,c,y,n)}return{packedArray:I,numSplats:A}}const zQ={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},fI={0:0,1:9,2:24,3:45};function VI(g){var M;let I=0;const B=new DataView(g.buffer,I,4096);I+=4096;const C=B.getUint8(0),E=B.getUint8(1);if(C!==0||E<1)throw new Error(`Unsupported .ksplat version: ${C}.${E}`);const i=B.getUint32(4,!0),D=B.getUint32(16,!0),w=B.getUint16(20,!0);if(w<0||w>2)throw new Error(`Invalid .ksplat compression level: ${w}`);const o=B.getFloat32(36,!0)||-1.5,s=B.getFloat32(40,!0)||1.5,a=D,t=oQ(a),c=new Uint32Array(t*4),y={};let n=4096+i*1024;for(let J=0;J<i;++J){let G=function(L,k){if(w===0)return N.getFloat32(L+f+k*4,!0);if(w===1)return wA(N.getUint16(L+f+k*2,!0));const kA=N.getUint8(L+f+k)/255;return o+kA*(s-o)};const h=new DataView(g.buffer,I,1024);I+=1024;const F=h.getUint32(0,!0),U=h.getUint32(4,!0),K=h.getUint32(8,!0),T=h.getUint32(12,!0),W=h.getFloat32(16,!0),X=h.getUint16(20,!0),Y=(h.getUint32(24,!0)||((M=zQ[w])==null?void 0:M.scaleRange))??1,AA=h.getUint32(36,!0)*4,m=X*T+AA,j=h.getUint16(40,!0),b=fI[j],{bytesPerCenter:p,bytesPerScale:O,bytesPerRotation:H,bytesPerColor:oA,bytesPerSphericalHarmonicsComponent:QA,scaleOffsetBytes:q,rotationOffsetBytes:r,colorOffsetBytes:z,sphericalHarmonicsOffsetBytes:f}=zQ[w],V=p+O+H+oA+b*QA,R=V*U,IA=R+m,v=[0,3,6,1,4,7,2,5,8],sA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],P=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],BA=j>=1?new Float32Array(3*3):void 0,gA=j>=2?new Float32Array(5*3):void 0,cA=j>=3?new Float32Array(7*3):void 0,CA=W/2/Y,aA=n+AA,tA=n+m,N=new DataView(g.buffer,tA,R),d=new Float32Array(g.buffer,aA,T*3);for(let L=0;L<F;++L){const k=L*V,kA=Math.floor(L/K),tQ=w===0?N.getFloat32(k+0,!0):(N.getUint16(k+0,!0)-Y)*CA+d[3*kA+0],cQ=w===0?N.getFloat32(k+4,!0):(N.getUint16(k+2,!0)-Y)*CA+d[3*kA+1],GQ=w===0?N.getFloat32(k+8,!0):(N.getUint16(k+4,!0)-Y)*CA+d[3*kA+2],hQ=w===0?N.getFloat32(k+q+0,!0):wA(N.getUint16(k+q+0,!0)),yQ=w===0?N.getFloat32(k+q+4,!0):wA(N.getUint16(k+q+2,!0)),MQ=w===0?N.getFloat32(k+q+8,!0):wA(N.getUint16(k+q+4,!0)),NQ=w===0?N.getFloat32(k+r+0,!0):wA(N.getUint16(k+r+0,!0)),FQ=w===0?N.getFloat32(k+r+4,!0):wA(N.getUint16(k+r+2,!0)),XI=w===0?N.getFloat32(k+r+8,!0):wA(N.getUint16(k+r+4,!0)),jI=w===0?N.getFloat32(k+r+12,!0):wA(N.getUint16(k+r+6,!0)),zI=N.getUint8(k+z+0)/255,TI=N.getUint8(k+z+1)/255,OI=N.getUint8(k+z+2)/255,vI=N.getUint8(k+z+3)/255;if(iQ(c,L,tQ,cQ,GQ,hQ,yQ,MQ,FQ,XI,jI,NQ,vI,zI,TI,OI),j>=1){if(BA){y.sh1||(y.sh1=new Uint32Array(a*2));for(const[KA,bA]of v.entries())BA[KA]=G(k,bA);DQ(y.sh1,L,BA)}if(gA){y.sh2||(y.sh2=new Uint32Array(a*4));for(const[KA,bA]of sA.entries())gA[KA]=G(k,bA);wQ(y.sh2,L,gA)}if(cA){y.sh3||(y.sh3=new Uint32Array(a*4));for(const[KA,bA]of P.entries())cA[KA]=G(k,bA);sQ(y.sh3,L,cA)}}}n+=IA}return{packedArray:c,numSplats:a,extra:y}}const rA=31744,ZA=rA+1;let l=null;function _I({totalSplats:g,readback:A,ordering:Q}){l||(l=new Uint32Array(ZA)),l.fill(0);const I=A.map(D=>new Uint32Array(D.buffer)),B=I[0].length,C=Math.ceil(g/B);let E=0;for(let D=0;D<C;++D){const w=I[D],o=Math.min(w.length,g-E);for(let s=0;s<o;++s){const a=w[s]&32767;a<rA&&(l[a]+=1)}E+=o}let i=0;for(let D=0;D<ZA;++D){const w=i+l[D];l[D]=i,i=w}E=0;for(let D=0;D<C;++D){const w=I[D],o=Math.min(w.length,g-E);for(let s=0;s<o;++s){const a=w[s]&32767;a<rA&&(Q[l[a]]=E+s,l[a]+=1)}E+=o}if(l[ZA-1]!==i)throw new Error(`Expected ${i} active splats but got ${l[ZA-1]}`);return{activeSplats:i,ordering:Q}}function $I({numSplats:g,readback:A,ordering:Q}){l||(l=new Uint32Array(ZA)),l.fill(0);for(let B=0;B<g;++B){const C=A[B];C<rA&&(l[C]+=1)}let I=0;for(let B=rA-1;B>=0;--B){const C=I+l[B];l[B]=I,I=C}for(let B=0;B<g;++B){const C=A[B];C<rA&&(Q[l[C]]=B,l[C]+=1)}if(l[0]!==I)throw new Error(`Expected ${I} active splats but got ${l[0]}`);return{activeSplats:I,ordering:Q}}const aQ=[];function TQ(g){aQ.push(g)}async function uI(){self.addEventListener("message",TQ),await nQ(),self.removeEventListener("message",TQ),self.addEventListener("message",jQ);for(const g of aQ)jQ(g);aQ.length=0}uI().catch(console.error)})();\n', XI = typeof self < "u" && self.Blob && new Blob([tt], { type: "text/javascript;charset=utf-8" });
function ue(Q) {
  let A;
  try {
    if (A = XI && (self.URL || self.webkitURL).createObjectURL(XI), !A) throw "";
    const I = new Worker(A, {
      name: Q == null ? void 0 : Q.name
    });
    return I.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(A);
    }), I;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(tt),
      {
        name: Q == null ? void 0 : Q.name
      }
    );
  } finally {
    A && (self.URL || self.webkitURL).revokeObjectURL(A);
  }
}
class Ue {
  constructor() {
    this.messages = {}, this.messageIdNext = 0, this.worker = new ue(), this.worker.onmessage = (A) => this.onMessage(A);
  }
  makeMessageId() {
    return ++this.messageIdNext;
  }
  makeMessagePromiseId() {
    const A = this.makeMessageId(), I = new Promise((g, B) => {
      this.messages[A] = { resolve: g, reject: B };
    });
    return { id: A, promise: I };
  }
  onMessage(A) {
    const { id: I, result: g, error: B } = A.data, C = this.messages[I];
    C && (delete this.messages[I], B ? C.reject(B) : C.resolve(g));
  }
  // Invoke an RPC on the worker with the given name and arguments.
  // The normal usage of a worker is to run one activity at a time,
  // but this function allows for concurrent calls, tagging each request
  // with a unique message Id and awaiting a response to that same Id.
  // The method will automatically transfer any ArrayBuffers in the
  // arguments to the worker. If you'd like to transfer a copy of a
  // buffer then you must clone it before passing to this function.
  async call(A, I) {
    const { id: g, promise: B } = this.makeMessagePromiseId();
    return this.worker.postMessage(
      { name: A, args: I, id: g },
      { transfer: sB(I) }
    ), B;
  }
}
let it = 4, QI = 0;
const st = [], ot = [];
async function Se() {
  const Q = st.shift();
  if (Q)
    return Q;
  if (QI < it) {
    const A = new Ue();
    return QI += 1, A;
  }
  return new Promise((A) => {
    ot.push(A);
  });
}
function Le(Q) {
  if (QI > it) {
    QI -= 1;
    return;
  }
  const A = ot.shift();
  if (A) {
    A(Q);
    return;
  }
  st.push(Q);
}
async function eQ(Q) {
  const A = await Se();
  try {
    return await Q(A);
  } finally {
    Le(A);
  }
}
class JD extends Yt {
  constructor(A) {
    super(A), this.fileLoader = new dt(A);
  }
  load(A, I, g, B) {
    this.fileLoader.setResponseType("arraybuffer"), this.fileLoader.setCrossOrigin(this.crossOrigin), this.fileLoader.setWithCredentials(this.withCredentials), this.fileLoader.setPath(this.path), this.fileLoader.setResourcePath(this.resourcePath), this.fileLoader.setRequestHeader(this.requestHeader), this.fileLoader.load(
      A,
      async (C) => {
        if (I) {
          const t = await at({
            input: C,
            fileType: this.fileType,
            pathOrUrl: A
          });
          I(new fA(t));
        }
      },
      g,
      B
    );
  }
  async loadAsync(A, I) {
    return new Promise((g, B) => {
      this.load(
        A,
        (C) => {
          g(C);
        },
        I,
        B
      );
    });
  }
  parse(A) {
    return new OA({ packedSplats: A });
  }
}
var pe = /* @__PURE__ */ ((Q) => (Q.PLY = "ply", Q.WLG0 = "wlg0", Q.SPZ = "spz", Q.SPLAT = "splat", Q.KSPLAT = "ksplat", Q))(pe || {});
function He(Q) {
  const A = new DataView(Q.buffer);
  if ((A.getUint32(0, !0) & 16777215) === 7957616)
    return "ply";
  if (A.getUint32(0, !0) === 809978967)
    return "wlg0";
  if ((A.getUint32(0, !0) & 16777215) === 559903) {
    const I = hB(Q, 4);
    return new DataView(I.buffer).getUint32(0, !0) === 1347635022 ? "spz" : void 0;
  }
}
function fe(Q) {
  const A = Q.split(/[?#]/, 1)[0], I = Math.max(
    A.lastIndexOf("/"),
    A.lastIndexOf("\\")
  ), g = A.slice(I + 1), B = g.lastIndexOf(".");
  return B <= 0 || B === g.length - 1 ? "" : g.slice(B + 1).toLowerCase();
}
async function at({
  input: Q,
  fileType: A,
  pathOrUrl: I
}) {
  const g = Q instanceof ArrayBuffer ? new Uint8Array(Q) : Q;
  let B = A;
  if (!A && (B = He(g), !B && I)) {
    const C = fe(I);
    C === "ply" ? B = "ply" : C === "wlg" ? B = "wlg0" : C === "spz" ? B = "spz" : C === "splat" ? B = "splat" : C === "ksplat" && (B = "ksplat");
  }
  if (B === "wlg0")
    return await eQ(async (C) => {
      const { packedArray: E, numSplats: t } = await C.call("decodeWlg", {
        fileBytes: g
      });
      return { packedArray: E, numSplats: t };
    });
  if (B === "ply") {
    const C = new kI({ fileBytes: g });
    await C.parseHeader();
    const E = C.numSplats, t = wA(E).maxSplats, s = { fileBytes: g, packedArray: new Uint32Array(t * 4) };
    return await eQ(async (o) => {
      const { packedArray: a, numSplats: i, extra: D } = await o.call(
        "unpackPly",
        s
      );
      return { packedArray: a, numSplats: i, extra: D };
    });
  }
  if (B === "spz")
    return await eQ(async (C) => {
      const { packedArray: E, numSplats: t, extra: s } = await C.call(
        "decodeSpz",
        {
          fileBytes: g
        }
      );
      return { packedArray: E, numSplats: t, extra: s };
    });
  if (B === "splat")
    return await eQ(async (C) => {
      const { packedArray: E, numSplats: t } = await C.call("decodeAntiSplat", {
        fileBytes: g
      });
      return { packedArray: E, numSplats: t };
    });
  if (B === "ksplat")
    return await eQ(async (C) => {
      const { packedArray: E, numSplats: t, extra: s } = await C.call(
        "decodeKsplat",
        { fileBytes: g }
      );
      return { packedArray: E, numSplats: t, extra: s };
    });
  throw new Error("Unknown splat file type");
}
var me = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;
const K = class K {
  constructor(A = {}) {
    this.maxSplats = 0, this.numSplats = 0, this.packedArray = null, this.isInitialized = !1, this.target = null, this.source = null, this.needsUpdate = !0, this.extra = {}, this.dyno = new mI({ packedSplats: this }), this.initialized = Promise.resolve(this), this.reinitialize(A);
  }
  reinitialize(A) {
    this.isInitialized = !1, A.url || A.fileBytes || A.construct ? this.initialized = this.asyncInitialize(A).then(() => (this.isInitialized = !0, this)) : (this.initialize(A), this.isInitialized = !0, this.initialized = Promise.resolve(this));
  }
  initialize(A) {
    A.packedArray ? (this.packedArray = A.packedArray, this.maxSplats = Math.floor(this.packedArray.length / 4), this.maxSplats = Math.floor(this.maxSplats / Z) * Z, this.numSplats = Math.min(
      this.maxSplats,
      A.numSplats ?? Number.POSITIVE_INFINITY
    )) : (this.maxSplats = A.maxSplats ?? 0, this.numSplats = 0), this.extra = A.extra ?? {};
  }
  async asyncInitialize(A) {
    let { url: I, fileBytes: g, construct: B } = A;
    if (I && (g = await fetch(I).then(async (C) => {
      if (!C.ok)
        throw new Error(
          `${C.status} "${C.statusText}" fetching URL: ${I}`
        );
      return await C.arrayBuffer();
    })), g) {
      const C = await at({
        input: g,
        fileType: A.fileType,
        pathOrUrl: I
      });
      this.initialize(C);
    }
    if (B) {
      const C = B(this);
      C instanceof Promise && await C;
    }
  }
  // Call this when you are finished with the PackedSplats and want to free
  // any buffers it holds.
  dispose() {
    this.target && (this.target.dispose(), this.target = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
  // resize exponentially and copy over the original data.
  //
  // Typically you don't need to call this, because calling this.setSplat(index, ...)
  // and this.pushSplat(...) will automatically call ensureSplats() so we have
  // enough splats.
  ensureSplats(A) {
    const I = A <= this.maxSplats ? this.maxSplats : (
      // Grow exponentially to avoid frequent reallocations
      Math.max(A, 2 * this.maxSplats)
    ), g = this.packedArray ? this.packedArray.length / 4 : 0;
    if (!this.packedArray || I > g) {
      this.maxSplats = wA(I).maxSplats;
      const B = new Uint32Array(this.maxSplats * 4);
      this.packedArray && B.set(this.packedArray), this.packedArray = B;
    }
    return this.packedArray;
  }
  // Ensure the extra array for the given level is large enough to hold numSplats
  ensureSplatsSh(A, I) {
    let g, B;
    if (A === 0)
      return this.ensureSplats(I);
    if (A === 1)
      g = 2, B = "sh1";
    else if (A === 2)
      g = 4, B = "sh2";
    else if (A === 3)
      g = 4, B = "sh3";
    else
      throw new Error(`Invalid level: ${A}`);
    let C = this.extra[B] ? this.extra[B].length / g : 0;
    const E = I <= C ? C : Math.max(I, 2 * C);
    if (!this.extra[B] || E > C) {
      C = wA(E).maxSplats;
      const t = new Uint32Array(C * g);
      this.extra[B] && t.set(this.extra[B]), this.extra[B] = t;
    }
    return this.extra[B];
  }
  // Unpack the 16-byte Gsplat data at index into the Three.js components
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number 0..1, color: THREE.Color 0..1.
  getSplat(A) {
    if (!this.packedArray || A >= this.numSplats)
      throw new Error("Invalid index");
    return yI(this.packedArray, A);
  }
  // Set all PackedSplat components at index with the provided Gsplat attributes
  // (can be the same objects returned by getSplat). Ensures there is capacity
  // for at least index+1 Gsplats.
  setSplat(A, I, g, B, C, E) {
    const t = this.ensureSplats(A + 1);
    hI(
      t,
      A,
      I.x,
      I.y,
      I.z,
      g.x,
      g.y,
      g.z,
      B.x,
      B.y,
      B.z,
      B.w,
      C,
      E.r,
      E.g,
      E.b
    ), this.numSplats = Math.max(this.numSplats, A + 1);
  }
  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
  // construction where you just want to iterate and create a collection of Gsplats.
  pushSplat(A, I, g, B, C) {
    const E = this.ensureSplats(this.numSplats + 1);
    hI(
      E,
      this.numSplats,
      A.x,
      A.y,
      A.z,
      I.x,
      I.y,
      I.z,
      g.x,
      g.y,
      g.z,
      g.w,
      B,
      C.r,
      C.g,
      C.b
    ), ++this.numSplats;
  }
  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
  // and invoke the callback function with the Gsplat attributes.
  forEachSplat(A) {
    if (!(!this.packedArray || !this.numSplats))
      for (let I = 0; I < this.numSplats; ++I) {
        const g = yI(this.packedArray, I);
        A(
          I,
          g.center,
          g.scales,
          g.quaternion,
          g.opacity,
          g.color
        );
      }
  }
  // Ensures our PackedSplats.target render target has enough space to generate
  // maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate(A) {
    if (this.target && (A ?? 1) <= this.maxSplats)
      return !1;
    this.dispose();
    const I = wA(A ?? 1), { width: g, height: B, depth: C } = I;
    return this.maxSplats = I.maxSplats, this.target = new e.WebGLArrayRenderTarget(g, B, C, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: e.NearestFilter,
      minFilter: e.NearestFilter
    }), this.target.texture.format = e.RGBAIntegerFormat, this.target.texture.type = e.UnsignedIntType, this.target.texture.internalFormat = "RGBA32UI", !0;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(A) {
    let I = 0;
    const g = A.map((B) => {
      const C = I, E = Math.ceil(B / Z) * Z;
      return I += E, { base: C, count: B };
    });
    return { maxSplats: I, mapping: g };
  }
  // Returns a THREE.DataArrayTexture representing the PackedSplats content as
  // a Uint32x4 data array texture (2048 x 2048 x depth in size)
  getTexture() {
    return this.target ? this.target.texture : this.source || this.packedArray ? this.maybeUpdateSource() : K.getEmpty();
  }
  // Check if source texture needs to be created/updated
  maybeUpdateSource() {
    if (!this.packedArray)
      throw new Error("No packed splats");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: I, depth: g } = this.source.image;
        this.maxSplats !== A * I * g && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.packedArray.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.packedArray.buffer));
      else {
        const { width: A, height: I, depth: g } = wA(this.maxSplats);
        this.source = new e.DataArrayTexture(
          this.packedArray,
          A,
          I,
          g
        ), this.source.format = e.RGBAIntegerFormat, this.source.type = e.UnsignedIntType, this.source.internalFormat = "RGBA32UI", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!K.emptySource) {
      const { width: A, height: I, depth: g, maxSplats: B } = wA(1), C = new Uint32Array(B * 4);
      K.emptySource = new e.DataArrayTexture(
        C,
        A,
        I,
        g
      ), K.emptySource.format = e.RGBAIntegerFormat, K.emptySource.type = e.UnsignedIntType, K.emptySource.internalFormat = "RGBA32UI", K.emptySource.needsUpdate = !0;
    }
    return K.emptySource;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let I = K.generatorProgram.get(A);
    if (!I) {
      const B = UA(
        { index: "int" },
        { output: "uvec4" },
        ({ index: C }) => {
          A.inputs.index = C;
          const E = A.outputs.gsplat;
          return { output: wg(E) };
        }
      );
      K.programTemplate || (K.programTemplate = new HI(
        me
      )), I = new pI({
        graph: B,
        inputs: { index: "index" },
        outputs: { output: "target" },
        template: K.programTemplate
      }), Object.assign(I.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), K.generatorProgram.set(A, I);
    }
    const g = I.prepareMaterial();
    return K.mesh.material = g, { program: I, material: g };
  }
  saveRenderState(A) {
    return {
      xrPresenting: A.xr.isPresenting,
      autoClear: A.autoClear,
      scissorTest: A.getScissorTest()
    };
  }
  resetRenderState(A, I) {
    A.setRenderTarget(null), A.xr.isPresenting = I.xrPresenting, A.autoClear = I.autoClear, A.setScissorTest(I.scissorTest);
  }
  // Executes a dyno program specified by generator which is any DynoBlock that
  // maps { index: "int" } to { gsplat: Gsplat }. This is called in
  // ForgeRenderer.updateInternal() to re-generate Gsplats in the scene for
  // SplatGenerator instances whose version is newer than what was generated
  // for it last time.
  generate({
    generator: A,
    base: I,
    count: g,
    renderer: B
  }) {
    if (!this.target)
      throw new Error("Target must be initialized with ensureSplats");
    if (I + g > this.maxSplats)
      throw new Error("Base + count exceeds maxSplats");
    const { program: C, material: E } = this.prepareProgramMaterial(A);
    C.update();
    const t = this.saveRenderState(B), s = Math.ceil((I + g) / Z) * Z, o = Z * IQ;
    for (E.uniforms.targetBase.value = I, E.uniforms.targetCount.value = g; I < s; ) {
      const a = Math.floor(I / o);
      E.uniforms.targetLayer.value = a;
      const i = a * o, D = Math.floor((I - i) / Z), n = Math.min(
        IQ,
        Math.ceil((s - i) / Z)
      );
      B.setRenderTarget(this.target, a), B.xr.isPresenting = !1, B.autoClear = !1, B.setScissorTest(!0), B.setScissor(
        0,
        D,
        Z,
        n - D
      ), B.render(K.scene, K.camera), I += Z * (n - D);
    }
    return this.resetRenderState(B, t), { nextBase: s };
  }
};
K.emptySource = null, K.programTemplate = null, K.generatorProgram = /* @__PURE__ */ new Map(), K.geometry = new e.PlaneGeometry(2, 2), K.mesh = new e.Mesh(
  K.geometry,
  new e.RawShaderMaterial({ visible: !1 })
), K.scene = new e.Scene().add(K.mesh), K.camera = new e.Camera();
let fA = K;
class mI extends F {
  constructor({ packedSplats: A } = {}) {
    super({
      key: "packedSplats",
      type: HQ,
      globals: () => [CI],
      value: {
        texture: fA.getEmpty(),
        numSplats: 0
      },
      update: (I) => {
        var g, B;
        return I.texture = ((g = this.packedSplats) == null ? void 0 : g.getTexture()) ?? fA.getEmpty(), I.numSplats = ((B = this.packedSplats) == null ? void 0 : B.numSplats) ?? 0, I;
      }
    }), this.packedSplats = A;
  }
}
class FI extends e.InstancedBufferGeometry {
  constructor(A, I) {
    super(), this.ordering = A, this.setAttribute("position", new e.BufferAttribute(be, 3)), this.setIndex(new e.BufferAttribute(xe, 1)), this._maxInstanceCount = A.length, this.instanceCount = I, this.attribute = new e.InstancedBufferAttribute(A, 1, !1, 1), this.attribute.setUsage(e.DynamicDrawUsage), this.setAttribute("splatIndex", this.attribute);
  }
  update(A, I) {
    this.ordering = A, this.attribute.array = A, this.instanceCount = I, this.attribute.addUpdateRange(0, I), this.attribute.needsUpdate = !0;
  }
}
const be = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]), xe = new Uint16Array([0, 1, 2, 0, 2, 3]), XA = class XA {
  constructor(A) {
    if (this.lastTime = null, this.encodeLinear = !1, this.superXY = 1, this.display = null, this.sorting = null, this.pending = null, this.sortingCheck = !1, this.readback = new Uint16Array(0), this.forge = A.forge, this.camera = A.camera, this.viewToWorld = A.viewToWorld ?? new e.Matrix4(), A.target) {
      const { width: I, height: g, doubleBuffer: B } = A.target, C = Math.max(1, Math.min(4, A.target.superXY ?? 1));
      if (this.superXY = C, I * C > 8192 || g * C > 8192)
        throw new Error("Target size too large");
      this.target = new e.WebGLRenderTarget(
        I * C,
        g * C,
        {
          format: e.RGBAFormat,
          type: e.UnsignedByteType,
          colorSpace: e.SRGBColorSpace
        }
      ), B && (this.back = new e.WebGLRenderTarget(
        I * C,
        g * C,
        {
          format: e.RGBAFormat,
          type: e.UnsignedByteType,
          colorSpace: e.SRGBColorSpace
        }
      )), this.encodeLinear = !0;
    }
    this.onTextureUpdated = A.onTextureUpdated, this.sortRadial = A.sortRadial ?? !0, this.sortDistance = A.sortDistance, this.sortCoorient = A.sortCoorient, this.depthBias = A.depthBias, this.sort360 = A.sort360, this.orderingFreelist = new oB({
      allocate: (I) => new Uint32Array(I),
      valid: (I, g) => I.length === g
    }), this.autoUpdate = !1, this.setAutoUpdate(A.autoUpdate ?? !1);
  }
  // Call this when you are done with the ForgeViewpoint and want to
  // free up its resources (GPU targets, pixel buffers, etc.)
  dispose() {
    var A;
    this.setAutoUpdate(!1), this.target && (this.target.dispose(), this.target = void 0), this.back && (this.back.dispose(), this.back = void 0), this.display && (this.forge.releaseAccumulator(this.display.accumulator), this.display.geometry.dispose(), this.display = null), (A = this.pending) != null && A.accumulator && (this.forge.releaseAccumulator(this.pending.accumulator), this.pending = null);
  }
  // Use this function to change whether this viewpoint will auto-update
  // its sort order whenever the attached ForgeRenderer updates the Gsplats.
  // Turn this on or off depending on whether you expect to do renders from
  // this viewpoint most frames.
  setAutoUpdate(A) {
    !this.autoUpdate && A ? this.forge.autoViewpoints.push(this) : this.autoUpdate && !A && (this.forge.autoViewpoints = this.forge.autoViewpoints.filter(
      (I) => I !== this
    )), this.autoUpdate = A;
  }
  // See below async prepareRenderPixels() for explanation of parameters.
  // Awaiting this method updates the Gsplats in the scene and performs a sort of the
  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()
  // call in the same tick.
  async prepare({
    scene: A,
    camera: I,
    viewToWorld: g,
    update: B,
    forceOrigin: C
  }) {
    var t;
    for (g ? this.viewToWorld = g : (this.camera = I ?? this.camera, this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone())); B ?? !0; ) {
      const s = C ? this.viewToWorld : void 0;
      if (this.forge.updateInternal({ scene: A, originToWorld: s }))
        break;
      await new Promise((a) => setTimeout(a, 10));
    }
    const E = this.forge.active;
    E !== ((t = this.display) == null ? void 0 : t.accumulator) && (this.forge.active.refCount += 1), await this.sortUpdate({ accumulator: E, viewToWorld: this.viewToWorld });
  }
  // Render out the viewpoint to the view target RGBA buffer.
  // Swaps buffers if doubleBuffer: true was set.
  // Calls onTextureUpdated(texture) with the resulting texture.
  renderTarget({
    scene: A,
    camera: I
  }) {
    var B;
    const g = this.back ?? this.target;
    if (!g)
      throw new Error("Must initialize ForgeViewpoint with target");
    if (I = I ?? this.camera, !I)
      throw new Error("Must provide camera");
    if (I instanceof e.PerspectiveCamera) {
      const C = new e.PerspectiveCamera().copy(I, !1);
      C.aspect = g.width / g.height, C.updateProjectionMatrix(), I = C;
    }
    this.viewToWorld = I.matrixWorld.clone();
    try {
      this.forge.renderer.setRenderTarget(g), this.forge.prepareViewpoint(this), this.forge.renderer.render(A, I);
    } finally {
      this.forge.prepareViewpoint(this.forge.defaultView), this.forge.renderer.setRenderTarget(null);
    }
    g !== this.target && ([this.target, this.back] = [this.back, this.target]), (B = this.onTextureUpdated) == null || B.call(this, g.texture);
  }
  // Read back the previously rendered target image as a Uint8Array of packed
  // RGBA values (in that order). If superXY was set greater than 1 then
  // downsampling is performed in the target pixel array with simple averaging
  // to derive the returned pixel values. Subsequent calls to this.readTarget()
  // will reuse the same buffers to minimize memory allocations.
  async readTarget() {
    if (!this.target)
      throw new Error("Must initialize ForgeViewpoint with target");
    const { width: A, height: I } = this.target, g = A * I * 4;
    (!this.superPixels || this.superPixels.length < g) && (this.superPixels = new Uint8Array(g)), await this.forge.renderer.readRenderTargetPixelsAsync(
      this.target,
      0,
      0,
      A,
      I,
      this.superPixels
    );
    const { superXY: B } = this;
    if (B === 1)
      return this.superPixels;
    const C = A / B, E = I / B, t = C * E * 4;
    (!this.pixels || this.pixels.length < t) && (this.pixels = new Uint8Array(t));
    const { superPixels: s, pixels: o } = this, a = B * B;
    for (let i = 0; i < E; i++) {
      const D = i * C;
      for (let n = 0; n < C; n++) {
        const w = n * B;
        let c = 0, r = 0, y = 0, G = 0;
        for (let M = 0; M < B; M++) {
          const l = (i * B + M) * this.target.width;
          for (let k = 0; k < B; k++) {
            const R = (l + w + k) * 4;
            c += s[R], r += s[R + 1], y += s[R + 2], G += s[R + 3];
          }
        }
        const h = (D + n) * 4;
        o[h] = c / a, o[h + 1] = r / a, o[h + 2] = y / a, o[h + 3] = G / a;
      }
    }
    return o;
  }
  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene
  // and any camera/viewToWorld viewpoint overrides. By default update is true,
  // which triggers its ForgeRenderer to check and potentially update the Gsplats.
  // Setting update to false disables this and sorts the Gsplats as they are.
  // Setting forceOrigin (default: false) to true forces the view update to
  // recalculate the splats with this view origin, potentially altering any
  // view-dependent effects. If you expect view-dependent effects to play a role
  // in the rendering quality, enable this.
  //
  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),
  // this.renderTarget(...), and finally returns the result this.readTarget(),
  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially
  // downsampled if the superXY parameter was used). These steps can also be called
  // manually, for example if you need to alter the scene before and after
  // this.renderTarget(...) to hide UI elements from being rendered.
  async prepareRenderPixels({
    scene: A,
    camera: I,
    viewToWorld: g,
    update: B,
    forceOrigin: C
  }) {
    return await this.prepare({ scene: A, camera: I, viewToWorld: g, update: B, forceOrigin: C }), this.renderTarget({ scene: A, camera: I }), this.readTarget();
  }
  // This is called automatically by ForgeRenderer, there is no need to call it!
  // The method cannot be private because then ForgeRenderer would
  // not be able to call it.
  autoPoll({ accumulator: A }) {
    var B, C, E;
    this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone());
    let I = !1;
    if (!this.display)
      I = !0;
    else if (A) {
      I = !0;
      const { mappingVersion: t } = this.display.accumulator;
      A.mappingVersion === t && (this.forge.releaseAccumulator(this.display.accumulator), this.display.accumulator = A);
    }
    const g = ((B = this.sorting) == null ? void 0 : B.viewToWorld) ?? ((C = this.display) == null ? void 0 : C.viewToWorld);
    g && !_Q({
      matrix1: this.viewToWorld,
      matrix2: g,
      // By default update sort each 1 cm
      maxDistance: this.sortDistance ?? 0.01,
      // By default for radial sort, update for intermittent movement so that
      // we bring back splats culled by being behind the camera.
      // For depth sort, small rotations can change sort order a lot, so
      // update sort for even small rotations.
      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999
    }) && (I = !0), I && (A && (A.refCount += 1), A && ((E = this.pending) != null && E.accumulator) && this.forge.releaseAccumulator(this.pending.accumulator), this.pending = { accumulator: A, viewToWorld: this.viewToWorld }, this.driveSort());
  }
  async driveSort() {
    var A;
    for (; ; ) {
      if (this.sorting || !this.pending)
        return;
      const I = this.pending.viewToWorld;
      let g = this.pending.accumulator ?? ((A = this.display) == null ? void 0 : A.accumulator);
      if (g || (g = this.forge.active, g.refCount += 1), this.pending = null, !g)
        throw new Error("No accumulator to sort");
      this.sorting = { viewToWorld: I }, await this.sortUpdate({ accumulator: g, viewToWorld: I }), this.sorting = null;
    }
  }
  async sortUpdate({
    accumulator: A,
    viewToWorld: I
  }) {
    if (this.sortingCheck)
      throw new Error("Only one sort at a time");
    this.sortingCheck = !0, A = A ?? this.forge.active;
    const { numSplats: g, maxSplats: B } = A.splats;
    let C = 0, E = this.orderingFreelist.alloc(B);
    if (g > 0) {
      const {
        reader: t,
        doubleSortReader: s,
        dynoSortRadial: o,
        dynoOrigin: a,
        dynoDirection: i,
        dynoDepthBias: D,
        dynoSort360: n,
        dynoSplats: w
      } = XA.makeSorter(), c = Math.ceil(B / 2);
      this.readback = t.ensureBuffer(c, this.readback);
      const r = A.toWorld.clone().invert(), y = I.clone().premultiply(r);
      o.value = this.sort360 ? !0 : this.sortRadial, a.value.set(0, 0, 0).applyMatrix4(y), i.value.set(0, 0, -1).applyMatrix4(y).sub(a.value).normalize(), D.value = this.depthBias ?? 1, n.value = this.sort360 ?? !1, w.packedSplats = A.splats, await t.renderReadback({
        renderer: this.forge.renderer,
        reader: s,
        count: Math.ceil(g / 2),
        readback: this.readback
      });
      const G = await eQ(async (h) => h.call("sortDoubleSplats", {
        numSplats: g,
        readback: this.readback,
        ordering: E
      }));
      this.readback = G.readback, E = G.ordering, C = G.activeSplats;
    }
    this.updateDisplay({ accumulator: A, viewToWorld: I, ordering: E, activeSplats: C }), this.sortingCheck = !1;
  }
  updateDisplay({
    accumulator: A,
    viewToWorld: I,
    ordering: g,
    activeSplats: B
  }) {
    if (!this.display)
      this.display = {
        accumulator: A,
        viewToWorld: I,
        geometry: new FI(g, B)
      };
    else {
      A !== this.display.accumulator && (this.forge.releaseAccumulator(this.display.accumulator), this.display.accumulator = A), this.display.viewToWorld = I;
      const C = this.display.geometry.ordering;
      C.length === g.length ? this.display.geometry.update(g, B) : (this.display.geometry.dispose(), this.display.geometry = new FI(g, B)), this.orderingFreelist.free(C);
    }
    this.forge.viewpoint === this && this.forge.prepareViewpoint(this);
  }
  static makeSorter() {
    if (!XA.dynos) {
      const A = new PQ({ value: !0 }), I = new hQ({ value: new e.Vector3() }), g = new hQ({ value: new e.Vector3() }), B = new gQ({ value: 1 }), C = new PQ({ value: !1 }), E = new mI(), t = new $Q(), s = UA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: o }) => {
          if (!o)
            throw new Error("No index");
          const a = {
            sortRadial: A,
            sortOrigin: I,
            sortDirection: g,
            sortDepthBias: B,
            sort360: C
          }, i = BA(o, q("int", 2)), D = dQ(E, i), n = jI({ gsplat: D, ...a }), w = dQ(
            E,
            cA(i, q("int", 1))
          ), c = jI({ gsplat: w, ...a }), r = HA({
            vectorType: "vec2",
            x: n,
            y: c
          });
          return { rgba8: MC(lC(r)) };
        }
      );
      XA.dynos = {
        dynoSortRadial: A,
        dynoOrigin: I,
        dynoDirection: g,
        dynoDepthBias: B,
        dynoSort360: C,
        dynoSplats: E,
        reader: t,
        doubleSortReader: s
      };
    }
    return XA.dynos;
  }
};
XA.EMPTY_TEXTURE = new e.Texture(), XA.dynos = null;
let II = XA;
const Ke = IA(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);
function jI({
  gsplat: Q,
  sortRadial: A,
  sortOrigin: I,
  sortDirection: g,
  sortDepthBias: B,
  sort360: C
}) {
  return pQ({
    inTypes: {
      gsplat: v,
      sortRadial: "bool",
      sortOrigin: "vec3",
      sortDirection: "vec3",
      sortDepthBias: "float",
      sort360: "bool"
    },
    outTypes: { metric: "float" },
    globals: () => [rA, Ke],
    inputs: {
      gsplat: Q,
      sortRadial: A,
      sortOrigin: I,
      sortDirection: g,
      sortDepthBias: B,
      sort360: C
    },
    statements: ({ inputs: E, outputs: t }) => {
      const {
        gsplat: s,
        sortRadial: o,
        sortOrigin: a,
        sortDirection: i,
        sortDepthBias: D,
        sort360: n
      } = E;
      return JA(`
        ${t.metric} = computeSort(${s}, ${o}, ${a}, ${i}, ${D}, ${n});
      `);
    }
  }).outputs.metric;
}
class DI {
  constructor() {
    this.splats = new fA(), this.toWorld = new e.Matrix4(), this.mapping = [], this.refCount = 0, this.splatsVersion = -1, this.mappingVersion = -1;
  }
  ensureGenerate(A) {
    this.splats.ensureGenerate(A) && (this.mapping = []);
  }
  // Generate all Gsplats from an array of generators
  generateSplats({
    renderer: A,
    modifier: I,
    generators: g,
    forceUpdate: B,
    originToWorld: C
  }) {
    const E = this.mapping.reduce((o, a) => (o.set(a.node, a), o), /* @__PURE__ */ new Map());
    let t = 0, s = 0;
    for (const { node: o, generator: a, version: i, base: D, count: n } of g) {
      const w = E.get(o);
      if ((B || a !== (w == null ? void 0 : w.generator) || i !== (w == null ? void 0 : w.version) || D !== (w == null ? void 0 : w.base) || n !== (w == null ? void 0 : w.count)) && a) {
        const c = I.apply(a);
        try {
          this.splats.generate({
            generator: c,
            base: D,
            count: n,
            renderer: A
          });
        } catch (r) {
          o.generator = void 0, o.generatorError = r;
        }
        t += 1;
      }
      s = Math.max(s, D + n);
    }
    return this.splats.numSplats = s, this.toWorld = C, this.mapping = g, t !== 0;
  }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  hasCorrespondence(A) {
    return this.mapping.length !== A.mapping.length ? !1 : this.mapping.every(({ node: I, base: g, count: B }, C) => {
      const {
        node: E,
        base: t,
        count: s
      } = A.mapping[C];
      return I === E && g === t && B === s;
    });
  }
}
var Ze = `const float LN_SCALE_MIN = -9.0;
const float LN_SCALE_MAX = 9.0;
const float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; 

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

const float MAX_PIXEL_RADIUS = 512.0;
const float MIN_ALPHA = 0.01;
const float MAX_STDDEV = sqrt(8.0);

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    rgba = vec4(uRgba) / 255.0;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),
        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),
        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`, qe = `precision highp float;
precision highp int;

#include <splatDefines>

uniform bool encodeLinear;
uniform float maxStdDev;
uniform bool disableFalloff;
uniform float falloff;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;

void main() {
    float z = dot(vSplatUv, vSplatUv);
    if (z > (maxStdDev * maxStdDev)) {
        discard;
    }

    float alpha = vRgba.a;
    alpha *= mix(1.0, exp(-0.5 * z), falloff);
    if (alpha < MIN_ALPHA) {
        discard;
    }

    vec3 rgb = vRgba.rgb;
    if (encodeLinear) {
        rgb = srgbToLinear(rgb);
    }
    fragColor = vec4(rgb, alpha);
}`, We = `precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float clipXY;

uniform usampler2DArray packedSplats;

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }
    if (splatIndex == 0xffffffffu) {
        
        return;
    }

    ivec3 texCoord = ivec3(
        splatIndex & SPLAT_TEX_WIDTH_MASK,
        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
        splatIndex >> SPLAT_TEX_LAYER_BITS
    );
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplat(packed, center, scales, quaternion, rgba);

    if (rgba.a < MIN_ALPHA) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 focal = 0.5 * renderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);
    float invZ = 1.0 / viewCenter.z;
    vec2 J1 = focal * invZ;
    vec2 J2 = -(J1 * viewCenter.xy) * invZ;
    mat3 J = mat3(
        J1.x, 0.0, J2.x,
        0.0, J1.y, J2.y,
        0.0, 0.0, 0.0
    );

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    
    float detOrig = a * d - b * b;
    a += blurAmount;
    d += blurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < MIN_ALPHA) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));
    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));

    
    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / renderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
}`;
let nI = null;
function Ve() {
  return nI || (e.ShaderChunk.splatDefines = Ze, nI = {
    splatVertex: We,
    splatFragment: qe
  }), nI;
}
const zI = 5;
let RI = !1, JI = !1, et;
const Dt = e.Scene.prototype.add;
e.Scene.prototype.add = function(Q) {
  return RI = RI || Q instanceof OA, JI = JI || Q instanceof gI, Dt.call(this, Q), this;
};
const ve = e.Scene.prototype.onBeforeRender;
e.Scene.prototype.onBeforeRender = function(Q) {
  if (RI) {
    if (!JI) {
      const A = et || new gI({ renderer: Q });
      this.add(A);
    }
    e.Scene.prototype.onBeforeRender = ve, e.Scene.prototype.add = Dt;
  }
};
const sA = class sA extends e.Mesh {
  constructor(A) {
    const I = sA.makeUniforms(), g = Ve(), B = new e.ShaderMaterial({
      glslVersion: e.GLSL3,
      vertexShader: g.splatVertex,
      fragmentShader: g.splatFragment,
      uniforms: I,
      transparent: !0,
      blending: e.NormalBlending,
      depthTest: !0,
      depthWrite: !1,
      side: e.DoubleSide
    });
    super(OI, B), this.autoViewpoints = [], this.rotateToAccumulator = new fQ({ value: new e.Quaternion() }), this.translateToAccumulator = new hQ({ value: new e.Vector3() }), this.lastFrame = -1, this.lastUpdateTime = null, this.defaultCameras = [], this.pendingUpdate = null, this.envViewpoint = null, this.frustumCulled = !1, this.renderer = A.renderer, this.material = B, this.uniforms = I;
    const C = UA(
      { gsplat: v },
      { gsplat: v },
      ({ gsplat: E }) => {
        if (!E)
          throw new Error("gsplat not defined");
        return E = UI(E, {
          rotate: this.rotateToAccumulator,
          translate: this.translateToAccumulator
        }), { gsplat: E };
      }
    );
    this.modifier = new le(C), this.autoUpdate = A.autoUpdate ?? !0, this.preUpdate = A.preUpdate ?? !1, this.originDistance = A.originDistance ?? 1, this.maxStdDev = A.maxStdDev ?? Math.sqrt(8), this.enable2DGS = A.enable2DGS ?? !0, this.preBlurAmount = A.preBlurAmount ?? 0, this.blurAmount = A.blurAmount ?? 0.3, this.falloff = A.falloff ?? 1, this.clipXY = A.clipXY ?? 1.4, this.active = new DI(), this.accumulatorCount = 1, this.freeAccumulators = [];
    for (let E = 0; E < 1; ++E)
      this.freeAccumulators.push(new DI()), this.accumulatorCount += 1;
    this.defaultView = new II({
      ...A.view,
      autoUpdate: !0,
      forge: this
    }), this.viewpoint = this.defaultView, this.prepareViewpoint(this.viewpoint), this.clock = A.clock ? aB(A.clock) : new e.Clock(), et = this;
  }
  static makeUniforms() {
    return {
      // Size of render viewport in pixels
      renderSize: { value: new e.Vector2() },
      // Total number of Gsplats in packedSplats to render
      numSplats: { value: 0 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new e.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new e.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: !1 },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Gsplat collection to render
      packedSplats: { type: "t", value: fA.getEmpty() },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: !1 },
      // Debug flag that alternates each frame
      debugFlag: { value: !1 }
    };
  }
  canAllocAccumulator() {
    return this.freeAccumulators.length > 0 || this.accumulatorCount < zI;
  }
  maybeAllocAccumulator() {
    let A = this.freeAccumulators.pop();
    if (A === void 0) {
      if (this.accumulatorCount >= zI)
        return null;
      A = new DI(), this.accumulatorCount += 1;
    }
    return A.refCount = 1, A;
  }
  releaseAccumulator(A) {
    A.refCount -= 1, A.refCount === 0 && this.freeAccumulators.push(A);
  }
  newViewpoint(A) {
    return new II({ ...A, forge: this });
  }
  onBeforeRender(A, I, g) {
    var D, n;
    const B = this.time ?? this.clock.getElapsedTime(), C = B - (this.viewpoint.lastTime ?? B);
    this.viewpoint.lastTime = B;
    const E = A.info.render.frame, t = E !== this.lastFrame;
    this.lastFrame = E;
    const s = this.viewpoint;
    if (s === this.defaultView) {
      if (t)
        if (!A.xr.isPresenting)
          this.defaultView.viewToWorld = g.matrixWorld.clone(), this.defaultCameras = [this.defaultView.viewToWorld];
        else {
          const w = A.xr.getCamera().cameras;
          this.defaultCameras = [
            w[0].matrixWorld,
            w[1].matrixWorld
          ], this.defaultView.viewToWorld = Te(this.defaultCameras) ?? new e.Matrix4();
        }
      this.autoUpdate && this.update({ scene: I, viewToWorld: this.defaultView.viewToWorld });
    }
    if (t && (this.uniforms.time.value = B, this.uniforms.deltaTime.value = C, this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1), s.target)
      this.uniforms.renderSize.value.set(
        s.target.width,
        s.target.height
      );
    else {
      const w = A.getSize(this.uniforms.renderSize.value);
      if (w.x === 1 && w.y === 1) {
        const c = (D = A.xr.getSession()) == null ? void 0 : D.renderState.baseLayer;
        c && (w.x = c.framebufferWidth, w.y = c.framebufferHeight);
      }
    }
    this.uniforms.encodeLinear.value = s.encodeLinear, this.uniforms.maxStdDev.value = this.maxStdDev, this.uniforms.enable2DGS.value = this.enable2DGS, this.uniforms.preBlurAmount.value = this.preBlurAmount, this.uniforms.blurAmount.value = this.blurAmount, this.uniforms.falloff.value = this.falloff, this.uniforms.clipXY.value = this.clipXY;
    const o = ((n = s.display) == null ? void 0 : n.accumulator.toWorld) ?? new e.Matrix4(), a = g.matrixWorld.clone().invert();
    o.clone().premultiply(a).decompose(
      this.uniforms.renderToViewPos.value,
      this.uniforms.renderToViewQuat.value,
      new e.Vector3()
    );
  }
  // Update the uniforms for the given viewpoint.
  // Note that the client expects to be able to call render() at any point
  // to update the canvas, so we must switch the viewpoint back to
  // defaultView when we're finished.
  prepareViewpoint(A) {
    if (this.viewpoint = A ?? this.viewpoint, this.viewpoint.display) {
      const { accumulator: I, geometry: g } = this.viewpoint.display;
      this.uniforms.numSplats.value = I.splats.numSplats, this.uniforms.packedSplats.value = I.splats.getTexture(), this.geometry = g;
    } else
      this.uniforms.numSplats.value = 0, this.uniforms.packedSplats.value = fA.getEmpty(), this.geometry = OI;
  }
  // If forge.autoUpdate is false then you must manually call
  // forge.update({ scene }) to have the scene Gsplats be re-generated.
  update({
    scene: A,
    viewToWorld: I
  }) {
    const g = this.matrixWorld.clone();
    this.preUpdate ? this.updateInternal({ scene: A, originToWorld: g, viewToWorld: I }) : (this.pendingUpdate = {
      scene: A,
      originToWorld: g
    }, setTimeout(() => {
      if (this.pendingUpdate) {
        const { scene: B, originToWorld: C } = this.pendingUpdate;
        this.pendingUpdate = null, this.updateInternal({ scene: B, originToWorld: C, viewToWorld: I });
      }
    }, 1));
  }
  updateInternal({
    scene: A,
    originToWorld: I,
    viewToWorld: g
  }) {
    var D;
    if (!this.canAllocAccumulator())
      return !1;
    I || (I = this.active.toWorld), g = g ?? I.clone();
    const B = this.time ?? this.clock.getElapsedTime(), C = B - (this.lastUpdateTime ?? B);
    this.lastUpdateTime = B;
    const E = this.active.mapping.reduce((n, w) => (n.set(w.node, w), n), /* @__PURE__ */ new Map()), { generators: t, globalEdits: s } = this.compileScene(A);
    for (const n of t)
      (D = n.frameUpdate) == null || D.call(n, {
        object: n,
        time: B,
        deltaTime: C,
        viewToWorld: g,
        globalEdits: s
      });
    for (const n of t) {
      const w = E.get(n), c = n.generator ? n.numSplats : 0;
      (n.generator !== (w == null ? void 0 : w.generator) || c !== (w == null ? void 0 : w.count)) && n.updateVersion();
    }
    const a = !_Q({
      matrix1: I,
      matrix2: this.active.toWorld,
      maxDistance: this.originDistance
    }) || t.length !== E.size || t.some((n) => {
      var w;
      return n.version !== ((w = E.get(n)) == null ? void 0 : w.version);
    });
    let i = null;
    if (a) {
      if (i = this.maybeAllocAccumulator(), !i)
        throw new Error("Unreachable");
      const n = !_Q({
        matrix1: I,
        matrix2: this.active.toWorld,
        maxDistance: 1e-5,
        minCoorient: 0.99999
      }), c = t.map((l, k) => {
        const R = E.get(l);
        return R ? (
          // Sort by version deltas then by previous ordering in the mapping,
          // attempting to keep unchanging generators near the front
          // to improve our chances of avoiding a re-generation.
          [l.version - R.version, R.base, l]
        ) : [Number.POSITIVE_INFINITY, l.version, l];
      }).sort((l, k) => l[0] !== k[0] ? l[0] - k[0] : l[1] - k[1]).map(([l, k, R]) => R), r = c.map((l) => l.numSplats), { maxSplats: y, mapping: G } = i.splats.generateMapping(r), h = c.map((l, k) => {
        const { base: R, count: Y } = G[k];
        return {
          node: l,
          generator: l.generator,
          version: l.version,
          base: R,
          count: Y
        };
      });
      I.clone().invert().decompose(
        this.translateToAccumulator.value,
        this.rotateToAccumulator.value,
        new e.Vector3()
      ), i.ensureGenerate(y), i.generateSplats({
        renderer: this.renderer,
        modifier: this.modifier,
        generators: h,
        forceUpdate: n,
        originToWorld: I
      }), i.splatsVersion = this.active.splatsVersion + 1;
      const M = i.hasCorrespondence(this.active);
      i.mappingVersion = this.active.mappingVersion + (M ? 0 : 1), this.releaseAccumulator(this.active), this.active = i, this.prepareViewpoint();
    }
    return setTimeout(() => {
      for (const n of this.autoViewpoints)
        n.autoPoll({ accumulator: i ?? void 0 });
    }, 1), !0;
  }
  compileScene(A) {
    const I = [];
    A.traverse((B) => {
      B instanceof iI && I.push(B);
    });
    const g = /* @__PURE__ */ new Set();
    return A.traverseVisible((B) => {
      if (B instanceof AI) {
        let C = B.parent;
        for (; C != null && !(C instanceof OA); )
          C = C.parent;
        C == null && g.add(B);
      }
    }), { generators: I, globalEdits: Array.from(g) };
  }
  // Renders out the scene to an environment map that can be used for
  // Image-based lighting or similar applications. First optionally updates Gsplats,
  // sorts them with respect to the provided worldCenter, renders 6 cube faces,
  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture
  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.
  async renderEnvMap({
    renderer: A,
    scene: I,
    worldCenter: g,
    size: B = 256,
    near: C = 0.1,
    far: E = 1e3,
    hideObjects: t = [],
    update: s = !1
  }) {
    var n, w;
    if (this.envViewpoint || (this.envViewpoint = this.newViewpoint({ sort360: !0 })), !sA.cubeRender || sA.cubeRender.target.width !== B || sA.cubeRender.near !== C || sA.cubeRender.far !== E) {
      sA.cubeRender && sA.cubeRender.target.dispose();
      const c = new e.WebGLCubeRenderTarget(B, {
        format: e.RGBAFormat,
        generateMipmaps: !0,
        minFilter: e.LinearMipMapLinearFilter
      }), r = new e.CubeCamera(C, E, c);
      sA.cubeRender = { target: c, camera: r, near: C, far: E };
    }
    sA.pmrem || (sA.pmrem = new e.PMREMGenerator(A ?? this.renderer));
    const o = new e.Matrix4().setPosition(g);
    await ((n = this.envViewpoint) == null ? void 0 : n.prepare({ scene: I, viewToWorld: o, update: s }));
    const { target: a, camera: i } = sA.cubeRender;
    i.position.copy(g);
    const D = /* @__PURE__ */ new Map();
    for (const c of t)
      D.set(c, c.visible), c.visible = !1;
    this.prepareViewpoint(this.envViewpoint), i.update(A ?? this.renderer, I), this.prepareViewpoint(this.defaultView);
    for (const [c, r] of D.entries())
      c.visible = r;
    return (w = sA.pmrem) == null ? void 0 : w.fromCubemap(a.texture).texture;
  }
  // Utility function to recursively set the envMap property for any
  // THREE.MeshStandardMaterial within the subtree of root.
  recurseSetEnvMap(A, I) {
    A.traverse((g) => {
      if (g instanceof e.Mesh)
        if (Array.isArray(g.material))
          for (const B of g.material)
            B instanceof e.MeshStandardMaterial && (B.envMap = I);
        else
          g.material instanceof e.MeshStandardMaterial && (g.material.envMap = I);
    });
  }
  // Utility function that helps extract the Gsplat RGBA values from a
  // SplatGenerator, including the result of any real-time RGBA SDF edits applied
  // to a SplatMesh. This effectively "bakes" any computed RGBA values, which can
  // now be used as a pipeline input via SplatMesh.splatRgba to inject these
  // baked values into the Gsplat data.
  getRgba({
    generator: A,
    rgba: I
  }) {
    const g = this.active.mapping.find(({ node: B }) => B === A);
    if (!g)
      throw new Error("Generator not found");
    return I = I ?? new NI(), I.fromPackedSplats({
      packedSplats: this.active.splats,
      base: g.base,
      count: g.count,
      renderer: this.renderer
    }), I;
  }
  // Utility function that builds on getRgba({ generator }) and additionally
  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA
  // in that byte order.
  async readRgba({
    generator: A,
    rgba: I
  }) {
    return I = this.getRgba({ generator: A, rgba: I }), I.read();
  }
};
sA.cubeRender = null, sA.pmrem = null;
let gI = sA;
const OI = new FI(new Uint32Array(1), 0);
UA(
  { packedSplats: HQ, index: "int" },
  { gsplat: v },
  ({ packedSplats: Q, index: A }) => {
    if (!Q || !A)
      throw new Error("Invalid input");
    return { gsplat: dQ(Q, A) };
  }
);
function Te(Q) {
  if (Q.length === 0)
    return null;
  const A = new e.Vector3(), I = new e.Quaternion(), g = new e.Vector3(), B = [], C = [];
  for (const E of Q)
    E.decompose(A, I, g), B.push(A), C.push(I);
  return new e.Matrix4().compose(
    DB(B),
    nB(C),
    new e.Vector3(1, 1, 1)
  );
}
class YD {
  constructor({ fileBytes: A }) {
    this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A, this.reader = new yB({ fileBytes: this.fileBytes });
    const I = new DataView(this.reader.read(16).buffer);
    if (I.getUint32(0, !0) !== 1347635022)
      throw new Error("Invalid SPZ file");
    if (this.version = I.getUint32(4, !0), this.version < 1 || this.version > 2)
      throw new Error(`Unsupported SPZ version: ${this.version}`);
    this.numSplats = I.getUint32(8, !0), this.shDegree = I.getUint8(12), this.fractionalBits = I.getUint8(13), this.flags = I.getUint8(14), this.flagAntiAlias = (this.flags & 1) !== 0, this.reserved = I.getUint8(15), this.parsed = !1;
  }
  parseSplats(A, I, g, B, C, E) {
    if (this.parsed)
      throw new Error("SPZ file already parsed");
    if (this.parsed = !0, this.version === 1) {
      const t = this.reader.read(this.numSplats * 3 * 2), s = new Uint16Array(t.buffer);
      for (let o = 0; o < this.numSplats; o++) {
        const a = o * 3, i = CQ(s[a]), D = CQ(s[a + 1]), n = CQ(s[a + 2]);
        A(o, i, D, n);
      }
    } else if (this.version === 2) {
      const t = 1 << this.fractionalBits, s = this.reader.read(this.numSplats * 3 * 3);
      for (let o = 0; o < this.numSplats; o++) {
        const a = o * 9, i = ((s[a + 2] << 24 | s[a + 1] << 16 | s[a] << 8) >> 8) / t, D = ((s[a + 5] << 24 | s[a + 4] << 16 | s[a + 3] << 8) >> 8) / t, n = ((s[a + 8] << 24 | s[a + 7] << 16 | s[a + 6] << 8) >> 8) / t;
        A(o, i, D, n);
      }
    } else
      throw new Error("Unreachable");
    {
      const t = this.reader.read(this.numSplats);
      for (let s = 0; s < this.numSplats; s++)
        I(s, t[s] / 255);
    }
    {
      const t = this.reader.read(this.numSplats * 3), s = je / 0.15;
      for (let o = 0; o < this.numSplats; o++) {
        const a = o * 3, i = (t[a] / 255 - 0.5) * s + 0.5, D = (t[a + 1] / 255 - 0.5) * s + 0.5, n = (t[a + 2] / 255 - 0.5) * s + 0.5;
        g(o, i, D, n);
      }
    }
    {
      const t = this.reader.read(this.numSplats * 3);
      for (let s = 0; s < this.numSplats; s++) {
        const o = s * 3, a = Math.exp(t[o] / 16 - 10), i = Math.exp(t[o + 1] / 16 - 10), D = Math.exp(t[o + 2] / 16 - 10);
        B(s, a, i, D);
      }
    }
    {
      const t = this.reader.read(this.numSplats * 3);
      for (let s = 0; s < this.numSplats; s++) {
        const o = s * 3, a = t[o] / 127.5 - 1, i = t[o + 1] / 127.5 - 1, D = t[o + 2] / 127.5 - 1, n = Math.sqrt(
          Math.max(0, 1 - a * a - i * i - D * D)
        );
        C(s, a, i, D, n);
      }
    }
    if (E && this.shDegree >= 1) {
      const t = new Float32Array(9), s = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0, o = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0, a = this.reader.read(
        this.numSplats * Xe[this.shDegree] * 3
      );
      let i = 0;
      for (let D = 0; D < this.numSplats; D++) {
        for (let n = 0; n < 9; ++n)
          t[n] = (a[i + n] - 128) / 128;
        if (i += 9, s) {
          for (let n = 0; n < 15; ++n)
            s[n] = (a[i + n] - 128) / 128;
          i += 15;
        }
        if (o) {
          for (let n = 0; n < 21; ++n)
            o[n] = (a[i + n] - 128) / 128;
          i += 21;
        }
        E(D, t, s, o);
      }
    }
  }
}
const Xe = { 1: 3, 2: 8, 3: 15 }, je = 0.28209479177387814;
class dD {
  constructor(A) {
    this.mesh = A.mesh, this.numSplats = A.numSplats ?? this.mesh.numSplats;
    const { width: I, height: g, depth: B, maxSplats: C } = wA(this.numSplats);
    this.skinData = new Uint16Array(C * 4), this.skinTexture = new e.DataArrayTexture(
      this.skinData,
      I,
      g,
      B
    ), this.skinTexture.format = e.RGBAIntegerFormat, this.skinTexture.type = e.UnsignedShortType, this.skinTexture.internalFormat = "RGBA16UI", this.skinTexture.needsUpdate = !0, this.numBones = A.numBones ?? 256, this.boneData = new Float32Array(this.numBones * 16), this.boneTexture = new e.DataTexture(
      this.boneData,
      4,
      this.numBones,
      e.RGBAFormat,
      e.FloatType
    ), this.boneTexture.internalFormat = "RGBA32F", this.boneTexture.needsUpdate = !0, this.uniform = new F({
      key: "skinning",
      type: nt,
      globals: () => [ct],
      value: {
        numSplats: this.numSplats,
        numBones: this.numBones,
        skinTexture: this.skinTexture,
        boneTexture: this.boneTexture
      }
    });
  }
  // Apply the skeletal animation to a Gsplat in a dyno program.
  modify(A) {
    return Oe(A, this.uniform);
  }
  // Set the "rest" pose for a bone with position and quaternion orientation.
  setRestQuatPos(A, I, g) {
    const B = A * 16;
    this.boneData[B + 0] = I.x, this.boneData[B + 1] = I.y, this.boneData[B + 2] = I.z, this.boneData[B + 3] = I.w, this.boneData[B + 4] = g.x, this.boneData[B + 5] = g.y, this.boneData[B + 6] = g.z, this.boneData[B + 7] = 0, this.boneData[B + 8] = 0, this.boneData[B + 9] = 0, this.boneData[B + 10] = 0, this.boneData[B + 11] = 1, this.boneData[B + 12] = 0, this.boneData[B + 13] = 0, this.boneData[B + 14] = 0, this.boneData[B + 15] = 0;
  }
  // Set the "current" position and orientation of a bone.
  setBoneQuatPos(A, I, g) {
    const B = A * 16, C = new e.Quaternion(
      this.boneData[B + 0],
      this.boneData[B + 1],
      this.boneData[B + 2],
      this.boneData[B + 3]
    ), E = new e.Vector3(
      this.boneData[B + 4],
      this.boneData[B + 5],
      this.boneData[B + 6]
    ), t = C.clone().invert(), s = g.clone().sub(E);
    s.applyQuaternion(t), t.multiply(I);
    const o = new e.Quaternion(
      s.x,
      s.y,
      s.z,
      0
    ).multiply(C);
    this.boneData[B + 8] = t.x, this.boneData[B + 9] = t.y, this.boneData[B + 10] = t.z, this.boneData[B + 11] = t.w, this.boneData[B + 12] = 0.5 * o.x, this.boneData[B + 13] = 0.5 * o.y, this.boneData[B + 14] = 0.5 * o.z, this.boneData[B + 15] = 0.5 * o.w;
  }
  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,
  // you can set the remaining weights to 0 (and index=0).
  setSplatBones(A, I, g) {
    const B = A * 4;
    this.skinData[B + 0] = Math.min(255, Math.max(0, Math.round(g.x * 255))) + (I.x << 8), this.skinData[B + 1] = Math.min(255, Math.max(0, Math.round(g.y * 255))) + (I.y << 8), this.skinData[B + 2] = Math.min(255, Math.max(0, Math.round(g.z * 255))) + (I.z << 8), this.skinData[B + 3] = Math.min(255, Math.max(0, Math.round(g.w * 255))) + (I.w << 8);
  }
  // Call this to indicate that the bones have changed and the Gsplats need to be
  // re-generated with updated skinning.
  updateBones() {
    this.boneTexture.needsUpdate = !0, this.mesh.needsUpdate = !0;
  }
}
const nt = { type: "GsplatSkinning" }, ct = IA(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`), ze = IA(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);
function Oe(Q, A) {
  return new f({
    inTypes: { gsplat: v, skinning: nt },
    outTypes: { gsplat: v },
    globals: () => [ct, ze],
    inputs: { gsplat: Q, skinning: A },
    statements: ({ inputs: g, outputs: B }) => {
      const { skinning: C } = g, { gsplat: E } = B;
      return JA(`
        ${E} = ${g.gsplat};
        if (isGsplatActive(${E}.flags)) {
          applyGsplatSkinning(
            ${C}.numSplats, ${C}.numBones,
            ${C}.skinTexture, ${C}.boneTexture,
            ${E}.index, ${E}.center, ${E}.quaternion
          );
        }
      `);
    }
  }).outputs.gsplat;
}
function uD({
  // PackedSplats object to add splats to
  splats: Q,
  // min and max box extents of the grid
  extents: A,
  // step size along each grid axis
  stepSize: I = 1,
  // spherical radius of each Gsplat
  pointRadius: g = 0.01,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  pointShadowScale: B = 2,
  // Gsplat opacity
  opacity: C = 1,
  // Gsplat color (THREE.Color) or function to set color for position:
  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)
  color: E
}) {
  const s = new e.Vector3(), o = new e.Vector3(), a = new e.Quaternion(0, 0, 0, 1);
  E == null && (E = (D, n) => D.set(
    0.55 + 0.45 * Math.cos(n.x * 1),
    0.55 + 0.45 * Math.cos(n.y * 1),
    0.55 + 0.45 * Math.cos(n.z * 1)
  ));
  const i = new e.Color();
  for (let D = A.min.z; D < A.max.z + 1e-6; D += I)
    for (let n = A.min.y; n < A.max.y + 1e-6; n += I)
      for (let w = A.min.x; w < A.max.x + 1e-6; w += I) {
        s.set(w, n, D);
        for (let c = 0; c < 2; ++c)
          o.setScalar(g * (c ? 1 : B)), c ? typeof E == "function" ? E(i, s) : i.copy(E) : i.setScalar(0), Q.pushSplat(s, o, a, C, i);
      }
}
function UD({
  // PackedSplats object to add splats to
  splats: Q,
  // scale (Gsplat scale along axis)
  scale: A = 0.25,
  // radius of the axes (Gsplat scale orthogonal to axis)
  axisRadius: I = 75e-4,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  axisShadowScale: g = 2,
  // origins of the axes (default single axis at origin)
  origins: B = [new e.Vector3()]
}) {
  const C = new e.Vector3(), E = new e.Vector3(), t = new e.Quaternion(0, 0, 0, 1), s = new e.Color(), o = 1;
  for (const a of B)
    for (let i = 0; i < 3; ++i) {
      C.set(
        a.x + (i === 0 ? A : 0),
        a.y + (i === 1 ? A : 0),
        a.z + (i === 2 ? A : 0)
      );
      for (let D = 0; D < 2; ++D)
        E.set(
          (i === 0 ? A : I) * (D ? 1 : g),
          (i === 1 ? A : I) * (D ? 1 : g),
          (i === 2 ? A : I) * (D ? 1 : g)
        ), s.setRGB(
          D === 0 ? 0 : i === 0 ? 1 : 0,
          D === 0 ? 0 : i === 1 ? 1 : 0,
          D === 0 ? 0 : i === 2 ? 1 : 0
        ), Q.pushSplat(C, E, t, o, s);
    }
}
function SD({
  // PackedSplats object to add splats to
  splats: Q,
  // center of the sphere (default: origin)
  origin: A = new e.Vector3(),
  // radius of the sphere
  radius: I = 1,
  // maximum depth of recursion for subdividing the sphere
  // Warning: Gsplat count grows exponentially with depth
  maxDepth: g = 3,
  // filter function to apply to each point, for example to select
  // points in a certain direction or other function ((THREE.Vector3) => boolean)
  // (default: null)
  filter: B = null,
  // radius of each oriented Gsplat
  pointRadius: C = 0.02,
  // flatness of each oriented Gsplat
  pointThickness: E = 1e-3,
  // color of each Gsplat (THREE.Color) or function to set color for point:
  // ((THREE.Color, THREE.Vector3) => void) (default: white)
  color: t = new e.Color(1, 1, 1)
}) {
  const s = {};
  function o(c) {
    if (B && !B(c))
      return;
    const r = `${c.x},${c.y},${c.z}`;
    s[r] || (s[r] = c);
  }
  function a(c, r, y, G) {
    if (o(r), o(y), o(G), c >= g)
      return;
    const h = new e.Vector3().addVectors(r, y).normalize(), M = new e.Vector3().addVectors(y, G).normalize(), l = new e.Vector3().addVectors(G, r).normalize();
    a(c + 1, r, h, l), a(c + 1, h, y, M), a(c + 1, l, M, G), a(c + 1, h, M, l);
  }
  for (const c of [-1, 1])
    for (const r of [-1, 1])
      for (const y of [-1, 1]) {
        const G = new e.Vector3(c, 0, 0), h = new e.Vector3(0, r, 0), M = new e.Vector3(0, 0, y);
        a(0, G, h, M);
      }
  const i = Object.values(s), D = new e.Vector3(C, C, E), n = new e.Quaternion(), w = typeof t == "function" ? new e.Color() : t;
  for (const c of i)
    n.setFromUnitVectors(new e.Vector3(0, 0, -1), c), typeof t == "function" && t(w, c), c.multiplyScalar(I), c.add(A), Q.pushSplat(c, D, n, 1, w);
}
function LD({
  // text string to display
  text: Q,
  // browser font to render text with (default: "Arial")
  font: A,
  // font size in pixels/Gsplats (default: 32)
  fontSize: I,
  // SplatMesh.recolor tint assuming white Gsplats (default: white)
  color: g,
  // Individual Gsplat color (default: white)
  rgb: B,
  // Gsplat radius (default: 0.8 covers 1-unit spacing well)
  dotRadius: C,
  // text alignment: "left", "center", "right", "start", "end" (default: "start")
  textAlign: E,
  // line spacing multiplier, lines delimited by "\n" (default: 1.0)
  lineHeight: t
}) {
  A = A ?? "Arial", I = I ?? 32, g = g ?? new e.Color(1, 1, 1), C = C ?? 0.8, E = E ?? "start", t = t ?? 1;
  const s = Q.split(`
`), o = document.createElement("canvas"), a = o.getContext("2d");
  if (!a)
    throw new Error("Failed to create canvas context");
  a.font = `${I}px ${A}`, a.textAlign = E;
  const i = a.measureText(""), D = i.fontBoundingBoxAscent + i.fontBoundingBoxDescent;
  let n = Number.POSITIVE_INFINITY, w = Number.NEGATIVE_INFINITY, c = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY;
  for (let U = 0; U < s.length; ++U) {
    const S = a.measureText(s[U]), T = D * t * U;
    n = Math.min(n, -S.actualBoundingBoxLeft), w = Math.max(w, S.actualBoundingBoxRight), c = Math.min(c, T - S.actualBoundingBoxAscent), r = Math.max(r, T + S.actualBoundingBoxDescent);
  }
  const y = Math.floor(n), G = Math.floor(c), h = Math.ceil(w) - y, M = Math.ceil(r) - G;
  o.width = h, o.height = M, a.font = `${I}px ${A}`, a.textAlign = E, a.textBaseline = "alphabetic", a.fillStyle = "#FFFFFF";
  for (let U = 0; U < s.length; ++U) {
    const S = D * t * U - G;
    a.fillText(s[U], -y, S);
  }
  const l = a.getImageData(0, 0, h, M), k = new Uint8Array(l.data.buffer), R = new fA(), Y = new e.Vector3(), d = new e.Vector3().setScalar(C), m = new e.Quaternion(0, 0, 0, 1);
  B = B ?? new e.Color(1, 1, 1);
  let J = 0;
  for (let U = 0; U < M; ++U)
    for (let S = 0; S < h; ++S) {
      const T = k[J + 3];
      if (T > 0) {
        const V = T / 255;
        Y.set(S - 0.5 * (h - 1), 0.5 * (M - 1) - U, 0), R.pushSplat(Y, d, m, V, B);
      }
      J += 4;
    }
  const x = new OA({ packedSplats: R });
  return x.recolor = g, x;
}
function pD({
  // URL of the image to convert to splats (example: `url: "./image.png"`)
  url: Q,
  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)
  dotRadius: A,
  // Subsampling factor for the image. Higher values reduce resolution,
  // for example 2 will halve the width and height by averaging (default: 1)
  subXY: I,
  // Optional callback function to modify each Gsplat before it's added.
  // Return null to skip adding the Gsplat, or a number to set the opacity
  // and add the Gsplat with parameter values in the objects center, rgba etc. were
  // passed into the forEachSplat callback. Ending the callback in `return opacity;`
  // will retain the original opacity.
  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)
  forEachSplat: g
}) {
  return A = A ?? 0.8, I = Math.max(1, Math.floor(I ?? 1)), new OA({
    constructSplats: async (B) => new Promise((C, E) => {
      const t = new Image();
      t.onerror = E, t.onload = () => {
        const { width: s, height: o } = t, a = document.createElement("canvas");
        a.width = s, a.height = o;
        const i = a.getContext("2d");
        if (!i) {
          E(new Error("Failed to create canvas context"));
          return;
        }
        i.imageSmoothingEnabled = !0, i.imageSmoothingQuality = "high";
        const D = Math.round(s / I), n = Math.round(o / I);
        i.drawImage(t, 0, 0, D, n);
        try {
          const w = i.getImageData(0, 0, D, n), c = new Uint8Array(w.data.buffer), r = new e.Vector3(), y = new e.Vector3().setScalar(A), G = new e.Quaternion(0, 0, 0, 1), h = new e.Color();
          let M = 0;
          for (let l = 0; l < n; ++l)
            for (let k = 0; k < D; ++k) {
              const R = M * 4, Y = c[R + 3];
              if (Y > 0) {
                let d = Y / 255;
                h.set(
                  c[R + 0] / 255,
                  c[R + 1] / 255,
                  c[R + 2] / 255
                ), r.set(
                  k - 0.5 * (D - 1),
                  0.5 * (n - 1) - l,
                  0
                ), y.setScalar(A), G.set(0, 0, 0, 1);
                let m = !0;
                if (g) {
                  const J = g(
                    D,
                    n,
                    M,
                    r,
                    y,
                    G,
                    d,
                    h
                  );
                  d = J ?? d, m = J !== null;
                }
                m && B.pushSplat(r, y, G, d, h);
              }
              M += 1;
            }
          C();
        } catch (w) {
          E(w);
        }
      }, t.src = Q;
    })
  });
}
function Pe({
  box: Q,
  cells: A,
  dotScale: I,
  color: g,
  opacity: B
}) {
  A.x = Math.max(1, Math.round(A.x)), A.y = Math.max(1, Math.round(A.y)), A.z = Math.max(1, Math.round(A.z)), B = B ?? 1;
  const C = A.x * A.y * A.z, E = q("int", A.x), t = q("int", A.y);
  q("int", A.z);
  const s = LA(0), o = new iI({
    numSplats: C,
    generator: UA(
      { index: "int" },
      { gsplat: v },
      ({ index: i }) => {
        if (!i)
          throw new Error("index is undefined");
        const D = GI(i, E), n = jQ(i, E), w = GI(n, t), c = jQ(n, t), r = HA({
          vectorType: "ivec3",
          x: D,
          y: w,
          z: c
        }), y = GC(s), G = HA({ vectorType: "ivec2", x: i, y }), h = NE(G), M = q("vec3", Q.min), l = q("vec3", Q.max), k = UQ(l, M), R = jQ(cA(EQ(r), h), q("vec3", A));
        let Y, d, m;
        g ? (Y = q("float", g.r), d = q("float", g.g), m = q("float", g.b)) : { r: Y, g: d, b: m } = JQ(R).outputs;
        const J = HA({
          vectorType: "vec4",
          r: Y,
          g: d,
          b: m,
          a: q("float", B)
        }), x = cA(M, BA(k, R)), U = EQ(q("float", I)), S = q("vec4", new e.Quaternion(0, 0, 0, 1));
        let T = rQ({
          flags: OQ("uint", "GSPLAT_FLAG_ACTIVE"),
          index: i,
          center: x,
          scales: U,
          quaternion: S,
          rgba: J
        });
        return T = a.modify(T), { gsplat: T };
      },
      {
        globals: () => [rA]
      }
    ),
    update: ({ time: i }) => {
      s.value = i, a.update(o), o.updateVersion();
    }
  }), a = new nQ();
  return o;
}
const _e = {
  box: new e.Box3(
    new e.Vector3(-1, -1, -1),
    new e.Vector3(1, 1, 1)
  ),
  density: 100,
  fallDirection: new e.Vector3(-1, -3, 1).normalize(),
  fallVelocity: 0.02,
  wanderScale: 0.04,
  wanderVariance: 2,
  color1: new e.Color(1, 1, 1),
  color2: new e.Color(0.5, 0.5, 1),
  minScale: 1e-3,
  maxScale: 5e-3,
  anisoScale: new e.Vector3(1, 1, 1)
}, $e = {
  box: new e.Box3(
    new e.Vector3(-2, -1, -2),
    new e.Vector3(2, 5, 2)
  ),
  density: 10,
  fallDirection: new e.Vector3(0, -1, 0),
  fallVelocity: 2,
  wanderScale: 0.1,
  wanderVariance: 1,
  color1: new e.Color(1, 1, 1),
  color2: new e.Color(0.25, 0.25, 0.5),
  minScale: 5e-3,
  maxScale: 0.01,
  anisoScale: new e.Vector3(0.1, 1, 0.1)
};
function AD({
  // min and max box extents of the snowBox
  box: Q,
  // minimum y-coordinate to clamp particle position, which can be used to
  // fake hitting a ground plane and lingering there for a bit
  minY: A,
  // number of Gsplats to generate (default: calculated from box and density)
  numSplats: I,
  // density of Gsplats per unit volume (default: 100)
  density: g,
  // The xyz anisotropic scale of the Gsplat, which can be used for example
  // to elongate rain particles (default: (1, 1, 1))
  anisoScale: B,
  // Minimum Gsplat particle scale (default: 0.001)
  minScale: C,
  // Maximum Gsplat particle scale (default: 0.005)
  maxScale: E,
  // The average direction of fall (default: (0, -1, 0))
  fallDirection: t,
  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)
  fallVelocity: s,
  // The world scale of wandering overlay motion (default: 0.01)
  wanderScale: o,
  // Controls how uniformly the particles wander in sync, more variance mean
  // more randomness in the motion (default: 2)
  wanderVariance: a,
  // Color 1 of the two colors interpolated between (default: (1, 1, 1))
  color1: i,
  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))
  color2: D,
  // The base opacity of the Gsplats (default: 1)
  opacity: n,
  // Optional callback function to call each frame.
  onFrame: w
}) {
  Q = Q ?? new e.Box3(new e.Vector3(-1, -1, -1), new e.Vector3(1, 1, 1));
  const c = (Q.max.x - Q.min.x) * (Q.max.y - Q.min.y) * (Q.max.z - Q.min.z);
  g = g ?? 100, I = I ?? Math.max(1, Math.min(1e6, Math.round(c * g)));
  const r = LA(C ?? 1e-3), y = LA(E ?? 5e-3), G = vA(
    ((B == null ? void 0 : B.clone()) ?? new e.Vector3(1, 1, 1)).normalize()
  ), h = vA(
    (t ?? new e.Vector3(0, -1, 0)).normalize()
  ), M = LA(s ?? 0.02), l = LA(o ?? 0.01), k = LA(a ?? 2), R = vA(i ?? new e.Color(1, 1, 1)), Y = vA(D ?? new e.Color(0.5, 0.5, 1)), d = LA(n ?? 1), m = LA(0), J = vA(new e.Vector3(0, 0, 0)), x = vA(Q.min), U = vA(Q.max), S = LA(A ?? Number.NEGATIVE_INFINITY), T = UQ(U, x), V = new iI({
    numSplats: I,
    generator: UA(
      { index: "int" },
      { gsplat: v },
      ({ index: _ }) => {
        if (!_)
          throw new Error("index not defined");
        const X = lI(_), aA = JQ(X).outputs.w;
        let $ = EQ(X), iA = zQ(BA(aA, q("float", 100)));
        iA = MI(BA(OQ("float", "PI"), iA)), iA = cA(r, BA(iA, UQ(y, r)));
        const eA = BA(iA, G), YA = zQ(BA(aA, q("float", 10))), hA = zQ(aA), DA = kB(R, Y, hA), L = BA(DA, YA), yA = lI(
          HA({
            vectorType: "ivec2",
            x: _,
            y: q("int", 6837)
          })
        );
        let gA = EQ(yA), GA = BA(JQ(yA).outputs.w, k);
        GA = cA(m, GA), $ = cA($, J);
        const lA = MB(
          $,
          q("vec3", new e.Vector3(1, 1, 1))
        );
        $ = cA(x, BA(T, lA));
        const SA = q("vec4", new e.Quaternion(0, 0, 0, 1));
        gA = MI(cA(EQ(GA), gA)), gA = BA(gA, l);
        let MA = cA($, gA), bA = JQ(MA).outputs.y;
        bA = NB(S, bA), MA = HA({ vector: MA, y: bA });
        let NA = rQ({
          flags: OQ("uint", "GSPLAT_FLAG_ACTIVE"),
          index: _,
          center: MA,
          scales: eA,
          quaternion: SA,
          rgb: L,
          opacity: d
        });
        return NA = P.modify(NA), { gsplat: NA };
      },
      {
        globals: () => [rA]
      }
    ),
    update: ({ object: _, time: X, deltaTime: aA }) => {
      m.value = X, P.update(V);
      const $ = h.value.clone().multiplyScalar(M.value * aA);
      J.value.add($), _.visible = d.value > 0, w == null || w({ object: _, time: X, deltaTime: aA }), V.updateVersion();
    }
  }), P = new nQ();
  return {
    snow: V,
    min: x,
    max: U,
    minY: S,
    color1: R,
    color2: Y,
    opacity: d,
    fallVelocity: M,
    wanderVariance: k,
    wanderScale: l,
    fallDirection: h,
    minScale: r,
    maxScale: y,
    anisoScale: G
  };
}
const HD = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_RAIN: $e,
  DEFAULT_SNOW: _e,
  snowBox: AD,
  staticBox: Pe
}, Symbol.toStringTag, { value: "Module" })), YQ = class YQ {
  static createButton(A, I = {}) {
    const g = navigator.xr;
    if (!g)
      return null;
    const B = g, C = document.createElement("button");
    A.xr.enabled = !0, A.xr.setReferenceSpaceType("local");
    function E() {
      let i = null;
      async function D(c) {
        console.log("onSessionStarted"), c.addEventListener("end", n), await A.xr.setSession(c), C.textContent = "EXIT VR", i = c;
      }
      function n() {
        console.log("onSessionEnded"), i == null || i.removeEventListener("end", n), C.textContent = "ENTER VR", i = null;
      }
      C.style.display = "", C.style.cursor = "pointer", C.style.left = "calc(50% - 100px)", C.style.width = "200px", C.style.height = "100px", C.textContent = "ENTER VR";
      const w = {
        ...I,
        optionalFeatures: [
          // "local-floor",
          // "bounded-floor",
          // "layers",
          ...I.optionalFeatures || []
        ]
      };
      C.onmouseenter = () => {
        C.style.opacity = "1.0";
      }, C.onmouseleave = () => {
        C.style.opacity = "0.5";
      }, C.onclick = () => {
        i === null ? (console.log("requesting session"), B.requestSession("immersive-vr", w).then(
          D
        )) : (console.log("ending session"), i.end());
      };
    }
    function t() {
      C.style.display = "none", C.style.cursor = "auto", C.style.left = "calc(50% - 75px)", C.style.width = "150px", C.onmouseenter = null, C.onmouseleave = null, C.onclick = null;
    }
    function s() {
      t(), C.textContent = "VR NOT SUPPORTED";
    }
    function o(i) {
      t(), console.warn(
        "Exception when trying to call xr.isSessionSupported",
        i
      ), C.textContent = "VR NOT ALLOWED";
    }
    function a(i) {
      i.style.position = "absolute", i.style.bottom = "20px", i.style.padding = "12px 6px", i.style.border = "1px solid #fff", i.style.borderRadius = "4px", i.style.background = "rgba(0,0,0,0.1)", i.style.color = "#fff", i.style.font = "normal 13px sans-serif", i.style.textAlign = "center", i.style.opacity = "0.5", i.style.outline = "none", i.style.zIndex = "999";
    }
    return C.id = "VRButton", C.style.display = "none", a(C), B.isSessionSupported("immersive-vr").then((i) => {
      i ? E() : s(), i && YQ.xrSessionIsGranted && C.click();
    }).catch(o), C;
  }
  static registerSessionGrantedListener() {
    const A = navigator.xr;
    if (!A)
      return null;
    const I = A;
    /WebXRViewer\//i.test(navigator.userAgent) || I.addEventListener("sessiongranted", () => {
      YQ.xrSessionIsGranted = !0;
    });
  }
};
YQ.xrSessionIsGranted = !1;
let YI = YQ;
YI.registerSessionGrantedListener();
const QD = 0.5, ID = 0.5, gD = 0;
var bI = /* @__PURE__ */ ((Q) => (Q.w = "wrist", Q.t0 = "thumb-metacarpal", Q.t1 = "thumb-phalanx-proximal", Q.t2 = "thumb-phalanx-distal", Q.t3 = "thumb-tip", Q.i0 = "index-finger-metacarpal", Q.i1 = "index-finger-phalanx-proximal", Q.i2 = "index-finger-phalanx-intermediate", Q.i3 = "index-finger-phalanx-distal", Q.i4 = "index-finger-tip", Q.m0 = "middle-finger-metacarpal", Q.m1 = "middle-finger-phalanx-proximal", Q.m2 = "middle-finger-phalanx-intermediate", Q.m3 = "middle-finger-phalanx-distal", Q.m4 = "middle-finger-tip", Q.r0 = "ring-finger-metacarpal", Q.r1 = "ring-finger-phalanx-proximal", Q.r2 = "ring-finger-phalanx-intermediate", Q.r3 = "ring-finger-phalanx-distal", Q.r4 = "ring-finger-tip", Q.p0 = "pinky-finger-metacarpal", Q.p1 = "pinky-finger-phalanx-proximal", Q.p2 = "pinky-finger-phalanx-intermediate", Q.p3 = "pinky-finger-phalanx-distal", Q.p4 = "pinky-finger-tip", Q))(bI || {});
const wt = Object.keys(bI), fD = wt.length, mD = {
  w: 0,
  t0: 1,
  t1: 2,
  t2: 3,
  t3: 4,
  i0: 5,
  i1: 6,
  i2: 7,
  i3: 8,
  i4: 9,
  m0: 10,
  m1: 11,
  m2: 12,
  m3: 13,
  m4: 14,
  r0: 15,
  r1: 16,
  r2: 17,
  r3: 18,
  r4: 19,
  p0: 20,
  p1: 21,
  p2: 22,
  p3: 23,
  p4: 24
}, WQ = {
  w: 0.02,
  t0: 0.02,
  t1: 0.014,
  t2: 0.0115,
  t3: 85e-4,
  i0: 0.022,
  i1: 0.012,
  i2: 85e-4,
  i3: 75e-4,
  i4: 65e-4,
  m0: 0.021,
  m1: 0.012,
  m2: 8e-3,
  m3: 75e-4,
  m4: 65e-4,
  r0: 0.019,
  r1: 0.011,
  r2: 75e-4,
  r3: 7e-3,
  r4: 6e-3,
  p0: 0.012,
  p1: 0.01,
  p2: 7e-3,
  p3: 65e-4,
  p4: 55e-4
}, BD = [
  ["w", "t0", "t1", "t2", "t3"],
  ["w", "i0", "i1", "i2", "i3", "i4"],
  ["w", "m0", "m1", "m2", "m3", "m4"],
  ["w", "r0", "r1", "r2", "r3", "r4"],
  ["w", "p0", "p1", "p2", "p3", "p4"]
], CD = [
  [8, 10, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6]
], bD = ["t3", "i4", "m4", "r4", "p4"], xD = ["i4", "m4", "r4", "p4"];
var rt = /* @__PURE__ */ ((Q) => (Q.left = "left", Q.right = "right", Q))(rt || {});
const dI = Object.keys(rt);
class KD {
  constructor() {
    this.hands = {}, this.last = {}, this.values = {}, this.tests = {}, this.lastTests = {}, this.updated = !1;
  }
  update({ xr: A, xrFrame: I }) {
    const g = A.getSession();
    if (!g)
      return;
    const B = A.getReferenceSpace();
    if (B && I.getJointPose) {
      this.last = this.hands, this.lastTests = this.tests, this.hands = {}, this.values = {}, this.tests = {};
      for (const C of g.inputSources) {
        if (!C.hand)
          continue;
        const E = C.handedness;
        this.hands[E] = {};
        for (const t of wt) {
          const s = C.hand.get(bI[t]);
          if (s) {
            const o = I.getJointPose(s, B);
            if (o) {
              const { position: a, orientation: i } = o.transform;
              this.hands[E][t] = {
                position: new uA(a.x, a.y, a.z),
                quaternion: new xI(
                  i.x,
                  i.y,
                  i.z,
                  i.w
                ),
                radius: o.radius || 1e-3
              };
            }
          }
        }
      }
      for (const C of dI)
        for (const { key: E, value: t } of [
          { key: `${C}AllTips`, value: this.allTipsTouching(C) },
          {
            key: `${C}IndexThumb`,
            value: this.touching(C, "i4", C, "t3")
          },
          {
            key: `${C}MiddleThumb`,
            value: this.touching(C, "m4", C, "t3")
          },
          {
            key: `${C}RingThumb`,
            value: this.touching(C, "r4", C, "t3")
          },
          {
            key: `${C}PinkyThumb`,
            value: this.touching(C, "p4", C, "t3")
          },
          { key: `${C}TriTips`, value: this.triTipsTouching(C) }
        ])
          this.values[E] = t, this.tests[E] = t === 1 ? !0 : t === 0 ? !1 : this.lastTests[E] ?? !1;
    }
  }
  makeGhostMesh() {
    const A = new uA(), I = new uA(0.01, 0.01, 0.01), g = new xI(0, 0, 0, 1), B = new KI(1, 1, 1), C = Math.PI * 3, E = new KI(1, 1, 1);
    let t = 1;
    const s = new OA({
      onFrame: () => {
        let o = 0;
        for (const a of dI) {
          const i = this.values[`${a}MiddleThumb`], D = this.hands[a];
          for (const [n, w] of BD.entries())
            for (let c = 1; c < w.length; ++c) {
              const r = CD[n][c - 1] * 2, y = c + 1 === w.length, G = D == null ? void 0 : D[w[c - 1]], h = D == null ? void 0 : D[w[c]];
              for (let M = 0; M < r; ++M) {
                const l = (M + 0.5) / r;
                if (t = 0, G && h) {
                  A.copy(G.position).lerp(h.position, l), g.copy(G.quaternion).slerp(h.quaternion, l);
                  const k = WQ[w[c - 1]], R = WQ[w[c]];
                  let Y = (1 - l) * k + l * R;
                  y && l > 0.8 && (Y *= Math.sqrt(1 - ((l - 0.8) / 0.2) ** 2)), I.set(0.65 * Y, 0.5 * Y, 3e-3), B.set(
                    0.55 + 0.45 * Math.sin(A.x * C),
                    0.55 + 0.45 * Math.sin(A.y * C),
                    0.55 + 0.45 * Math.sin(A.z * C)
                  ), a === "right" && B.set(1 - B.r, 1 - B.g, 1 - B.b), B.lerp(E, i), t = 0.75;
                }
                s.packedSplats.setSplat(
                  o,
                  A,
                  I,
                  g,
                  t,
                  B
                ), o += 1;
              }
            }
        }
        s.packedSplats.numSplats = o, s.packedSplats.needsUpdate = !0, s.numSplats = o;
      }
    });
    return s;
  }
  distance(A, I, g, B, C = !1) {
    const E = C ? this.last[A] : this.hands[A], t = C ? this.last[g] : this.hands[g], s = E == null ? void 0 : E[I], o = t == null ? void 0 : t[B];
    return !s || !o ? Number.POSITIVE_INFINITY : s.position.distanceTo(o.position);
  }
  separation(A, I, g, B, C = !1) {
    const E = this.distance(A, I, g, B, C);
    return E === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : E - WQ[I] - WQ[B];
  }
  touching(A, I, g, B, C = !1) {
    const E = this.separation(A, I, g, B, C);
    return E === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : 1 - Math.max(0, Math.min(1, E / 0.01 - gD));
  }
  allTipsTouching(A, I = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", I),
      this.touching(A, "i4", A, "m4", I),
      this.touching(A, "m4", A, "r4", I),
      this.touching(A, "r4", A, "p4", I)
      // this.touching(hand, "p4", hand, "t3", last),
    );
  }
  triTipsTouching(A, I = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", I),
      this.touching(A, "i4", A, "m4", I),
      this.touching(A, "m4", A, "t3", I)
    );
  }
}
class ZD {
  constructor({
    xrHands: A,
    control: I,
    moveInertia: g,
    rotateInertia: B
  }) {
    this.lastGrip = {}, this.lastPivot = new uA(), this.rotateVelocity = 0, this.velocity = new uA(), this.xrHands = A, this.control = I, this.moveInertia = g ?? QD, this.rotateInertia = B ?? ID;
  }
  update(A) {
    var C, E, t, s, o;
    const I = {};
    for (const a of dI) {
      const i = this.xrHands.hands[a];
      i && this.xrHands.tests[`${a}MiddleThumb`] && (I[a] = new uA().add(((C = i.t3) == null ? void 0 : C.position) ?? new uA()).add(((E = i.i4) == null ? void 0 : E.position) ?? new uA()).add(((t = i.m4) == null ? void 0 : t.position) ?? new uA()).add(((s = i.r4) == null ? void 0 : s.position) ?? new uA()).add(((o = i.p4) == null ? void 0 : o.position) ?? new uA()).multiplyScalar(1 / 5));
    }
    if (I.left && I.right && this.lastGrip.left && this.lastGrip.right) {
      const a = I.left.clone().add(I.right).multiplyScalar(0.5), i = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);
      this.lastPivot = a;
      const D = a.clone().applyMatrix4(this.control.matrix);
      D.sub(i.clone().applyMatrix4(this.control.matrix)), D.multiplyScalar(1 / A), this.velocity.lerp(D, 1 - Math.exp(-20 * A));
      const n = Math.atan2(I.left.z - a.z, I.left.x - a.x), w = Math.atan2(
        this.lastGrip.left.z - i.z,
        this.lastGrip.left.x - i.x
      );
      let c = n - w;
      c > Math.PI ? c -= Math.PI * 2 : c < -Math.PI && (c += Math.PI * 2);
      const r = c / A, y = Math.exp(-20 * A);
      this.rotateVelocity = this.rotateVelocity * y + r * (1 - y);
    } else if (this.rotateVelocity *= Math.exp(-A / this.rotateInertia), I.left && this.lastGrip.left) {
      const a = I.left.clone().applyMatrix4(this.control.matrix);
      a.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)), a.multiplyScalar(1 / A), this.velocity.lerp(a, 1 - Math.exp(-20 * A));
    } else if (I.right && this.lastGrip.right) {
      const a = I.right.clone().applyMatrix4(this.control.matrix);
      a.sub(
        this.lastGrip.right.clone().applyMatrix4(this.control.matrix)
      ), a.multiplyScalar(1 / A), this.velocity.lerp(a, 1 - Math.exp(-20 * A));
    } else
      this.velocity.multiplyScalar(Math.exp(-A / this.moveInertia));
    const g = this.lastPivot.clone().negate(), B = new sI().makeTranslation(g).premultiply(new sI().makeRotationY(this.rotateVelocity * A)).premultiply(new sI().makeTranslation(this.lastPivot));
    this.control.matrix.multiply(B), this.control.matrix.decompose(
      this.control.position,
      this.control.quaternion,
      this.control.scale
    ), this.control.updateMatrixWorld(!0), this.control.position.sub(this.velocity.clone().multiplyScalar(A)), this.lastGrip = I;
  }
}
const ED = 1, tD = 2, iD = 2e-3, sD = 6e-3, oD = 15e-4, aD = 0.15, eD = 0.15, DD = 0.1, nD = 2, cD = 200, wD = 400, rD = 50, hD = {
  KeyW: new e.Vector3(0, 0, -1),
  KeyS: new e.Vector3(0, 0, 1),
  KeyA: new e.Vector3(-1, 0, 0),
  KeyD: new e.Vector3(1, 0, 0),
  KeyR: new e.Vector3(0, 1, 0),
  KeyF: new e.Vector3(0, -1, 0)
}, yD = {
  ArrowUp: new e.Vector3(0, 0, -1),
  ArrowDown: new e.Vector3(0, 0, 1),
  ArrowLeft: new e.Vector3(-1, 0, 0),
  ArrowRight: new e.Vector3(1, 0, 0),
  PageUp: new e.Vector3(0, 1, 0),
  PageDown: new e.Vector3(0, -1, 0)
}, GD = {
  KeyQ: new e.Vector3(0, 0, 1),
  KeyE: new e.Vector3(0, 0, -1)
}, lD = {
  Home: new e.Vector3(0, -1, 0),
  End: new e.Vector3(0, 1, 0),
  Insert: new e.Vector3(-1, 0, 0),
  Delete: new e.Vector3(1, 0, 0)
};
class qD {
  constructor({ canvas: A }) {
    this.lastTime = 0, this.fpsMovement = new MD({}), this.pointerControls = new ND({ canvas: A });
  }
  update(A) {
    const I = performance.now(), g = (I - (this.lastTime || I)) / 1e3;
    this.lastTime = I, this.fpsMovement.update(g, A), this.pointerControls.update(g, A);
  }
}
class MD {
  constructor({
    moveSpeed: A,
    rollSpeed: I,
    stickThreshold: g,
    rotateSpeed: B,
    keycodeMoveMapping: C,
    keycodeRotateMapping: E,
    gamepadMapping: t,
    capsMultiplier: s,
    shiftMultiplier: o,
    ctrlMultiplier: a,
    xr: i
  } = {}) {
    this.enable = !0, this.moveSpeed = A ?? ED, this.rollSpeed = I ?? tD, this.stickThreshold = g ?? DD, this.rotateSpeed = B ?? nD, this.keycodeMoveMapping = C ?? {
      ...hD,
      ...yD
    }, this.keycodeRotateMapping = E ?? {
      ...GD,
      ...lD
    }, this.gamepadMapping = t ?? {
      4: "rollLeft",
      5: "rollRight",
      6: "ctrl",
      7: "shift"
    }, this.capsMultiplier = s ?? 10, this.shiftMultiplier = o ?? 5, this.ctrlMultiplier = a ?? 1 / 5, this.xr = i, this.keydown = {}, this.keycode = {}, document.addEventListener("keydown", (D) => {
      this.keydown[D.key] = !0, this.keycode[D.code] = !0;
    }), document.addEventListener("keyup", (D) => {
      this.keydown[D.key] = !1, this.keycode[D.code] = !1;
    });
  }
  // Call this method in your render loop with `control` set to the object to control
  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`
  // in seconds since the last update.
  update(A, I) {
    var a, i;
    if (!this.enable)
      return;
    const g = [new e.Vector2(), new e.Vector2()], B = navigator.getGamepads()[0];
    B && (g[0].set(B.axes[0], B.axes[1]), g[1].set(B.axes[2], B.axes[3]));
    const C = (B == null ? void 0 : B.buttons.map((D) => D.pressed)) || [], E = Array.from(((i = (a = this.xr) == null ? void 0 : a.getSession()) == null ? void 0 : i.inputSources) ?? []);
    for (const D of E) {
      const n = D.gamepad;
      if (n)
        switch (D.handedness) {
          case "none": {
            g[0].x += n.axes[0], g[0].y += n.axes[1], g[1].x += n.axes[2], g[1].y += n.axes[3];
            break;
          }
          case "left": {
            g[0].x += n.axes[2], g[0].y += n.axes[3];
            break;
          }
          case "right": {
            g[1].x += n.axes[2], g[1].y += n.axes[3];
            break;
          }
        }
    }
    for (const D of g)
      D.x = Math.abs(D.x) >= this.stickThreshold ? D.x : 0, D.y = Math.abs(D.y) >= this.stickThreshold ? D.y : 0;
    const t = new e.Vector3(
      g[1].x,
      g[1].y,
      0
    ).multiplyScalar(this.rotateSpeed);
    for (const [D, n] of Object.entries(this.keycodeRotateMapping))
      this.keycode[D] && t.add(n);
    for (const D in this.gamepadMapping)
      if (C[Number.parseInt(D)])
        switch (this.gamepadMapping[D]) {
          case "rollLeft":
            t.z += 1;
            break;
          case "rollRight":
            t.z -= 1;
            break;
        }
    if (t.multiply(
      new e.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)
    ), t.manhattanLength() > 0) {
      t.multiplyScalar(A);
      const D = new e.Euler().setFromQuaternion(
        I.quaternion,
        "YXZ"
      );
      D.y -= t.x, D.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, D.x - t.y)
      ), D.z = Math.max(-Math.PI, Math.min(Math.PI, D.z + t.z)), I.quaternion.setFromEuler(D);
    }
    const s = new e.Vector3(g[0].x, 0, g[0].y);
    for (const [D, n] of Object.entries(this.keycodeMoveMapping))
      this.keycode[D] && s.add(n);
    let o = 1;
    this.keydown.CapsLock && (o *= this.capsMultiplier), (this.keycode.ShiftLeft || this.keycode.ShiftRight) && (o *= this.shiftMultiplier), (this.keycode.ControlLeft || this.keycode.ControlRight) && (o *= this.ctrlMultiplier);
    for (const D in this.gamepadMapping)
      if (C[Number.parseInt(D)])
        switch (this.gamepadMapping[D]) {
          case "shift":
            o *= this.shiftMultiplier;
            break;
          case "ctrl":
            o *= this.ctrlMultiplier;
            break;
        }
    s.applyQuaternion(I.quaternion), I.position.add(
      s.multiplyScalar(this.moveSpeed * o * A)
    );
  }
}
class ND {
  constructor({
    // The HTML canvas element to attach pointer events to
    canvas: A,
    // Speed of rotation (default DEFAULT_ROTATE_SPEED)
    rotateSpeed: I,
    // Speed of sliding when dragging with right/middle mouse button or two fingers
    // (default DEFAULT_SLIDE_SPEED)
    slideSpeed: g,
    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)
    scrollSpeed: B,
    // Reverse the direction of rotation (default: false)
    reverseRotate: C,
    // Reverse the direction of sliding (default: false)
    reverseSlide: E,
    // Reverse the direction of swipe gestures (default: false)
    reverseSwipe: t,
    // Reverse the direction of scroll wheel movement (default: false)
    reverseScroll: s,
    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)
    moveInertia: o,
    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)
    rotateInertia: a,
    // Callback for double press events (default: () => {})
    doublePress: i
  }) {
    this.enable = !0, this.canvas = A, this.rotateSpeed = I ?? iD, this.slideSpeed = g ?? sD, this.scrollSpeed = B ?? oD, this.reverseRotate = C ?? !1, this.reverseSlide = E ?? !1, this.reverseSwipe = t ?? !1, this.reverseScroll = s ?? !1, this.moveInertia = o ?? eD, this.rotateInertia = a ?? aD, this.doublePress = i ?? (() => {
    }), this.doublePressLimitMs = wD, this.doublePressDistance = rD, this.lastUp = null, this.rotating = null, this.sliding = null, this.dualPress = !1, this.scroll = new e.Vector3(), this.rotateVelocity = new e.Vector3(), this.moveVelocity = new e.Vector3(), A.addEventListener("pointerdown", (n) => {
      const w = this.getPointerPosition(n), c = w.clone(), r = w.clone(), y = !this.rotating && (n.pointerType !== "mouse" || n.button === 0), { pointerId: G, timeStamp: h } = n;
      if (y)
        this.rotating = { initial: c, last: r, position: w, pointerId: G, timeStamp: h }, A.setPointerCapture(n.pointerId), this.dualPress = !1;
      else if (!this.sliding) {
        const M = n.pointerType === "mouse" ? n.button : void 0;
        this.sliding = {
          initial: c,
          last: r,
          position: w,
          pointerId: G,
          button: M,
          timeStamp: h
        }, A.setPointerCapture(n.pointerId), this.dualPress = this.rotating != null && h - this.rotating.timeStamp < cD;
      }
    });
    const D = (n) => {
      var r, y;
      ((r = this.rotating) == null ? void 0 : r.pointerId) === n.pointerId ? (this.rotating = null, A.releasePointerCapture(n.pointerId), this.dualPress && this.sliding && (A.releasePointerCapture(this.sliding.pointerId), this.sliding = null)) : ((y = this.sliding) == null ? void 0 : y.pointerId) === n.pointerId && (this.sliding = null, A.releasePointerCapture(n.pointerId), this.dualPress && this.rotating && (A.releasePointerCapture(this.rotating.pointerId), this.rotating = null));
      const w = this.getPointerPosition(n), c = this.lastUp;
      if (this.lastUp = { position: w, time: n.timeStamp }, c && c.position.distanceTo(w) < this.doublePressDistance) {
        const h = n.timeStamp - c.time;
        h < this.doublePressLimitMs && (this.lastUp = null, this.doublePress({ position: w, intervalMs: h }));
      }
    };
    document.addEventListener("pointerup", D), document.addEventListener("pointercancel", D), document.addEventListener("pointermove", (n) => {
      var w, c;
      ((w = this.rotating) == null ? void 0 : w.pointerId) === n.pointerId ? this.rotating.position = this.getPointerPosition(n) : ((c = this.sliding) == null ? void 0 : c.pointerId) === n.pointerId && (this.sliding.position = this.getPointerPosition(n));
    }), A.addEventListener("contextmenu", (n) => {
      n.preventDefault();
    }), A.addEventListener("wheel", (n) => {
      this.scroll.add(
        new e.Vector3(n.deltaX, n.deltaY, n.deltaZ)
      ), n.preventDefault();
    });
  }
  getPointerPosition(A) {
    const I = this.canvas.getBoundingClientRect();
    return new e.Vector2(
      A.clientX - I.left,
      A.clientY - I.top
    );
  }
  update(A, I) {
    if (!this.enable)
      return;
    if (this.dualPress && this.rotating && this.sliding) {
      const B = [
        this.rotating.position.clone().sub(this.rotating.last),
        this.sliding.position.clone().sub(this.sliding.last)
      ], C = B[0].dot(B[1]);
      if (C >= 0.2) {
        const E = B[0].clone().add(B[1]), t = new e.Vector3(E.x, -E.y, 0);
        t.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1)), t.applyQuaternion(I.quaternion), I.position.add(t), this.moveVelocity = t.clone().multiplyScalar(1 / A);
      } else if (C <= -0.2) {
        const E = this.sliding.last.clone().sub(this.rotating.last), t = E.length();
        E.multiplyScalar(1 / t).normalize();
        const s = new e.Vector2(-E.y, E.x), o = [B[0].dot(E), B[1].dot(E)], a = [B[0].dot(s), B[1].dot(s)], i = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);
        let D = new e.Vector3();
        if (I instanceof e.Camera) {
          const G = new e.Vector2(
            i.x / this.canvas.clientWidth * 2 - 1,
            -(i.y / this.canvas.clientHeight) * 2 + 1
          ), h = new e.Raycaster();
          h.setFromCamera(G, I), D = h.ray.direction;
        }
        const n = o[1] - o[0], w = D.multiplyScalar(n * this.slideSpeed);
        I.position.add(w), this.moveVelocity = w.clone().multiplyScalar(1 / A);
        const c = [
          Math.atan(a[0] / (-0.5 * t)),
          Math.atan(a[1] / (0.5 * t))
        ], r = 0.5 * (c[0] + c[1]), y = new e.Euler().setFromQuaternion(
          I.quaternion,
          "YXZ"
        );
        y.z = Math.max(
          -Math.PI,
          Math.min(Math.PI, y.z + 0.5 * r)
        ), I.quaternion.setFromEuler(y);
      }
      this.rotating.last.copy(this.rotating.position), this.sliding.last.copy(this.sliding.position);
    } else {
      const B = new e.Vector3();
      if (this.rotating && !this.dualPress) {
        const E = this.rotating.position.clone().sub(this.rotating.last);
        this.rotating.last.copy(this.rotating.position), B.set(E.x, E.y, 0), B.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1)), this.rotateVelocity = B.clone().multiplyScalar(1 / A);
      } else
        this.rotateVelocity.multiplyScalar(
          Math.exp(-A / this.rotateInertia)
        ), B.addScaledVector(this.rotateVelocity, A);
      const C = new e.Euler().setFromQuaternion(
        I.quaternion,
        "YXZ"
      );
      if (C.y -= B.x, C.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, C.x - B.y)
      ), C.z *= Math.exp(-0 * A), I.quaternion.setFromEuler(C), this.sliding && !this.dualPress) {
        const E = this.sliding.position.clone().sub(this.sliding.last);
        this.sliding.last.copy(this.sliding.position);
        const t = this.sliding.button !== 2 ? new e.Vector3(E.x, 0, E.y) : new e.Vector3(E.x, -E.y, 0);
        t.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1)), t.applyQuaternion(I.quaternion), I.position.add(t), this.moveVelocity = t.clone().multiplyScalar(1 / A);
      } else
        this.moveVelocity.multiplyScalar(
          Math.exp(-A / this.moveInertia)
        ), I.position.addScaledVector(this.moveVelocity, A);
    }
    const g = this.scroll.multiplyScalar(this.scrollSpeed);
    g.set(g.x, g.z, g.y), this.reverseScroll && g.multiplyScalar(-1), g.applyQuaternion(I.quaternion), I.position.add(g), this.scroll.set(0, 0, 0);
  }
}
export {
  xD as FINGER_TIPS,
  qD as ForgeControls,
  gI as ForgeRenderer,
  II as ForgeViewpoint,
  MD as FpsMovement,
  dI as HANDS,
  rt as Hand,
  ZD as HandMovement,
  wt as JOINT_IDS,
  mD as JOINT_INDEX,
  WQ as JOINT_RADIUS,
  BD as JOINT_SEGMENTS,
  CD as JOINT_SEGMENT_STEPS,
  bD as JOINT_TIPS,
  bI as JointEnum,
  fD as NUM_JOINTS,
  fA as PackedSplats,
  kI as PlyReader,
  ND as PointerControls,
  $Q as Readback,
  As as Sint8ToFloat,
  DI as SplatAccumulator,
  AI as SplatEdit,
  we as SplatEditRgbaBlendMode,
  he as SplatEditSdf,
  ne as SplatEditSdfType,
  ye as SplatEdits,
  pe as SplatFileType,
  iI as SplatGenerator,
  JD as SplatLoader,
  OA as SplatMesh,
  le as SplatModifier,
  dD as SplatSkinning,
  nQ as SplatTransformer,
  YD as SpzReader,
  $i as Uint8ToFloat,
  YI as VRButton,
  KD as XrHands,
  UD as constructAxes,
  uD as constructGrid,
  SD as constructSpherePoints,
  RD as dyno,
  hs as flipPixels,
  XQ as floatToSint8,
  xA as floatToUint8,
  CQ as fromHalf,
  HD as generators,
  He as getSplatFileType,
  pD as imageSplats,
  ws as isAndroid,
  cs as isMobile,
  rs as isOculus,
  ys as pixelsToPngUrl,
  hI as setPackedSplat,
  LD as textSplats,
  BQ as toHalf,
  yI as unpackSplat,
  at as unpackSplats,
  FD as utils
};

import * as u from "three";
import { Mesh as fo, OrthographicCamera as po, BufferGeometry as yo, Float32BufferAttribute as us, Loader as wo, FileLoader as mo, Quaternion as hs, Vector3 as _A, Color as Cs, Matrix4 as De } from "three";
const xo = new po(-1, 1, 1, -1, 0, 1);
class So extends yo {
  constructor() {
    super(), this.setAttribute("position", new us([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)), this.setAttribute("uv", new us([0, 2, 0, 0, 2, 0], 2));
  }
}
const Do = new So();
class xs {
  /**
   * Constructs a new full screen quad.
   *
   * @param {?Material} material - The material to render te full screen quad with.
   */
  constructor(A) {
    this._mesh = new fo(Do, A);
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever the instance is no longer used in your app.
   */
  dispose() {
    this._mesh.geometry.dispose();
  }
  /**
   * Renders the full screen quad.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  render(A) {
    A.render(this._mesh, xo);
  }
  /**
   * The quad's material.
   *
   * @type {?Material}
   */
  get material() {
    return this._mesh.material;
  }
  set material(A) {
    this._mesh.material = A;
  }
}
var uA = Uint8Array, mt = Uint16Array, Mo = Int32Array, Ss = new uA([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), Ds = new uA([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), vo = new uA([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), Ms = function(t, A) {
  for (var e = new mt(31), s = 0; s < 31; ++s)
    e[s] = A += 1 << t[s - 1];
  for (var n = new Mo(e[30]), s = 1; s < 30; ++s)
    for (var i = e[s]; i < e[s + 1]; ++i)
      n[i] = i - e[s] << 5 | s;
  return { b: e, r: n };
}, vs = Ms(Ss, 2), bs = vs.b, bo = vs.r;
bs[28] = 258, bo[258] = 28;
var Fo = Ms(Ds, 0), ko = Fo.b, Ue = new mt(32768);
for (var sA = 0; sA < 32768; ++sA) {
  var At = (sA & 43690) >> 1 | (sA & 21845) << 1;
  At = (At & 52428) >> 2 | (At & 13107) << 2, At = (At & 61680) >> 4 | (At & 3855) << 4, Ue[sA] = ((At & 65280) >> 8 | (At & 255) << 8) >> 1;
}
var Lt = function(t, A, e) {
  for (var s = t.length, n = 0, i = new mt(A); n < s; ++n)
    t[n] && ++i[t[n] - 1];
  var r = new mt(A);
  for (n = 1; n < A; ++n)
    r[n] = r[n - 1] + i[n - 1] << 1;
  var a;
  if (e) {
    a = new mt(1 << A);
    var o = 15 - A;
    for (n = 0; n < s; ++n)
      if (t[n])
        for (var c = n << 4 | t[n], l = A - t[n], g = r[t[n] - 1]++ << l, I = g | (1 << l) - 1; g <= I; ++g)
          a[Ue[g] >> o] = c;
  } else
    for (a = new mt(s), n = 0; n < s; ++n)
      t[n] && (a[n] = Ue[r[t[n] - 1]++] >> 15 - t[n]);
  return a;
}, Pt = new uA(288);
for (var sA = 0; sA < 144; ++sA)
  Pt[sA] = 8;
for (var sA = 144; sA < 256; ++sA)
  Pt[sA] = 9;
for (var sA = 256; sA < 280; ++sA)
  Pt[sA] = 7;
for (var sA = 280; sA < 288; ++sA)
  Pt[sA] = 8;
var Fs = new uA(32);
for (var sA = 0; sA < 32; ++sA)
  Fs[sA] = 5;
var To = /* @__PURE__ */ Lt(Pt, 9, 1), No = /* @__PURE__ */ Lt(Fs, 5, 1), Me = function(t) {
  for (var A = t[0], e = 1; e < t.length; ++e)
    t[e] > A && (A = t[e]);
  return A;
}, JA = function(t, A, e) {
  var s = A / 8 | 0;
  return (t[s] | t[s + 1] << 8) >> (A & 7) & e;
}, ve = function(t, A) {
  var e = A / 8 | 0;
  return (t[e] | t[e + 1] << 8 | t[e + 2] << 16) >> (A & 7);
}, ks = function(t) {
  return (t + 7) / 8 | 0;
}, Mt = function(t, A, e) {
  return (A == null || A < 0) && (A = 0), (e == null || e > t.length) && (e = t.length), new uA(t.subarray(A, e));
}, Uo = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], yA = function(t, A, e) {
  var s = new Error(A || Uo[t]);
  if (s.code = t, Error.captureStackTrace && Error.captureStackTrace(s, yA), !e)
    throw s;
  return s;
}, Ts = function(t, A, e, s) {
  var n = t.length, i = s ? s.length : 0;
  if (!n || A.f && !A.l)
    return e || new uA(0);
  var r = !e, a = r || A.i != 2, o = A.i;
  r && (e = new uA(n * 3));
  var c = function(dA) {
    var xA = e.length;
    if (dA > xA) {
      var CA = new uA(Math.max(xA * 2, dA));
      CA.set(e), e = CA;
    }
  }, l = A.f || 0, g = A.p || 0, I = A.b || 0, h = A.l, Q = A.d, C = A.m, B = A.n, E = n * 8;
  do {
    if (!h) {
      l = JA(t, g, 1);
      var p = JA(t, g + 1, 3);
      if (g += 3, p)
        if (p == 1)
          h = To, Q = No, C = 9, B = 5;
        else if (p == 2) {
          var D = JA(t, g, 31) + 257, x = JA(t, g + 10, 15) + 4, w = D + JA(t, g + 5, 31) + 1;
          g += 14;
          for (var m = new uA(w), T = new uA(19), M = 0; M < x; ++M)
            T[vo[M]] = JA(t, g + M * 3, 7);
          g += x * 3;
          for (var S = Me(T), U = (1 << S) - 1, F = Lt(T, S, 1), M = 0; M < w; ) {
            var b = F[JA(t, g, U)];
            g += b & 15;
            var f = b >> 4;
            if (f < 16)
              m[M++] = f;
            else {
              var N = 0, R = 0;
              for (f == 16 ? (R = 3 + JA(t, g, 3), g += 2, N = m[M - 1]) : f == 17 ? (R = 3 + JA(t, g, 7), g += 3) : f == 18 && (R = 11 + JA(t, g, 127), g += 7); R--; )
                m[M++] = N;
            }
          }
          var O = m.subarray(0, D), _ = m.subarray(D);
          C = Me(O), B = Me(_), h = Lt(O, C, 1), Q = Lt(_, B, 1);
        } else
          yA(1);
      else {
        var f = ks(g) + 4, d = t[f - 4] | t[f - 3] << 8, y = f + d;
        if (y > n) {
          o && yA(0);
          break;
        }
        a && c(I + d), e.set(t.subarray(f, y), I), A.b = I += d, A.p = g = y * 8, A.f = l;
        continue;
      }
      if (g > E) {
        o && yA(0);
        break;
      }
    }
    a && c(I + 131072);
    for (var eA = (1 << C) - 1, H = (1 << B) - 1, W = g; ; W = g) {
      var N = h[ve(t, g) & eA], L = N >> 4;
      if (g += N & 15, g > E) {
        o && yA(0);
        break;
      }
      if (N || yA(2), L < 256)
        e[I++] = L;
      else if (L == 256) {
        W = g, h = null;
        break;
      } else {
        var j = L - 254;
        if (L > 264) {
          var M = L - 257, P = Ss[M];
          j = JA(t, g, (1 << P) - 1) + bs[M], g += P;
        }
        var Z = Q[ve(t, g) & H], G = Z >> 4;
        Z || yA(3), g += Z & 15;
        var _ = ko[G];
        if (G > 3) {
          var P = Ds[G];
          _ += ve(t, g) & (1 << P) - 1, g += P;
        }
        if (g > E) {
          o && yA(0);
          break;
        }
        a && c(I + 131072);
        var fA = I + j;
        if (I < _) {
          var cA = i - _, pA = Math.min(_, fA);
          for (cA + I < 0 && yA(3); I < pA; ++I)
            e[I] = s[cA + I];
        }
        for (; I < fA; ++I)
          e[I] = e[I - _];
      }
    }
    A.l = h, A.p = W, A.b = I, A.f = l, h && (l = 1, A.m = C, A.d = Q, A.n = B);
  } while (!l);
  return I != e.length && r ? Mt(e, 0, I) : e.subarray(0, I);
}, Go = /* @__PURE__ */ new uA(0), HA = function(t, A) {
  return t[A] | t[A + 1] << 8;
}, LA = function(t, A) {
  return (t[A] | t[A + 1] << 8 | t[A + 2] << 16 | t[A + 3] << 24) >>> 0;
}, be = function(t, A) {
  return LA(t, A) + LA(t, A + 4) * 4294967296;
}, Ro = function(t) {
  (t[0] != 31 || t[1] != 139 || t[2] != 8) && yA(6, "invalid gzip data");
  var A = t[3], e = 10;
  A & 4 && (e += (t[10] | t[11] << 8) + 2);
  for (var s = (A >> 3 & 1) + (A >> 4 & 1); s > 0; s -= !t[e++])
    ;
  return e + (A & 2);
}, Fe = /* @__PURE__ */ function() {
  function t(A, e) {
    typeof A == "function" && (e = A, A = {}), this.ondata = e;
    var s = A && A.dictionary && A.dictionary.subarray(-32768);
    this.s = { i: 0, b: s ? s.length : 0 }, this.o = new uA(32768), this.p = new uA(0), s && this.o.set(s);
  }
  return t.prototype.e = function(A) {
    if (this.ondata || yA(5), this.d && yA(4), !this.p.length)
      this.p = A;
    else if (A.length) {
      var e = new uA(this.p.length + A.length);
      e.set(this.p), e.set(A, this.p.length), this.p = e;
    }
  }, t.prototype.c = function(A) {
    this.s.i = +(this.d = A || !1);
    var e = this.s.b, s = Ts(this.p, this.s, this.o);
    this.ondata(Mt(s, e, this.s.b), this.d), this.o = Mt(s, this.s.b - 32768), this.s.b = this.o.length, this.p = Mt(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, t.prototype.push = function(A, e) {
    this.e(A), this.c(e);
  }, t;
}();
function Yo(t, A) {
  return Ts(t, { i: 2 }, A && A.out, A && A.dictionary);
}
var Ns = /* @__PURE__ */ function() {
  function t(A, e) {
    this.v = 1, this.r = 0, Fe.call(this, A, e);
  }
  return t.prototype.push = function(A, e) {
    if (Fe.prototype.e.call(this, A), this.r += A.length, this.v) {
      var s = this.p.subarray(this.v - 1), n = s.length > 3 ? Ro(s) : 4;
      if (n > s.length) {
        if (!e)
          return;
      } else this.v > 1 && this.onmember && this.onmember(this.r - s.length);
      this.p = s.subarray(n), this.v = 0;
    }
    Fe.prototype.c.call(this, e), this.s.f && !this.s.l && !e && (this.v = ks(this.s.p) + 9, this.s = { i: 0 }, this.o = new uA(0), this.push(new uA(0), e));
  }, t;
}(), Ge = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), Jo = 0;
try {
  Ge.decode(Go, { stream: !0 }), Jo = 1;
} catch {
}
var _o = function(t) {
  for (var A = "", e = 0; ; ) {
    var s = t[e++], n = (s > 127) + (s > 223) + (s > 239);
    if (e + n > t.length)
      return { s: A, r: Mt(t, e - 1) };
    n ? n == 3 ? (s = ((s & 15) << 18 | (t[e++] & 63) << 12 | (t[e++] & 63) << 6 | t[e++] & 63) - 65536, A += String.fromCharCode(55296 | s >> 10, 56320 | s & 1023)) : n & 1 ? A += String.fromCharCode((s & 31) << 6 | t[e++] & 63) : A += String.fromCharCode((s & 15) << 12 | (t[e++] & 63) << 6 | t[e++] & 63) : A += String.fromCharCode(s);
  }
};
function Lo(t, A) {
  if (A) {
    for (var e = "", s = 0; s < t.length; s += 16384)
      e += String.fromCharCode.apply(null, t.subarray(s, s + 16384));
    return e;
  } else {
    if (Ge)
      return Ge.decode(t);
    var n = _o(t), i = n.s, e = n.r;
    return e.length && yA(8), i;
  }
}
var zo = function(t, A) {
  return A + 30 + HA(t, A + 26) + HA(t, A + 28);
}, qo = function(t, A, e) {
  var s = HA(t, A + 28), n = Lo(t.subarray(A + 46, A + 46 + s), !(HA(t, A + 8) & 2048)), i = A + 46 + s, r = LA(t, A + 20), a = e && r == 4294967295 ? Ho(t, i) : [r, LA(t, A + 24), LA(t, A + 42)], o = a[0], c = a[1], l = a[2];
  return [HA(t, A + 10), o, c, n, i + HA(t, A + 30) + HA(t, A + 32), l];
}, Ho = function(t, A) {
  for (; HA(t, A) != 1; A += 4 + HA(t, A + 2))
    ;
  return [be(t, A + 12), be(t, A + 4), be(t, A + 20)];
};
function Ko(t, A) {
  for (var e = {}, s = t.length - 22; LA(t, s) != 101010256; --s)
    (!s || t.length - s > 65558) && yA(13);
  var n = HA(t, s + 8);
  if (!n)
    return {};
  var i = LA(t, s + 16), r = i == 4294967295 || n == 65535;
  if (r) {
    var a = LA(t, s - 12);
    r = LA(t, a) == 101075792, r && (n = LA(t, a + 32), i = LA(t, a + 48));
  }
  for (var o = A && A.filter, c = 0; c < n; ++c) {
    var l = qo(t, i, r), g = l[0], I = l[1], h = l[2], Q = l[3], C = l[4], B = l[5], E = zo(t, B);
    i = C, (!o || o({
      name: Q,
      size: I,
      originalSize: h,
      compression: g
    })) && (g ? g == 8 ? e[Q] = Yo(t.subarray(E, E + I), { out: new uA(h) }) : yA(14, "unknown compression type " + g) : e[Q] = Mt(t, E, E + I));
  }
  return e;
}
let OA;
const Us = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && Us.decode();
let Yt = null;
function $o() {
  return (Yt === null || Yt.byteLength === 0) && (Yt = new Uint8Array(OA.memory.buffer)), Yt;
}
function Vo(t, A) {
  return t = t >>> 0, Us.decode($o().subarray(t, t + A));
}
function Po(t, A, e, s, n, i, r, a, o, c, l, g, I) {
  return OA.raycast_splats(t, A, e, s, n, i, r, a, o, c, l, g, I);
}
async function Xo(t, A) {
  if (typeof Response == "function" && t instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(t, A);
      } catch (s) {
        if (t.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", s);
        else
          throw s;
      }
    const e = await t.arrayBuffer();
    return await WebAssembly.instantiate(e, A);
  } else {
    const e = await WebAssembly.instantiate(t, A);
    return e instanceof WebAssembly.Instance ? { instance: e, module: t } : e;
  }
}
function Oo() {
  const t = {};
  return t.wbg = {}, t.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, t.wbg.__wbg_length_3b4f022188ae8db6 = function(A) {
    return A.length;
  }, t.wbg.__wbg_length_6ca527665d89694d = function(A) {
    return A.length;
  }, t.wbg.__wbg_length_8cfd2c6409af88ad = function(A) {
    return A.length;
  }, t.wbg.__wbg_new_9fee97a409b32b68 = function(A) {
    return new Uint16Array(A);
  }, t.wbg.__wbg_new_e3b321dcfef89fc7 = function(A) {
    return new Uint32Array(A);
  }, t.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(A, e, s) {
    return new Float32Array(A, e >>> 0, s >>> 0);
  }, t.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(A, e, s) {
    return new Uint32Array(A, e >>> 0, s >>> 0);
  }, t.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(A) {
    return new Float32Array(A >>> 0);
  }, t.wbg.__wbg_set_10bad9bee0e9c58b = function(A, e, s) {
    A.set(e, s >>> 0);
  }, t.wbg.__wbg_set_d23661d19148b229 = function(A, e, s) {
    A.set(e, s >>> 0);
  }, t.wbg.__wbg_set_f4f1f0daa30696fc = function(A, e, s) {
    A.set(e, s >>> 0);
  }, t.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(A, e, s) {
    return A.subarray(e >>> 0, s >>> 0);
  }, t.wbg.__wbg_subarray_769e1e0f81bb259b = function(A, e, s) {
    return A.subarray(e >>> 0, s >>> 0);
  }, t.wbg.__wbindgen_init_externref_table = function() {
    const A = OA.__wbindgen_export_0, e = A.grow(4);
    A.set(0, void 0), A.set(e + 0, void 0), A.set(e + 1, null), A.set(e + 2, !0), A.set(e + 3, !1);
  }, t.wbg.__wbindgen_memory = function() {
    return OA.memory;
  }, t.wbg.__wbindgen_throw = function(A, e) {
    throw new Error(Vo(A, e));
  }, t;
}
function Wo(t, A) {
  return OA = t.exports, Gs.__wbindgen_wasm_module = A, Yt = null, OA.__wbindgen_start(), OA;
}
async function Gs(t) {
  if (OA !== void 0) return OA;
  typeof t < "u" && (Object.getPrototypeOf(t) === Object.prototype ? { module_or_path: t } = t : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof t > "u" && (t = new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gA39/fwBgAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgAW8Bf2AAAX9gBH9/f38AYAAAYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAcDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABwN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAHA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAcDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADgNhYAMAAQIIBQQCEwEMAAEBAgAAAQwBBAYFBQQAAQYFFAENBAAGBQQEAQQOAgECAQAIBAAVARYG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ACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC/MCAQR/IwBBMGsiACQAAkACQEGQksAAKAIARQRAQaiSwAAoAgAhAUGoksAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUGQksAAKAIAIgMNAgJAIANFDQBBlJLAACgCACICRQ0AQZiSwAAoAgAgAkECdBBlC0GUksAAIAE2AgBBkJLAAEEBNgIAQZiSwAAgACkDCDcCAEGgksAAIABBEGopAwA3AgALIABBMGokAEGUksAADwsgAEEANgIoIABBATYCHCAAQaCHwAA2AhggAEIENwIgIABBGGpBiIjAABBDAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQZQsgAEEANgIoIABBATYCHCAAQaiIwAA2AhggAEIENwIgIAFBsIjAABBDAAuoAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQcCIwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8AALQAAGiACIAU3AwBBDEEEEF0iAUUEQEEEQQwQbQALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHgisAANgIEIAAgATYCACACQUBrJAAL0gECBH8BfiMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIEQQF0IgEgAiABIAJLGyICIAJBCEkb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QQRqrUKAgICA4ACENwMoIAEgAa1CgICAgOAAhDcDICABIAFBIGo2AhAgAUEIakHIj8AAEEMAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQfyNwAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhBDAAtpAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0H4kcAANgIIIANCAjcCFCADQoCAgIDgACIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQQwALZgAjAEEwayIAJABBsJPAAC0AAARAIABBAjYCDCAAQbCKwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIDgAIQ3AyAgACAAQSBqNgIQIABBCGpB0IrAABBDAAsgAEEwaiQAC5QBAgN/AW8jAEEgayIDJAAgAyAAKAIAEHAiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahBAAAsQWyIEEFMiBSUBEAUhBhAbIgIgBiYBIAVBhAFPBEAgBRAtCyACIAAoAgAgAUECdhBkIAJBhAFPBEAgAhAtCyAEQYQBTwRAIAQQLQsgA0EgaiQAC08BAX8jAEEwayIAJAAgAEEBNgIMIABBwI3AADYCCCAAQgE3AhQgACAAQS9qrUKAgICAoAWENwMgIAAgAEEgajYCECAAQQhqQcSBwAAQQwALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAlIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALTQECf0Gxk8AALQAAGiABKAIEIQIgASgCACEDQQhBBBBdIgFFBEBBBEEIEG0ACyABIAI2AgQgASADNgIAIABB8IrAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhApIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALQQEBfyMAQSBrIgIkACACQQA2AhAgAkEBNgIEIAJCBDcCCCACQS42AhwgAiAANgIYIAIgAkEYajYCACACIAEQQwALswIBA38gACgCACECIAEoAhwiAEEQcUUE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ZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkdgMQACoAAAAvVXNlcnMvZG1hcmNvcy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwCoAxAAXwAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAABgEEAAOAAAAqAMQAF8AAAB6AgAADQAAABYAAAAMAAAABAAAABcAAAAYAAAAGQAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZABYBBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAWAQQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAAsFEAAVAAAAIAUQAA0AAABzdGQvc3JjL2FsbG9jLnJzQAUQABAAAABjAQAACQAAABYAAAAMAAAABAAAABoAAAAAAAAACAAAAAQAAAAbAAAAAAAAAAgAAAAEAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACEAAAAiAAAAIwAAACQAAABFcnJvcgAAACUAAAAMAAAABAAAACYAAAAnAAAAKAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA2AUQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc/QFEAAUAAAAGAAAAAUAQaCMwAAL8AUBAAAAKQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAfgYQABAAAAB+AgAADgAAAEJvcnJvd011dEVycm9yYWxyZWFkeSBib3Jyb3dlZDogrgYQABIAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAyAYQACAAAADoBhAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogABcHEAAQAAAAJwcQABcAAAA+BxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAAXBxAAEAAAAGAHEAAQAAAAcAcQAAkAAAA+BxAACQAAADogAAABAAAAAAAAAJwHEAACAAAAfSB9Y29yZS9zcmMvZm10L251bS5ycwAAswcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlyYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACiCBAAEgAAALQIEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgIEAAQAAAAtAgQACIAAAAAAAA/AAAAvwBBqJLAAAsBFABwCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44My4wICg5MGIzNWE2MjMgMjAyNC0xMS0yNikGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4HMC4yLjEwMABJD3RhcmdldF9mZWF0dXJlcwQrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQrD3JlZmVyZW5jZS10eXBlcysKbXVsdGl2YWx1ZQ==", import.meta.url));
  const A = Oo();
  (typeof t == "string" || typeof Request == "function" && t instanceof Request || typeof URL == "function" && t instanceof URL) && (t = fetch(t));
  const { instance: e, module: s } = await Xo(await t, A);
  return Wo(e, s);
}
const UA = -12, GA = 9, jo = Math.exp(UA), Zo = Math.exp(GA), Rs = -30, It = Math.exp(Rs), Oe = 11, We = 11, Ys = 11, Ag = Oe + We, X = 1 << Oe, KA = 1 << We, Js = 1 << Ys, je = 1, tg = X - 1, eg = KA - 1, sg = Js - 1, ng = !0, ig = !0, $h = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LN_SCALE_MAX: GA,
  LN_SCALE_MIN: UA,
  LN_SCALE_ZERO: Rs,
  SCALE_MAX: Zo,
  SCALE_MIN: jo,
  SCALE_ZERO: It,
  SPLAT_TEX_DEPTH: Js,
  SPLAT_TEX_DEPTH_BITS: Ys,
  SPLAT_TEX_DEPTH_MASK: sg,
  SPLAT_TEX_HEIGHT: KA,
  SPLAT_TEX_HEIGHT_BITS: We,
  SPLAT_TEX_HEIGHT_MASK: eg,
  SPLAT_TEX_LAYER_BITS: Ag,
  SPLAT_TEX_MIN_HEIGHT: je,
  SPLAT_TEX_WIDTH: X,
  SPLAT_TEX_WIDTH_BITS: Oe,
  SPLAT_TEX_WIDTH_MASK: tg,
  USE_COMPILED_PARSER_FUNCTION: ig,
  WASM_SPLAT_SORT: ng
}, Symbol.toStringTag, { value: "Module" }));
function pt(t) {
  return t === "bool" || t === "bvec2" || t === "bvec3" || t === "bvec4";
}
function dt(t) {
  return t === "int" || t === "uint" || t === "float";
}
function QA(t) {
  return t === "int" || t === "ivec2" || t === "ivec3" || t === "ivec4";
}
function EA(t) {
  return t === "uint" || t === "uvec2" || t === "uvec3" || t === "uvec4";
}
function Xt(t) {
  return t === "float" || t === "vec2" || t === "vec3" || t === "vec4";
}
function _s(t) {
  return t === "mat2" || t === "mat2x2" || t === "mat2x3" || t === "mat2x4" || t === "mat3" || t === "mat3x2" || t === "mat3x3" || t === "mat3x4" || t === "mat4" || t === "mat4x2" || t === "mat4x3" || t === "mat4x4";
}
function at(t) {
  return Xt(t) || _s(t);
}
function kt(t) {
  return t === "vec2" || t === "ivec2" || t === "uvec2";
}
function Tt(t) {
  return t === "vec3" || t === "ivec3" || t === "uvec3";
}
function Ot(t) {
  return t === "vec4" || t === "ivec4" || t === "uvec4";
}
function rg(t) {
  return kt(t) || Tt(t) || Ot(t);
}
function ot(t) {
  return t === "mat2" || t === "mat2x2";
}
function gt(t) {
  return t === "mat3" || t === "mat3x3";
}
function ct(t) {
  return t === "mat4" || t === "mat4x4";
}
function Ls(t) {
  switch (t) {
    case "vec2":
      return "float";
    case "vec3":
      return "float";
    case "vec4":
      return "float";
    case "ivec2":
      return "int";
    case "ivec3":
      return "int";
    case "ivec4":
      return "int";
    case "uvec2":
      return "uint";
    case "uvec3":
      return "uint";
    case "uvec4":
      return "uint";
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
function zs(t) {
  switch (t) {
    case "vec2":
    case "ivec2":
    case "uvec2":
      return 2;
    case "vec3":
    case "ivec3":
    case "uvec3":
      return 3;
    case "vec4":
    case "ivec4":
    case "uvec4":
      return 4;
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
function ag(t) {
  if (dt(t))
    return "float";
  if (kt(t))
    return "vec2";
  if (Tt(t))
    return "vec3";
  if (Ot(t))
    return "vec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function qs(t) {
  if (dt(t))
    return "uint";
  if (kt(t))
    return "uvec2";
  if (Tt(t))
    return "uvec3";
  if (Ot(t))
    return "uvec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function og(t) {
  if (dt(t))
    return "int";
  if (kt(t))
    return "ivec2";
  if (Tt(t))
    return "ivec3";
  if (Ot(t))
    return "ivec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function Hs(t) {
  if (typeof t == "string")
    return t;
  if (typeof t == "object" && t.type)
    return t.type;
  throw new Error(`Invalid DynoType: ${String(t)}`);
}
function rA(t) {
  return Math.trunc(t).toString();
}
function aA(t) {
  return `${Math.max(0, Math.trunc(t)).toString()}u`;
}
function q(t) {
  return t === Number.POSITIVE_INFINITY ? "INFINITY" : t === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(t) ? t.toFixed(1) : t.toString();
}
function $(t) {
  return t instanceof it ? t.type : t.dynoOut().type;
}
class it {
  constructor(A) {
    this.__isDynoValue = !0, this.type = A;
  }
}
class K extends it {
  constructor(A, e) {
    super(A.outTypes[e]), this.dyno = A, this.key = e;
  }
}
class vt extends it {
  constructor(A, e) {
    super(A), this.literal = e;
  }
  getLiteral() {
    return this.literal;
  }
}
function oe(t, A) {
  return new vt(t, A);
}
class Ks extends vt {
  constructor(A, e) {
    super(A, ""), this.value = e;
  }
  getLiteral() {
    const { type: A, value: e } = this;
    switch (A) {
      case "bool":
        return e ? "true" : "false";
      case "uint":
        return aA(e);
      case "int":
        return rA(e);
      case "float":
        return q(e);
      case "bvec2": {
        const s = e;
        return `bvec2(${s[0]}, ${s[1]})`;
      }
      case "uvec2": {
        if (e instanceof u.Vector2)
          return `uvec2(${aA(e.x)}, ${aA(e.y)})`;
        const s = e;
        return `uvec2(${aA(s[0])}, ${aA(s[1])})`;
      }
      case "ivec2": {
        if (e instanceof u.Vector2)
          return `ivec2(${rA(e.x)}, ${rA(e.y)})`;
        const s = e;
        return `ivec2(${rA(s[0])}, ${rA(s[1])})`;
      }
      case "vec2": {
        if (e instanceof u.Vector2)
          return `vec2(${q(e.x)}, ${q(e.y)})`;
        const s = e;
        return `vec2(${q(s[0])}, ${q(s[1])})`;
      }
      case "bvec3": {
        const s = e;
        return `bvec3(${s[0]}, ${s[1]}, ${s[2]})`;
      }
      case "uvec3": {
        if (e instanceof u.Vector3)
          return `uvec3(${aA(e.x)}, ${aA(e.y)}, ${aA(e.z)})`;
        const s = e;
        return `uvec3(${aA(s[0])}, ${aA(s[1])}, ${aA(s[2])})`;
      }
      case "ivec3": {
        if (e instanceof u.Vector3)
          return `ivec3(${rA(e.x)}, ${rA(e.y)}, ${rA(e.z)})`;
        const s = e;
        return `ivec3(${rA(s[0])}, ${rA(s[1])}, ${rA(s[2])})`;
      }
      case "vec3": {
        if (e instanceof u.Vector3)
          return `vec3(${q(e.x)}, ${q(e.y)}, ${q(e.z)})`;
        const s = e;
        return `vec3(${q(s[0])}, ${q(s[1])}, ${q(s[2])})`;
      }
      case "bvec4": {
        const s = e;
        return `bvec4(${s[0]}, ${s[1]}, ${s[2]}, ${s[3]})`;
      }
      case "uvec4": {
        if (e instanceof u.Vector4)
          return `uvec4(${aA(e.x)}, ${aA(e.y)}, ${aA(e.z)}, ${aA(e.w)})`;
        const s = e;
        return `uvec4(${aA(s[0])}, ${aA(s[1])}, ${aA(s[2])}, ${aA(s[3])})`;
      }
      case "ivec4": {
        if (e instanceof u.Vector4)
          return `ivec4(${rA(e.x)}, ${rA(e.y)}, ${rA(e.z)}, ${rA(e.w)})`;
        const s = e;
        return `ivec4(${rA(s[0])}, ${rA(s[1])}, ${rA(s[2])}, ${rA(s[3])})`;
      }
      case "vec4": {
        if (e instanceof u.Vector4)
          return `vec4(${q(e.x)}, ${q(e.y)}, ${q(e.z)}, ${q(e.w)})`;
        if (e instanceof u.Quaternion)
          return `vec4(${q(e.x)}, ${q(e.y)}, ${q(e.z)}, ${q(e.w)})`;
        const s = e;
        return `vec4(${q(s[0])}, ${q(s[1])}, ${q(s[2])}, ${q(s[3])})`;
      }
      case "mat2":
      case "mat2x2": {
        const s = e, n = s instanceof u.Matrix2 ? s.elements : e, i = new Array(4).fill(0).map((r, a) => q(n[a]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat2x3": {
        const s = e, n = new Array(6).fill(0).map((i, r) => q(s[r]));
        return `${A}(${n.join(", ")})`;
      }
      case "mat2x4": {
        const s = e, n = new Array(8).fill(0).map((i, r) => q(s[r]));
        return `${A}(${n.join(", ")})`;
      }
      case "mat3":
      case "mat3x3": {
        const s = e, n = s instanceof u.Matrix3 ? s.elements : e, i = new Array(9).fill(0).map((r, a) => q(n[a]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat3x2": {
        const s = e, n = new Array(6).fill(0).map((i, r) => q(s[r]));
        return `${A}(${n.join(", ")})`;
      }
      case "mat3x4": {
        const s = e, n = new Array(12).fill(0).map((i, r) => q(s[r]));
        return `${A}(${n.join(", ")})`;
      }
      case "mat4":
      case "mat4x4": {
        const s = e, n = s instanceof u.Matrix4 ? s.elements : e, i = new Array(16).fill(0).map((r, a) => q(n[a]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat4x2": {
        const s = e, n = new Array(8).fill(0).map((i, r) => q(s[r]));
        return `${A}(${n.join(", ")})`;
      }
      case "mat4x3": {
        const s = e, n = new Array(12).fill(0).map((i, r) => q(s[r]));
        return `${A}(${n.join(", ")})`;
      }
      default:
        throw new Error(`Type not implemented: ${String(A)}`);
    }
  }
}
function J(t, A) {
  return new Ks(t, A);
}
function Jt(t) {
  const A = String(t);
  if (pt(t))
    return `${A}(false)`;
  if (at(t))
    return `${A}(0.0)`;
  if (QA(t))
    return `${A}(0)`;
  if (EA(t))
    return `${A}(0u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function gg(t) {
  const A = String(t);
  if (pt(t))
    return `${A}(true)`;
  if (at(t))
    return `${A}(1.0)`;
  if (QA(t))
    return `${A}(1)`;
  if (EA(t))
    return `${A}(1u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function cg(t) {
  const A = String(t);
  if (pt(t))
    return `${A}(true)`;
  if (at(t))
    return `${A}(-1.0)`;
  if (QA(t))
    return `${A}(-1)`;
  if (EA(t))
    return `${A}(0xFFFFFFFFu)`;
  throw new Error(`Type not implemented: ${A}`);
}
const Bs = "    ";
class $s {
  constructor({ indent: A } = {}) {
    this.globals = /* @__PURE__ */ new Set(), this.statements = [], this.uniforms = {}, this.declares = /* @__PURE__ */ new Set(), this.updaters = [], this.sequence = 0, this.indent = Bs, this.indent = A ?? Bs;
  }
  nextSequence() {
    return this.sequence++;
  }
}
class V {
  constructor({
    inTypes: A,
    outTypes: e,
    inputs: s,
    update: n,
    globals: i,
    statements: r,
    generate: a
  }) {
    this.inTypes = A ?? {}, this.outTypes = e ?? {}, this.inputs = s ?? {}, this.update = n, this.globals = i, this.statements = r, this.generate = a ?? (({ inputs: o, outputs: c, compile: l }) => {
      var g, I;
      return {
        globals: (g = this.globals) == null ? void 0 : g.call(this, { inputs: o, outputs: c, compile: l }),
        statements: (I = this.statements) == null ? void 0 : I.call(this, { inputs: o, outputs: c, compile: l })
      };
    });
  }
  get outputs() {
    const A = {};
    for (const e in this.outTypes)
      A[e] = new K(this, e);
    return A;
  }
  apply(A) {
    return Object.assign(this.inputs, A), this.outputs;
  }
  compile({
    inputs: A,
    outputs: e,
    compile: s
  }) {
    const n = [
      `// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(e).join(", ")})`
    ], i = [];
    for (const c in e) {
      const l = e[c];
      l && !s.declares.has(l) && (s.declares.add(l), i.push(c));
    }
    const { globals: r, statements: a, uniforms: o } = this.generate({
      inputs: A,
      outputs: e,
      compile: s
    });
    for (const c of r ?? [])
      s.globals.add(c);
    for (const c in o)
      s.uniforms[c] = o[c];
    this.update && s.updaters.push(this.update);
    for (const c of i) {
      const l = e[c];
      l && (s.uniforms[l] || n.push(`${Ze(l, this.outTypes[c])};`));
    }
    return a != null && a.length && (n.push("{"), n.push(...a.map((c) => s.indent + c)), n.push("}")), n;
  }
}
class PA extends V {
  constructor({
    inTypes: A,
    outTypes: e,
    inputs: s,
    update: n,
    globals: i,
    construct: r
  }) {
    super({
      inTypes: A,
      outTypes: e,
      inputs: s,
      update: n,
      globals: i,
      generate: (a) => this.generateBlock(a)
    }), this.construct = r;
  }
  generateBlock({
    inputs: A,
    outputs: e,
    compile: s
  }) {
    var Q, C;
    const n = {}, i = {};
    for (const B in A)
      A[B] != null && (n[B] = new vt(this.inTypes[B], A[B]));
    for (const B in e)
      e[B] != null && (i[B] = new it(this.outTypes[B]));
    const r = { roots: [] }, a = this.construct(n, i, r);
    for (const B of ((Q = this.globals) == null ? void 0 : Q.call(this, { inputs: A, outputs: e, compile: s })) ?? [])
      s.globals.add(B);
    const o = [], c = /* @__PURE__ */ new Map();
    function l(B, E, p) {
      let f = c.get(B);
      if (!f) {
        f = {
          sequence: s.nextSequence(),
          outNames: /* @__PURE__ */ new Map(),
          newOuts: /* @__PURE__ */ new Set()
        }, c.set(B, f);
        for (const d in B.inputs) {
          let y = B.inputs[d];
          for (; y; ) {
            if (y instanceof it) {
              y instanceof K && l(y.dyno, y.key);
              break;
            }
            y = y.dynoOut();
          }
        }
        o.push(B);
      }
      E && (p || f.newOuts.add(E), f.outNames.set(E, p ?? `${E}_${f.sequence}`));
    }
    for (const B of r.roots)
      l(B);
    for (const B in i) {
      let E = (a == null ? void 0 : a[B]) ?? i[B];
      for (; E; ) {
        if (E instanceof it) {
          E instanceof K && l(E.dyno, E.key, e[B]);
          break;
        }
        E = E.dynoOut();
      }
      i[B] = E;
    }
    const g = [];
    for (const B of o) {
      const E = {}, p = {};
      for (const y in B.inputs) {
        let D = B.inputs[y];
        for (; D; ) {
          if (D instanceof it) {
            if (D instanceof vt)
              E[y] = D.getLiteral();
            else if (D instanceof K) {
              const x = (C = c.get(D.dyno)) == null ? void 0 : C.outNames.get(D.key);
              if (!x)
                throw new Error(
                  `Source not found for ${D.dyno.constructor.name}.${D.key}`
                );
              E[y] = x;
            }
            break;
          }
          D = D.dynoOut();
        }
      }
      const f = c.get(B) ?? { outNames: /* @__PURE__ */ new Map() };
      for (const [y, D] of f.outNames.entries())
        p[y] = D;
      const d = B.compile({ inputs: E, outputs: p, compile: s });
      g.push(d);
    }
    const I = [];
    for (const B in e)
      i[B] instanceof vt && I.push(
        `${e[B]} = ${i[B].getLiteral()};`
      );
    return I.length > 0 && g.push(I), { statements: g.flatMap((B, E) => E === 0 ? B : ["", ...B]) };
  }
}
function vA(t, A, e, { update: s, globals: n } = {}) {
  return new PA({ inTypes: t, outTypes: A, construct: e, update: s, globals: n });
}
function Wt({
  inTypes: t,
  outTypes: A,
  inputs: e,
  update: s,
  globals: n,
  statements: i,
  generate: r
}) {
  return new V({
    inTypes: t,
    outTypes: A,
    inputs: e,
    update: s,
    globals: n,
    statements: i,
    generate: r
  });
}
function Ze(t, A, e) {
  const s = typeof A == "string" ? A : A.type;
  if (!s)
    throw new Error(`Invalid DynoType: ${String(A)}`);
  return `${s} ${t}${e != null ? `[${e}]` : ""}`;
}
function RA(t) {
  var i;
  let A = !1;
  const e = t.split(`
`).map((r) => {
    const a = r.trimEnd();
    return A ? a : a.length > 0 ? (A = !0, a) : null;
  }).filter((r) => r != null);
  for (; e.length > 0 && e[e.length - 1].length === 0; )
    e.pop();
  if (e.length === 0)
    return [];
  const s = (i = e[0].match(/^\s*/)) == null ? void 0 : i[0];
  if (!s)
    return e;
  const n = new RegExp(`^${s}`);
  return e.map((r) => r.replace(n, ""));
}
function hA(t) {
  return RA(t).join(`
`);
}
class v extends V {
  constructor({
    a: A,
    outKey: e,
    outTypeFunc: s
  }) {
    const n = { a: $(A) }, i = s($(A)), r = { [e]: i };
    super({ inTypes: n, outTypes: r, inputs: { a: A } }), this.outKey = e;
  }
  dynoOut() {
    return new K(this, this.outKey);
  }
}
class tA extends V {
  constructor({
    a: A,
    b: e,
    outKey: s,
    outTypeFunc: n
  }) {
    const i = { a: $(A), b: $(e) }, r = n($(A), $(e)), a = { [s]: r };
    super({ inTypes: i, outTypes: a, inputs: { a: A, b: e } }), this.outKey = s;
  }
  dynoOut() {
    return new K(this, this.outKey);
  }
}
class yt extends V {
  constructor({
    a: A,
    b: e,
    c: s,
    outKey: n,
    outTypeFunc: i
  }) {
    const r = { a: $(A), b: $(e), c: $(s) }, a = i($(A), $(e), $(s)), o = { [n]: a };
    super({ inTypes: r, outTypes: o, inputs: { a: A, b: e, c: s } }), this.outKey = n;
  }
  dynoOut() {
    return new K(this, this.outKey);
  }
}
const AA = { type: "Gsplat" }, jt = { type: "PackedSplats" }, lg = (t) => new Ps({ packedSplats: t }), bt = (t, A) => new Os({ packedSplats: t, index: A }), Vs = (t, A, e, s) => new Ws({ packedSplats: t, index: A, base: e, count: s }), ut = (t) => new js({ gsplat: t }), rt = ({
  gsplat: t,
  flags: A,
  index: e,
  center: s,
  scales: n,
  quaternion: i,
  rgba: r,
  rgb: a,
  opacity: o,
  x: c,
  y: l,
  z: g,
  r: I,
  g: h,
  b: Q
}) => new Zs({
  gsplat: t,
  flags: A,
  index: e,
  center: s,
  scales: n,
  quaternion: i,
  rgba: r,
  rgb: a,
  opacity: o,
  x: c,
  y: l,
  z: g,
  r: I,
  g: h,
  b: Q
}), Re = (t) => new tn({ gsplat: t }), As = (t, {
  scale: A,
  rotate: e,
  translate: s,
  recolor: n
}) => new en({ gsplat: t, scale: A, rotate: e, translate: s, recolor: n }), bA = hA(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`), Ee = hA(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
    vec4 rgbMinMaxLnScaleMinMax;
  };
`);
class Ps extends v {
  constructor({
    packedSplats: A
  }) {
    super({ a: A, outKey: "numSplats", outTypeFunc: () => "int" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.numSplats} = ${e.a}.numSplats;`
    ];
  }
}
const Xs = hA(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, vec4 rgbMinMaxLnScaleMinMax, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplatEncoding(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba, rgbMinMaxLnScaleMinMax);
      return true;
    } else {
      return false;
    }
  }
`);
class Os extends V {
  constructor({
    packedSplats: A,
    index: e
  }) {
    super({
      inTypes: { packedSplats: jt, index: "int" },
      outTypes: { gsplat: AA },
      inputs: { packedSplats: A, index: e },
      globals: () => [bA, Ee, Xs],
      statements: ({ inputs: s, outputs: n }) => {
        const { gsplat: i } = n;
        if (!i)
          return [];
        const { packedSplats: r, index: a } = s;
        let o;
        return r && a ? o = RA(`
            if (readPackedSplat(${r}.texture, ${r}.numSplats, ${r}.rgbMinMaxLnScaleMinMax, ${a}, ${i})) {
              bool zeroSize = all(equal(${i}.scales, vec3(0.0, 0.0, 0.0)));
              ${i}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${i}.flags = 0u;
            }
          `) : o = [`${i}.flags = 0u;`], o.push(`${i}.index = ${a ?? "0"};`), o;
      }
    });
  }
  dynoOut() {
    return new K(this, "gsplat");
  }
}
class Ws extends V {
  constructor({
    packedSplats: A,
    index: e,
    base: s,
    count: n
  }) {
    super({
      inTypes: {
        packedSplats: jt,
        index: "int",
        base: "int",
        count: "int"
      },
      outTypes: { gsplat: AA },
      inputs: { packedSplats: A, index: e, base: s, count: n },
      globals: () => [bA, Ee, Xs],
      statements: ({ inputs: i, outputs: r }) => {
        const { gsplat: a } = r;
        if (!a)
          return [];
        const { packedSplats: o, index: c, base: l, count: g } = i;
        let I;
        return o && c && l && g ? I = RA(`
            ${a}.flags = 0u;
            if ((${c} >= ${l}) && (${c} < (${l} + ${g}))) {
              if (readPackedSplat(${o}.texture, ${o}.numSplats, ${o}.rgbMinMaxLnScaleMinMax, ${c}, ${a})) {
                bool zeroSize = all(equal(${a}.scales, vec3(0.0, 0.0, 0.0)));
                ${a}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `) : I = [`${a}.flags = 0u;`], I.push(`${a}.index = ${c ?? "0"};`), I;
      }
    });
  }
  dynoOut() {
    return new K(this, "gsplat");
  }
}
class js extends V {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: AA },
      outTypes: {
        flags: "uint",
        active: "bool",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      inputs: { gsplat: A },
      globals: () => [bA],
      statements: ({ inputs: e, outputs: s }) => {
        const { gsplat: n } = e, {
          flags: i,
          active: r,
          index: a,
          center: o,
          scales: c,
          quaternion: l,
          rgba: g,
          rgb: I,
          opacity: h,
          x: Q,
          y: C,
          z: B,
          r: E,
          g: p,
          b: f
        } = s;
        return [
          i ? `${i} = ${n ? `${n}.flags` : "0u"};` : null,
          r ? `${r} = isGsplatActive(${n ? `${n}.flags` : "0u"});` : null,
          a ? `${a} = ${n ? `${n}.index` : "0"};` : null,
          o ? `${o} = ${n ? `${n}.center` : "vec3(0.0, 0.0, 0.0)"};` : null,
          c ? `${c} = ${n ? `${n}.scales` : "vec3(0.0, 0.0, 0.0)"};` : null,
          l ? `${l} = ${n ? `${n}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};` : null,
          g ? `${g} = ${n ? `${n}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};` : null,
          I ? `${I} = ${n ? `${n}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};` : null,
          h ? `${h} = ${n ? `${n}.rgba.a` : "0.0"};` : null,
          Q ? `${Q} = ${n ? `${n}.center.x` : "0.0"};` : null,
          C ? `${C} = ${n ? `${n}.center.y` : "0.0"};` : null,
          B ? `${B} = ${n ? `${n}.center.z` : "0.0"};` : null,
          E ? `${E} = ${n ? `${n}.rgba.r` : "0.0"};` : null,
          p ? `${p} = ${n ? `${n}.rgba.g` : "0.0"};` : null,
          f ? `${f} = ${n ? `${n}.rgba.b` : "0.0"};` : null
        ].filter(Boolean);
      }
    });
  }
}
class Zs extends V {
  constructor({
    gsplat: A,
    flags: e,
    index: s,
    center: n,
    scales: i,
    quaternion: r,
    rgba: a,
    rgb: o,
    opacity: c,
    x: l,
    y: g,
    z: I,
    r: h,
    g: Q,
    b: C
  }) {
    super({
      inTypes: {
        gsplat: AA,
        flags: "uint",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      outTypes: { gsplat: AA },
      inputs: {
        gsplat: A,
        flags: e,
        index: s,
        center: n,
        scales: i,
        quaternion: r,
        rgba: a,
        rgb: o,
        opacity: c,
        x: l,
        y: g,
        z: I,
        r: h,
        g: Q,
        b: C
      },
      globals: () => [bA],
      statements: ({ inputs: B, outputs: E }) => {
        const { gsplat: p } = E;
        if (!p)
          return [];
        const {
          gsplat: f,
          flags: d,
          index: y,
          center: D,
          scales: x,
          quaternion: w,
          rgba: m,
          rgb: T,
          opacity: M,
          x: S,
          y: U,
          z: F,
          r: b,
          g: N,
          b: R
        } = B;
        return [
          `${p}.flags = ${d ?? (f ? `${f}.flags` : "0u")};`,
          `${p}.index = ${y ?? (f ? `${f}.index` : "0")};`,
          `${p}.center = ${D ?? (f ? `${f}.center` : "vec3(0.0, 0.0, 0.0)")};`,
          `${p}.scales = ${x ?? (f ? `${f}.scales` : "vec3(0.0, 0.0, 0.0)")};`,
          `${p}.quaternion = ${w ?? (f ? `${f}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,
          `${p}.rgba = ${m ?? (f ? `${f}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,
          T ? `${p}.rgba.rgb = ${T};` : null,
          M ? `${p}.rgba.a = ${M};` : null,
          S ? `${p}.center.x = ${S};` : null,
          U ? `${p}.center.y = ${U};` : null,
          F ? `${p}.center.z = ${F};` : null,
          b ? `${p}.rgba.r = ${b};` : null,
          N ? `${p}.rgba.g = ${N};` : null,
          R ? `${p}.rgba.b = ${R};` : null
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new K(this, "gsplat");
  }
}
const An = hA(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);
class tn extends v {
  constructor({ gsplat: A }) {
    super({ a: A, outKey: "normal", outTypeFunc: () => "vec3" }), this.globals = () => [bA, An], this.statements = ({ inputs: e, outputs: s }) => [
      `${s.normal} = gsplatNormal(${e.a}.scales, ${e.a}.quaternion);`
    ];
  }
}
class en extends V {
  constructor({
    gsplat: A,
    scale: e,
    rotate: s,
    translate: n,
    recolor: i
  }) {
    super({
      inTypes: {
        gsplat: AA,
        scale: "float",
        rotate: "vec4",
        translate: "vec3",
        recolor: "vec4"
      },
      outTypes: { gsplat: AA },
      inputs: { gsplat: A, scale: e, rotate: s, translate: n, recolor: i },
      globals: () => [bA],
      statements: ({ inputs: r, outputs: a, compile: o }) => {
        const { gsplat: c } = a;
        if (!c || !r.gsplat)
          return [];
        const { scale: l, rotate: g, translate: I, recolor: h } = r, Q = o.indent;
        return [
          `${c} = ${r.gsplat};`,
          `if (isGsplatActive(${c}.flags)) {`,
          l ? `${Q}${c}.center *= ${l};` : null,
          g ? `${Q}${c}.center = quatVec(${g}, ${c}.center);` : null,
          I ? `${Q}${c}.center += ${I};` : null,
          l ? `${Q}${c}.scales *= ${l};` : null,
          g ? `${Q}${c}.quaternion = quatQuat(${g}, ${c}.quaternion);` : null,
          h ? `${Q}${c}.rgba *= ${h};` : null,
          "}"
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new K(this, "gsplat");
  }
}
const sn = (t, A) => new nn({ gsplat: t, rgbMinMaxLnScaleMinMax: A }), Ig = (t) => new ts({ rgba8: t });
class nn extends V {
  constructor({
    gsplat: A,
    rgbMinMaxLnScaleMinMax: e
  }) {
    super({
      inTypes: { gsplat: AA, rgbMinMaxLnScaleMinMax: "vec4" },
      inputs: { gsplat: A, rgbMinMaxLnScaleMinMax: e },
      globals: () => [bA],
      statements: ({ inputs: s, outputs: n }) => {
        const { output: i } = n;
        if (!i)
          return [];
        const { gsplat: r, rgbMinMaxLnScaleMinMax: a } = s;
        return r ? RA(`
            if (isGsplatActive(${r}.flags)) {
              ${i} = packSplatEncoding(${r}.center, ${r}.scales, ${r}.quaternion, ${r}.rgba, ${a});
            } else {
              ${i} = uvec4(0u, 0u, 0u, 0u);
            }
          `) : [`${i} = uvec4(0u, 0u, 0u, 0u);`];
      }
    });
  }
  dynoOut() {
    return new K(this, "output");
  }
}
class ts extends V {
  constructor({ rgba8: A }) {
    super({
      inTypes: { rgba8: "vec4" },
      inputs: { rgba8: A },
      statements: ({ inputs: e, outputs: s }) => [
        `target = ${e.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`
      ]
    });
  }
  dynoOut() {
    return new K(this, "rgba8");
  }
}
const ug = (t, A, e) => new k({ key: t, type: A, value: e }), hg = (t = !1, A) => new ge({ key: A, value: t }), Cg = (t = 0, A) => new rn({ key: A, value: t }), Bg = (t = 0, A) => new $t({ key: A, value: t }), qA = (t = 0, A) => new ht({ key: A, value: t }), Qg = (t, A) => new an({ key: A, value: t }), Eg = (t, A) => new on({ key: A, value: t }), fg = (t, A) => new gn({ key: A, value: t }), pg = (t, A) => new zt({ key: A, value: t }), dg = (t, A) => new cn({ key: A, value: t }), yg = (t, A) => new ln({ key: A, value: t }), wg = (t, A) => new In({ key: A, value: t }), tt = (t, A) => new Ft({ key: A, value: t }), mg = (t, A) => new un({ key: A, value: t }), xg = (t, A) => new hn({ key: A, value: t }), Sg = (t, A) => new Cn({ key: A, value: t }), Dg = (t, A) => new Nt({ key: A, value: t }), Mg = (t, A) => new Bn({ key: A, value: t }), vg = (t, A) => new Qn({ key: A, value: t }), bg = (t, A) => new En({ key: A, value: t }), Fg = (t, A) => new fn({ key: A, value: t }), kg = (t, A) => new pn({ key: A, value: t }), Tg = (t, A) => new dn({ key: A, value: t }), Ng = (t, A) => new yn({ key: A, value: t }), Ug = (t, A) => new wn({ key: A, value: t }), Gg = (t, A) => new mn({ key: A, value: t }), Rg = (t, A) => new xn({ key: A, value: t }), Yg = (t, A) => new Sn({ key: A, value: t }), Jg = (t, A) => new Dn({ key: A, value: t }), _g = (t, A) => new Mn({ key: A, value: t }), Lg = (t, A) => new vn({ key: A, value: t }), zg = (t, A) => new bn({ key: A, value: t }), qg = (t, A) => new qt({ key: A, value: t }), Hg = (t, A) => new Fn({ key: t, value: A }), Kg = (t, A) => new kn({ key: A, value: t }), $g = (t, A) => new Tn({ key: A, value: t }), Vg = (t, A) => new Nn({ key: A, value: t }), Pg = (t, A) => new Un({ key: A, value: t }), Xg = (t, A) => new Gn({ key: A, value: t }), Og = (t, A) => new Rn({ key: A, value: t }), Wg = (t, A) => new Yn({ key: A, value: t }), jg = (t, A) => new Jn({ key: A, value: t }), Zg = (t, A) => new _n({ key: A, value: t }), Ac = (t, A) => new Ln({ key: A, value: t });
class k extends V {
  constructor({
    key: A,
    type: e,
    count: s,
    value: n,
    update: i,
    globals: r
  }) {
    A = A ?? "value", super({
      outTypes: { [A]: e },
      update: () => {
        if (i) {
          const a = i(this.value);
          a !== void 0 && (this.value = a);
        }
        this.uniform.value = this.value;
      },
      generate: ({ inputs: a, outputs: o }) => {
        const c = (r == null ? void 0 : r({ inputs: a, outputs: o })) ?? [], l = {}, g = o[A];
        return g && (c.push(`uniform ${Ze(g, e, s)};`), l[g] = this.uniform), { globals: c, uniforms: l };
      }
    }), this.type = e, this.count = s, this.value = n, this.uniform = { value: n }, this.outKey = A;
  }
  dynoOut() {
    return new K(this, this.outKey);
  }
}
class ge extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "bool", value: e, update: s });
  }
}
class rn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "uint", value: e, update: s });
  }
}
class $t extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "int", value: e, update: s });
  }
}
class ht extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "float", value: e, update: s });
  }
}
class an extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "bvec2", value: e, update: s });
  }
}
class on extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "uvec2", value: e, update: s });
  }
}
class gn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "ivec2", value: e, update: s });
  }
}
class zt extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "vec2", value: e, update: s });
  }
}
class cn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "bvec3", value: e, update: s });
  }
}
class ln extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "uvec3", value: e, update: s });
  }
}
class In extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "ivec3", value: e, update: s });
  }
}
class Ft extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "vec3", value: e, update: s });
  }
}
class un extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "bvec4", value: e, update: s });
  }
}
class hn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "uvec4", value: e, update: s });
  }
}
class Cn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "ivec4", value: e, update: s });
  }
}
class Nt extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "vec4", value: e, update: s });
  }
}
class Bn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat2", value: e, update: s });
  }
}
class Qn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat2x2", value: e, update: s });
  }
}
class En extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat2x3", value: e, update: s });
  }
}
class fn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat2x4", value: e, update: s });
  }
}
class pn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat3", value: e, update: s });
  }
}
class dn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat3x2", value: e, update: s });
  }
}
class yn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat3x3", value: e, update: s });
  }
}
class wn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat3x4", value: e, update: s });
  }
}
class mn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat4", value: e, update: s });
  }
}
class xn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat4x2", value: e, update: s });
  }
}
class Sn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat4x3", value: e, update: s });
  }
}
class Dn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "mat4x4", value: e, update: s });
  }
}
class Mn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "usampler2D", value: e, update: s });
  }
}
class vn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "isampler2D", value: e, update: s });
  }
}
class bn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler2D", value: e, update: s });
  }
}
class qt extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "usampler2DArray", value: e, update: s });
  }
}
class Fn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "isampler2DArray", value: e, update: s });
  }
}
class kn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler2DArray", value: e, update: s });
  }
}
class Tn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "usampler3D", value: e, update: s });
  }
}
class Nn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "isampler3D", value: e, update: s });
  }
}
class Un extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler3D", value: e, update: s });
  }
}
class Gn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "usamplerCube", value: e, update: s });
  }
}
class Rn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "isamplerCube", value: e, update: s });
  }
}
class Yn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "samplerCube", value: e, update: s });
  }
}
class Jn extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler2DShadow", value: e, update: s });
  }
}
class _n extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "sampler2DArrayShadow", value: e, update: s });
  }
}
class Ln extends k {
  constructor({
    key: A,
    value: e,
    update: s
  }) {
    super({ key: A, type: "samplerCubeShadow", value: e, update: s });
  }
}
const Zt = new Float32Array(1), fe = new Uint32Array(Zt.buffer), es = "Float16Array" in globalThis, Ht = es ? new globalThis.Float16Array(1) : null, zn = new Uint16Array(Ht == null ? void 0 : Ht.buffer);
function qn(t) {
  const A = Math.sqrt(t.reduce((e, s) => e + s * s, 0));
  return t.map((e) => e / A);
}
function tc(t) {
  return Zt[0] = t, fe[0];
}
function ec(t) {
  return fe[0] = t, Zt[0];
}
const Ct = es ? sc : nc, wA = es ? ic : rc;
function sc(t) {
  return Ht[0] = t, zn[0];
}
function nc(t) {
  Zt[0] = t;
  const A = fe[0], e = A >> 31 & 1, s = A >> 23 & 255, n = A & 8388607, i = e << 15;
  if (s === 255)
    return n !== 0 ? i | 32767 : i | 31744;
  const r = s - 127 + 15;
  if (r >= 31)
    return i | 31744;
  if (r <= 0) {
    if (r < -10)
      return i;
    const o = (n | 8388608) >> 1 - r + 13;
    return i | o;
  }
  const a = n >> 13;
  return i | r << 10 | a;
}
function ic(t) {
  return zn[0] = t, Ht[0];
}
function rc(t) {
  const A = t >> 15 & 1, e = t >> 10 & 31, s = t & 1023;
  let n;
  if (e === 0)
    if (s === 0)
      n = A << 31;
    else {
      let i = s, r = -14;
      for (; (i & 1024) === 0; )
        i <<= 1, r--;
      i &= 1023;
      const a = r + 127, o = i << 13;
      n = A << 31 | a << 23 | o;
    }
  else if (e === 31)
    s === 0 ? n = A << 31 | 2139095040 : n = A << 31 | 2143289344;
  else {
    const i = e - 15 + 127, r = s << 13;
    n = A << 31 | i << 23 | r;
  }
  return fe[0] = n, Zt[0];
}
function FA(t) {
  return Math.max(0, Math.min(255, Math.round(t * 255)));
}
function ie(t) {
  return Math.max(-127, Math.min(127, Math.round(t * 127)));
}
function ac(t) {
  return t / 255;
}
function oc(t) {
  return t / 127;
}
class gc {
  // Create a DataCache with a given function that fetches data not in the cache.
  constructor({
    asyncFetch: A,
    maxItems: e = 5
  }) {
    this.asyncFetch = A, this.maxItems = e, this.items = [];
  }
  // Fetch data for the key, returning cached data if available.
  async getFetch(A) {
    const e = this.items.findIndex((n) => n.key === A);
    if (e >= 0) {
      const n = this.items.splice(e, 1)[0];
      return this.items.push(n), n.data;
    }
    const s = await this.asyncFetch(A);
    for (this.items.push({ key: A, data: s }); this.items.length > this.maxItems; )
      this.items.shift();
    return s;
  }
}
function cc(t, A) {
  const e = Object.entries(t).map(([s, n]) => [
    s,
    A(n, s)
  ]);
  return Object.fromEntries(e);
}
function lc(t, A) {
  const e = Object.entries(t).map(([s, n]) => [s, A(n, s)]).filter(([s, n]) => n !== void 0);
  return Object.fromEntries(e);
}
function Hn(t) {
  const A = [], e = /* @__PURE__ */ new Set();
  function s(n) {
    n && typeof n == "object" && !e.has(n) && (e.add(n), n instanceof ArrayBuffer ? A.push(n) : ArrayBuffer.isView(n) ? A.push(n.buffer) : Array.isArray(n) ? n.forEach(s) : Object.values(n).forEach(s));
  }
  return s(t), A;
}
function Ic(t, A) {
  return new Array(t).fill(null).map((e, s) => A(s));
}
class Kn {
  constructor({
    // Allocate a new item with the given args
    allocate: A,
    // Dispose of an item (optional, if GC is enough)
    dispose: e,
    // Check if an existing item in the list is valid for the given args,
    // allowing you to store heterogeneous items in the list.
    valid: s
  }) {
    this.items = [], this.allocate = A, this.dispose = e, this.valid = s;
  }
  // Allocate a new item from the free list, first checking if a existing item
  // on the freelist is valid for the given args.
  alloc(A) {
    for (; ; ) {
      const e = this.items.pop();
      if (!e)
        break;
      if (this.valid(e, A))
        return e;
      this.dispose && this.dispose(e);
    }
    return this.allocate(A);
  }
  free(A) {
    this.items.push(A);
  }
  disposeAll() {
    let A;
    for (A = this.items.pop(); A; )
      this.dispose && this.dispose(A), A = this.items.pop();
  }
}
function Ye(t, A, e, s, n, i, r, a, o, c, l, g, I, h, Q, C, B) {
  const E = (B == null ? void 0 : B.rgbMin) ?? 0, f = ((B == null ? void 0 : B.rgbMax) ?? 1) - E, d = FA((h - E) / f), y = FA((Q - E) / f), D = FA((C - E) / f), x = FA(I), w = ss(
    $n.set(o, c, l, g)
  ), m = w & 255, T = w >>> 8 & 255, M = w >>> 16 & 255, S = (B == null ? void 0 : B.lnScaleMin) ?? UA, F = 254 / (((B == null ? void 0 : B.lnScaleMax) ?? GA) - S), b = i < It ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(i) - S) * F) + 1
    )
  ), N = r < It ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(r) - S) * F) + 1
    )
  ), R = a < It ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(a) - S) * F) + 1
    )
  ), O = Ct(e), _ = Ct(s), eA = Ct(n), H = A * 4;
  t[H] = d | y << 8 | D << 16 | x << 24, t[H + 1] = O | _ << 16, t[H + 2] = eA | m << 16 | T << 24, t[H + 3] = b | N << 8 | R << 16 | M << 24;
}
function uc(t, A, e, s, n) {
  const i = Ct(e), r = Ct(s), a = Ct(n), o = A * 4;
  t[o + 1] = i | r << 16, t[o + 2] = a | t[o + 2] & 4294901760;
}
function hc(t, A, e, s, n, i) {
  const r = (i == null ? void 0 : i.lnScaleMin) ?? UA, o = 254 / (((i == null ? void 0 : i.lnScaleMax) ?? GA) - r), c = e < It ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(e) - r) * o) + 1
    )
  ), l = s < It ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(s) - r) * o) + 1
    )
  ), g = n < It ? 0 : Math.min(
    255,
    Math.max(
      1,
      Math.round((Math.log(n) - r) * o) + 1
    )
  ), I = A * 4;
  t[I + 3] = c | l << 8 | g << 16 | t[I + 3] & 4278190080;
}
const $n = new u.Quaternion();
function Cc(t, A, e, s, n, i) {
  const r = ss(
    $n.set(e, s, n, i)
  ), a = r & 255, o = r >>> 8 & 255, c = r >>> 16 & 255, l = A * 4;
  t[l + 2] = t[l + 2] & 65535 | a << 16 | o << 24, t[l + 3] = t[l + 3] & 16777215 | c << 24;
}
function Bc(t, A, e, s, n, i, r) {
  const a = (r == null ? void 0 : r.rgbMin) ?? 0, c = ((r == null ? void 0 : r.rgbMax) ?? 1) - a, l = FA((e - a) / c), g = FA((s - a) / c), I = FA((n - a) / c), h = FA(i), Q = A * 4;
  t[Q] = l | g << 8 | I << 16 | h << 24;
}
function Qc(t, A, e, s, n, i) {
  const r = (i == null ? void 0 : i.rgbMin) ?? 0, o = ((i == null ? void 0 : i.rgbMax) ?? 1) - r, c = FA((e - r) / o), l = FA((s - r) / o), g = FA((n - r) / o), I = A * 4;
  t[I] = c | l << 8 | g << 16 | t[I] & 4278190080;
}
function Ec(t, A, e) {
  const s = FA(e), n = A * 4;
  t[n] = t[n] & 16777215 | s << 24;
}
const fc = new u.Vector3(), pc = new u.Vector3(), dc = new u.Quaternion(), yc = new u.Color(), wc = {
  center: fc,
  scales: pc,
  quaternion: dc,
  color: yc,
  opacity: 0
};
function Je(t, A, e) {
  const s = wc, n = A * 4, i = t[n], r = t[n + 1], a = t[n + 2], o = t[n + 3], c = (e == null ? void 0 : e.rgbMin) ?? 0, g = ((e == null ? void 0 : e.rgbMax) ?? 1) - c;
  s.color.set(
    c + (i & 255) / 255 * g,
    c + (i >>> 8 & 255) / 255 * g,
    c + (i >>> 16 & 255) / 255 * g
  ), s.opacity = (i >>> 24 & 255) / 255, s.center.set(
    wA(r & 65535),
    wA(r >>> 16 & 65535),
    wA(a & 65535)
  );
  const I = (e == null ? void 0 : e.lnScaleMin) ?? UA, Q = (((e == null ? void 0 : e.lnScaleMax) ?? GA) - I) / 254, C = o & 255;
  s.scales.x = C === 0 ? 0 : Math.exp(I + (C - 1) * Q);
  const B = o >>> 8 & 255;
  s.scales.y = B === 0 ? 0 : Math.exp(I + (B - 1) * Q);
  const E = o >>> 16 & 255;
  s.scales.z = E === 0 ? 0 : Math.exp(I + (E - 1) * Q);
  const p = a >>> 16 & 65535 | o >>> 8 & 16711680;
  return Zn(p, s.quaternion), s;
}
function mA(t) {
  const A = X, e = Math.max(
    je,
    Math.min(KA, Math.ceil(t / A))
  ), s = Math.ceil(t / (A * e)), n = A * e * s;
  return { width: A, height: e, depth: s, maxSplats: n };
}
function mc(t) {
  const A = X, e = Math.max(
    je,
    Math.min(KA, Math.ceil(t / A))
  ), s = Math.ceil(t / (A * e));
  return A * e * s;
}
function xc() {
  return navigator.maxTouchPoints > 0 ? !0 : /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(
    navigator.userAgent
  );
}
function Sc() {
  return /Android/.test(navigator.userAgent);
}
function Dc() {
  return /Oculus/.test(navigator.userAgent);
}
function Mc(t, A, e) {
  const s = new Uint8Array(A * 4);
  for (let n = 0; n < e / 2; n++) {
    const i = n * A * 4, r = (e - 1 - n) * A * 4;
    s.set(t.subarray(i, i + A * 4)), t.set(
      t.subarray(r, r + A * 4),
      i
    ), t.set(s, r);
  }
  return t;
}
function vc(t, A, e) {
  const s = document.createElement("canvas");
  s.width = A, s.height = e;
  const n = s.getContext("2d");
  if (!n)
    throw new Error("Can't get 2d context");
  const i = n.createImageData(A, e);
  return i.data.set(t), n.putImageData(i, 0, 0), s.toDataURL("image/png");
}
function Vn(t) {
  const A = new u.Clock(t.autoStart);
  return A.startTime = t.startTime, A.oldTime = t.oldTime, A.elapsedTime = t.elapsedTime, A.running = t.running, A;
}
function bc(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([A, e]) => e !== void 0)
  );
}
const Pn = hA(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);
function Xn(t) {
  const A = new u.Vector3();
  for (const e of t)
    A.add(e);
  return A.divideScalar(t.length);
}
function On(t) {
  if (t.length === 0)
    return new u.Quaternion();
  const A = t[0].clone();
  for (let e = 1; e < t.length; e++)
    t[e].dot(t[0]) < 0 ? (A.x -= t[e].x, A.y -= t[e].y, A.z -= t[e].z, A.w -= t[e].w) : (A.x += t[e].x, A.y += t[e].y, A.z += t[e].z, A.w += t[e].w);
  return A.normalize();
}
function Wn(t, A) {
  const e = new u.Vector3(0, 0, 0).applyMatrix4(t), s = new u.Vector3(0, 0, 0).applyMatrix4(A), n = new u.Vector3(0, 0, -1).applyMatrix4(t).sub(e).normalize(), i = new u.Vector3(0, 0, -1).applyMatrix4(A).sub(s).normalize(), r = e.distanceTo(s), a = n.dot(i);
  return { distance: r, coincidence: a };
}
function Fc({
  matrix1: t,
  matrix2: A,
  maxDistance: e
}) {
  const s = new u.Vector3(0, 0, 0).applyMatrix4(t), n = new u.Vector3(0, 0, 0).applyMatrix4(A);
  return s.distanceTo(n) <= e;
}
function kc({
  matrix1: t,
  matrix2: A,
  maxDistance: e,
  minCoincidence: s
}) {
  const { distance: n, coincidence: i } = Wn(t, A);
  return n <= e && (s == null || i >= s);
}
function jn(t, A) {
  const [e, s] = [new u.Vector3(), new u.Quaternion()], [n, i] = [new u.Vector3(), new u.Quaternion()];
  t.decompose(e, s, new u.Vector3()), A.decompose(n, i, new u.Vector3());
  const r = e.distanceTo(n), a = Math.abs(s.dot(i));
  return { distance: r, coorient: a };
}
function ce({
  matrix1: t,
  matrix2: A,
  maxDistance: e,
  minCoorient: s
}) {
  const { distance: n, coorient: i } = jn(t, A);
  return n <= e && (s == null || i >= s);
}
function Tc(t, A = 1e-3) {
  return Math.abs(t) < A ? 0 : Math.sign(t);
}
function Nc(t) {
  const A = t.w < 0, e = ie(A ? -t.x : t.x), s = ie(A ? -t.y : t.y), n = ie(A ? -t.z : t.z), i = e & 255, r = s & 255, a = n & 255;
  return i | r << 8 | a << 16;
}
function Uc(t, A) {
  const e = t << 24 >> 24, s = t << 16 >> 24, n = t << 8 >> 24;
  A.set(e / 127, s / 127, n / 127, 0);
  const i = A.x * A.x + A.y * A.y + A.z * A.z;
  return A.w = Math.sqrt(Math.max(0, 1 - i)), A;
}
const Gc = new u.Quaternion(), _e = new u.Vector3();
function ss(t) {
  const A = Gc.copy(t).normalize();
  A.w < 0 && A.set(-A.x, -A.y, -A.z, -A.w);
  const e = 2 * Math.acos(A.w), s = Math.sqrt(
    A.x * A.x + A.y * A.y + A.z * A.z
  ), n = s < 1e-6 ? _e.set(1, 0, 0) : _e.set(A.x, A.y, A.z).divideScalar(s), i = Math.abs(n.x) + Math.abs(n.y) + Math.abs(n.z);
  let r = n.x / i, a = n.y / i;
  if (n.z < 0) {
    const h = r;
    r = (1 - Math.abs(a)) * (r >= 0 ? 1 : -1), a = (1 - Math.abs(h)) * (a >= 0 ? 1 : -1);
  }
  const o = r * 0.5 + 0.5, c = a * 0.5 + 0.5, l = Math.round(o * 255), g = Math.round(c * 255);
  return Math.round(e * (255 / Math.PI)) << 16 | g << 8 | l;
}
function Zn(t, A) {
  const e = t & 255, s = t >>> 8 & 255, n = t >>> 16 & 255, i = e / 255, r = s / 255;
  let a = (i - 0.5) * 2, o = (r - 0.5) * 2;
  const c = 1 - (Math.abs(a) + Math.abs(o)), l = Math.max(-c, 0);
  a += a >= 0 ? -l : l, o += o >= 0 ? -l : l;
  const g = _e.set(a, o, c).normalize(), h = n / 255 * Math.PI * 0.5, Q = Math.sin(h), C = Math.cos(h);
  return A.set(g.x * Q, g.y * Q, g.z * Q, C), A;
}
function Rc(t) {
  const A = t.clone().normalize(), e = 2 * (A.w * A.x + A.y * A.z), s = 1 - 2 * (A.x * A.x + A.y * A.y), n = Math.atan2(e, s), i = 2 * (A.w * A.y - A.z * A.x), r = Math.abs(i) >= 1 ? Math.sign(i) * (Math.PI / 2) : Math.asin(i), a = 2 * (A.w * A.z + A.x * A.y), o = 1 - 2 * (A.y * A.y + A.z * A.z), c = Math.atan2(a, o), l = (n + Math.PI) / (2 * Math.PI), g = (r + Math.PI) / (2 * Math.PI), I = (c + Math.PI) / (2 * Math.PI), h = Math.round(l * 255), Q = Math.round(g * 255);
  return Math.round(I * 255) << 16 | Q << 8 | h;
}
function Yc(t, A) {
  const e = t & 255, s = t >>> 8 & 255, n = t >>> 16 & 255, i = e / 255, r = s / 255, a = n / 255, o = i * (2 * Math.PI) - Math.PI, c = r * (2 * Math.PI) - Math.PI, l = a * (2 * Math.PI) - Math.PI, g = Math.cos(o * 0.5), I = Math.sin(o * 0.5), h = Math.cos(c * 0.5), Q = Math.sin(c * 0.5), C = Math.cos(l * 0.5), B = Math.sin(l * 0.5);
  return A.w = g * h * C + I * Q * B, A.x = I * h * C - g * Q * B, A.y = g * Q * C + I * h * B, A.z = g * h * B - I * Q * C, A.normalize(), A;
}
function te(t, A, e, s) {
  const n = Math.max(-127, Math.min(127, t * 127)), i = Math.max(-127, Math.min(127, A * 127)), r = Math.max(-127, Math.min(127, e * 127)), a = Math.max(-127, Math.min(127, s * 127));
  return n & 255 | (i & 255) << 8 | (r & 255) << 16 | (a & 255) << 24;
}
function Jc(t, A, e, s) {
  const n = (s == null ? void 0 : s.sh1Min) ?? -1, i = (s == null ? void 0 : s.sh1Max) ?? 1, r = 0.5 * (n + i), a = 126 / (i - n), o = A * 2;
  for (let c = 0; c < 9; ++c) {
    const l = (e[c] - r) * a, g = Math.round(Math.max(-63, Math.min(63, l))) & 127, I = c * 7, h = I + 7, Q = Math.floor(I / 32), C = I - Q * 32, B = g << C & 4294967295;
    if (t[o + Q] |= B, h > Q * 32 + 32) {
      const E = g >>> 32 - C & 4294967295;
      t[o + Q + 1] |= E;
    }
  }
}
function _c(t, A, e, s) {
  const n = (s == null ? void 0 : s.sh2Min) ?? -1, i = (s == null ? void 0 : s.sh2Max) ?? 1, r = 0.5 * (n + i), a = 2 / (i - n);
  t[A * 4 + 0] = te(
    (e[0] - r) * a,
    (e[1] - r) * a,
    (e[2] - r) * a,
    (e[3] - r) * a
  ), t[A * 4 + 1] = te(
    (e[4] - r) * a,
    (e[5] - r) * a,
    (e[6] - r) * a,
    (e[7] - r) * a
  ), t[A * 4 + 2] = te(
    (e[8] - r) * a,
    (e[9] - r) * a,
    (e[10] - r) * a,
    (e[11] - r) * a
  ), t[A * 4 + 3] = te(
    (e[12] - r) * a,
    (e[13] - r) * a,
    (e[14] - r) * a,
    0
  );
}
function Lc(t, A, e, s) {
  const n = (s == null ? void 0 : s.sh3Min) ?? -1, i = (s == null ? void 0 : s.sh3Max) ?? 1, r = 0.5 * (n + i), a = 62 / (i - n), o = A * 4;
  for (let c = 0; c < 21; ++c) {
    const l = (e[c] - r) * a, g = Math.round(Math.max(-31, Math.min(31, l))) & 63, I = c * 6, h = I + 6, Q = Math.floor(I / 32), C = I - Q * 32, B = g << C & 4294967295;
    if (t[o + Q] |= B, h > Q * 32 + 32) {
      const E = g >>> 32 - C & 4294967295;
      t[o + Q + 1] |= E;
    }
  }
}
function Ai(t, A) {
  const e = [];
  let s = 0, n = null;
  const i = new Ns((o, c) => {
    if (e.push(o), s += o.length, c || s >= A) {
      const l = new Uint8Array(s);
      let g = 0;
      for (const I of e)
        l.set(I, g), g += I.length;
      n = l.slice(0, A);
    }
  }), r = 1024;
  let a = 0;
  for (; n == null && a < t.length; ) {
    const o = t.slice(a, a + r);
    i.push(o, !1), a += r;
  }
  if (n == null && (i.push(new Uint8Array(), !0), n == null))
    throw new Error("Failed to decompress partial gzip");
  return n;
}
class ti {
  constructor({
    fileBytes: A,
    chunkBytes: e = 64 * 1024
  }) {
    this.fileBytes = A, this.chunkBytes = e, this.offset = 0, this.chunks = [], this.totalBytes = 0, this.gunzip = new Ns((s, n) => {
      this.chunks.push(s), this.totalBytes += s.length;
    });
  }
  read(A) {
    for (; this.totalBytes < A && this.offset < this.fileBytes.length; ) {
      const i = Math.min(
        this.offset + this.chunkBytes,
        this.fileBytes.length
      );
      this.gunzip.push(this.fileBytes.subarray(this.offset, i), !1), this.offset = i;
    }
    if (this.totalBytes < A && this.offset >= this.fileBytes.length && this.gunzip.push(new Uint8Array(0), !0), this.totalBytes < A)
      throw new Error(
        `Unexpected EOF: needed ${A}, got ${this.totalBytes}`
      );
    const e = new Uint8Array(this.totalBytes);
    let s = 0;
    for (const i of this.chunks)
      e.set(i, s), s += i.length;
    const n = e.subarray(0, A);
    return this.chunks = [e.subarray(A)], this.totalBytes -= A, n;
  }
}
const Vh = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataCache: gc,
  FreeList: Kn,
  GunzipReader: ti,
  IDENT_VERTEX_SHADER: Pn,
  Sint8ToFloat: oc,
  Uint8ToFloat: ac,
  averagePositions: Xn,
  averageQuaternions: On,
  cloneClock: Vn,
  coinciDist: Wn,
  computeMaxSplats: mc,
  coorientDist: jn,
  decodeQuatEulerXyz888: Yc,
  decodeQuatOctXy88R8: Zn,
  decodeQuatXyz888: Uc,
  decompressPartialGzip: Ai,
  encodeQuatEulerXyz888: Rc,
  encodeQuatOctXy88R8: ss,
  encodeQuatXyz888: Nc,
  encodeSh1Rgb: Jc,
  encodeSh2Rgb: _c,
  encodeSh3Rgb: Lc,
  epsilonSign: Tc,
  flipPixels: Mc,
  floatBitsToUint: tc,
  floatToSint8: ie,
  floatToUint8: FA,
  fromHalf: wA,
  getArrayBuffers: Hn,
  getTextureSize: mA,
  isAndroid: Sc,
  isMobile: xc,
  isOculus: Dc,
  mapFilterObject: lc,
  mapObject: cc,
  newArray: Ic,
  normalize: qn,
  omitUndefined: bc,
  pixelsToPngUrl: vc,
  setPackedSplat: Ye,
  setPackedSplatCenter: uc,
  setPackedSplatOpacity: Ec,
  setPackedSplatQuat: Cc,
  setPackedSplatRgb: Qc,
  setPackedSplatRgba: Bc,
  setPackedSplatScales: hc,
  toHalf: Ct,
  uintBitsToFloat: ec,
  unpackSplat: Je,
  withinCoinciDist: kc,
  withinCoorientDist: ce,
  withinDist: Fc
}, Symbol.toStringTag, { value: "Module" }));
class ns {
  constructor({
    graph: A,
    inputs: e,
    outputs: s,
    template: n
  }) {
    this.graph = A, this.template = n, this.inputs = e ?? {}, this.outputs = s ?? {};
    const i = new $s({ indent: this.template.indent });
    for (const a in this.outputs)
      this.outputs[a] && i.declares.add(this.outputs[a]);
    const r = A.compile({
      inputs: this.inputs,
      outputs: this.outputs,
      compile: i
    });
    this.shader = n.generate({ globals: i.globals, statements: r }), this.uniforms = i.uniforms, this.updaters = i.updaters;
  }
  prepareMaterial() {
    return zc(this);
  }
  update() {
    for (const A of this.updaters)
      A();
  }
}
class is {
  constructor(A) {
    const e = A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m), s = A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);
    if (!e || !s)
      throw new Error(
        "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
      );
    this.before = A.substring(0, e.index), this.between = A.substring(
      e.index + e[0].length,
      s.index
    ), this.after = A.substring(
      s.index + s[0].length
    ), this.indent = s[1];
  }
  generate({
    globals: A,
    statements: e
  }) {
    return this.before + Array.from(A).join(`

`) + this.between + e.map((s) => this.indent + s).join(`
`) + this.after;
  }
}
const Qs = /* @__PURE__ */ new Map();
function zc(t) {
  let A = Qs.get(t);
  return A || (A = new u.RawShaderMaterial({
    glslVersion: u.GLSL3,
    vertexShader: Pn,
    fragmentShader: t.shader,
    uniforms: t.uniforms
  }), Qs.set(t, A), A);
}
function rs(t, A, e = "add") {
  const s = () => {
    throw new Error(`Invalid ${e} types: ${t}, ${A}`);
  };
  if (t === A) return t;
  if (t === "int") {
    if (QA(A)) return A;
    s();
  }
  if (A === "int") {
    if (QA(t)) return t;
    s();
  }
  if (t === "uint") {
    if (EA(A)) return A;
    s();
  }
  if (A === "uint") {
    if (EA(t)) return t;
    s();
  }
  if (t === "float") {
    if (at(A)) return A;
    s();
  }
  if (A === "float") {
    if (at(t)) return t;
    s();
  }
  throw new Error(`Invalid ${e} types: ${t}, ${A}`);
}
function qc(t, A) {
  return rs(t, A, "sub");
}
function Hc(t, A) {
  const e = () => {
    throw new Error(`Invalid mul types: ${t}, ${A}`);
  }, s = (n) => n;
  if (t === "int") {
    if (QA(A)) return s(A);
    e();
  }
  if (A === "int") {
    if (QA(t)) return s(t);
    e();
  }
  if (t === "uint") {
    if (EA(A)) return s(A);
    e();
  }
  if (A === "uint") {
    if (EA(t)) return s(t);
    e();
  }
  if (t === "float") {
    if (at(A)) return s(A);
    e();
  }
  if (A === "float") {
    if (at(t)) return s(t);
    e();
  }
  if (QA(t) || EA(t) || QA(A) || EA(A)) {
    if (t === A) return s(t);
    e();
  }
  if (t === "vec2") {
    if (A === "vec2" || ot(A)) return s("vec2");
    if (A === "mat3x2") return s("vec3");
    if (A === "mat4x2") return s("vec4");
    e();
  }
  if (t === "vec3") {
    if (A === "mat2x3") return s("vec2");
    if (A === "vec3" || gt(A)) return s("vec3");
    if (A === "mat4x3") return s("vec4");
    e();
  }
  if (t === "vec4") {
    if (A === "mat2x4") return s("vec2");
    if (A === "mat3x4") return s("vec3");
    if (A === "vec4" || ct(A)) return s("vec4");
    e();
  }
  if (A === "vec2") {
    if (ot(t)) return s("vec2");
    if (t === "mat2x3") return s("vec3");
    if (t === "mat2x4") return s("vec4");
    e();
  }
  if (A === "vec3") {
    if (t === "mat3x2") return s("vec2");
    if (gt(t)) return s("vec3");
    if (t === "mat3x4") return s("vec4");
    e();
  }
  if (A === "vec4") {
    if (t === "mat4x2") return s("vec2");
    if (t === "mat4x3") return s("vec3");
    if (ct(t)) return s("vec4");
    e();
  }
  if (ot(t)) {
    if (ot(A)) return s("mat2");
    if (A === "mat3x2") return s("mat3x2");
    if (A === "mat4x2") return s("mat4x2");
    e();
  }
  if (t === "mat2x3") {
    if (ot(A)) return s("mat2x3");
    if (A === "mat3x2") return s("mat3");
    if (A === "mat4x2") return s("mat4x3");
    e();
  }
  if (t === "mat2x4") {
    if (ot(A)) return s("mat2x4");
    if (A === "mat3x2") return s("mat3x4");
    if (A === "mat4x2") return s("mat4");
    e();
  }
  if (t === "mat3x2") {
    if (A === "mat2x3") return s("mat2");
    if (gt(A)) return s("mat3x2");
    if (A === "mat4x3") return s("mat4x2");
    e();
  }
  if (gt(t)) {
    if (A === "mat2x3") return s("mat2x3");
    if (gt(A)) return s("mat3");
    if (A === "mat4x3") return s("mat4x3");
    e();
  }
  if (t === "mat3x4") {
    if (A === "mat2x3") return s("mat2x4");
    if (gt(A)) return s("mat3x4");
    if (A === "mat4x3") return s("mat4");
    e();
  }
  if (t === "mat4x2") {
    if (A === "mat2x4") return s("mat2");
    if (A === "mat3x4") return s("mat3x2");
    if (ct(A)) return s("mat4x2");
    e();
  }
  if (t === "mat4x3") {
    if (A === "mat2x4") return s("mat2x3");
    if (A === "mat3x4") return s("mat3");
    if (ct(A)) return s("mat4x3");
    e();
  }
  if (ct(t)) {
    if (A === "mat2x4") return s("mat2x4");
    if (A === "mat3x4") return s("mat3x4");
    if (ct(A)) return s("mat4");
    e();
  }
  throw new Error(`Invalid mul types: ${t}, ${A}`);
}
function Kc(t, A) {
  return rs(t, A, "div");
}
function $c(t, A) {
  if (t === A) return t;
  if (t === "int") {
    if (QA(A)) return A;
  } else if (A === "int") {
    if (QA(t)) return t;
  } else if (t === "uint") {
    if (EA(A)) return A;
  } else if (A === "uint" && EA(t))
    return t;
  throw new Error(`Invalid imod types: ${t}, ${A}`);
}
function Vc(t, A) {
  if (t === A || A === "float") return t;
  throw new Error(`Invalid mod types: ${t}, ${A}`);
}
function Pc(t) {
  return t;
}
function Xc(t) {
  return t;
}
function Oc(t) {
  return t;
}
function Wc(t) {
  return t;
}
function jc(t) {
  return t;
}
function Zc(t) {
  return t;
}
function Al(t) {
  return t;
}
function tl(t) {
  return t;
}
function el(t) {
  return t;
}
function sl(t) {
  return t;
}
function nl(t) {
  return t;
}
function il(t) {
  return t;
}
function rl(t) {
  return t;
}
function al(t) {
  return t;
}
function ol(t) {
  return t;
}
function gl(t) {
  return t;
}
function ei(t, A, e = "min") {
  if (t === A) return t;
  if (A === "float") {
    if (Xt(t)) return t;
  } else if (A === "int") {
    if (QA(t)) return t;
  } else if (A === "uint" && EA(t))
    return t;
  throw new Error(`Invalid ${e} types: ${t}, ${A}`);
}
function cl(t, A) {
  return ei(t, A, "max");
}
function ll(t, A, e) {
  if (A === "float") {
    if (Xt(t)) return t;
  } else if (A === "int") {
    if (QA(t)) return t;
  } else if (A === "uint" && EA(t))
    return t;
  throw new Error(`Invalid clamp types: ${t}, ${A}`);
}
function Il(t, A, e) {
  if (e === t || e === "float" || e === "bool" && t === "float" || e === "bvec2" && t === "vec2" || e === "bvec3" && t === "vec3" || e === "bvec4" && t === "vec4") return t;
  throw new Error(`Invalid mix types: ${t}, ${A}, ${e}`);
}
function ul(t, A) {
  if (t === A || A === "float") return A;
  throw new Error(`Invalid step types: ${t}, ${A}`);
}
function hl(t, A, e) {
  if (t === A && (t === e || t === "float"))
    return e;
  throw new Error(`Invalid smoothstep types: ${t}, ${A}, ${e}`);
}
function si(t, A = "isNan") {
  if (t === "float") return "bool";
  if (t === "vec2") return "bvec2";
  if (t === "vec3") return "bvec3";
  if (t === "vec4") return "bvec4";
  throw new Error(`Invalid ${A} types: ${t}`);
}
function Cl(t) {
  return si(t, "isInf");
}
const BA = (t, A) => new ai({ a: t, b: A }), Et = (t, A) => new oi({ a: t, b: A }), iA = (t, A) => new gi({ a: t, b: A }), re = (t, A) => new ci({ a: t, b: A }), Le = (t, A) => new li({ a: t, b: A }), ni = (t, A) => new Ii({ a: t, b: A }), Bl = (t) => new ui({ a: t }).outputs, as = (t) => new hi({ a: t }), Ql = (t) => new Ci({ a: t }), El = (t) => new Bi({ a: t }), fl = (t) => new Qi({ a: t }), pl = (t) => new Ei({ a: t }), dl = (t) => new fi({ a: t }), yl = (t) => new pi({ a: t }), ae = (t) => new di({ a: t }), wl = (t, A) => new yi({ a: t, b: A }), ml = (t) => new wi({ a: t }), xl = (t) => new mi({ a: t }), Sl = (t) => new xi({ a: t }), Dl = (t) => new Si({ a: t }), Ml = (t) => new Di({ a: t }), vl = (t) => new Mi({ a: t }), bl = (t) => new vi({ a: t }), Fl = (t, A) => new bi({ a: t, b: A }), ii = (t, A) => new Fi({ a: t, b: A }), kl = (t, A, e) => new ki({ a: t, min: A, max: e }), ri = (t, A, e) => new Ti({ a: t, b: A, t: e }), Tl = (t, A) => new Ni({ edge: t, x: A }), Nl = (t, A, e) => new Ui({ edge0: t, edge1: A, x: e }), Ul = (t) => new Gi({ a: t }), Gl = (t) => new Ri({ a: t });
class ai extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "sum", outTypeFunc: rs }), this.statements = ({ inputs: s, outputs: n }) => [`${n.sum} = ${s.a} + ${s.b};`];
  }
}
class oi extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "difference", outTypeFunc: qc }), this.statements = ({ inputs: s, outputs: n }) => [`${n.difference} = ${s.a} - ${s.b};`];
  }
}
class gi extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "product", outTypeFunc: Hc }), this.statements = ({ inputs: s, outputs: n }) => [`${n.product} = ${s.a} * ${s.b};`];
  }
}
class ci extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "quotient", outTypeFunc: Kc }), this.statements = ({ inputs: s, outputs: n }) => [`${n.quotient} = ${s.a} / ${s.b};`];
  }
}
class li extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "remainder", outTypeFunc: $c }), this.statements = ({ inputs: s, outputs: n }) => [`${n.remainder} = ${s.a} % ${s.b};`];
  }
}
class Ii extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "remainder", outTypeFunc: Vc }), this.statements = ({ inputs: s, outputs: n }) => [`${n.remainder} = mod(${s.a}, ${s.b});`];
  }
}
class ui extends V {
  constructor({ a: A }) {
    const e = { a: $(A) }, s = e.a, n = {
      fract: s,
      integer: s
    };
    super({ inTypes: e, outTypes: n, inputs: { a: A } }), this.statements = ({ inputs: i, outputs: r }) => [`${r.fract} = modf(${i.a}, ${r.integer});`];
  }
}
class hi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "neg", outTypeFunc: Pc }), this.statements = ({ inputs: e, outputs: s }) => [`${s.neg} = -${e.a};`];
  }
}
class Ci extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "abs", outTypeFunc: Xc }), this.statements = ({ inputs: e, outputs: s }) => [`${s.abs} = abs(${e.a});`];
  }
}
class Bi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "sign", outTypeFunc: Oc }), this.statements = ({ inputs: e, outputs: s }) => [`${s.sign} = sign(${e.a});`];
  }
}
class Qi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "floor", outTypeFunc: Wc }), this.statements = ({ inputs: e, outputs: s }) => [`${s.floor} = floor(${e.a});`];
  }
}
class Ei extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "ceil", outTypeFunc: jc }), this.statements = ({ inputs: e, outputs: s }) => [`${s.ceil} = ceil(${e.a});`];
  }
}
class fi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "trunc", outTypeFunc: Zc }), this.statements = ({ inputs: e, outputs: s }) => [`${s.trunc} = trunc(${e.a});`];
  }
}
class pi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "round", outTypeFunc: Al }), this.statements = ({ inputs: e, outputs: s }) => [`${s.round} = round(${e.a});`];
  }
}
class di extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "fract", outTypeFunc: tl }), this.statements = ({ inputs: e, outputs: s }) => [`${s.fract} = fract(${e.a});`];
  }
}
class yi extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "power", outTypeFunc: el }), this.statements = ({ inputs: s, outputs: n }) => [`${n.power} = pow(${s.a}, ${s.b});`];
  }
}
class wi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp", outTypeFunc: sl }), this.statements = ({ inputs: e, outputs: s }) => [`${s.exp} = exp(${e.a});`];
  }
}
class mi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp2", outTypeFunc: nl }), this.statements = ({ inputs: e, outputs: s }) => [`${s.exp2} = exp2(${e.a});`];
  }
}
class xi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "log", outTypeFunc: il }), this.statements = ({ inputs: e, outputs: s }) => [`${s.log} = log(${e.a});`];
  }
}
class Si extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "log2", outTypeFunc: rl }), this.statements = ({ inputs: e, outputs: s }) => [`${s.log2} = log2(${e.a});`];
  }
}
class Di extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqr", outTypeFunc: al }), this.statements = ({ inputs: e, outputs: s }) => [`${s.sqr} = ${e.a} * ${e.a};`];
  }
}
class Mi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqrt", outTypeFunc: ol }), this.statements = ({ inputs: e, outputs: s }) => [`${s.sqrt} = sqrt(${e.a});`];
  }
}
class vi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "inversesqrt", outTypeFunc: gl }), this.statements = ({ inputs: e, outputs: s }) => [`${s.inversesqrt} = inversesqrt(${e.a});`];
  }
}
class bi extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "min", outTypeFunc: ei }), this.statements = ({ inputs: s, outputs: n }) => [`${n.min} = min(${s.a}, ${s.b});`];
  }
}
class Fi extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "max", outTypeFunc: cl }), this.statements = ({ inputs: s, outputs: n }) => [`${n.max} = max(${s.a}, ${s.b});`];
  }
}
class ki extends yt {
  constructor({
    a: A,
    min: e,
    max: s
  }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "clamp",
      outTypeFunc: ll
    }), this.statements = ({ inputs: n, outputs: i }) => {
      const { a: r, b: a, c: o } = n;
      return [`${i.clamp} = clamp(${r}, ${a}, ${o});`];
    };
  }
}
class Ti extends yt {
  constructor({ a: A, b: e, t: s }) {
    super({ a: A, b: e, c: s, outKey: "mix", outTypeFunc: Il }), this.statements = ({ inputs: n, outputs: i }) => {
      const { a: r, b: a, c: o } = n;
      return [`${i.mix} = mix(${r}, ${a}, ${o});`];
    };
  }
}
class Ni extends tA {
  constructor({ edge: A, x: e }) {
    super({
      a: A,
      b: e,
      outKey: "step",
      outTypeFunc: ul
    }), this.statements = ({ inputs: s, outputs: n }) => {
      const { a: i, b: r } = s;
      return [`${n.step} = step(${i}, ${r});`];
    };
  }
}
class Ui extends yt {
  constructor({
    edge0: A,
    edge1: e,
    x: s
  }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "smoothstep",
      outTypeFunc: hl
    }), this.statements = ({ inputs: n, outputs: i }) => {
      const { a: r, b: a, c: o } = n;
      return [`${i.smoothstep} = smoothstep(${r}, ${a}, ${o});`];
    };
  }
}
class Gi extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "isNan", outTypeFunc: si }), this.statements = ({ inputs: e, outputs: s }) => [`${s.isNan} = isNan(${e.a});`];
  }
}
class Ri extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "isInf", outTypeFunc: Cl }), this.statements = ({ inputs: e, outputs: s }) => [`${s.isInf} = isInf(${e.a});`];
  }
}
const Rl = (t, A) => new Ji({ a: t, b: A }), Yl = (t, A) => new _i({ a: t, b: A }), Jl = (t, A) => new Li({ a: t, b: A }), _l = (t) => new zi({ a: t }), Ll = (t, A) => new qi({ a: t, b: A }), zl = (t, A) => new Hi({ a: t, b: A }), ql = (t, A) => new Ki({ a: t, b: A }), Yi = (t, A) => new $i({ a: t, b: A }), Hl = (t, A) => new Vi({ a: t, b: A }), Kl = (t, A) => new Pi({ a: t, b: A }), $l = (t) => new Xi({ a: t }), Vl = (t) => new Oi({ a: t }), os = (t, A, e) => new Wi({ cond: t, t: A, f: e }), Pl = (t) => new Zi({ a: t });
class Ji extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (s, n) => s, outKey: "and" }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.and === "bool" ? [`${n.and} = ${s.a} && ${s.b};`] : [`${n.and} = ${s.a} & ${s.b};`];
  }
}
class _i extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (s, n) => s, outKey: "or" }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.or === "bool" ? [`${n.or} = ${s.a} || ${s.b};`] : [`${n.or} = ${s.a} | ${s.b};`];
  }
}
class Li extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: (s, n) => s, outKey: "xor" }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.xor === "bool" ? [`${n.xor} = ${s.a} ^^ ${s.b};`] : [`${n.xor} = ${s.a} ^ ${s.b};`];
  }
}
class zi extends v {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "not" }), this.statements = ({ inputs: e, outputs: s }) => this.outTypes.not === "bool" ? [`${s.not} = !${e.a};`] : [`${s.not} = not(${e.a});`];
  }
}
class qi extends tA {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, n) => pe(s, "lessThan"),
      outKey: "lessThan"
    }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.lessThan === "bool" ? [`${n.lessThan} = ${s.a} < ${s.b};`] : [`${n.lessThan} = lessThan(${s.a}, ${s.b});`];
  }
}
class Hi extends tA {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, n) => pe(s, "lessThanEqual"),
      outKey: "lessThanEqual"
    }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.lessThanEqual === "bool" ? [`${n.lessThanEqual} = ${s.a} <= ${s.b};`] : [
      `${n.lessThanEqual} = lessThanEqual(${s.a}, ${s.b});`
    ];
  }
}
class Ki extends tA {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, n) => pe(s, "greaterThan"),
      outKey: "greaterThan"
    }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.greaterThan === "bool" ? [`${n.greaterThan} = ${s.a} > ${s.b};`] : [
      `${n.greaterThan} = greaterThan(${s.a}, ${s.b});`
    ];
  }
}
class $i extends tA {
  constructor({ a: A, b: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, n) => pe(s, "greaterThanEqual"),
      outKey: "greaterThanEqual"
    }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.greaterThanEqual === "bool" ? [`${n.greaterThanEqual} = ${s.a} >= ${s.b};`] : [
      `${n.greaterThanEqual} = greaterThanEqual(${s.a}, ${s.b});`
    ];
  }
}
class Vi extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: ji, outKey: "equal" }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.equal === "bool" ? [`${n.equal} = ${s.a} == ${s.b};`] : [`${n.equal} = equal(${s.a}, ${s.b});`];
  }
}
class Pi extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outTypeFunc: Xl, outKey: "notEqual" }), this.statements = ({ inputs: s, outputs: n }) => this.outTypes.notEqual === "bool" ? [`${n.notEqual} = ${s.a} != ${s.b};`] : [`${n.notEqual} = notEqual(${s.a}, ${s.b});`];
  }
}
class Xi extends v {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "bool", outKey: "any" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.any} = any(${e.a});`];
  }
}
class Oi extends v {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "bool", outKey: "all" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.all} = all(${e.a});`];
  }
}
class Wi extends yt {
  constructor({
    cond: A,
    t: e,
    f: s
  }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "select",
      outTypeFunc: (n, i, r) => i
    }), this.statements = ({ inputs: n, outputs: i }) => {
      const { a: r, b: a, c: o } = n;
      return [`${i.select} = (${r}) ? (${a}) : (${o});`];
    };
  }
}
function pe(t, A) {
  if (dt(t))
    return "bool";
  if (t === "ivec2" || t === "uvec2" || t === "vec2")
    return "bvec2";
  if (t === "ivec3" || t === "uvec3" || t === "vec3")
    return "bvec3";
  if (t === "ivec4" || t === "uvec4" || t === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${t}`);
}
function ji(t, A = "equal") {
  if (dt(t))
    return "bool";
  if (pt(t))
    return t;
  if (t === "ivec2" || t === "uvec2" || t === "vec2")
    return "bvec2";
  if (t === "ivec3" || t === "uvec3" || t === "vec3")
    return "bvec3";
  if (t === "ivec4" || t === "uvec4" || t === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${t}`);
}
function Xl(t) {
  return ji(t, "notEqual");
}
function Ol(t) {
  if (pt(t))
    return "bool";
  if (QA(t))
    return "int";
  if (EA(t))
    return "uint";
  throw new Error(`Invalid compXor type: ${t}`);
}
class Zi extends v {
  constructor({ a: A }) {
    const e = Ol($(A));
    super({ a: A, outTypeFunc: (s) => e, outKey: "compXor" }), this.statements = ({ inputs: s, outputs: n }) => {
      if (dt(this.outTypes.compXor))
        return [`${n.compXor} = ${s.a};`];
      const r = (kt(e) ? ["x", "y"] : Tt(e) ? ["x", "y", "z"] : ["x", "y", "z", "w"]).map((o) => `${s.a}.${o}`), a = pt(e) ? "^^" : "^";
      return [`${n.compXor} = ${r.join(` ${a} `)};`];
    };
  }
}
const Wl = (t) => new rr({ value: t }), jl = (t) => new ar({ value: t }), Zl = (t) => new or({ value: t }), Ar = (t) => new gr({ value: t }), AI = (t) => new cr({ value: t }), tI = (t) => new lr({ value: t }), eI = (t) => new Ir({ value: t }), sI = (t) => new ur({ value: t }), nI = (t) => new hr({ value: t }), iI = (t) => new Cr({ value: t }), rI = (t) => new Br({ value: t }), aI = (t) => new Qr({ value: t }), oI = (t) => new Er({ value: t }), tr = (t) => new fr({ value: t }), Bt = (t) => new pr({ value: t }), er = (t) => new dr({ value: t }), gI = (t) => new yr({ value: t }), cI = (t) => new wr({ value: t }), lI = (t) => new mr({ value: t }), sr = (t) => new xr({ value: t }), nr = (t) => new Sr({ value: t }), II = (t) => new Dr({ value: t }), uI = (t) => new Mr({ value: t }), hI = (t) => new vr({ value: t }), CI = (t) => new br({ value: t }), BI = (t) => new Fr({ value: t }), QI = (t) => new kr({ value: t }), ir = (t) => new Tr({ value: t }), EI = (t) => new Nr({ value: t }), ze = (t) => new Ur({ value: t });
class gA extends v {
  constructor({
    value: A,
    outType: e,
    outKey: s
  }) {
    super({ a: A, outTypeFunc: () => e, outKey: s }), this.statements = ({ inputs: n, outputs: i }) => [
      `${i[s]} = ${Hs(e)}(${n.a});`
    ];
  }
}
class rr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bool", outKey: "bool" });
  }
}
class ar extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "int", outKey: "int" });
  }
}
class or extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uint", outKey: "uint" });
  }
}
class gr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "float", outKey: "float" });
  }
}
class cr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec2", outKey: "bvec2" });
  }
}
class lr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec3", outKey: "bvec3" });
  }
}
class Ir extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec4", outKey: "bvec4" });
  }
}
class ur extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec2", outKey: "ivec2" });
  }
}
class hr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec3", outKey: "ivec3" });
  }
}
class Cr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec4", outKey: "ivec4" });
  }
}
class Br extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec2", outKey: "uvec2" });
  }
}
class Qr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec3", outKey: "uvec3" });
  }
}
class Er extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec4", outKey: "uvec4" });
  }
}
class fr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec2", outKey: "vec2" });
  }
}
class pr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec3", outKey: "vec3" });
  }
}
class dr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec4", outKey: "vec4" });
  }
}
class yr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat2", outKey: "mat2" });
  }
}
class wr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat3", outKey: "mat3" });
  }
}
class mr extends gA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat4", outKey: "mat4" });
  }
}
class xr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "int", outTypeFunc: () => "int" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.int} = floatBitsToInt(${e.a});`];
  }
}
class Sr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.uint} = floatBitsToUint(${e.a});`];
  }
}
class Dr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.float} = intBitsToFloat(${e.a});`];
  }
}
class Mr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.float} = uintBitsToFloat(${e.a});`];
  }
}
class vr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.uint} = packSnorm2x16(${e.a});`];
  }
}
class br extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.vec2} = unpackSnorm2x16(${e.a});`];
  }
}
class Fr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.uint} = packUnorm2x16(${e.a});`];
  }
}
class kr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.vec2} = unpackUnorm2x16(${e.a});`];
  }
}
class Tr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.uint} = packHalf2x16(${e.a});`];
  }
}
class Nr extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: e, outputs: s }) => [`${s.vec2} = unpackHalf2x16(${e.a});`];
  }
}
class Ur extends v {
  constructor({ value: A }) {
    super({ a: A, outKey: "rgba8", outTypeFunc: () => "vec4" }), this.statements = ({ inputs: e, outputs: s }) => [
      `uvec4 uRgba = uvec4(${e.a} & 0xffu, (${e.a} >> 8u) & 0xffu, (${e.a} >> 16u) & 0xffu, (${e.a} >> 24u) & 0xffu);`,
      `${s.rgba8} = vec4(uRgba) / 255.0;`
    ];
  }
}
const fI = (t) => new Jr({ a: t }), pI = (t, A) => new _r({ a: t, b: A }), Gr = (t, A) => new Lr({ a: t, b: A }), dI = (t, A) => new zr({ a: t, b: A }), Rr = (t) => new qr({ a: t }), yI = (t, A, e) => new $r({ a: t, b: A, c: e }), wI = (t, A) => new Vr({ incident: t, normal: A }), mI = (t, A, e) => new Pr({ incident: t, normal: A, eta: e }), Qt = (t) => new Aa({ vector: t }), $A = ({
  vector: t,
  vectorType: A,
  x: e,
  y: s,
  z: n,
  w: i,
  r,
  g: a,
  b: o,
  a: c
}) => new ta({ vector: t, vectorType: A, x: e, y: s, z: n, w: i, r, g: a, b: o, a: c }), xI = (t) => new Hr({ a: t }), Yr = (t, A) => new Kr({ a: t, b: A }), SI = (t, A) => new ea({ vector: t, select: A }), DI = (t, A) => new Xr({ a: t, b: A }), MI = (t, A) => new Or({ a: t, b: A }), vI = (t) => new Wr({ a: t }), bI = (t) => new jr({ a: t }), FI = (t) => new Zr({ a: t });
class Jr extends v {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => "float", outKey: "length" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.length} = length(${e.a});`
    ];
  }
}
class _r extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "distance", outTypeFunc: (s, n) => "float" }), this.statements = ({ inputs: s, outputs: n }) => [
      `${n.distance} = distance(${s.a}, ${s.b});`
    ];
  }
}
class Lr extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "dot", outTypeFunc: (s, n) => "float" }), this.statements = ({ inputs: s, outputs: n }) => [
      `${n.dot} = dot(${s.a}, ${s.b});`
    ];
  }
}
class zr extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "cross", outTypeFunc: (s, n) => "vec3" }), this.statements = ({ inputs: s, outputs: n }) => [
      `${n.cross} = cross(${s.a}, ${s.b});`
    ];
  }
}
class qr extends v {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "normalize" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.normalize} = normalize(${e.a});`
    ];
  }
}
function kI(t) {
  if (t === "vec3")
    return "vec2";
  if (t === "vec4")
    return "vec3";
  throw new Error("Invalid type");
}
class Hr extends v {
  constructor({ a: A }) {
    super({
      a: A,
      outTypeFunc: (e) => kI(e),
      outKey: "projected"
    }), this.statements = ({ inputs: e, outputs: s }) => {
      if (this.inTypes.a === "vec3")
        return [`${s.projected} = ${e.a}.xy / ${e.a}.z;`];
      if (this.inTypes.a === "vec4")
        return [`${s.projected} = ${e.a}.xyz / ${e.a}.w;`];
      throw new Error("Invalid type");
    };
  }
}
function TI(t) {
  if (t === "float") return "vec2";
  if (t === "vec2") return "vec3";
  if (t === "vec3") return "vec4";
  throw new Error("Invalid type");
}
class Kr extends tA {
  constructor({ a: A, b: e }) {
    const s = $(A), n = TI(s);
    super({ a: A, b: e, outKey: "extend", outTypeFunc: () => n }), this.statements = ({ inputs: i, outputs: r }) => [
      `${r.extend} = ${n}(${i.a}, ${i.b});`
    ];
  }
}
class $r extends yt {
  constructor({ a: A, b: e, c: s }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "forward",
      outTypeFunc: (n, i, r) => n
    }), this.statements = ({ inputs: n, outputs: i }) => [
      `${i.forward} = faceforward(${n.a}, ${n.b}, ${n.c});`
    ];
  }
}
class Vr extends tA {
  constructor({
    incident: A,
    normal: e
  }) {
    super({
      a: A,
      b: e,
      outKey: "reflection",
      outTypeFunc: (s, n) => s
    }), this.statements = ({ inputs: s, outputs: n }) => [
      `${n.reflection} = reflect(${s.a}, ${s.b});`
    ];
  }
}
class Pr extends yt {
  constructor({
    incident: A,
    normal: e,
    eta: s
  }) {
    super({
      a: A,
      b: e,
      c: s,
      outKey: "refraction",
      outTypeFunc: (n, i, r) => n
    }), this.statements = ({ inputs: n, outputs: i }) => [
      `${i.refraction} = refract(${n.a}, ${n.b}, ${n.c});`
    ];
  }
}
class Xr extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "product", outTypeFunc: (s, n) => s }), this.statements = ({ inputs: s, outputs: n }) => [
      `${n.product} = matrixCompMult(${A}, ${e});`
    ];
  }
}
function NI(t, A) {
  if (t === "vec2") {
    if (A === "vec2") return "mat2";
    if (A === "vec3") return "mat3x2";
    if (A === "vec4") return "mat4x2";
  }
  if (t === "vec3") {
    if (A === "vec2") return "mat2x3";
    if (A === "vec3") return "mat3";
    if (A === "vec4") return "mat4x3";
  }
  if (t === "vec4") {
    if (A === "vec2") return "mat2x4";
    if (A === "vec3") return "mat3x4";
    if (A === "vec4") return "mat4";
  }
  throw new Error(`Invalid outer type: ${t}, ${A}`);
}
class Or extends tA {
  constructor({ a: A, b: e }) {
    super({ a: A, b: e, outKey: "outer", outTypeFunc: NI }), this.statements = ({ inputs: s, outputs: n }) => [
      `${n.outer} = outerProduct(${s.a}, ${s.b});`
    ];
  }
}
function UI(t) {
  if (t === "mat2") return "mat2";
  if (t === "mat3") return "mat3";
  if (t === "mat4") return "mat4";
  if (t === "mat2x2") return "mat2x2";
  if (t === "mat2x3") return "mat3x2";
  if (t === "mat2x4") return "mat4x2";
  if (t === "mat3x2") return "mat2x3";
  if (t === "mat3x3") return "mat3x3";
  if (t === "mat3x4") return "mat4x3";
  if (t === "mat4x2") return "mat2x4";
  if (t === "mat4x3") return "mat3x4";
  if (t === "mat4x4") return "mat4x4";
  throw new Error(`Invalid transpose type: ${t}`);
}
class Wr extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "transpose", outTypeFunc: UI }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.transpose} = transpose(${e.a});`
    ];
  }
}
class jr extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "det", outTypeFunc: (e) => "float" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.det} = determinant(${e.a});`
    ];
  }
}
class Zr extends v {
  constructor({ a: A }) {
    super({ a: A, outKey: "inverse", outTypeFunc: (e) => e }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.inverse} = inverse(${A});`
    ];
  }
}
function GI(t) {
  const A = (e) => e;
  switch (t) {
    case "vec2":
      return A({ x: "float", y: "float", r: "float", g: "float" });
    case "vec3":
      return A({
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      });
    case "vec4":
      return A({
        x: "float",
        y: "float",
        z: "float",
        w: "float",
        r: "float",
        g: "float",
        b: "float",
        a: "float"
      });
    case "ivec2":
      return A({ x: "int", y: "int", r: "int", g: "int" });
    case "ivec3":
      return A({
        x: "int",
        y: "int",
        z: "int",
        r: "int",
        g: "int",
        b: "int"
      });
    case "ivec4":
      return A({
        x: "int",
        y: "int",
        z: "int",
        w: "int",
        r: "int",
        g: "int",
        b: "int",
        a: "int"
      });
    case "uvec2":
      return A({ x: "uint", y: "uint", r: "uint", g: "uint" });
    case "uvec3":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        r: "uint",
        g: "uint",
        b: "uint"
      });
    case "uvec4":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        w: "uint",
        r: "uint",
        g: "uint",
        b: "uint",
        a: "uint"
      });
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
class Aa extends V {
  constructor({ vector: A }) {
    const s = { vector: $(A) }, n = GI(s.vector);
    super({ inTypes: s, outTypes: n, inputs: { vector: A } }), this.statements = ({ inputs: i, outputs: r }) => {
      const { x: a, y: o, z: c, w: l, r: g, g: I, b: h, a: Q } = r, { vector: C } = i;
      return [
        a ? `${a} = ${C}.x;` : null,
        o ? `${o} = ${C}.y;` : null,
        c ? `${c} = ${C}.z;` : null,
        l ? `${l} = ${C}.w;` : null,
        g ? `${g} = ${C}.r;` : null,
        I ? `${I} = ${C}.g;` : null,
        h ? `${h} = ${C}.b;` : null,
        Q ? `${Q} = ${C}.a;` : null
      ].filter(Boolean);
    };
  }
}
class ta extends V {
  constructor({
    vector: A,
    vectorType: e,
    x: s,
    y: n,
    z: i,
    w: r,
    r: a,
    g: o,
    b: c,
    a: l
  }) {
    if (!A && !e)
      throw new Error("Either vector or vectorType must be provided");
    const g = e ?? $(A), I = Ls(g), h = zs(g), Q = {
      vector: g,
      x: I,
      y: I,
      r: I,
      g: I
    }, C = { vector: A, x: s, y: n, r: a, g: o };
    h >= 3 && (Object.assign(Q, { z: I, b: I }), Object.assign(C, { z: i, b: c })), h >= 4 && (Object.assign(Q, { w: I, a: I }), Object.assign(C, { w: r, a: l })), super({ inTypes: Q, outTypes: { vector: g }, inputs: C }), this.statements = ({ inputs: B, outputs: E }) => {
      const { vector: p } = E, {
        vector: f,
        x: d,
        y,
        z: D,
        w: x,
        r: w,
        g: m,
        b: T,
        a: M
      } = B, S = [
        `${p}.x = ${d ?? w ?? (f ? `${f}.x` : Jt(I))};`,
        `${p}.y = ${y ?? m ?? (f ? `${f}.y` : Jt(I))};`
      ];
      return h >= 3 && S.push(
        `${p}.z = ${D ?? T ?? (f ? `${f}.z` : Jt(I))};`
      ), h >= 4 && S.push(
        `${p}.w = ${x ?? M ?? (f ? `${f}.w` : Jt(I))};`
      ), S;
    };
  }
  dynoOut() {
    return new K(
      this,
      "vector"
    );
  }
}
function RI(t, A) {
  let e = null;
  if (Xt(t) ? e = A.length === 1 ? "float" : A.length === 2 ? "vec2" : A.length === 3 ? "vec3" : A.length === 4 ? "vec4" : null : QA(t) ? e = A.length === 1 ? "int" : A.length === 2 ? "ivec2" : A.length === 3 ? "ivec3" : A.length === 4 ? "ivec4" : null : EA(t) && (e = A.length === 1 ? "uint" : A.length === 2 ? "uvec2" : A.length === 3 ? "uvec3" : A.length === 4 ? "uvec4" : null), e == null)
    throw new Error(`Invalid swizzle: ${A}`);
  return e;
}
class ea extends v {
  constructor({ vector: A, select: e }) {
    super({
      a: A,
      outKey: "swizzle",
      outTypeFunc: (s) => RI(s, e)
    }), this.statements = ({ inputs: s, outputs: n }) => [
      `${n.swizzle} = ${s.a}.${e};`
    ];
  }
}
const YI = (t, A, e) => new ga({ index: t, from: A, to: e }), JI = (t) => new Ut({ value: t }), _I = (t) => new TA({ state: t }), LI = (t) => new NA({ state: t }), sa = (t) => new ca({ value: t }), na = (t) => new la({ value: t }), ia = (t) => new Ia({ value: t }), ra = (t) => new ua({ value: t }), zI = (t) => new ha({ value: t }), qI = (t) => new Ca({ value: t }), aa = (t) => new Ba({ value: t }), qe = (t) => new Qa({ value: t }), oa = (t, A, e) => new Ea({ z: t, zNear: A, zFar: e }).outputs.depth;
class ga extends V {
  constructor({
    from: A,
    to: e,
    index: s
  }) {
    super({
      inTypes: { from: "int", to: "int", index: "int" },
      outTypes: { index: "int" },
      inputs: { from: A, to: e, index: s },
      statements: ({ inputs: n, outputs: i }) => [
        `${i.index} = ${n.index} - ${n.from} + ${n.to};`
      ]
    });
  }
  dynoOut() {
    return new K(this, "index");
  }
}
class TA extends V {
  constructor({ state: A }) {
    const e = $(A);
    super({
      inTypes: { state: e },
      outTypes: { state: "uint" },
      inputs: { state: A },
      globals: () => [
        hA(`
          uint pcg_next(uint state) {
            return state * 747796405u + 2891336453u;
          }
        `)
      ],
      statements: ({ inputs: s, outputs: n }) => {
        const i = e === "uint" ? `${s.state}` : e === "int" ? `uint(${s.state})` : `floatBitsToUint(${s.state})`;
        return [`${n.state} = pcg_next(${i});`];
      }
    });
  }
  dynoOut() {
    return new K(this, "state");
  }
}
class NA extends V {
  constructor({ state: A }) {
    super({
      inTypes: { state: "uint" },
      outTypes: { hash: "uint" },
      inputs: { state: A },
      globals: () => [
        hA(`
          uint pcg_hash(uint state) {
            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
            return (hash >> 22u) ^ hash;
          }
        `)
      ],
      statements: ({ inputs: e, outputs: s }) => [
        `${s.hash} = pcg_hash(${e.state});`
      ]
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Ut extends V {
  constructor({ value: A }) {
    const e = $(A), s = qs(e);
    super({
      inTypes: { value: e },
      outTypes: { state: "uint" },
      inputs: { value: A },
      globals: () => [
        hA(`
          uint pcg_mix(uint value) {
            return value;
          }
          uint pcg_mix(uvec2 value) {
            return value.x + 0x9e3779b9u * value.y;
          }
          uint pcg_mix(uvec3 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;
          }
          uint pcg_mix(uvec4 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;
          }
        `)
      ],
      statements: ({ inputs: n, outputs: i }) => {
        const r = EA(e) ? `${n.value}` : QA(e) ? `${s}(${n.value})` : `floatBitsToUint(${n.value})`;
        return [
          `${s} bits = ${r};`,
          `${i.state} = pcg_mix(bits);`
        ];
      }
    });
  }
  dynoOut() {
    return new K(this, "state");
  }
}
class ca extends PA {
  constructor({ value: A }) {
    super({
      inTypes: { value: $(A) },
      outTypes: { hash: "uint" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let s = new Ut({ value: e }).outputs.state;
        return s = new TA({ state: s }).outputs.state, new NA({ state: s }).outputs;
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class la extends PA {
  constructor({ value: A }) {
    super({
      inTypes: { value: $(A) },
      outTypes: { hash: "uvec2" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let s = new Ut({ value: e }).outputs.state;
        s = new TA({ state: s }).outputs.state;
        const n = new NA({ state: s }).outputs.hash;
        s = new TA({ state: s }).outputs.state;
        const i = new NA({ state: s }).outputs.hash;
        return { hash: $A({ vectorType: "uvec2", x: n, y: i }) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Ia extends PA {
  constructor({ value: A }) {
    super({
      inTypes: { value: $(A) },
      outTypes: { hash: "uvec3" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let s = new Ut({ value: e }).outputs.state;
        s = new TA({ state: s }).outputs.state;
        const n = new NA({ state: s }).outputs.hash;
        s = new TA({ state: s }).outputs.state;
        const i = new NA({ state: s }).outputs.hash;
        s = new TA({ state: s }).outputs.state;
        const r = new NA({ state: s }).outputs.hash;
        return { hash: $A({ vectorType: "uvec3", x: n, y: i, z: r }) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class ua extends PA {
  constructor({ value: A }) {
    super({
      inTypes: { value: $(A) },
      outTypes: { hash: "uvec4" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        let s = new Ut({ value: e }).outputs.state;
        s = new TA({ state: s }).outputs.state;
        const n = new NA({ state: s }).outputs.hash;
        s = new TA({ state: s }).outputs.state;
        const i = new NA({ state: s }).outputs.hash;
        s = new TA({ state: s }).outputs.state;
        const r = new NA({ state: s }).outputs.hash;
        s = new TA({ state: s }).outputs.state;
        const a = new NA({ state: s }).outputs.hash;
        return { hash: $A({ vectorType: "uvec4", x: n, y: i, z: r, w: a }) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class ha extends PA {
  constructor({ value: A }) {
    super({
      inTypes: { value: $(A) },
      outTypes: { hash: "float" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const s = sa(e);
        return { hash: iA(Ar(s), J("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Ca extends PA {
  constructor({ value: A }) {
    super({
      inTypes: { value: $(A) },
      outTypes: { hash: "vec2" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const s = na(e);
        return { hash: iA(tr(s), J("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Ba extends PA {
  constructor({ value: A }) {
    super({
      inTypes: { value: $(A) },
      outTypes: { hash: "vec3" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const s = ia(e);
        return { hash: iA(Bt(s), J("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Qa extends PA {
  constructor({ value: A }) {
    super({
      inTypes: { value: $(A) },
      outTypes: { hash: "vec4" },
      inputs: { value: A },
      construct: ({ value: e }) => {
        if (!e)
          throw new Error("value is required");
        const s = ra(e);
        return { hash: iA(er(s), J("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new K(this, "hash");
  }
}
class Ea extends V {
  constructor({
    z: A,
    zNear: e,
    zFar: s
  }) {
    super({
      inTypes: { z: "float", zNear: "float", zFar: "float" },
      outTypes: { depth: "float" },
      inputs: { z: A, zNear: e, zFar: s },
      statements: ({ inputs: n, outputs: i }) => [
        `float clamped = clamp(${n.z}, ${n.zNear}, ${n.zFar});`,
        `${i.depth} = (log2(clamped + 1.0) - log2(${n.zNear} + 1.0)) / (log2(${n.zFar} + 1.0) - log2(${n.zNear} + 1.0));`
      ]
    });
  }
  dynoOut() {
    return new K(this, "depth");
  }
}
const fa = (t, {
  scale: A,
  scales: e,
  rotate: s,
  translate: n
}) => new da({ position: t, scale: A, scales: e, rotate: s, translate: n }).outputs.position, pa = (t, {
  scale: A,
  scales: e,
  rotate: s
}) => new ya({ dir: t, scale: A, scales: e, rotate: s }).outputs.dir, HI = (t, { rotate: A }) => new wa({ quaternion: t, rotate: A }).outputs.quaternion;
class da extends V {
  constructor({
    position: A,
    scale: e,
    scales: s,
    rotate: n,
    translate: i
  }) {
    super({
      inTypes: {
        position: "vec3",
        scale: "float",
        scales: "vec3",
        rotate: "vec4",
        translate: "vec3"
      },
      outTypes: { position: "vec3" },
      inputs: { position: A, scale: e, scales: s, rotate: n, translate: i },
      statements: ({ inputs: r, outputs: a }) => {
        const { position: o } = a;
        if (!o)
          return [];
        const { scale: c, scales: l, rotate: g, translate: I } = r;
        return [
          `${o} = ${r.position ?? "vec3(0.0, 0.0, 0.0)"};`,
          c ? `${o} *= ${c};` : null,
          l ? `${o} *= ${l};` : null,
          g ? `${o} = quatVec(${g}, ${o});` : null,
          I ? `${o} += ${I};` : null
        ].filter(Boolean);
      }
    });
  }
}
class ya extends V {
  constructor({
    dir: A,
    scale: e,
    scales: s,
    rotate: n
  }) {
    super({
      inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
      outTypes: { dir: "vec3" },
      inputs: { dir: A, scale: e, scales: s, rotate: n },
      statements: ({ inputs: i, outputs: r }) => {
        const { dir: a } = r;
        if (!a)
          return [];
        const { scale: o, scales: c, rotate: l } = i;
        return [
          `${a} = ${i.dir ?? "vec3(0.0, 0.0, 0.0)"};`,
          o ? `${a} *= ${o};` : null,
          c ? `${a} *= ${c};` : null,
          l ? `${a} = quatVec(${l}, ${a});` : null
        ].filter(Boolean);
      }
    });
  }
}
class wa extends V {
  constructor({
    quaternion: A,
    rotate: e
  }) {
    super({
      inTypes: { quaternion: "vec4", rotate: "vec4" },
      outTypes: { quaternion: "vec4" },
      inputs: { quaternion: A, rotate: e },
      statements: ({ inputs: s, outputs: n }) => {
        const { quaternion: i } = n;
        return i ? [
          `${i} = ${s.quaternion ?? "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          e ? `${i} = quatQuat(${s.rotate}, ${i});` : null
        ].filter(Boolean) : [];
      }
    });
  }
}
const KI = () => {
  throw new Error("Not implemented");
}, $I = () => {
  throw new Error("Not implemented");
}, VI = () => {
  throw new Error("Not implemented");
}, PI = () => {
  throw new Error("Not implemented");
}, XI = () => {
  throw new Error("Not implemented");
}, OI = () => {
  throw new Error("Not implemented");
}, WI = (t, A) => new ma({ texture: t, lod: A }), jI = (t, A, e) => new xa({ texture: t, coord: A, bias: e }), ZI = (t, A, e) => new Sa({ texture: t, coord: A, lod: e });
class ma extends V {
  constructor({ texture: A, lod: e }) {
    const s = $(A);
    super({
      inTypes: { texture: s, lod: "int" },
      outTypes: { size: Da(s) },
      inputs: { texture: A, lod: e },
      statements: ({ inputs: n, outputs: i }) => [
        `${i.size} = textureSize(${n.texture}, ${n.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new K(this, "size");
  }
}
class xa extends V {
  constructor({
    texture: A,
    coord: e,
    bias: s
  }) {
    const n = $(A);
    super({
      inTypes: {
        texture: n,
        coord: Au(n),
        bias: "float"
      },
      outTypes: { sample: Ma(n) },
      inputs: { texture: A, coord: e, bias: s },
      statements: ({ inputs: i, outputs: r }) => [
        `${r.sample} = texture(${i.texture}, ${i.coord}${i.bias ? `, ${i.bias}` : ""});`
      ]
    });
  }
  dynoOut() {
    return new K(this, "sample");
  }
}
class Sa extends V {
  constructor({
    texture: A,
    coord: e,
    lod: s
  }) {
    const n = $(A);
    super({
      inTypes: {
        texture: n,
        coord: Da(n),
        lod: "int"
      },
      outTypes: { texel: Ma(n) },
      inputs: { texture: A, coord: e, lod: s },
      statements: ({ inputs: i, outputs: r }) => [
        `${r.texel} = texelFetch(${i.texture}, ${i.coord}, ${i.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new K(this, "texel");
  }
}
function Da(t) {
  switch (t) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DShadow":
    case "samplerCubeShadow":
      return "ivec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DArrayShadow":
      return "ivec3";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
function Au(t) {
  switch (t) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
      return "vec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DShadow":
      return "vec3";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "vec4";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
function Ma(t) {
  switch (t) {
    case "sampler2D":
    case "sampler2DArray":
    case "sampler3D":
    case "samplerCube":
    case "sampler2DShadow":
      return "vec4";
    case "usampler2D":
    case "usampler2DArray":
    case "usampler3D":
    case "usamplerCube":
      return "uvec4";
    case "isampler2D":
    case "isampler2DArray":
    case "isampler3D":
    case "isamplerCube":
      return "ivec4";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "float";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
const tu = (t) => new va({ degrees: t }), eu = (t) => new ba({ radians: t }), He = (t) => new Fa({ radians: t }), su = (t) => new ka({ radians: t }), nu = (t) => new Ta({ radians: t }), iu = (t) => new Na({ sin: t }), ru = (t) => new Ua({ cos: t }), au = (t) => new Ga({ tan: t }), ou = (t, A) => new Ra({ y: t, x: A }), gu = (t) => new Ya({ x: t }), cu = (t) => new Ja({ x: t }), lu = (t) => new _a({ x: t }), Iu = (t) => new La({ x: t }), uu = (t) => new za({ x: t }), hu = (t) => new qa({ x: t });
class va extends v {
  constructor({ degrees: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "radians" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.radians} = radians(${e.a});`
    ];
  }
}
class ba extends v {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "degrees" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.degrees} = degrees(${e.a});`
    ];
  }
}
class Fa extends v {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "sin" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.sin} = sin(${e.a});`
    ];
  }
}
class ka extends v {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "cos" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.cos} = cos(${e.a});`
    ];
  }
}
class Ta extends v {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "tan" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.tan} = tan(${e.a});`
    ];
  }
}
class Na extends v {
  constructor({ sin: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "asin" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.asin} = asin(${e.a});`
    ];
  }
}
class Ua extends v {
  constructor({ cos: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "acos" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.acos} = acos(${e.a});`
    ];
  }
}
class Ga extends v {
  constructor({ tan: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "atan" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.atan} = atan(${e.a});`
    ];
  }
}
class Ra extends tA {
  constructor({ y: A, x: e }) {
    super({
      a: A,
      b: e,
      outTypeFunc: (s, n) => s,
      outKey: "atan2"
    }), this.statements = ({ inputs: s, outputs: n }) => [
      `${n.atan2} = atan2(${s.a}, ${s.b});`
    ];
  }
}
class Ya extends v {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "sinh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.sinh} = sinh(${e.a});`
    ];
  }
}
class Ja extends v {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "cosh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.cosh} = cosh(${e.a});`
    ];
  }
}
class _a extends v {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "tanh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.tanh} = tanh(${e.a});`
    ];
  }
}
class La extends v {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "asinh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.asinh} = asinh(${e.a});`
    ];
  }
}
class za extends v {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "acosh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.acosh} = acosh(${e.a});`
    ];
  }
}
class qa extends v {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (e) => e, outKey: "atanh" }), this.statements = ({ inputs: e, outputs: s }) => [
      `${s.atanh} = atanh(${e.a});`
    ];
  }
}
const Ph = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs: Ci,
  Acos: Ua,
  Acosh: za,
  Add: ai,
  All: Oi,
  And: Ji,
  Any: Xi,
  Asin: Na,
  Asinh: La,
  Atan: Ga,
  Atan2: Ra,
  Atanh: qa,
  BVec2: cr,
  BVec3: lr,
  BVec4: Ir,
  BinaryOp: tA,
  Bool: rr,
  Ceil: Ei,
  Clamp: ki,
  Combine: ta,
  CombineGsplat: Zs,
  CompMult: Xr,
  CompXor: Zi,
  Compilation: $s,
  Cos: ka,
  Cosh: Ja,
  Cross: zr,
  Degrees: ba,
  Determinant: jr,
  Distance: _r,
  Div: ci,
  Dot: Lr,
  Dyno: V,
  DynoBlock: PA,
  DynoBool: ge,
  DynoBvec2: an,
  DynoBvec3: cn,
  DynoBvec4: un,
  DynoConst: Ks,
  DynoFloat: ht,
  DynoInt: $t,
  DynoIsampler2D: vn,
  DynoIsampler2DArray: Fn,
  DynoIsampler3D: Nn,
  DynoIsamplerCube: Rn,
  DynoIvec2: gn,
  DynoIvec3: In,
  DynoIvec4: Cn,
  DynoLiteral: vt,
  DynoMat2: Bn,
  DynoMat2x2: Qn,
  DynoMat2x3: En,
  DynoMat2x4: fn,
  DynoMat3: pn,
  DynoMat3x2: dn,
  DynoMat3x3: yn,
  DynoMat3x4: wn,
  DynoMat4: mn,
  DynoMat4x2: xn,
  DynoMat4x3: Sn,
  DynoMat4x4: Dn,
  DynoOutput: K,
  DynoProgram: ns,
  DynoProgramTemplate: is,
  DynoRemapIndex: ga,
  DynoSampler2D: bn,
  DynoSampler2DArray: kn,
  DynoSampler2DArrayShadow: _n,
  DynoSampler2DShadow: Jn,
  DynoSampler3D: Un,
  DynoSamplerCube: Yn,
  DynoSamplerCubeShadow: Ln,
  DynoUint: rn,
  DynoUniform: k,
  DynoUsampler2D: Mn,
  DynoUsampler2DArray: qt,
  DynoUsampler3D: Tn,
  DynoUsamplerCube: Gn,
  DynoUvec2: on,
  DynoUvec3: ln,
  DynoUvec4: hn,
  DynoValue: it,
  DynoVec2: zt,
  DynoVec3: Ft,
  DynoVec4: Nt,
  Equal: Vi,
  Exp: wi,
  Exp2: mi,
  ExtendVec: Kr,
  FaceForward: $r,
  Float: gr,
  FloatBitsToInt: xr,
  FloatBitsToUint: Sr,
  Floor: Qi,
  Fract: di,
  GreaterThan: Ki,
  GreaterThanEqual: $i,
  Gsplat: AA,
  GsplatNormal: tn,
  Hash: ca,
  Hash2: la,
  Hash3: Ia,
  Hash4: ua,
  HashFloat: ha,
  HashVec2: Ca,
  HashVec3: Ba,
  HashVec4: Qa,
  IMod: li,
  IVec2: ur,
  IVec3: hr,
  IVec4: Cr,
  Int: ar,
  IntBitsToFloat: Dr,
  Inverse: Zr,
  InverseSqrt: vi,
  IsInf: Ri,
  IsNan: Gi,
  Length: Jr,
  LessThan: qi,
  LessThanEqual: Hi,
  Log: xi,
  Log2: Si,
  Mat2: yr,
  Mat3: wr,
  Mat4: mr,
  Max: Fi,
  Min: bi,
  Mix: Ti,
  Mod: Ii,
  Modf: ui,
  Mul: gi,
  Neg: hi,
  Normalize: qr,
  NormalizedDepth: Ea,
  Not: zi,
  NotEqual: Pi,
  NumPackedSplats: Ps,
  Or: _i,
  Outer: Or,
  OutputPackedSplat: nn,
  OutputRgba8: ts,
  PackHalf2x16: Tr,
  PackSnorm2x16: vr,
  PackUnorm2x16: Fr,
  PcgHash: NA,
  PcgMix: Ut,
  PcgNext: TA,
  Pow: yi,
  ProjectH: Hr,
  Radians: va,
  ReadPackedSplat: Os,
  ReadPackedSplatRange: Ws,
  ReflectVec: Vr,
  RefractVec: Pr,
  Round: pi,
  Select: Wi,
  Sign: Bi,
  SimpleCast: gA,
  Sin: Fa,
  Sinh: Ya,
  Smoothstep: Ui,
  Split: Aa,
  SplitGsplat: js,
  Sqr: Di,
  Sqrt: Mi,
  Step: Ni,
  Sub: oi,
  Swizzle: ea,
  TPackedSplats: jt,
  Tan: Ta,
  Tanh: _a,
  TexelFetch: Sa,
  Texture: xa,
  TextureSize: ma,
  TransformDir: ya,
  TransformGsplat: en,
  TransformPosition: da,
  TransformQuaternion: wa,
  Transpose: Wr,
  TrinaryOp: yt,
  Trunc: fi,
  UVec2: Br,
  UVec3: Qr,
  UVec4: Er,
  Uint: or,
  UintBitsToFloat: Mr,
  UintToRgba8: Ur,
  UnaryOp: v,
  UnpackHalf2x16: Nr,
  UnpackSnorm2x16: br,
  UnpackUnorm2x16: kr,
  Vec2: fr,
  Vec3: pr,
  Vec4: dr,
  Xor: Li,
  abs: Ql,
  acos: ru,
  acosh: uu,
  add: BA,
  all: Vl,
  and: Rl,
  any: $l,
  arrayIndex: XI,
  arrayLength: OI,
  asin: iu,
  asinh: Iu,
  atan: au,
  atan2: ou,
  atanh: hu,
  bool: Wl,
  bvec2: AI,
  bvec3: tI,
  bvec4: eI,
  ceil: pl,
  clamp: kl,
  combine: $A,
  combineGsplat: rt,
  comment: PI,
  compMult: DI,
  compXor: Pl,
  cos: su,
  cosh: cu,
  cross: dI,
  defineGsplat: bA,
  defineGsplatNormal: An,
  definePackedSplats: Ee,
  degrees: eu,
  determinant: bI,
  distance: pI,
  div: re,
  dot: Gr,
  dyno: Wt,
  dynoBlock: vA,
  dynoBool: hg,
  dynoBvec2: Qg,
  dynoBvec3: dg,
  dynoBvec4: mg,
  dynoConst: J,
  dynoDeclare: Ze,
  dynoFloat: qA,
  dynoFor: VI,
  dynoIf: KI,
  dynoInt: Bg,
  dynoIsampler2D: Lg,
  dynoIsampler2DArray: Hg,
  dynoIsampler3D: Vg,
  dynoIsamplerCube: Og,
  dynoIvec2: fg,
  dynoIvec3: wg,
  dynoIvec4: Sg,
  dynoLiteral: oe,
  dynoMat2: Mg,
  dynoMat2x2: vg,
  dynoMat2x3: bg,
  dynoMat2x4: Fg,
  dynoMat3: kg,
  dynoMat3x2: Tg,
  dynoMat3x3: Ng,
  dynoMat3x4: Ug,
  dynoMat4: Gg,
  dynoMat4x2: Rg,
  dynoMat4x3: Yg,
  dynoMat4x4: Jg,
  dynoSampler2D: zg,
  dynoSampler2DArray: Kg,
  dynoSampler2DArrayShadow: Zg,
  dynoSampler2DShadow: jg,
  dynoSampler3D: Pg,
  dynoSamplerCube: Wg,
  dynoSamplerCubeShadow: Ac,
  dynoSwitch: $I,
  dynoUint: Cg,
  dynoUsampler2D: _g,
  dynoUsampler2DArray: qg,
  dynoUsampler3D: $g,
  dynoUsamplerCube: Xg,
  dynoUvec2: Eg,
  dynoUvec3: yg,
  dynoUvec4: xg,
  dynoVec2: pg,
  dynoVec3: tt,
  dynoVec4: Dg,
  equal: Hl,
  exp: ml,
  exp2: xl,
  extendVec: Yr,
  faceforward: yI,
  float: Ar,
  floatBitsToInt: sr,
  floatBitsToUint: nr,
  floor: fl,
  fract: ae,
  greaterThan: ql,
  greaterThanEqual: Yi,
  gsplatNormal: Re,
  hash: sa,
  hash2: na,
  hash3: ia,
  hash4: ra,
  hashFloat: zI,
  hashVec2: qI,
  hashVec3: aa,
  hashVec4: qe,
  imod: Le,
  int: jl,
  intBitsToFloat: II,
  inverse: FI,
  inversesqrt: bl,
  isAllFloatType: at,
  isBoolType: pt,
  isFloatType: Xt,
  isInf: Gl,
  isIntType: QA,
  isMat2: ot,
  isMat3: gt,
  isMat4: ct,
  isMatFloatType: _s,
  isNan: Ul,
  isScalarType: dt,
  isUintType: EA,
  isVector2Type: kt,
  isVector3Type: Tt,
  isVector4Type: Ot,
  isVectorType: rg,
  ivec2: sI,
  ivec3: nI,
  ivec4: iI,
  length: fI,
  lessThan: Ll,
  lessThanEqual: zl,
  literalNegOne: cg,
  literalOne: gg,
  literalZero: Jt,
  log: Sl,
  log2: Dl,
  mat2: gI,
  mat3: cI,
  mat4: lI,
  max: ii,
  min: Fl,
  mix: ri,
  mod: ni,
  modf: Bl,
  mul: iA,
  neg: as,
  normalize: Rr,
  normalizedDepth: oa,
  not: _l,
  notEqual: Kl,
  numPackedSplats: lg,
  numberAsFloat: q,
  numberAsInt: rA,
  numberAsUint: aA,
  or: Yl,
  outer: MI,
  outputPackedSplat: sn,
  outputRgba8: Ig,
  packHalf2x16: ir,
  packSnorm2x16: hI,
  packUnorm2x16: BI,
  pcgHash: LI,
  pcgMix: JI,
  pcgNext: _I,
  pow: wl,
  projectH: xI,
  radians: tu,
  readPackedSplat: bt,
  readPackedSplatRange: Vs,
  reflectVec: wI,
  refractVec: mI,
  remapIndex: YI,
  round: yl,
  sameSizeIvec: og,
  sameSizeUvec: qs,
  sameSizeVec: ag,
  select: os,
  sign: El,
  sin: He,
  sinh: gu,
  smoothstep: Nl,
  split: Qt,
  splitGsplat: ut,
  sqr: Ml,
  sqrt: vl,
  step: Tl,
  sub: Et,
  swizzle: SI,
  tan: nu,
  tanh: lu,
  texelFetch: ZI,
  texture: jI,
  textureSize: WI,
  transformDir: pa,
  transformGsplat: As,
  transformPos: fa,
  transformQuat: HI,
  transpose: vI,
  trunc: dl,
  typeLiteral: Hs,
  uint: Zl,
  uintBitsToFloat: uI,
  uintToRgba8: ze,
  uniform: ug,
  unindent: hA,
  unindentLines: RA,
  unpackHalf2x16: EI,
  unpackSnorm2x16: CI,
  unpackUnorm2x16: QI,
  uvec2: rI,
  uvec3: aI,
  uvec4: oI,
  valType: $,
  vec2: tr,
  vec3: Bt,
  vec4: er,
  vectorDim: zs,
  vectorElementType: Ls,
  xor: Jl
}, Symbol.toStringTag, { value: "Module" }));
var Cu = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;
const kA = class kA {
  constructor({ renderer: A } = {}) {
    this.renderer = A, this.capacity = 0, this.count = 0;
  }
  dispose() {
    this.target && (this.target.dispose(), this.target = void 0);
  }
  // Ensure we have a buffer large enough for the readback of count indices.
  // Pass in previous bufer of the desired type.
  ensureBuffer(A, e) {
    const n = Math.ceil(Math.max(1, A) / X) * X * 4;
    if (e.byteLength >= n)
      return e;
    const i = new ArrayBuffer(n);
    if (e instanceof ArrayBuffer)
      return i;
    const r = e.constructor;
    return new r(i);
  }
  // Ensure our render target is large enough for the readback of capacity indices.
  ensureCapacity(A) {
    const { width: e, height: s, depth: n, maxSplats: i } = mA(A);
    (!this.target || i > this.capacity) && (this.dispose(), this.capacity = i, this.target = new u.WebGLArrayRenderTarget(e, s, n, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: u.NearestFilter,
      minFilter: u.NearestFilter
    }), this.target.texture.format = u.RGBAFormat, this.target.texture.type = u.UnsignedByteType, this.target.texture.internalFormat = "RGBA8", this.target.scissorTest = !0);
  }
  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let e = kA.readbackProgram.get(A);
    if (!e) {
      const n = vA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: i }) => (A.inputs.index = i, { rgba8: new ts({ rgba8: A.outputs.rgba8 }) })
      );
      kA.programTemplate || (kA.programTemplate = new is(Cu)), e = new ns({
        graph: n,
        inputs: { index: "index" },
        outputs: { rgba8: "target" },
        template: kA.programTemplate
      }), Object.assign(e.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), kA.readbackProgram.set(A, e);
    }
    const s = e.prepareMaterial();
    return kA.fullScreenQuad.material = s, { program: e, material: s };
  }
  saveRenderState(A) {
    return {
      xrEnabled: A.xr.enabled,
      autoClear: A.autoClear
    };
  }
  resetRenderState(A, e) {
    A.setRenderTarget(null), A.xr.enabled = e.xrEnabled, A.autoClear = e.autoClear;
  }
  process({
    count: A,
    material: e
  }) {
    const s = this.renderer;
    if (!s)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const n = X * KA;
    e.uniforms.targetBase.value = 0, e.uniforms.targetCount.value = A;
    let i = 0;
    for (; i < A; ) {
      const r = Math.floor(i / n), a = r * n, o = Math.min(
        KA,
        Math.ceil((A - a) / X)
      );
      e.uniforms.targetLayer.value = r, this.target.scissor.set(0, 0, X, o), s.setRenderTarget(this.target, r), s.xr.enabled = !1, s.autoClear = !1, kA.fullScreenQuad.render(s), i += X * o;
    }
    this.count = A;
  }
  async read({
    readback: A
  }) {
    const e = this.renderer;
    if (!e)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const s = Math.ceil(this.count / X) * X;
    if (A.byteLength < s * 4)
      throw new Error(
        `Readback buffer too small: ${A.byteLength} < ${s * 4}`
      );
    const n = new Uint8Array(
      A instanceof ArrayBuffer ? A : A.buffer
    ), i = X * KA;
    let r = 0;
    const a = [];
    for (; r < this.count; ) {
      const o = Math.floor(r / i), c = o * i, l = Math.min(
        KA,
        Math.ceil((this.count - c) / X)
      );
      e.setRenderTarget(this.target, o);
      const g = X * l * 4, I = n.subarray(
        c * 4,
        c * 4 + g
      ), h = e == null ? void 0 : e.readRenderTargetPixelsAsync(
        this.target,
        0,
        0,
        X,
        l,
        I
      );
      a.push(h), r += X * l;
    }
    return Promise.all(a).then(() => A);
  }
  // Perform render operation to run the Rgba8Readback program
  // but don't perform the readback yet.
  render({
    reader: A,
    count: e,
    renderer: s
  }) {
    if (this.renderer = s || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(e);
    const { program: n, material: i } = this.prepareProgramMaterial(A);
    n.update();
    const r = this.saveRenderState(this.renderer);
    this.process({ count: e, material: i }), this.resetRenderState(this.renderer, r);
  }
  // Perform a readback of the render target, returning a buffer of the
  // given type.
  async readback({
    readback: A
  }) {
    if (!this.renderer)
      throw new Error("No renderer");
    const e = this.saveRenderState(this.renderer), s = this.read({ readback: A });
    return this.resetRenderState(this.renderer, e), s;
  }
  // Perform a render and readback operation for the given Rgba8Readback,
  // and readback buffer (call ensureBuffer first).
  async renderReadback({
    reader: A,
    count: e,
    renderer: s,
    readback: n
  }) {
    if (this.renderer = s || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(e);
    const { program: i, material: r } = this.prepareProgramMaterial(A);
    i.update();
    const a = this.saveRenderState(this.renderer);
    this.process({ count: e, material: r });
    const o = this.read({ readback: n });
    return this.resetRenderState(this.renderer, a), o;
  }
  getTexture() {
    var A;
    return (A = this.target) == null ? void 0 : A.texture;
  }
};
kA.programTemplate = null, kA.readbackProgram = /* @__PURE__ */ new Map(), kA.fullScreenQuad = new xs(
  new u.RawShaderMaterial({ visible: !1 })
);
let le = kA;
const IA = class IA {
  constructor(A = {}) {
    this.capacity = 0, this.count = 0, this.array = null, this.readback = null, this.source = null, this.needsUpdate = !0, this.dyno = new k({
      key: "rgbaArray",
      type: Ha,
      globals: () => [Ka],
      value: {
        texture: IA.getEmpty(),
        count: 0
      },
      update: (e) => {
        var s;
        return e.texture = ((s = this.readback) == null ? void 0 : s.getTexture()) ?? this.source ?? IA.getEmpty(), e.count = this.count, e;
      }
    }), A.array ? (this.array = A.array, this.capacity = Math.floor(this.array.length / 4), this.capacity = Math.floor(this.capacity / X) * X, this.count = Math.min(
      this.capacity,
      A.count ?? Number.POSITIVE_INFINITY
    )) : (this.capacity = A.capacity ?? 0, this.count = 0);
  }
  // Free up resources
  dispose() {
    this.readback && (this.readback.dispose(), this.readback = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensure that our array is large enough to hold capacity RGBA8 values.
  ensureCapacity(A) {
    var e;
    if (!this.array || A > (((e = this.array) == null ? void 0 : e.length) ?? 0) / 4) {
      this.capacity = mA(A).maxSplats;
      const s = new Uint8Array(this.capacity * 4);
      this.array && s.set(this.array), this.array = s;
    }
    return this.array;
  }
  // Get the THREE.DataArrayTexture from either the readback or the source.
  getTexture() {
    var e;
    let A = (e = this.readback) == null ? void 0 : e.getTexture();
    return (this.source || this.array) && (A = this.maybeUpdateSource()), A ?? IA.getEmpty();
  }
  // Create or get a THREE.DataArrayTexture from the data array.
  maybeUpdateSource() {
    if (!this.array)
      throw new Error("No array");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: e, depth: s } = this.source.image;
        this.capacity !== A * e * s && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.array.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.array.buffer));
      else {
        const { width: A, height: e, depth: s } = mA(this.capacity);
        this.source = new u.DataArrayTexture(
          this.array,
          A,
          e,
          s
        ), this.source.format = u.RGBAFormat, this.source.type = u.UnsignedByteType, this.source.internalFormat = "RGBA8", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Generate the RGBA8 values from a Rgba8Readback dyno program.
  render({
    reader: A,
    count: e,
    renderer: s
  }) {
    this.readback || (this.readback = new le({ renderer: s })), this.readback.render({ reader: A, count: e, renderer: s }), this.capacity = this.readback.capacity, this.count = this.readback.count;
  }
  // Extract the RGBA8 values from a PackedSplats collection.
  fromPackedSplats({
    packedSplats: A,
    base: e,
    count: s,
    renderer: n
  }) {
    const { dynoSplats: i, dynoBase: r, dynoCount: a, reader: o } = IA.makeDynos();
    return i.packedSplats = A, r.value = e, a.value = s, this.render({ reader: o, count: s, renderer: n }), this;
  }
  // Read back the RGBA8 values from the readback buffer.
  async read() {
    if (!this.readback)
      throw new Error("No readback");
    return (!this.array || this.array.length < this.count * 4) && (this.array = new Uint8Array(this.capacity * 4)), (await this.readback.readback({ readback: this.array })).subarray(0, this.count * 4);
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!IA.emptySource) {
      const A = new Uint8Array(4);
      IA.emptySource = new u.DataArrayTexture(A, 1, 1, 1), IA.emptySource.format = u.RGBAFormat, IA.emptySource.type = u.UnsignedByteType, IA.emptySource.internalFormat = "RGBA8", IA.emptySource.needsUpdate = !0;
    }
    return IA.emptySource;
  }
  // Create a dyno program that can extract RGBA8 values from a PackedSplats
  static makeDynos() {
    if (!IA.dynos) {
      const A = new ls(), e = new $t({ value: 0 }), s = new $t({ value: 0 }), n = vA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: i }) => {
          if (!i)
            throw new Error("index is undefined");
          i = BA(i, e);
          const r = Vs(
            A,
            i,
            e,
            s
          );
          return { rgba8: ut(r).outputs.rgba };
        }
      );
      IA.dynos = { dynoSplats: A, dynoBase: e, dynoCount: s, reader: n };
    }
    return IA.dynos;
  }
};
IA.emptySource = null, IA.dynos = null;
let Ke = IA;
const Ha = { type: "RgbaArray" }, Ka = hA(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);
function Bu(t, A) {
  return new V({
    inTypes: { rgba: Ha, index: "int" },
    outTypes: { rgba: "vec4" },
    inputs: { rgba: t, index: A },
    globals: () => [Ka],
    statements: ({ inputs: s, outputs: n }) => RA(`
        if ((index >= 0) && (index < ${s.rgba}.count)) {
          ${n.rgba} = texelFetch(${s.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${n.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)
  }).outputs.rgba;
}
var Qu = /* @__PURE__ */ ((t) => (t.ALL = "all", t.PLANE = "plane", t.SPHERE = "sphere", t.BOX = "box", t.ELLIPSOID = "ellipsoid", t.CYLINDER = "cylinder", t.CAPSULE = "capsule", t.INFINITE_CONE = "infinite_cone", t))(Qu || {});
function Eu(t) {
  switch (t) {
    case "all":
      return 0;
    case "plane":
      return 1;
    case "sphere":
      return 2;
    case "box":
      return 3;
    case "ellipsoid":
      return 4;
    case "cylinder":
      return 5;
    case "capsule":
      return 6;
    case "infinite_cone":
      return 7;
    default:
      throw new Error(`Unknown SDF type: ${t}`);
  }
}
var fu = /* @__PURE__ */ ((t) => (t.MULTIPLY = "multiply", t.SET_RGB = "set_rgb", t.ADD_RGBA = "add_rgba", t))(fu || {});
function pu(t) {
  switch (t) {
    case "multiply":
      return 0;
    case "set_rgb":
      return 1;
    case "add_rgba":
      return 2;
    default:
      throw new Error(`Unknown blend mode: ${t}`);
  }
}
class du extends u.Object3D {
  constructor(A = {}) {
    super();
    const { type: e, invert: s, opacity: n, color: i, displace: r, radius: a } = A;
    this.type = e ?? "sphere", this.invert = s ?? !1, this.opacity = n ?? 1, this.color = i ?? new u.Color(1, 1, 1), this.displace = r ?? new u.Vector3(0, 0, 0), this.radius = a ?? 0;
  }
}
const Qe = class Qe extends u.Object3D {
  constructor(A = {}) {
    const {
      name: e,
      rgbaBlendMode: s = "multiply",
      sdfSmooth: n = 0,
      softEdge: i = 0,
      invert: r = !1,
      sdfs: a = null
    } = A;
    super(), this.rgbaBlendMode = s, this.sdfSmooth = n, this.softEdge = i, this.invert = r, this.sdfs = a, this.ordering = Qe.nextOrdering++, this.name = e ?? `Edit ${this.ordering}`;
  }
  addSdf(A) {
    this.sdfs == null && (this.sdfs = []), this.sdfs.includes(A) || this.sdfs.push(A);
  }
  removeSdf(A) {
    this.sdfs != null && (this.sdfs = this.sdfs.filter((e) => e !== A));
  }
};
Qe.nextOrdering = 1;
let Ie = Qe;
class yu {
  constructor({ maxSdfs: A, maxEdits: e }) {
    this.maxSdfs = Math.max(16, A ?? 0), this.numSdfs = 0, this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs), this.dynoSdfArray = new k({
      key: "sdfArray",
      type: $a,
      globals: () => [Va],
      value: {
        numSdfs: 0,
        sdfTexture: this.sdfTexture
      },
      update: (s) => (s.numSdfs = this.numSdfs, s.sdfTexture = this.sdfTexture, s)
    }), this.maxEdits = Math.max(16, e ?? 0), this.numEdits = 0, this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoNumEdits = new $t({ value: 0 }), this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
  }
  newSdfTexture(A, e) {
    const s = new u.DataTexture(
      A,
      8,
      e,
      u.RGBAIntegerFormat,
      u.UnsignedIntType
    );
    return s.internalFormat = "RGBA32UI", s.needsUpdate = !0, s;
  }
  newEdits(A, e) {
    return new k({
      key: "edits",
      type: "uvec4",
      count: e,
      globals: () => [Pa],
      value: A
    });
  }
  // Ensure our SDF texture and edits uniform array have enough capacity.
  // Reallocate if not.
  ensureCapacity({
    maxSdfs: A,
    maxEdits: e
  }) {
    let s = !1;
    return A > this.sdfTexture.image.height && (this.sdfTexture.dispose(), this.maxSdfs = Math.max(this.maxSdfs * 2, A), this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs)), e > (this.dynoEdits.count ?? 0) && (this.maxEdits = Math.max(this.maxEdits * 2, e), this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoEdits = this.newEdits(this.editData, this.maxEdits), s = !0), s;
  }
  updateEditData(A, e) {
    const s = this.editData[A] !== e;
    return this.editData[A] = e, s;
  }
  updateEditFloatData(A, e) {
    wt[0] = e;
    const s = this.editFloatData[A] !== wt[0];
    return s && (this.editFloatData[A] = wt[0]), s;
  }
  encodeEdit(A, {
    sdfFirst: e,
    sdfCount: s,
    invert: n,
    rgbaBlendMode: i,
    softEdge: r,
    sdfSmooth: a
  }) {
    const o = A * 4;
    let c = !1;
    return c = this.updateEditData(o + 0, i | (n ? 256 : 0)) || c, c = this.updateEditData(o + 1, e | s << 16) || c, c = this.updateEditFloatData(o + 2, r) || c, c = this.updateEditFloatData(o + 3, a) || c, c;
  }
  updateSdfData(A, e) {
    const s = this.sdfData[A] !== e;
    return this.sdfData[A] = e, s;
  }
  updateSdfFloatData(A, e) {
    wt[0] = e;
    const s = this.sdfFloatData[A] !== wt[0];
    return s && (this.sdfFloatData[A] = wt[0]), s;
  }
  encodeSdf(A, {
    sdfType: e,
    invert: s,
    center: n,
    quaternion: i,
    scale: r,
    sizes: a
  }, o) {
    const c = A * 32, l = e | (s ? 256 : 0);
    let g = !1;
    g = this.updateSdfFloatData(c + 0, (n == null ? void 0 : n.x) ?? 0) || g, g = this.updateSdfFloatData(c + 1, (n == null ? void 0 : n.y) ?? 0) || g, g = this.updateSdfFloatData(c + 2, (n == null ? void 0 : n.z) ?? 0) || g, g = this.updateSdfData(c + 3, l) || g, g = this.updateSdfFloatData(c + 4, (i == null ? void 0 : i.x) ?? 0) || g, g = this.updateSdfFloatData(c + 5, (i == null ? void 0 : i.y) ?? 0) || g, g = this.updateSdfFloatData(c + 6, (i == null ? void 0 : i.z) ?? 0) || g, g = this.updateSdfFloatData(c + 7, (i == null ? void 0 : i.w) ?? 0) || g, g = this.updateSdfFloatData(c + 8, (r == null ? void 0 : r.x) ?? 0) || g, g = this.updateSdfFloatData(c + 9, (r == null ? void 0 : r.y) ?? 0) || g, g = this.updateSdfFloatData(c + 10, (r == null ? void 0 : r.z) ?? 0) || g, g = this.updateSdfData(c + 11, 0) || g, g = this.updateSdfFloatData(c + 12, (a == null ? void 0 : a.x) ?? 0) || g, g = this.updateSdfFloatData(c + 13, (a == null ? void 0 : a.y) ?? 0) || g, g = this.updateSdfFloatData(c + 14, (a == null ? void 0 : a.z) ?? 0) || g, g = this.updateSdfFloatData(c + 15, (a == null ? void 0 : a.w) ?? 0) || g;
    const I = Math.min(4, o.length);
    for (let h = 0; h < I; ++h) {
      const Q = c + 16 + h * 4;
      g = this.updateSdfFloatData(Q + 0, o[h].x) || g, g = this.updateSdfFloatData(Q + 1, o[h].y) || g, g = this.updateSdfFloatData(Q + 2, o[h].z) || g, g = this.updateSdfFloatData(Q + 3, o[h].w) || g;
    }
    return g;
  }
  // Update the SDFs and edits from an array of SplatEdits and their
  // associated SplatEditSdfs, updating it for the dyno shader program.
  update(A) {
    const e = A.reduce((g, { sdfs: I }) => g + I.length, 0), s = this.ensureCapacity({
      maxEdits: A.length,
      maxSdfs: e
    }), n = [new u.Vector4(), new u.Vector4()], i = new u.Vector3(), r = new u.Quaternion(), a = new u.Vector3(), o = new u.Vector4();
    let c = 0, l = s;
    A.length !== this.dynoNumEdits.value && (this.dynoNumEdits.value = A.length, this.numEdits = A.length, l = !0);
    for (const [g, { edit: I, sdfs: h }] of A.entries()) {
      l = this.encodeEdit(g, {
        sdfFirst: c,
        sdfCount: h.length,
        invert: I.invert,
        rgbaBlendMode: pu(I.rgbaBlendMode),
        softEdge: I.softEdge,
        sdfSmooth: I.sdfSmooth
      }) || l;
      let Q = !1;
      for (const C of h)
        o.set(C.scale.x, C.scale.y, C.scale.z, C.radius), C.scale.setScalar(1), C.updateMatrixWorld(), C.matrixWorld.clone().invert().decompose(i, r, a), C.scale.set(o.x, o.y, o.z), C.updateMatrixWorld(), n[0].set(C.color.r, C.color.g, C.color.b, C.opacity), n[1].set(C.displace.x, C.displace.y, C.displace.z, 1), Q = this.encodeSdf(
          c,
          {
            sdfType: Eu(C.type),
            invert: C.invert,
            center: i,
            quaternion: r,
            scale: a,
            sizes: o
          },
          n
        ) || Q, c += 1;
      this.numSdfs = c, Q && (this.sdfTexture.needsUpdate = !0), l || (l = Q);
    }
    return { updated: l, dynoUpdated: s };
  }
  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
  modify(A) {
    return wu(
      A,
      this.dynoSdfArray,
      this.dynoNumEdits,
      this.dynoEdits
    );
  }
}
const $a = { type: "SdfArray" }, Va = hA(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`), Pa = hA(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);
function wu(t, A, e, s) {
  return new V({
    inTypes: {
      gsplat: AA,
      sdfArray: $a,
      numEdits: "int",
      rgbaDisplaceEdits: "uvec4"
    },
    outTypes: { gsplat: AA },
    globals: () => [Va, Pa],
    inputs: { gsplat: t, sdfArray: A, numEdits: e, rgbaDisplaceEdits: s },
    statements: ({ inputs: i, outputs: r }) => {
      const { sdfArray: a, numEdits: o, rgbaDisplaceEdits: c } = i, { gsplat: l } = r;
      return RA(`
        ${l} = ${i.gsplat};
        if (isGsplatActive(${l}.flags)) {
          for (int editIndex = 0; editIndex < ${o}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${c}[editIndex], ${a}.sdfTexture, ${a}.numSdfs,
              ${l}.center, ${l}.rgba
            );
          }
        }
      `);
    }
  }).outputs.gsplat;
}
const wt = new Float32Array(1);
class mu {
  constructor(A) {
    this.modifier = A, this.cache = /* @__PURE__ */ new Map();
  }
  apply(A) {
    let e = this.cache.get(A);
    return e || (e = vA(
      { index: "int" },
      { gsplat: AA },
      ({ index: s }) => {
        const { gsplat: n } = A.apply({ index: s });
        return this.modifier.apply({ gsplat: n });
      }
    ), this.cache.set(A, e)), e;
  }
}
class xt {
  // Create the dyno uniforms that parameterize the transform, setting them
  // to initial values that are different from any valid transform.
  constructor() {
    this.scale = new ht({ value: Number.NEGATIVE_INFINITY }), this.rotate = new Nt({
      value: new u.Quaternion(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    }), this.translate = new Ft({
      value: new u.Vector3(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
  }
  // Apply the transform to a Vec3 position in a dyno program.
  apply(A) {
    return fa(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  applyDir(A) {
    return pa(A, {
      rotate: this.rotate
    });
  }
  // Apply the transform to a Gsplat in a dyno program.
  applyGsplat(A) {
    return As(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  // Update the uniforms to match the given transform matrix.
  updateFromMatrix(A) {
    const e = new u.Vector3(), s = new u.Quaternion(), n = new u.Vector3();
    A.decompose(n, s, e);
    const i = (e.x + e.y + e.z) / 3;
    let r = !1;
    return i !== this.scale.value && (this.scale.value = i, r = !0), n.equals(this.translate.value) || (this.translate.value.copy(n), r = !0), s.equals(this.rotate.value) || (this.rotate.value.copy(s), r = !0), r;
  }
  // Update this transform to match the object's to-world transform.
  update(A) {
    return A.updateMatrixWorld(), this.updateFromMatrix(A.matrixWorld);
  }
}
class Vt extends u.Object3D {
  constructor({
    numSplats: A,
    generator: e,
    construct: s,
    update: n
  }) {
    if (super(), this.numSplats = A ?? 0, this.generator = e, this.frameUpdate = n, this.version = 0, s) {
      const i = s(this);
      Object.assign(this, i);
    }
  }
  updateVersion() {
    this.version += 1;
  }
  set needsUpdate(A) {
    A && this.updateVersion();
  }
}
const st = class st extends Vt {
  constructor(A = {}) {
    const e = new xt(), s = new xt(), n = new xt(), i = new xt(), r = new Nt({
      value: new u.Vector4(
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      )
    }), a = new ht({ value: 0 }), o = new ht({ value: 0 }), c = {
      transform: e,
      viewToWorld: s,
      worldToView: n,
      viewToObject: i,
      recolor: r,
      time: a,
      deltaTime: o
    };
    if (super({
      update: ({ time: l, deltaTime: g, viewToWorld: I, globalEdits: h }) => this.update({ time: l, deltaTime: g, viewToWorld: I, globalEdits: h })
    }), this.isInitialized = !1, this.recolor = new u.Color(1, 1, 1), this.opacity = 1, this.enableViewToObject = !1, this.enableViewToWorld = !1, this.enableWorldToView = !1, this.skinning = null, this.edits = null, this.rgbaDisplaceEdits = null, this.splatRgba = null, this.maxSh = 3, this.packedSplats = A.packedSplats ?? new VA(), this.packedSplats.splatEncoding = A.splatEncoding ?? {
      ...de
    }, this.numSplats = this.packedSplats.numSplats, this.editable = A.editable ?? !0, this.onFrame = A.onFrame, this.context = c, this.objectModifier = A.objectModifier, this.worldModifier = A.worldModifier, this.updateGenerator(), A.url || A.fileBytes || A.constructSplats || A.packedSplats && !A.packedSplats.isInitialized)
      this.initialized = this.asyncInitialize(A).then(async () => {
        if (this.updateGenerator(), this.isInitialized = !0, A.onLoad) {
          const l = A.onLoad(this);
          l instanceof Promise && await l;
        }
        return this;
      });
    else if (this.isInitialized = !0, this.initialized = Promise.resolve(this), A.onLoad) {
      const l = A.onLoad(this);
      l instanceof Promise && (this.initialized = l.then(() => this));
    }
    this.add(Tu());
  }
  async asyncInitialize(A) {
    const {
      url: e,
      fileBytes: s,
      fileType: n,
      fileName: i,
      maxSplats: r,
      constructSplats: a,
      splatEncoding: o
    } = A;
    if (e || s || a) {
      const c = {
        url: e,
        fileBytes: s,
        fileType: n,
        fileName: i,
        maxSplats: r,
        construct: a,
        splatEncoding: o
      };
      this.packedSplats.reinitialize(c);
    }
    this.packedSplats && (await this.packedSplats.initialized, this.numSplats = this.packedSplats.numSplats, this.updateGenerator());
  }
  static async staticInitialize() {
    await Gs(), st.isStaticInitialized = !0;
  }
  // Creates a new Gsplat with the provided parameters (all values in "float" space,
  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
  // doubling strategy to fit the new data, so it's fairly efficient to just
  // pushSplat(...) each Gsplat you want to create in a loop.
  pushSplat(A, e, s, n, i) {
    this.packedSplats.pushSplat(A, e, s, n, i);
  }
  // This method iterates over all Gsplats in this instance's packedSplats,
  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
  // Note that the objects passed in as center etc. are the same for every callback
  // invocation: these objects are reused for efficiency. Changing these values has
  // no effect as they are decoded/unpacked copies of the underlying data. To update
  // the packedSplats, call .packedSplats.setSplat(index, center, scales,
  // quaternion, opacity, color).
  forEachSplat(A) {
    this.packedSplats.forEachSplat(A);
  }
  // Call this when you are finished with the SplatMesh and want to free
  // any buffers it holds (via packedSplats).
  dispose() {
    this.packedSplats.dispose();
  }
  // Returns axis-aligned bounding box of the SplatMesh. If centers_only is true,
  // only the centers of the splats are used to compute the bounding box.
  // IMPORTANT: This should only be called after the SplatMesh is initialized.
  getBoundingBox(A = !0) {
    if (!this.initialized)
      throw new Error(
        "Cannot get bounding box before SplatMesh is initialized"
      );
    const e = new u.Vector3(
      Number.POSITIVE_INFINITY,
      Number.POSITIVE_INFINITY,
      Number.POSITIVE_INFINITY
    ), s = new u.Vector3(
      Number.NEGATIVE_INFINITY,
      Number.NEGATIVE_INFINITY,
      Number.NEGATIVE_INFINITY
    ), n = new u.Vector3(), i = [-1, 1];
    return this.packedSplats.forEachSplat(
      (a, o, c, l, g, I) => {
        if (A)
          e.min(o), s.max(o);
        else
          for (const h of i)
            for (const Q of i)
              for (const C of i)
                n.set(h * c.x, Q * c.y, C * c.z), n.applyQuaternion(l), n.add(o), e.min(n), s.max(n);
      }
    ), new u.Box3(e, s);
  }
  constructGenerator(A) {
    const { transform: e, viewToObject: s, recolor: n } = A, i = vA(
      { index: "int" },
      { gsplat: AA },
      ({ index: r }) => {
        if (!r)
          throw new Error("index is undefined");
        let a = bt(this.packedSplats.dyno, r);
        if (this.maxSh >= 1) {
          const { sh1Texture: c, sh2Texture: l, sh3Texture: g } = this.ensureShTextures();
          if (c) {
            let I = function(f, d) {
              const { x: y, y: D } = Qt(d).outputs, x = iA(BA(y, D), J("float", 0.5)), w = iA(Et(D, y), J("float", 0.5));
              return BA(x, iA(f, w));
            };
            const h = s.translate, { center: Q } = ut(a).outputs, C = Rr(Et(Q, h)), B = Mu(a, c, C);
            let E = I(B, this.packedSplats.dynoSh1MinMax);
            if (this.maxSh >= 2 && l) {
              const f = vu(a, l, C);
              E = BA(
                E,
                I(f, this.packedSplats.dynoSh2MinMax)
              );
            }
            if (this.maxSh >= 3 && g) {
              const f = bu(a, g, C);
              E = BA(
                E,
                I(f, this.packedSplats.dynoSh3MinMax)
              );
            }
            let { rgba: p } = ut(a).outputs;
            p = BA(p, Yr(E, J("float", 0))), a = rt({ gsplat: a, rgba: p });
          }
        }
        if (this.splatRgba) {
          const c = Bu(this.splatRgba.dyno, r);
          a = rt({ gsplat: a, rgba: c });
        }
        this.skinning && (a = this.skinning.modify(a)), this.objectModifier && (a = this.objectModifier.apply({ gsplat: a }).gsplat), a = e.applyGsplat(a);
        const o = iA(n, ut(a).outputs.rgba);
        return a = rt({ gsplat: a, rgba: o }), this.rgbaDisplaceEdits && (a = this.rgbaDisplaceEdits.modify(a)), this.worldModifier && (a = this.worldModifier.apply({ gsplat: a }).gsplat), { gsplat: a };
      }
    );
    this.generator = i;
  }
  // Call this whenever something changes in the Gsplat processing pipeline,
  // for example changing maxSh or updating objectModifier or worldModifier.
  // Compiled generators are cached for efficiency and re-use when the same
  // pipeline structure emerges after successive changes.
  updateGenerator() {
    this.constructGenerator(this.context);
  }
  // This is called automatically by SparkRenderer and you should not have to
  // call it. It updates parameters for the generated pipeline and calls
  // updateGenerator() if the pipeline needs to change.
  update({
    time: A,
    viewToWorld: e,
    deltaTime: s,
    globalEdits: n
  }) {
    var B;
    this.numSplats = this.packedSplats.numSplats, this.context.time.value = A, this.context.deltaTime.value = s, st.dynoTime.value = A;
    const { transform: i, viewToObject: r, recolor: a } = this.context;
    let o = i.update(this);
    this.context.viewToWorld.updateFromMatrix(e) && this.enableViewToWorld && (o = !0);
    const c = e.clone().invert();
    this.context.worldToView.updateFromMatrix(c) && this.enableWorldToView && (o = !0);
    const I = new u.Matrix4().compose(
      i.translate.value,
      i.rotate.value,
      new u.Vector3().setScalar(i.scale.value)
    ).invert().multiply(e);
    r.updateFromMatrix(I) && (this.enableViewToObject || this.packedSplats.extra.sh1) && (o = !0);
    const h = new u.Vector4(
      this.recolor.r,
      this.recolor.g,
      this.recolor.b,
      this.opacity
    );
    h.equals(a.value) || (a.value.copy(h), o = !0);
    const Q = this.editable ? (this.edits ?? []).concat(n) : [];
    this.editable && !this.edits && this.traverseVisible((E) => {
      E instanceof Ie && Q.push(E);
    }), Q.sort((E, p) => E.ordering - p.ordering);
    const C = Q.map((E) => {
      if (E.sdfs != null)
        return { edit: E, sdfs: E.sdfs };
      const p = [];
      return E.traverseVisible((f) => {
        f instanceof du && p.push(f);
      }), { edit: E, sdfs: p };
    });
    if (C.length > 0 && !this.rgbaDisplaceEdits) {
      const E = C.length, p = C.reduce(
        (f, d) => f + d.sdfs.length,
        0
      );
      this.rgbaDisplaceEdits = new yu({
        maxEdits: E,
        maxSdfs: p
      }), this.updateGenerator();
    }
    if (this.rgbaDisplaceEdits) {
      const E = this.rgbaDisplaceEdits.update(C);
      o || (o = E.updated), E.dynoUpdated && this.updateGenerator();
    }
    o && this.updateVersion(), (B = this.onFrame) == null || B.call(this, { mesh: this, time: A, deltaTime: s });
  }
  // This method conforms to the standard THREE.Raycaster API, performing object-ray
  // intersections using this method to populate the provided intersects[] array
  // with each intersection point.
  raycast(A, e) {
    var h, Q;
    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats)
      return;
    const { near: s, far: n, ray: i } = A, r = this.matrixWorld.clone().invert(), a = new u.Matrix3().setFromMatrix4(r), o = i.origin.clone().applyMatrix4(r), c = i.direction.clone().applyMatrix3(a), l = new u.Vector3();
    r.decompose(new u.Vector3(), new u.Quaternion(), l), (l.x * l.y * l.z) ** (1 / 3);
    const I = Po(
      o.x,
      o.y,
      o.z,
      c.x,
      c.y,
      c.z,
      s,
      n,
      this.packedSplats.numSplats,
      this.packedSplats.packedArray,
      !0,
      ((h = this.packedSplats.splatEncoding) == null ? void 0 : h.lnScaleMin) ?? UA,
      ((Q = this.packedSplats.splatEncoding) == null ? void 0 : Q.lnScaleMax) ?? GA
    );
    for (const C of I) {
      const B = i.direction.clone().multiplyScalar(C).add(i.origin);
      e.push({
        distance: C,
        point: B,
        object: this
      });
    }
  }
  ensureShTextures() {
    if (!this.packedSplats.extra.sh1)
      return {};
    let A = this.packedSplats.extra.sh1Texture;
    if (!A) {
      let n = this.packedSplats.extra.sh1;
      const { width: i, height: r, depth: a, maxSplats: o } = mA(
        n.length / 2
      );
      if (n.length < o * 2) {
        const l = new Uint32Array(o * 2);
        l.set(n), this.packedSplats.extra.sh1 = l, n = l;
      }
      const c = new u.DataArrayTexture(n, i, r, a);
      c.format = u.RGIntegerFormat, c.type = u.UnsignedIntType, c.internalFormat = "RG32UI", c.needsUpdate = !0, A = new qt({
        value: c,
        key: "sh1"
      }), this.packedSplats.extra.sh1Texture = A;
    }
    if (!this.packedSplats.extra.sh2)
      return { sh1Texture: A };
    let e = this.packedSplats.extra.sh2Texture;
    if (!e) {
      let n = this.packedSplats.extra.sh2;
      const { width: i, height: r, depth: a, maxSplats: o } = mA(
        n.length / 4
      );
      if (n.length < o * 4) {
        const l = new Uint32Array(o * 4);
        l.set(n), this.packedSplats.extra.sh2 = l, n = l;
      }
      const c = new u.DataArrayTexture(n, i, r, a);
      c.format = u.RGBAIntegerFormat, c.type = u.UnsignedIntType, c.internalFormat = "RGBA32UI", c.needsUpdate = !0, e = new qt({
        value: c,
        key: "sh2"
      }), this.packedSplats.extra.sh2Texture = e;
    }
    if (!this.packedSplats.extra.sh3)
      return { sh1Texture: A, sh2Texture: e };
    let s = this.packedSplats.extra.sh3Texture;
    if (!s) {
      let n = this.packedSplats.extra.sh3;
      const { width: i, height: r, depth: a, maxSplats: o } = mA(
        n.length / 4
      );
      if (n.length < o * 4) {
        const l = new Uint32Array(o * 4);
        l.set(n), this.packedSplats.extra.sh3 = l, n = l;
      }
      const c = new u.DataArrayTexture(n, i, r, a);
      c.format = u.RGBAIntegerFormat, c.type = u.UnsignedIntType, c.internalFormat = "RGBA32UI", c.needsUpdate = !0, s = new qt({
        value: c,
        key: "sh3"
      }), this.packedSplats.extra.sh3Texture = s;
    }
    return { sh1Texture: A, sh2Texture: e, sh3Texture: s };
  }
};
st.staticInitialized = st.staticInitialize(), st.isStaticInitialized = !1, st.dynoTime = new ht({ value: 0 });
let ft = st;
const xu = hA(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`), Su = hA(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`), Du = hA(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);
function Mu(t, A, e) {
  return Wt({
    inTypes: { gsplat: AA, sh1: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh1: A, viewDir: e },
    globals: () => [bA, xu],
    statements: ({ inputs: s, outputs: n }) => RA(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${n.rgb} = evaluateSH1(${s.gsplat}, ${s.sh1}, ${s.viewDir});
        } else {
          ${n.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function vu(t, A, e) {
  return Wt({
    inTypes: { gsplat: AA, sh2: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh2: A, viewDir: e },
    globals: () => [bA, Su],
    statements: ({ inputs: s, outputs: n }) => RA(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${n.rgb} = evaluateSH2(${s.gsplat}, ${s.sh2}, ${s.viewDir});
        } else {
          ${n.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function bu(t, A, e) {
  return Wt({
    inTypes: { gsplat: AA, sh3: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh3: A, viewDir: e },
    globals: () => [bA, Du],
    statements: ({ inputs: s, outputs: n }) => RA(`
        if (isGsplatActive(${s.gsplat}.flags)) {
          ${n.rgb} = evaluateSH3(${s.gsplat}, ${s.sh3}, ${s.viewDir});
        } else {
          ${n.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
const Fu = new u.BufferGeometry(), ku = new u.ShaderMaterial();
function Tu() {
  const t = new u.Mesh(Fu, ku);
  return t.frustumCulled = !1, t.onBeforeRender = function(A, e) {
    if (!e.isScene) {
      this.removeFromParent();
      return;
    }
    let s = !1;
    e.traverse((n) => {
      n instanceof Be && (s = !0);
    }), s || e.add(new Be({ renderer: A })), this.removeFromParent();
  }, t;
}
const Es = [
  "char",
  "uchar",
  "short",
  "ushort",
  "int",
  "uint",
  "float",
  "double"
], Dt = class Dt {
  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
  constructor({ fileBytes: A }) {
    this.header = "", this.littleEndian = !0, this.elements = {}, this.comments = [], this.data = null, this.numSplats = 0, this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A;
  }
  // Identify and parse the PLY text header (assumed to be <64KB in size).
  // this.elements will contain all the elements in the file, typically
  // "vertex" contains the Gsplat data.
  async parseHeader() {
    const e = new ReadableStream({
      start: (r) => {
        r.enqueue(this.fileBytes.slice(0, 65536)), r.close();
      }
    }).pipeThrough(new TextDecoderStream()).getReader();
    this.header = "";
    const s = `end_header
`;
    for (; ; ) {
      const { value: r, done: a } = await e.read();
      if (a)
        throw new Error("Failed to read header");
      this.header += r;
      const o = this.header.indexOf(s);
      if (o >= 0) {
        this.header = this.header.slice(0, o + s.length);
        break;
      }
    }
    const n = new TextEncoder().encode(this.header).length;
    this.data = new DataView(this.fileBytes.buffer, n), this.elements = {};
    let i = null;
    this.comments = [], this.header.trim().split(`
`).forEach((r, a) => {
      const o = r.trim();
      if (a === 0) {
        if (o !== "ply")
          throw new Error("Invalid PLY header");
        return;
      }
      if (o.length === 0)
        return;
      const c = o.split(" ");
      switch (c[0]) {
        case "format":
          if (c[1] === "binary_little_endian")
            this.littleEndian = !0;
          else if (c[1] === "binary_big_endian")
            this.littleEndian = !1;
          else
            throw new Error(`Unsupported PLY format: ${c[1]}`);
          if (c[2] !== "1.0")
            throw new Error(`Unsupported PLY version: ${c[2]}`);
          break;
        case "end_header":
          break;
        case "comment":
          this.comments.push(o.slice(8));
          break;
        case "element": {
          const l = c[1];
          i = {
            name: l,
            count: Number.parseInt(c[2]),
            properties: {}
          }, this.elements[l] = i;
          break;
        }
        case "property":
          if (i == null)
            throw new Error("Property must be inside an element");
          c[1] === "list" ? i.properties[c[4]] = {
            isList: !0,
            type: c[3],
            countType: c[2]
          } : i.properties[c[2]] = {
            isList: !1,
            type: c[1]
          };
          break;
      }
    }), this.elements.vertex && (this.numSplats = this.elements.vertex.count);
  }
  parseData(A) {
    let e = 0;
    const s = this.data;
    if (s == null)
      throw new Error("No data to parse");
    for (const n in this.elements) {
      const i = this.elements[n], { count: r, properties: a } = i, o = Gu(a), c = Ru(a, this.littleEndian), l = A(i) ?? (() => {
      });
      for (let g = 0; g < r; g++)
        e = c(s, e, o), l(g, o);
    }
  }
  // Parse all the Gsplat data in the PLY file in go, invoking the given
  // callbacks for each Gsplat.
  parseSplats(A, e) {
    if (this.elements.vertex == null)
      throw new Error("No vertex element found");
    let s = !1;
    const n = [];
    let i = 0, r = [], a = [], o = [], c, l, g;
    function I() {
      const E = Uu[i];
      r = new Array(3).fill(null).flatMap((p, f) => [0, 1, 2].map((d, y) => f + y * E / 3)), a = new Array(5).fill(null).flatMap(
        (p, f) => [0, 1, 2].map((d, y) => 3 + f + y * E / 3)
      ), o = new Array(7).fill(null).flatMap(
        (p, f) => [0, 1, 2].map((d, y) => 8 + f + y * E / 3)
      ), c = i >= 1 ? new Float32Array(3 * 3) : void 0, l = i >= 2 ? new Float32Array(5 * 3) : void 0, g = i >= 3 ? new Float32Array(7 * 3) : void 0;
    }
    function h(E, p) {
      if (!c)
        throw new Error("Missing sh1");
      const f = p.f_rest;
      for (let d = 0; d < r.length; d++)
        c[d] = f[r[d]] * 8 / 255 - 4;
      if (l)
        for (let d = 0; d < a.length; d++)
          l[d] = f[a[d]] * 8 / 255 - 4;
      if (g)
        for (let d = 0; d < o.length; d++)
          g[d] = f[o[d]] * 8 / 255 - 4;
      e == null || e(E, c, l, g);
    }
    function Q(E) {
      const {
        min_x: p,
        min_y: f,
        min_z: d,
        max_x: y,
        max_y: D,
        max_z: x,
        min_scale_x: w,
        min_scale_y: m,
        min_scale_z: T,
        max_scale_x: M,
        max_scale_y: S,
        max_scale_z: U
      } = E.properties;
      if (!p || !f || !d || !y || !D || !x || !w || !m || !T || !M || !S || !U)
        throw new Error("Missing PLY chunk properties");
      return s = !0, (F, b) => {
        const {
          min_x: N,
          min_y: R,
          min_z: O,
          max_x: _,
          max_y: eA,
          max_z: H,
          min_scale_x: W,
          min_scale_y: L,
          min_scale_z: j,
          max_scale_x: P,
          max_scale_y: Z,
          max_scale_z: G,
          min_r: fA,
          min_g: cA,
          min_b: pA,
          max_r: dA,
          max_g: xA,
          max_b: CA
        } = b;
        n.push({
          min_x: N,
          min_y: R,
          min_z: O,
          max_x: _,
          max_y: eA,
          max_z: H,
          min_scale_x: W,
          min_scale_y: L,
          min_scale_z: j,
          max_scale_x: P,
          max_scale_y: Z,
          max_scale_z: G,
          min_r: fA,
          min_g: cA,
          min_b: pA,
          max_r: dA,
          max_g: xA,
          max_b: CA
        });
      };
    }
    function C(E) {
      if (e && E.name === "sh")
        return i = $e(E.properties), I(), h;
      if (E.name !== "vertex")
        return null;
      const { packed_position: p, packed_rotation: f, packed_scale: d, packed_color: y } = E.properties;
      if (!p || !f || !d || !y)
        throw new Error(
          "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
        );
      const D = Math.sqrt(2);
      return (x, w) => {
        const m = n[x >>> 8];
        if (m == null)
          throw new Error("Missing PLY chunk");
        const {
          min_x: T,
          min_y: M,
          min_z: S,
          max_x: U,
          max_y: F,
          max_z: b,
          min_scale_x: N,
          min_scale_y: R,
          min_scale_z: O,
          max_scale_x: _,
          max_scale_y: eA,
          max_scale_z: H,
          min_r: W,
          min_g: L,
          min_b: j,
          max_r: P,
          max_g: Z,
          max_b: G
        } = m, { packed_position: fA, packed_rotation: cA, packed_scale: pA, packed_color: dA } = w, xA = (fA >>> 21 & 2047) / 2047 * (U - T) + T, CA = (fA >>> 11 & 1023) / 1023 * (F - M) + M, YA = (fA & 2047) / 2047 * (b - S) + S, SA = ((cA >>> 20 & 1023) / 1023 - 0.5) * D, WA = ((cA >>> 10 & 1023) / 1023 - 0.5) * D, jA = ((cA & 1023) / 1023 - 0.5) * D, Y = Math.sqrt(Math.max(0, 1 - SA * SA - WA * WA - jA * jA)), DA = cA >>> 30, lA = DA === 0 ? SA : DA === 1 ? Y : WA, Gt = DA <= 1 ? WA : DA === 2 ? Y : jA, Ae = DA <= 2 ? jA : Y, MA = DA === 0 ? Y : SA, z = Math.exp(
          (pA >>> 21 & 2047) / 2047 * (_ - N) + N
        ), XA = Math.exp(
          (pA >>> 11 & 1023) / 1023 * (eA - R) + R
        ), ye = Math.exp(
          (pA & 2047) / 2047 * (H - O) + O
        ), we = (dA >>> 24 & 255) / 255 * ((P ?? 1) - (W ?? 0)) + (W ?? 0), me = (dA >>> 16 & 255) / 255 * ((Z ?? 1) - (L ?? 0)) + (L ?? 0), xe = (dA >>> 8 & 255) / 255 * ((G ?? 1) - (j ?? 0)) + (j ?? 0), Se = (dA & 255) / 255;
        A(
          x,
          xA,
          CA,
          YA,
          z,
          XA,
          ye,
          lA,
          Gt,
          Ae,
          MA,
          Se,
          we,
          me,
          xe
        );
      };
    }
    const B = (E) => {
      if (E.name === "chunk")
        return Q(E);
      if (s)
        return C(E);
      if (E.name !== "vertex")
        return null;
      const {
        x: p,
        y: f,
        z: d,
        scale_0: y,
        scale_1: D,
        scale_2: x,
        rot_0: w,
        rot_1: m,
        rot_2: T,
        rot_3: M,
        opacity: S,
        f_dc_0: U,
        f_dc_1: F,
        f_dc_2: b,
        red: N,
        green: R,
        blue: O,
        alpha: _
      } = E.properties;
      if (!p || !f || !d)
        throw new Error("Missing PLY properties: x, y, z");
      const eA = y && D && x, H = w && m && T && M, W = _ != null ? se[_.type] : 1, L = N != null ? se[N.type] : 1, j = R != null ? se[R.type] : 1, P = O != null ? se[O.type] : 1;
      return i = $e(E.properties), I(), (Z, G) => {
        const fA = eA ? Math.exp(G.scale_0) : Dt.defaultPointScale, cA = eA ? Math.exp(G.scale_1) : Dt.defaultPointScale, pA = eA ? Math.exp(G.scale_2) : Dt.defaultPointScale, dA = H ? G.rot_1 : 0, xA = H ? G.rot_2 : 0, CA = H ? G.rot_3 : 0, YA = H ? G.rot_0 : 1, SA = S != null ? 1 / (1 + Math.exp(-G.opacity)) : _ != null ? G.alpha / W : 1, WA = U != null ? G.f_dc_0 * ee + 0.5 : N != null ? G.red / L : 1, jA = F != null ? G.f_dc_1 * ee + 0.5 : R != null ? G.green / j : 1, Y = b != null ? G.f_dc_2 * ee + 0.5 : O != null ? G.blue / P : 1;
        if (A(
          Z,
          G.x,
          G.y,
          G.z,
          fA,
          cA,
          pA,
          dA,
          xA,
          CA,
          YA,
          SA,
          WA,
          jA,
          Y
        ), e && c) {
          const DA = G.f_rest;
          if (c)
            for (let lA = 0; lA < r.length; lA++)
              c[lA] = DA[r[lA]];
          if (l)
            for (let lA = 0; lA < a.length; lA++)
              l[lA] = DA[a[lA]];
          if (g)
            for (let lA = 0; lA < o.length; lA++)
              g[lA] = DA[o[lA]];
          e(Z, c, l, g);
        }
      };
    };
    this.parseData(B);
  }
  // Inject RGBA values into original PLY file, which can be used to modify
  // the color/opacity of the Gsplats and write out the modified PLY file.
  injectRgba(A) {
    let e = 0;
    const s = this.data;
    if (s == null)
      throw new Error("No parsed data");
    if (A.length !== this.numSplats * 4)
      throw new Error("Invalid RGBA array length");
    for (const n in this.elements) {
      const i = this.elements[n], { count: r, properties: a } = i, o = [];
      let c = 0;
      const l = n === "vertex";
      if (l) {
        for (const g of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"])
          if (!a[g] || a[g].type !== "float")
            throw new Error(`Can't injectRgba due to property: ${g}`);
      }
      for (const [g, I] of Object.entries(a))
        if (I.isList)
          o.push(() => {
            const h = St[I.countType](
              s,
              e,
              this.littleEndian
            );
            e += zA[I.countType], e += h * zA[I.type];
          });
        else {
          if (l)
            if (g === "f_dc_0" || g === "f_dc_1" || g === "f_dc_2") {
              const h = Number.parseInt(
                g.slice(5)
              );
              o.push(() => {
                const Q = (A[c + h] / 255 - 0.5) / ee;
                fs[I.type](
                  s,
                  e,
                  this.littleEndian,
                  Q
                );
              });
            } else g === "opacity" && o.push(() => {
              const h = Math.max(
                -100,
                Math.min(
                  100,
                  -Math.log(1 / (A[c + 3] / 255) - 1)
                )
              );
              fs[I.type](
                s,
                e,
                this.littleEndian,
                h
              );
            });
          o.push(() => {
            e += zA[I.type];
          });
        }
      for (let g = 0; g < r; g++) {
        for (const I of o)
          I();
        l && (c += 4);
      }
    }
  }
};
Dt.defaultPointScale = 1e-3;
let ue = Dt;
const ee = 0.28209479177387814, St = {
  char: (t, A, e) => t.getInt8(A),
  uchar: (t, A, e) => t.getUint8(A),
  short: (t, A, e) => t.getInt16(A, e),
  ushort: (t, A, e) => t.getUint16(A, e),
  int: (t, A, e) => t.getInt32(A, e),
  uint: (t, A, e) => t.getUint32(A, e),
  float: (t, A, e) => t.getFloat32(A, e),
  double: (t, A, e) => t.getFloat64(A, e)
}, fs = {
  char: (t, A, e, s) => {
    t.setInt8(A, s);
  },
  uchar: (t, A, e, s) => {
    t.setUint8(A, s);
  },
  short: (t, A, e, s) => {
    t.setInt16(A, s, e);
  },
  ushort: (t, A, e, s) => {
    t.setUint16(A, s, e);
  },
  int: (t, A, e, s) => {
    t.setInt32(A, s, e);
  },
  uint: (t, A, e, s) => {
    t.setUint32(A, s, e);
  },
  float: (t, A, e, s) => {
    t.setFloat32(A, s, e);
  },
  double: (t, A, e, s) => {
    t.setFloat64(A, s, e);
  }
}, zA = {
  char: 1,
  uchar: 1,
  short: 2,
  ushort: 2,
  int: 4,
  uint: 4,
  float: 4,
  double: 8
}, se = {
  char: 127,
  uchar: 255,
  short: 32767,
  ushort: 65535,
  int: 2147483647,
  uint: 4294967295,
  float: 1,
  double: 1
}, Nu = {
  0: 0,
  9: 1,
  24: 2,
  45: 3
}, Uu = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
}, gs = /^f_rest_([0-9]{1,2})$/;
function Gu(t) {
  const A = {};
  for (const [e, s] of Object.entries(t))
    gs.test(e) ? A.f_rest = new Array($e(t)) : A[e] = s.isList ? [] : 0;
  return A;
}
function Ru(t, A) {
  return _u(t) ? Lu(t, A) : zu(t, A);
}
const Yu = (() => {
  try {
    new Function("return 42;");
  } catch {
    return !1;
  }
  return !0;
})(), Ju = /^[a-zA-Z0-9_]+$/;
function _u(t) {
  if (!Yu)
    return !1;
  for (const [A, e] of Object.entries(t))
    if (!Ju.test(A) || e.isList && !Es.includes(e.countType) || !Es.includes(e.type))
      return !1;
  return !0;
}
function Lu(t, A) {
  const e = ["let list;"];
  for (const [n, i] of Object.entries(t)) {
    const r = n.match(gs);
    if (r) {
      const a = +r[1];
      e.push(
        /*js*/
        `
        item.f_rest[${a}] = PARSE_FIELD['${i.type}'](data, offset, ${A});
        offset += ${zA[i.type]};
      `
      );
    } else i.isList ? e.push(
      /*js*/
      `
        list = item['${n}'];
        list.length = PARSE_FIELD['${i.countType}'](data, offset, ${A});
        offset += ${zA[i.countType]};
        for (let i = 0; i < list.length; i++) {
          list[i] = PARSE_FIELD['${i.type}'](data, offset, ${A});
          offset += ${zA[i.type]};
        }
      `
    ) : e.push(
      /*js*/
      `
        item['${n}'] = PARSE_FIELD['${i.type}'](data, offset, ${A});
        offset += ${zA[i.type]};
      `
    );
  }
  e.push("return offset;");
  const s = new Function(
    "data",
    "offset",
    "item",
    "PARSE_FIELD",
    e.join(`
`)
  );
  return (n, i, r) => s(n, i, r, St);
}
function zu(t, A) {
  const e = [];
  for (const [s, n] of Object.entries(t)) {
    const i = s.match(gs);
    if (i) {
      const r = +i[1];
      e.push(
        (a, o, c) => (c.f_rest[r] = St[n.type](
          a,
          o,
          A
        ), o + zA[n.type])
      );
    } else n.isList ? e.push(
      (r, a, o) => {
        const c = o[s];
        c.length = St[n.countType](
          r,
          a,
          A
        );
        let l = a + zA[n.countType];
        for (let g = 0; g < c.length; g++)
          c[g] = St[n.type](
            r,
            l,
            A
          ), l += zA[n.type];
        return l;
      }
    ) : e.push(
      (r, a, o) => (o[s] = St[n.type](
        r,
        a,
        A
      ), a + zA[n.type])
    );
  }
  return (s, n, i) => {
    let r = n;
    for (let a = 0; a < e.length; a++)
      r = e[a](s, r, i);
    return r;
  };
}
function $e(t) {
  let A = 0;
  for (; t[`f_rest_${A}`]; )
    A += 1;
  const e = Nu[A];
  if (e == null)
    throw new Error(`Unsupported number of SH coefficients: ${A}`);
  return e;
}
const Xa = '(function(){"use strict";let xA;const ge=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&ge.decode();let jA=null;function ns(){return(jA===null||jA.byteLength===0)&&(jA=new Uint8Array(xA.memory.buffer)),jA}function gs(s,A){return s=s>>>0,ge.decode(ns().subarray(s,s+A))}function rs(s,A,t){return xA.sort_splats(s,A,t)>>>0}function Is(s,A,t){return xA.sort32_splats(s,A,t)>>>0}async function os(s,A){if(typeof Response=="function"&&s instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(s,A)}catch(e){if(s.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n",e);else throw e}const t=await s.arrayBuffer();return await WebAssembly.instantiate(t,A)}else{const t=await WebAssembly.instantiate(s,A);return t instanceof WebAssembly.Instance?{instance:t,module:s}:t}}function as(){const s={};return s.wbg={},s.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},s.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},s.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},s.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},s.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},s.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},s.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,t,e){return new Float32Array(A,t>>>0,e>>>0)},s.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,t,e){return new Uint32Array(A,t>>>0,e>>>0)},s.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},s.wbg.__wbg_set_10bad9bee0e9c58b=function(A,t,e){A.set(t,e>>>0)},s.wbg.__wbg_set_d23661d19148b229=function(A,t,e){A.set(t,e>>>0)},s.wbg.__wbg_set_f4f1f0daa30696fc=function(A,t,e){A.set(t,e>>>0)},s.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,t,e){return A.subarray(t>>>0,e>>>0)},s.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,t,e){return A.subarray(t>>>0,e>>>0)},s.wbg.__wbindgen_init_externref_table=function(){const A=xA.__wbindgen_export_0,t=A.grow(4);A.set(0,void 0),A.set(t+0,void 0),A.set(t+1,null),A.set(t+2,!0),A.set(t+3,!1)},s.wbg.__wbindgen_memory=function(){return xA.memory},s.wbg.__wbindgen_throw=function(A,t){throw new Error(gs(A,t))},s}function Cs(s,A){return xA=s.exports,re.__wbindgen_wasm_module=A,jA=null,xA.__wbindgen_start(),xA}async function re(s){if(xA!==void 0)return xA;typeof s<"u"&&(Object.getPrototypeOf(s)===Object.prototype?{module_or_path:s}=s:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof s>"u"&&(s=new URL("data:application/wasm;base64,AGFzbQEAAAABzAEeYAJ/fwF/YAJ/fwBgA39/fwF/YAF/AX9gA39/fwBgAX8AYAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAFvAW9gA29vfwBgAW8Bf2AAAX9gBH9/f38AYAAAYAR/f39/AX9gA39vbwF/YAF/AW9gAAFvYAF9AX1gBn9/f39/fwBgDX19fX19fX19f29/fX0Bb2AGf39/f39/AX9gBX9/fH9/AGAEf3x/fwBgBX9/fX9/AGAEf31/fwBgBX9/fn9/AGAEf35/fwBgAn19AX0C8gQRA3diZx1fX3diZ19idWZmZXJfNjA5Y2MzZWVlNTFlZDE1OAAJA3diZxpfX3diZ19uZXdfOWZlZTk3YTQwOWIzMmI2OAAJA3diZxpfX3diZ19zZXRfZjRmMWYwZGFhMzA2OTZmYwAKA3diZx1fX3diZ19sZW5ndGhfOGNmZDJjNjQwOWFmODhhZAALA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9mMWRlYWQ0NGQxZmM3MjEyAAcDd2JnGl9fd2JnX25ld19lM2IzMjFkY2ZlZjg5ZmM3AAkDd2JnGl9fd2JnX3NldF9kMjM2NjFkMTkxNDhiMjI5AAoDd2JnHV9fd2JnX2xlbmd0aF82Y2E1Mjc2NjVkODk2OTRkAAsDd2JnMV9fd2JnX25ld3dpdGhieXRlb2Zmc2V0YW5kbGVuZ3RoX2U2YjdlNjlhY2Q0YzczNTQABwN3YmcaX193Ymdfc2V0XzEwYmFkOWJlZTBlOWM1OGIACgN3YmcdX193YmdfbGVuZ3RoXzNiNGYwMjIxODhhZThkYjYACwN3YmcfX193Ymdfc3ViYXJyYXlfNzY5ZTFlMGY4MWJiMjU5YgAHA3diZx9fX3diZ19zdWJhcnJheV8zYWFlZWM4OWJiMjU0NGYwAAcDd2JnJF9fd2JnX25ld3dpdGhsZW5ndGhfNWE1ZWZlMzEzY2ZkNTlmMQARA3diZxBfX3diaW5kZ2VuX3Rocm93AAEDd2JnEV9fd2JpbmRnZW5fbWVtb3J5ABIDd2JnH19fd2JpbmRnZW5faW5pdF9leHRlcm5yZWZfdGFibGUADgNhYAMAAQIIBQQCEwEMAAEBAgAAAQwBBAYFBQQAAQYFFAENBAAGBQQEAQQOAgECAQAIBAAVARYG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ACIDKAIEQXhxRgRAIAMhAgwBCyABQRkgAkEBdmtBACACQR9HG3QhBQNAIAMgBUEddkEEcWpBEGoiBCgCACICRQ0CIAVBAXQhBSACIQMgAigCBEF4cSABRw0ACwsgAigCCCIBIAA2AgwgAiAANgIIIABBADYCGCAAIAI2AgwgACABNgIIDwsgBCAANgIAIAAgAzYCGCAAIAA2AgwgACAANgIIC/MCAQR/IwBBMGsiACQAAkACQEGQksAAKAIARQRAQaiSwAAoAgAhAUGoksAAQQA2AgAgAUUNASAAQRhqIAERBQAgAEEQaiICIABBJGopAgA3AwAgACAAKQIcNwMIIAAoAhghAUGQksAAKAIAIgMNAgJAIANFDQBBlJLAACgCACICRQ0AQZiSwAAoAgAgAkECdBBlC0GUksAAIAE2AgBBkJLAAEEBNgIAQZiSwAAgACkDCDcCAEGgksAAIABBEGopAwA3AgALIABBMGokAEGUksAADwsgAEEANgIoIABBATYCHCAAQaCHwAA2AhggAEIENwIgIABBGGpBiIjAABBDAAsgAEEoaiACKQMANwIAIAAgACkDCDcCICAAIAE2AhwgAEEBNgIYAkAgAEEYaiIBKAIARQ0AIAEoAgQiAkUNACABKAIIIAJBAnQQZQsgAEEANgIoIABBATYCHCAAQaiIwAA2AhggAEIENwIgIAFBsIjAABBDAAuoAgIDfwF+IwBBQGoiAiQAIAEoAgBBgICAgHhGBEAgASgCDCEDIAJBJGoiBEEANgIAIAJCgICAgBA3AhwgAkEwaiADKAIAIgNBCGopAgA3AwAgAkE4aiADQRBqKQIANwMAIAIgAykCADcDKCACQRxqQcCIwAAgAkEoahAYGiACQRhqIAQoAgAiAzYCACACIAIpAhwiBTcDECABQQhqIAM2AgAgASAFNwIACyABKQIAIQUgAUKAgICAEDcCACACQQhqIgMgAUEIaiIBKAIANgIAIAFBADYCAEGxk8AALQAAGiACIAU3AwBBDEEEEF0iAUUEQEEEQQwQbQALIAEgAikDADcCACABQQhqIAMoAgA2AgAgAEHgisAANgIEIAAgATYCACACQUBrJAAL0gECBH8BfiMAQSBrIgMkACABIAEgAmoiAksEQEEAQQAQUgALQQggACgCACIEQQF0IgEgAiABIAJLGyICIAJBCEkb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QQRqrUKAgICA4ACENwMoIAEgAa1CgICAgOAAhDcDICABIAFBIGo2AhAgAUEIakHIj8AAEEMAC2kCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQfyNwAA2AgggA0ICNwIUIANCgICAgOAAIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhBDAAtpAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0H4kcAANgIIIANCAjcCFCADQoCAgIDgACIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQQwALZgAjAEEwayIAJABBsJPAAC0AAARAIABBAjYCDCAAQbCKwAA2AgggAEIBNwIUIAAgATYCLCAAIABBLGqtQoCAgIDgAIQ3AyAgACAAQSBqNgIQIABBCGpB0IrAABBDAAsgAEEwaiQAC5QBAgN/AW8jAEEgayIDJAAgAyAAKAIAEHAiBDYCACADIAI2AgQgAiAERwRAIANBADYCCCADIANBBGogA0EIahBAAAsQWyIEEFMiBSUBEAUhBhAbIgIgBiYBIAVBhAFPBEAgBRAtCyACIAAoAgAgAUECdhBkIAJBhAFPBEAgAhAtCyAEQYQBTwRAIAQQLQsgA0EgaiQAC08BAX8jAEEwayIAJAAgAEEBNgIMIABBwI3AADYCCCAAQgE3AhQgACAAQS9qrUKAgICAoAWENwMgIAAgAEEgajYCECAAQQhqQcSBwAAQQwALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhAlIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALTQECf0Gxk8AALQAAGiABKAIEIQIgASgCACEDQQhBBBBdIgFFBEBBBEEIEG0ACyABIAI2AgQgASADNgIAIABB8IrAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhApIAAoAgghAwsgACgCBCADaiABIAIQHxogACACIANqNgIIQQALQQEBfyMAQSBrIgIkACACQQA2AhAgAkEBNgIEIAJCBDcCCCACQS42AhwgAiAANgIYIAIgAkEYajYCACACIAEQQwALswIBA38gACgCACECIAEoAhwiAEEQcUUE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ZCByZWN1cnNpdmVseSBvciBhZnRlciBiZWluZyBkcm9wcGVkTGF6eSBpbnN0YW5jZSBoYXMgcHJldmlvdXNseSBiZWVuIHBvaXNvbmVkdgMQACoAAAAvVXNlcnMvZG1hcmNvcy8uY2FyZ28vcmVnaXN0cnkvc3JjL2luZGV4LmNyYXRlcy5pby02ZjE3ZDIyYmJhMTUwMDFmL29uY2VfY2VsbC0xLjIxLjMvc3JjL2xpYi5ycwCoAxAAXwAAAAgDAAAZAAAAcmVlbnRyYW50IGluaXQAABgEEAAOAAAAqAMQAF8AAAB6AgAADQAAABYAAAAMAAAABAAAABcAAAAYAAAAGQAAAC9ydXN0L2RlcHMvZGxtYWxsb2MtMC4yLjYvc3JjL2RsbWFsbG9jLnJzYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPj0gc2l6ZSArIG1pbl9vdmVyaGVhZABYBBAAKQAAAKgEAAAJAAAAYXNzZXJ0aW9uIGZhaWxlZDogcHNpemUgPD0gc2l6ZSArIG1heF9vdmVyaGVhZAAAWAQQACkAAACuBAAADQAAAEFjY2Vzc0Vycm9ybWVtb3J5IGFsbG9jYXRpb24gb2YgIGJ5dGVzIGZhaWxlZAAAAAsFEAAVAAAAIAUQAA0AAABzdGQvc3JjL2FsbG9jLnJzQAUQABAAAABjAQAACQAAABYAAAAMAAAABAAAABoAAAAAAAAACAAAAAQAAAAbAAAAAAAAAAgAAAAEAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAQAAAABAAAACEAAAAiAAAAIwAAACQAAABFcnJvcgAAACUAAAAMAAAABAAAACYAAAAnAAAAKAAAAGNhcGFjaXR5IG92ZXJmbG93AAAA2AUQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5yc/QFEAAUAAAAGAAAAAUAQaCMwAAL8AUBAAAAKQAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAfgYQABAAAAB+AgAADgAAAEJvcnJvd011dEVycm9yYWxyZWFkeSBib3Jyb3dlZDogrgYQABIAAABpbmRleCBvdXQgb2YgYm91bmRzOiB0aGUgbGVuIGlzICBidXQgdGhlIGluZGV4IGlzIAAAyAYQACAAAADoBhAAEgAAAD09IT1tYXRjaGVzYXNzZXJ0aW9uIGBsZWZ0ICByaWdodGAgZmFpbGVkCiAgbGVmdDogCiByaWdodDogABcHEAAQAAAAJwcQABcAAAA+BxAACQAAACByaWdodGAgZmFpbGVkOiAKICBsZWZ0OiAAAAAXBxAAEAAAAGAHEAAQAAAAcAcQAAkAAAA+BxAACQAAADogAAABAAAAAAAAAJwHEAACAAAAfSB9Y29yZS9zcmMvZm10L251bS5ycwAAswcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTlyYW5nZSBzdGFydCBpbmRleCAgb3V0IG9mIHJhbmdlIGZvciBzbGljZSBvZiBsZW5ndGggAACiCBAAEgAAALQIEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgIEAAQAAAAtAgQACIAAAAAAAA/AAAAvwBBqJLAAAsBFABwCXByb2R1Y2VycwIIbGFuZ3VhZ2UBBFJ1c3QADHByb2Nlc3NlZC1ieQMFcnVzdGMdMS44My4wICg5MGIzNWE2MjMgMjAyNC0xMS0yNikGd2FscnVzBjAuMjMuMwx3YXNtLWJpbmRnZW4HMC4yLjEwMABJD3RhcmdldF9mZWF0dXJlcwQrD211dGFibGUtZ2xvYmFscysIc2lnbi1leHQrD3JlZmVyZW5jZS10eXBlcysKbXVsdGl2YWx1ZQ==",self.location.href));const A=as();(typeof s=="string"||typeof Request=="function"&&s instanceof Request||typeof URL=="function"&&s instanceof URL)&&(s=fetch(s));const{instance:t,module:e}=await os(await s,A);return Cs(t,e)}var Ie={},Bs=function(s,A,t,e,i){var n=new Worker(Ie[A]||(Ie[A]=URL.createObjectURL(new Blob([s+\';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})\'],{type:"text/javascript"}))));return n.onmessage=function(g){var r=g.data,I=r.$e$;if(I){var o=new Error(I[0]);o.code=I[1],o.stack=I[2],i(o,null)}else i(null,r)},n.postMessage(t,e),n},V=Uint8Array,JA=Uint16Array,oe=Int32Array,Mt=new V([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),dt=new V([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),ae=new V([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Ce=function(s,A){for(var t=new JA(31),e=0;e<31;++e)t[e]=A+=1<<s[e-1];for(var i=new oe(t[30]),e=1;e<30;++e)for(var n=t[e];n<t[e+1];++n)i[n]=n-t[e]<<5|e;return{b:t,r:i}},Be=Ce(Mt,2),Nt=Be.b,Qs=Be.r;Nt[28]=258,Qs[258]=28;for(var hs=Ce(dt,0),Qe=hs.b,It=new JA(32768),X=0;X<32768;++X){var dA=(X&43690)>>1|(X&21845)<<1;dA=(dA&52428)>>2|(dA&13107)<<2,dA=(dA&61680)>>4|(dA&3855)<<4,It[X]=((dA&65280)>>8|(dA&255)<<8)>>1}for(var TA=function(s,A,t){for(var e=s.length,i=0,n=new JA(A);i<e;++i)s[i]&&++n[s[i]-1];var g=new JA(A);for(i=1;i<A;++i)g[i]=g[i-1]+n[i-1]<<1;var r;if(t){r=new JA(1<<A);var I=15-A;for(i=0;i<e;++i)if(s[i])for(var o=i<<4|s[i],a=A-s[i],C=g[s[i]-1]++<<a,Q=C|(1<<a)-1;C<=Q;++C)r[It[C]>>I]=o}else for(r=new JA(e),i=0;i<e;++i)s[i]&&(r[i]=It[g[s[i]-1]++]>>15-s[i]);return r},$A=new V(288),X=0;X<144;++X)$A[X]=8;for(var X=144;X<256;++X)$A[X]=9;for(var X=256;X<280;++X)$A[X]=7;for(var X=280;X<288;++X)$A[X]=8;for(var he=new V(32),X=0;X<32;++X)he[X]=5;var Ee=TA($A,9,1),ce=TA(he,5,1),ot=function(s){for(var A=s[0],t=1;t<s.length;++t)s[t]>A&&(A=s[t]);return A},QA=function(s,A,t){var e=A/8|0;return(s[e]|s[e+1]<<8)>>(A&7)&t},at=function(s,A){var t=A/8|0;return(s[t]|s[t+1]<<8|s[t+2]<<16)>>(A&7)},kt=function(s){return(s+7)/8|0},NA=function(s,A,t){return(A==null||A<0)&&(A=0),(t==null||t>s.length)&&(t=s.length),new V(s.subarray(A,t))},le=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],O=function(s,A,t){var e=new Error(A||le[s]);if(e.code=s,Error.captureStackTrace&&Error.captureStackTrace(e,O),!t)throw e;return e},Gt=function(s,A,t,e){var i=s.length,n=e?e.length:0;if(!i||A.f&&!A.l)return t||new V(0);var g=!t,r=g||A.i!=2,I=A.i;g&&(t=new V(i*3));var o=function(rA){var aA=t.length;if(rA>aA){var CA=new V(Math.max(aA*2,rA));CA.set(t),t=CA}},a=A.f||0,C=A.p||0,Q=A.b||0,B=A.l,h=A.d,u=A.m,E=A.n,c=i*8;do{if(!B){a=QA(s,C,1);var f=QA(s,C+1,3);if(C+=3,f)if(f==1)B=Ee,h=ce,u=9,E=5;else if(f==2){var Y=QA(s,C,31)+257,N=QA(s,C+10,15)+4,m=Y+QA(s,C+5,31)+1;C+=14;for(var w=new V(m),R=new V(19),D=0;D<N;++D)R[ae[D]]=QA(s,C+D*3,7);C+=N*3;for(var p=ot(R),F=(1<<p)-1,S=TA(R,p,1),D=0;D<m;){var _=S[QA(s,C,F)];C+=_&15;var l=_>>4;if(l<16)w[D++]=l;else{var k=0,T=0;for(l==16?(T=3+QA(s,C,3),C+=2,k=w[D-1]):l==17?(T=3+QA(s,C,7),C+=3):l==18&&(T=11+QA(s,C,127),C+=7);T--;)w[D++]=k}}var K=w.subarray(0,Y),v=w.subarray(Y);u=ot(K),E=ot(v),B=TA(K,u,1),h=TA(v,E,1)}else O(1);else{var l=kt(C)+4,y=s[l-4]|s[l-3]<<8,x=l+y;if(x>i){I&&O(0);break}r&&o(Q+y),t.set(s.subarray(l,x),Q),A.b=Q+=y,A.p=C=x*8,A.f=a;continue}if(C>c){I&&O(0);break}}r&&o(Q+131072);for(var P=(1<<u)-1,Z=(1<<E)-1,W=C;;W=C){var k=B[at(s,C)&P],z=k>>4;if(C+=k&15,C>c){I&&O(0);break}if(k||O(2),z<256)t[Q++]=z;else if(z==256){W=C,B=null;break}else{var q=z-254;if(z>264){var D=z-257,J=Mt[D];q=QA(s,C,(1<<J)-1)+Nt[D],C+=J}var b=h[at(s,C)&Z],M=b>>4;b||O(3),C+=b&15;var v=Qe[M];if(M>3){var J=dt[M];v+=at(s,C)&(1<<J)-1,C+=J}if(C>c){I&&O(0);break}r&&o(Q+131072);var sA=Q+q;if(Q<v){var iA=n-v,oA=Math.min(v,sA);for(iA+Q<0&&O(3);Q<oA;++Q)t[Q]=e[iA+Q]}for(;Q<sA;++Q)t[Q]=t[Q-v]}}A.l=B,A.p=W,A.b=Q,A.f=a,B&&(a=1,A.m=u,A.d=h,A.n=E)}while(!a);return Q!=t.length&&g?NA(t,0,Q):t.subarray(0,Q)},Es=new V(0),cs=function(s,A){var t={};for(var e in s)t[e]=s[e];for(var e in A)t[e]=A[e];return t},ue=function(s,A,t){for(var e=s(),i=s.toString(),n=i.slice(i.indexOf("[")+1,i.lastIndexOf("]")).replace(/\\s+/g,"").split(","),g=0;g<e.length;++g){var r=e[g],I=n[g];if(typeof r=="function"){A+=";"+I+"=";var o=r.toString();if(r.prototype)if(o.indexOf("[native code]")!=-1){var a=o.indexOf(" ",8)+1;A+=o.slice(a,o.indexOf("(",a))}else{A+=o;for(var C in r.prototype)A+=";"+I+".prototype."+C+"="+r.prototype[C].toString()}else A+=o}else t[I]=r}return A},Ct=[],ls=function(s){var A=[];for(var t in s)s[t].buffer&&A.push((s[t]=new s[t].constructor(s[t])).buffer);return A},us=function(s,A,t,e){if(!Ct[t]){for(var i="",n={},g=s.length-1,r=0;r<g;++r)i=ue(s[r],i,n);Ct[t]={c:ue(s[g],i,n),e:n}}var I=cs({},Ct[t].e);return Bs(Ct[t].c+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+A.toString()+"}",t,I,ls(I),e)},fs=function(){return[V,JA,oe,Mt,dt,ae,Nt,Qe,Ee,ce,It,le,TA,ot,QA,at,kt,NA,O,Gt,Bt,fe,ye]},fe=function(s){return postMessage(s,[s.buffer])},ye=function(s){return s&&{out:s.size&&new V(s.size),dictionary:s.dictionary}},ys=function(s,A,t,e,i,n){var g=us(t,e,i,function(r,I){g.terminate(),n(r,I)});return g.postMessage([s,A],A.consume?[s.buffer]:[]),function(){g.terminate()}},uA=function(s,A){return s[A]|s[A+1]<<8},tA=function(s,A){return(s[A]|s[A+1]<<8|s[A+2]<<16|s[A+3]<<24)>>>0},Ut=function(s,A){return tA(s,A)+tA(s,A+4)*4294967296},ws=function(s){(s[0]!=31||s[1]!=139||s[2]!=8)&&O(6,"invalid gzip data");var A=s[3],t=10;A&4&&(t+=(s[10]|s[11]<<8)+2);for(var e=(A>>3&1)+(A>>4&1);e>0;e-=!s[t++]);return t+(A&2)},Yt=function(){function s(A,t){typeof A=="function"&&(t=A,A={}),this.ondata=t;var e=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:e?e.length:0},this.o=new V(32768),this.p=new V(0),e&&this.o.set(e)}return s.prototype.e=function(A){if(this.ondata||O(5),this.d&&O(4),!this.p.length)this.p=A;else if(A.length){var t=new V(this.p.length+A.length);t.set(this.p),t.set(A,this.p.length),this.p=t}},s.prototype.c=function(A){this.s.i=+(this.d=A||!1);var t=this.s.b,e=Gt(this.p,this.s,this.o);this.ondata(NA(e,t,this.s.b),this.d),this.o=NA(e,this.s.b-32768),this.s.b=this.o.length,this.p=NA(this.p,this.s.p/8|0),this.s.p&=7},s.prototype.push=function(A,t){this.e(A),this.c(t)},s}();function ms(s,A,t){return t||(t=A,A={}),typeof t!="function"&&O(7),ys(s,A,[fs],function(e){return fe(Bt(e.data[0],ye(e.data[1])))},1,t)}function Bt(s,A){return Gt(s,{i:2},A&&A.out,A&&A.dictionary)}var we=function(){function s(A,t){this.v=1,this.r=0,Yt.call(this,A,t)}return s.prototype.push=function(A,t){if(Yt.prototype.e.call(this,A),this.r+=A.length,this.v){var e=this.p.subarray(this.v-1),i=e.length>3?ws(e):4;if(i>e.length){if(!t)return}else this.v>1&&this.onmember&&this.onmember(this.r-e.length);this.p=e.subarray(i),this.v=0}Yt.prototype.c.call(this,t),this.s.f&&!this.s.l&&!t&&(this.v=kt(this.s.p)+9,this.s={i:0},this.o=new V(0),this.push(new V(0),t))},s}(),Rt=typeof TextDecoder<"u"&&new TextDecoder;try{Rt.decode(Es,{stream:!0})}catch{}var ps=function(s){for(var A="",t=0;;){var e=s[t++],i=(e>127)+(e>223)+(e>239);if(t+i>s.length)return{s:A,r:NA(s,t-1)};i?i==3?(e=((e&15)<<18|(s[t++]&63)<<12|(s[t++]&63)<<6|s[t++]&63)-65536,A+=String.fromCharCode(55296|e>>10,56320|e&1023)):i&1?A+=String.fromCharCode((e&31)<<6|s[t++]&63):A+=String.fromCharCode((e&15)<<12|(s[t++]&63)<<6|s[t++]&63):A+=String.fromCharCode(e)}};function xs(s,A){if(A){for(var t="",e=0;e<s.length;e+=16384)t+=String.fromCharCode.apply(null,s.subarray(e,e+16384));return t}else{if(Rt)return Rt.decode(s);var i=ps(s),n=i.s,t=i.r;return t.length&&O(8),n}}var me=function(s,A){return A+30+uA(s,A+26)+uA(s,A+28)},pe=function(s,A,t){var e=uA(s,A+28),i=xs(s.subarray(A+46,A+46+e),!(uA(s,A+8)&2048)),n=A+46+e,g=tA(s,A+20),r=t&&g==4294967295?Ds(s,n):[g,tA(s,A+24),tA(s,A+42)],I=r[0],o=r[1],a=r[2];return[uA(s,A+10),I,o,i,n+uA(s,A+30)+uA(s,A+32),a]},Ds=function(s,A){for(;uA(s,A)!=1;A+=4+uA(s,A+2));return[Ut(s,A+12),Ut(s,A+4),Ut(s,A+20)]},xe=typeof queueMicrotask=="function"?queueMicrotask:typeof setTimeout=="function"?setTimeout:function(s){s()};function Ss(s,A,t){t||(t=A,A={}),typeof t!="function"&&O(7);var e=[],i=function(){for(var E=0;E<e.length;++E)e[E]()},n={},g=function(E,c){xe(function(){t(E,c)})};xe(function(){g=t});for(var r=s.length-22;tA(s,r)!=101010256;--r)if(!r||s.length-r>65558)return g(O(13,0,1),null),i;var I=uA(s,r+8);if(I){var o=I,a=tA(s,r+16),C=a==4294967295||o==65535;if(C){var Q=tA(s,r-12);C=tA(s,Q)==101075792,C&&(o=I=tA(s,Q+32),a=tA(s,Q+48))}for(var B=A&&A.filter,h=function(E){var c=pe(s,a,C),f=c[0],l=c[1],y=c[2],x=c[3],Y=c[4],N=c[5],m=me(s,N);a=Y;var w=function(D,p){D?(i(),g(D,null)):(p&&(n[x]=p),--I||g(null,n))};if(!B||B({name:x,size:l,originalSize:y,compression:f}))if(!f)w(null,NA(s,m,m+l));else if(f==8){var R=s.subarray(m,m+l);if(y<524288||l>.8*y)try{w(null,Bt(R,{out:new V(y)}))}catch(D){w(D,null)}else e.push(ms(R,{size:y},w))}else w(O(14,"unknown compression type "+f,1),null);else w(null,null)},u=0;u<o;++u)h(u)}else g(null,{});return i}function Fs(s,A){for(var t={},e=s.length-22;tA(s,e)!=101010256;--e)(!e||s.length-e>65558)&&O(13);var i=uA(s,e+8);if(!i)return{};var n=tA(s,e+16),g=n==4294967295||i==65535;if(g){var r=tA(s,e-12);g=tA(s,r)==101075792,g&&(i=tA(s,r+32),n=tA(s,r+48))}for(var I=A&&A.filter,o=0;o<i;++o){var a=pe(s,n,g),C=a[0],Q=a[1],B=a[2],h=a[3],u=a[4],E=a[5],c=me(s,E);n=u,(!I||I({name:h,size:Q,originalSize:B,compression:C}))&&(C?C==8?t[h]=Bt(s.subarray(c,c+Q),{out:new V(B)}):O(14,"unknown compression type "+C):t[h]=NA(s,c,c+Q))}return t}/**\n * @license\n * Copyright 2010-2025 Three.js Authors\n * SPDX-License-Identifier: MIT\n */const De="178",Ms="",fA="srgb",Se="srgb-linear",Fe="linear",_t="srgb";function IA(s,A,t){return Math.max(A,Math.min(t,s))}function ds(s,A){return(s%A+A)%A}function bt(s,A,t){return(1-t)*s+t*A}class kA{constructor(A=0,t=0,e=0,i=1){this.isQuaternion=!0,this._x=A,this._y=t,this._z=e,this._w=i}static slerpFlat(A,t,e,i,n,g,r){let I=e[i+0],o=e[i+1],a=e[i+2],C=e[i+3];const Q=n[g+0],B=n[g+1],h=n[g+2],u=n[g+3];if(r===0){A[t+0]=I,A[t+1]=o,A[t+2]=a,A[t+3]=C;return}if(r===1){A[t+0]=Q,A[t+1]=B,A[t+2]=h,A[t+3]=u;return}if(C!==u||I!==Q||o!==B||a!==h){let E=1-r;const c=I*Q+o*B+a*h+C*u,f=c>=0?1:-1,l=1-c*c;if(l>Number.EPSILON){const x=Math.sqrt(l),Y=Math.atan2(x,c*f);E=Math.sin(E*Y)/x,r=Math.sin(r*Y)/x}const y=r*f;if(I=I*E+Q*y,o=o*E+B*y,a=a*E+h*y,C=C*E+u*y,E===1-r){const x=1/Math.sqrt(I*I+o*o+a*a+C*C);I*=x,o*=x,a*=x,C*=x}}A[t]=I,A[t+1]=o,A[t+2]=a,A[t+3]=C}static multiplyQuaternionsFlat(A,t,e,i,n,g){const r=e[i],I=e[i+1],o=e[i+2],a=e[i+3],C=n[g],Q=n[g+1],B=n[g+2],h=n[g+3];return A[t]=r*h+a*C+I*B-o*Q,A[t+1]=I*h+a*Q+o*C-r*B,A[t+2]=o*h+a*B+r*Q-I*C,A[t+3]=a*h-r*C-I*Q-o*B,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,t,e,i){return this._x=A,this._y=t,this._z=e,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,t=!0){const e=A._x,i=A._y,n=A._z,g=A._order,r=Math.cos,I=Math.sin,o=r(e/2),a=r(i/2),C=r(n/2),Q=I(e/2),B=I(i/2),h=I(n/2);switch(g){case"XYZ":this._x=Q*a*C+o*B*h,this._y=o*B*C-Q*a*h,this._z=o*a*h+Q*B*C,this._w=o*a*C-Q*B*h;break;case"YXZ":this._x=Q*a*C+o*B*h,this._y=o*B*C-Q*a*h,this._z=o*a*h-Q*B*C,this._w=o*a*C+Q*B*h;break;case"ZXY":this._x=Q*a*C-o*B*h,this._y=o*B*C+Q*a*h,this._z=o*a*h+Q*B*C,this._w=o*a*C-Q*B*h;break;case"ZYX":this._x=Q*a*C-o*B*h,this._y=o*B*C+Q*a*h,this._z=o*a*h-Q*B*C,this._w=o*a*C+Q*B*h;break;case"YZX":this._x=Q*a*C+o*B*h,this._y=o*B*C+Q*a*h,this._z=o*a*h-Q*B*C,this._w=o*a*C-Q*B*h;break;case"XZY":this._x=Q*a*C-o*B*h,this._y=o*B*C-Q*a*h,this._z=o*a*h+Q*B*C,this._w=o*a*C+Q*B*h;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+g)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(A,t){const e=t/2,i=Math.sin(e);return this._x=A.x*i,this._y=A.y*i,this._z=A.z*i,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(A){const t=A.elements,e=t[0],i=t[4],n=t[8],g=t[1],r=t[5],I=t[9],o=t[2],a=t[6],C=t[10],Q=e+r+C;if(Q>0){const B=.5/Math.sqrt(Q+1);this._w=.25/B,this._x=(a-I)*B,this._y=(n-o)*B,this._z=(g-i)*B}else if(e>r&&e>C){const B=2*Math.sqrt(1+e-r-C);this._w=(a-I)/B,this._x=.25*B,this._y=(i+g)/B,this._z=(n+o)/B}else if(r>C){const B=2*Math.sqrt(1+r-e-C);this._w=(n-o)/B,this._x=(i+g)/B,this._y=.25*B,this._z=(I+a)/B}else{const B=2*Math.sqrt(1+C-e-r);this._w=(g-i)/B,this._x=(n+o)/B,this._y=(I+a)/B,this._z=.25*B}return this._onChangeCallback(),this}setFromUnitVectors(A,t){let e=A.dot(t)+1;return e<1e-8?(e=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=e):(this._x=0,this._y=-A.z,this._z=A.y,this._w=e)):(this._x=A.y*t.z-A.z*t.y,this._y=A.z*t.x-A.x*t.z,this._z=A.x*t.y-A.y*t.x,this._w=e),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs(IA(this.dot(A),-1,1)))}rotateTowards(A,t){const e=this.angleTo(A);if(e===0)return this;const i=Math.min(1,t/e);return this.slerp(A,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,t){const e=A._x,i=A._y,n=A._z,g=A._w,r=t._x,I=t._y,o=t._z,a=t._w;return this._x=e*a+g*r+i*o-n*I,this._y=i*a+g*I+n*r-e*o,this._z=n*a+g*o+e*I-i*r,this._w=g*a-e*r-i*I-n*o,this._onChangeCallback(),this}slerp(A,t){if(t===0)return this;if(t===1)return this.copy(A);const e=this._x,i=this._y,n=this._z,g=this._w;let r=g*A._w+e*A._x+i*A._y+n*A._z;if(r<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,r=-r):this.copy(A),r>=1)return this._w=g,this._x=e,this._y=i,this._z=n,this;const I=1-r*r;if(I<=Number.EPSILON){const B=1-t;return this._w=B*g+t*this._w,this._x=B*e+t*this._x,this._y=B*i+t*this._y,this._z=B*n+t*this._z,this.normalize(),this}const o=Math.sqrt(I),a=Math.atan2(o,r),C=Math.sin((1-t)*a)/o,Q=Math.sin(t*a)/o;return this._w=g*C+this._w*Q,this._x=e*C+this._x*Q,this._y=i*C+this._y*Q,this._z=n*C+this._z*Q,this._onChangeCallback(),this}slerpQuaternions(A,t,e){return this.copy(A).slerp(t,e)}random(){const A=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),e=Math.random(),i=Math.sqrt(1-e),n=Math.sqrt(e);return this.set(i*Math.sin(A),i*Math.cos(A),n*Math.sin(t),n*Math.cos(t))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,t=0){return this._x=A[t],this._y=A[t+1],this._z=A[t+2],this._w=A[t+3],this._onChangeCallback(),this}toArray(A=[],t=0){return A[t]=this._x,A[t+1]=this._y,A[t+2]=this._z,A[t+3]=this._w,A}fromBufferAttribute(A,t){return this._x=A.getX(t),this._y=A.getY(t),this._z=A.getZ(t),this._w=A.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class d{constructor(A=0,t=0,e=0){d.prototype.isVector3=!0,this.x=A,this.y=t,this.z=e}set(A,t,e){return e===void 0&&(e=this.z),this.x=A,this.y=t,this.z=e,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,t){switch(A){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,t){return this.x=A.x+t.x,this.y=A.y+t.y,this.z=A.z+t.z,this}addScaledVector(A,t){return this.x+=A.x*t,this.y+=A.y*t,this.z+=A.z*t,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,t){return this.x=A.x-t.x,this.y=A.y-t.y,this.z=A.z-t.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,t){return this.x=A.x*t.x,this.y=A.y*t.y,this.z=A.z*t.z,this}applyEuler(A){return this.applyQuaternion(Me.setFromEuler(A))}applyAxisAngle(A,t){return this.applyQuaternion(Me.setFromAxisAngle(A,t))}applyMatrix3(A){const t=this.x,e=this.y,i=this.z,n=A.elements;return this.x=n[0]*t+n[3]*e+n[6]*i,this.y=n[1]*t+n[4]*e+n[7]*i,this.z=n[2]*t+n[5]*e+n[8]*i,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const t=this.x,e=this.y,i=this.z,n=A.elements,g=1/(n[3]*t+n[7]*e+n[11]*i+n[15]);return this.x=(n[0]*t+n[4]*e+n[8]*i+n[12])*g,this.y=(n[1]*t+n[5]*e+n[9]*i+n[13])*g,this.z=(n[2]*t+n[6]*e+n[10]*i+n[14])*g,this}applyQuaternion(A){const t=this.x,e=this.y,i=this.z,n=A.x,g=A.y,r=A.z,I=A.w,o=2*(g*i-r*e),a=2*(r*t-n*i),C=2*(n*e-g*t);return this.x=t+I*o+g*C-r*a,this.y=e+I*a+r*o-n*C,this.z=i+I*C+n*a-g*o,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const t=this.x,e=this.y,i=this.z,n=A.elements;return this.x=n[0]*t+n[4]*e+n[8]*i,this.y=n[1]*t+n[5]*e+n[9]*i,this.z=n[2]*t+n[6]*e+n[10]*i,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,t){return this.x=IA(this.x,A.x,t.x),this.y=IA(this.y,A.y,t.y),this.z=IA(this.z,A.z,t.z),this}clampScalar(A,t){return this.x=IA(this.x,A,t),this.y=IA(this.y,A,t),this.z=IA(this.z,A,t),this}clampLength(A,t){const e=this.length();return this.divideScalar(e||1).multiplyScalar(IA(e,A,t))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,t){return this.x+=(A.x-this.x)*t,this.y+=(A.y-this.y)*t,this.z+=(A.z-this.z)*t,this}lerpVectors(A,t,e){return this.x=A.x+(t.x-A.x)*e,this.y=A.y+(t.y-A.y)*e,this.z=A.z+(t.z-A.z)*e,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,t){const e=A.x,i=A.y,n=A.z,g=t.x,r=t.y,I=t.z;return this.x=i*I-n*r,this.y=n*g-e*I,this.z=e*r-i*g,this}projectOnVector(A){const t=A.lengthSq();if(t===0)return this.set(0,0,0);const e=A.dot(this)/t;return this.copy(A).multiplyScalar(e)}projectOnPlane(A){return Jt.copy(this).projectOnVector(A),this.sub(Jt)}reflect(A){return this.sub(Jt.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const t=Math.sqrt(this.lengthSq()*A.lengthSq());if(t===0)return Math.PI/2;const e=this.dot(A)/t;return Math.acos(IA(e,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const t=this.x-A.x,e=this.y-A.y,i=this.z-A.z;return t*t+e*e+i*i}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,t,e){const i=Math.sin(t)*A;return this.x=i*Math.sin(e),this.y=Math.cos(t)*A,this.z=i*Math.cos(e),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,t,e){return this.x=A*Math.sin(t),this.y=e,this.z=A*Math.cos(t),this}setFromMatrixPosition(A){const t=A.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(A){const t=this.setFromMatrixColumn(A,0).length(),e=this.setFromMatrixColumn(A,1).length(),i=this.setFromMatrixColumn(A,2).length();return this.x=t,this.y=e,this.z=i,this}setFromMatrixColumn(A,t){return this.fromArray(A.elements,t*4)}setFromMatrix3Column(A,t){return this.fromArray(A.elements,t*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}setFromColor(A){return this.x=A.r,this.y=A.g,this.z=A.b,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,t=0){return this.x=A[t],this.y=A[t+1],this.z=A[t+2],this}toArray(A=[],t=0){return A[t]=this.x,A[t+1]=this.y,A[t+2]=this.z,A}fromBufferAttribute(A,t){return this.x=A.getX(t),this.y=A.getY(t),this.z=A.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=Math.random()*Math.PI*2,t=Math.random()*2-1,e=Math.sqrt(1-t*t);return this.x=e*Math.cos(A),this.y=t,this.z=e*Math.sin(A),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const Jt=new d,Me=new kA;class At{constructor(A,t,e,i,n,g,r,I,o){At.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],A!==void 0&&this.set(A,t,e,i,n,g,r,I,o)}set(A,t,e,i,n,g,r,I,o){const a=this.elements;return a[0]=A,a[1]=i,a[2]=r,a[3]=t,a[4]=n,a[5]=I,a[6]=e,a[7]=g,a[8]=o,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const t=this.elements,e=A.elements;return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],this}extractBasis(A,t,e){return A.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),e.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const t=A.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,t){const e=A.elements,i=t.elements,n=this.elements,g=e[0],r=e[3],I=e[6],o=e[1],a=e[4],C=e[7],Q=e[2],B=e[5],h=e[8],u=i[0],E=i[3],c=i[6],f=i[1],l=i[4],y=i[7],x=i[2],Y=i[5],N=i[8];return n[0]=g*u+r*f+I*x,n[3]=g*E+r*l+I*Y,n[6]=g*c+r*y+I*N,n[1]=o*u+a*f+C*x,n[4]=o*E+a*l+C*Y,n[7]=o*c+a*y+C*N,n[2]=Q*u+B*f+h*x,n[5]=Q*E+B*l+h*Y,n[8]=Q*c+B*y+h*N,this}multiplyScalar(A){const t=this.elements;return t[0]*=A,t[3]*=A,t[6]*=A,t[1]*=A,t[4]*=A,t[7]*=A,t[2]*=A,t[5]*=A,t[8]*=A,this}determinant(){const A=this.elements,t=A[0],e=A[1],i=A[2],n=A[3],g=A[4],r=A[5],I=A[6],o=A[7],a=A[8];return t*g*a-t*r*o-e*n*a+e*r*I+i*n*o-i*g*I}invert(){const A=this.elements,t=A[0],e=A[1],i=A[2],n=A[3],g=A[4],r=A[5],I=A[6],o=A[7],a=A[8],C=a*g-r*o,Q=r*I-a*n,B=o*n-g*I,h=t*C+e*Q+i*B;if(h===0)return this.set(0,0,0,0,0,0,0,0,0);const u=1/h;return A[0]=C*u,A[1]=(i*o-a*e)*u,A[2]=(r*e-i*g)*u,A[3]=Q*u,A[4]=(a*t-i*I)*u,A[5]=(i*n-r*t)*u,A[6]=B*u,A[7]=(e*I-o*t)*u,A[8]=(g*t-e*n)*u,this}transpose(){let A;const t=this.elements;return A=t[1],t[1]=t[3],t[3]=A,A=t[2],t[2]=t[6],t[6]=A,A=t[5],t[5]=t[7],t[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const t=this.elements;return A[0]=t[0],A[1]=t[3],A[2]=t[6],A[3]=t[1],A[4]=t[4],A[5]=t[7],A[6]=t[2],A[7]=t[5],A[8]=t[8],this}setUvTransform(A,t,e,i,n,g,r){const I=Math.cos(n),o=Math.sin(n);return this.set(e*I,e*o,-e*(I*g+o*r)+g+A,-i*o,i*I,-i*(-o*g+I*r)+r+t,0,0,1),this}scale(A,t){return this.premultiply(Lt.makeScale(A,t)),this}rotate(A){return this.premultiply(Lt.makeRotation(-A)),this}translate(A,t){return this.premultiply(Lt.makeTranslation(A,t)),this}makeTranslation(A,t){return A.isVector2?this.set(1,0,A.x,0,1,A.y,0,0,1):this.set(1,0,A,0,1,t,0,0,1),this}makeRotation(A){const t=Math.cos(A),e=Math.sin(A);return this.set(t,-e,0,e,t,0,0,0,1),this}makeScale(A,t){return this.set(A,0,0,0,t,0,0,0,1),this}equals(A){const t=this.elements,e=A.elements;for(let i=0;i<9;i++)if(t[i]!==e[i])return!1;return!0}fromArray(A,t=0){for(let e=0;e<9;e++)this.elements[e]=A[e+t];return this}toArray(A=[],t=0){const e=this.elements;return A[t]=e[0],A[t+1]=e[1],A[t+2]=e[2],A[t+3]=e[3],A[t+4]=e[4],A[t+5]=e[5],A[t+6]=e[6],A[t+7]=e[7],A[t+8]=e[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const Lt=new At,de={};function Ne(s){s in de||(de[s]=!0,console.warn(s))}const ke=new At().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),Ge=new At().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function Ns(){const s={enabled:!0,workingColorSpace:Se,spaces:{},convert:function(i,n,g){return this.enabled===!1||n===g||!n||!g||(this.spaces[n].transfer===_t&&(i.r=vA(i.r),i.g=vA(i.g),i.b=vA(i.b)),this.spaces[n].primaries!==this.spaces[g].primaries&&(i.applyMatrix3(this.spaces[n].toXYZ),i.applyMatrix3(this.spaces[g].fromXYZ)),this.spaces[g].transfer===_t&&(i.r=qA(i.r),i.g=qA(i.g),i.b=qA(i.b))),i},workingToColorSpace:function(i,n){return this.convert(i,this.workingColorSpace,n)},colorSpaceToWorking:function(i,n){return this.convert(i,n,this.workingColorSpace)},getPrimaries:function(i){return this.spaces[i].primaries},getTransfer:function(i){return i===Ms?Fe:this.spaces[i].transfer},getLuminanceCoefficients:function(i,n=this.workingColorSpace){return i.fromArray(this.spaces[n].luminanceCoefficients)},define:function(i){Object.assign(this.spaces,i)},_getMatrix:function(i,n,g){return i.copy(this.spaces[n].toXYZ).multiply(this.spaces[g].fromXYZ)},_getDrawingBufferColorSpace:function(i){return this.spaces[i].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(i=this.workingColorSpace){return this.spaces[i].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(i,n){return Ne("THREE.ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),s.workingToColorSpace(i,n)},toWorkingColorSpace:function(i,n){return Ne("THREE.ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),s.colorSpaceToWorking(i,n)}},A=[.64,.33,.3,.6,.15,.06],t=[.2126,.7152,.0722],e=[.3127,.329];return s.define({[Se]:{primaries:A,whitePoint:e,transfer:Fe,toXYZ:ke,fromXYZ:Ge,luminanceCoefficients:t,workingColorSpaceConfig:{unpackColorSpace:fA},outputColorSpaceConfig:{drawingBufferColorSpace:fA}},[fA]:{primaries:A,whitePoint:e,transfer:_t,toXYZ:ke,fromXYZ:Ge,luminanceCoefficients:t,outputColorSpaceConfig:{drawingBufferColorSpace:fA}}}),s}const yA=Ns();function vA(s){return s<.04045?s*.0773993808:Math.pow(s*.9478672986+.0521327014,2.4)}function qA(s){return s<.0031308?s*12.92:1.055*Math.pow(s,.41666)-.055}class Ue{constructor(A=new d(1/0,1/0,1/0),t=new d(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=t}set(A,t){return this.min.copy(A),this.max.copy(t),this}setFromArray(A){this.makeEmpty();for(let t=0,e=A.length;t<e;t+=3)this.expandByPoint(wA.fromArray(A,t));return this}setFromBufferAttribute(A){this.makeEmpty();for(let t=0,e=A.count;t<e;t++)this.expandByPoint(wA.fromBufferAttribute(A,t));return this}setFromPoints(A){this.makeEmpty();for(let t=0,e=A.length;t<e;t++)this.expandByPoint(A[t]);return this}setFromCenterAndSize(A,t){const e=wA.copy(t).multiplyScalar(.5);return this.min.copy(A).sub(e),this.max.copy(A).add(e),this}setFromObject(A,t=!1){return this.makeEmpty(),this.expandByObject(A,t)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,t=!1){A.updateWorldMatrix(!1,!1);const e=A.geometry;if(e!==void 0){const n=e.getAttribute("position");if(t===!0&&n!==void 0&&A.isInstancedMesh!==!0)for(let g=0,r=n.count;g<r;g++)A.isMesh===!0?A.getVertexPosition(g,wA):wA.fromBufferAttribute(n,g),wA.applyMatrix4(A.matrixWorld),this.expandByPoint(wA);else A.boundingBox!==void 0?(A.boundingBox===null&&A.computeBoundingBox(),Qt.copy(A.boundingBox)):(e.boundingBox===null&&e.computeBoundingBox(),Qt.copy(e.boundingBox)),Qt.applyMatrix4(A.matrixWorld),this.union(Qt)}const i=A.children;for(let n=0,g=i.length;n<g;n++)this.expandByObject(i[n],t);return this}containsPoint(A){return A.x>=this.min.x&&A.x<=this.max.x&&A.y>=this.min.y&&A.y<=this.max.y&&A.z>=this.min.z&&A.z<=this.max.z}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,t){return t.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return A.max.x>=this.min.x&&A.min.x<=this.max.x&&A.max.y>=this.min.y&&A.min.y<=this.max.y&&A.max.z>=this.min.z&&A.min.z<=this.max.z}intersectsSphere(A){return this.clampPoint(A.center,wA),wA.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let t,e;return A.normal.x>0?(t=A.normal.x*this.min.x,e=A.normal.x*this.max.x):(t=A.normal.x*this.max.x,e=A.normal.x*this.min.x),A.normal.y>0?(t+=A.normal.y*this.min.y,e+=A.normal.y*this.max.y):(t+=A.normal.y*this.max.y,e+=A.normal.y*this.min.y),A.normal.z>0?(t+=A.normal.z*this.min.z,e+=A.normal.z*this.max.z):(t+=A.normal.z*this.max.z,e+=A.normal.z*this.min.z),t<=-A.constant&&e>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(tt),ht.subVectors(this.max,tt),KA.subVectors(A.a,tt),ZA.subVectors(A.b,tt),XA.subVectors(A.c,tt),GA.subVectors(ZA,KA),UA.subVectors(XA,ZA),LA.subVectors(KA,XA);let t=[0,-GA.z,GA.y,0,-UA.z,UA.y,0,-LA.z,LA.y,GA.z,0,-GA.x,UA.z,0,-UA.x,LA.z,0,-LA.x,-GA.y,GA.x,0,-UA.y,UA.x,0,-LA.y,LA.x,0];return!zt(t,KA,ZA,XA,ht)||(t=[1,0,0,0,1,0,0,0,1],!zt(t,KA,ZA,XA,ht))?!1:(Et.crossVectors(GA,UA),t=[Et.x,Et.y,Et.z],zt(t,KA,ZA,XA,ht))}clampPoint(A,t){return t.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,wA).distanceTo(A)}getBoundingSphere(A){return this.isEmpty()?A.makeEmpty():(this.getCenter(A.center),A.radius=this.getSize(wA).length()*.5),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(FA[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),FA[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),FA[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),FA[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),FA[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),FA[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),FA[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),FA[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(FA),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(A){return this.min.fromArray(A.min),this.max.fromArray(A.max),this}}const FA=[new d,new d,new d,new d,new d,new d,new d,new d],wA=new d,Qt=new Ue,KA=new d,ZA=new d,XA=new d,GA=new d,UA=new d,LA=new d,tt=new d,ht=new d,Et=new d,zA=new d;function zt(s,A,t,e,i){for(let n=0,g=s.length-3;n<=g;n+=3){zA.fromArray(s,n);const r=i.x*Math.abs(zA.x)+i.y*Math.abs(zA.y)+i.z*Math.abs(zA.z),I=A.dot(zA),o=t.dot(zA),a=e.dot(zA);if(Math.max(-Math.max(I,o,a),Math.min(I,o,a))>r)return!1}return!0}const Ye={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},YA={h:0,s:0,l:0},ct={h:0,s:0,l:0};function Ht(s,A,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?s+(A-s)*6*t:t<1/2?A:t<2/3?s+(A-s)*6*(2/3-t):s}class Tt{constructor(A,t,e){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(A,t,e)}set(A,t,e){if(t===void 0&&e===void 0){const i=A;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(A,t,e);return this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,t=fA){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,yA.colorSpaceToWorking(this,t),this}setRGB(A,t,e,i=yA.workingColorSpace){return this.r=A,this.g=t,this.b=e,yA.colorSpaceToWorking(this,i),this}setHSL(A,t,e,i=yA.workingColorSpace){if(A=ds(A,1),t=IA(t,0,1),e=IA(e,0,1),t===0)this.r=this.g=this.b=e;else{const n=e<=.5?e*(1+t):e+t-e*t,g=2*e-n;this.r=Ht(g,n,A+1/3),this.g=Ht(g,n,A),this.b=Ht(g,n,A-1/3)}return yA.colorSpaceToWorking(this,i),this}setStyle(A,t=fA){function e(n){n!==void 0&&parseFloat(n)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let i;if(i=/^(\\w+)\\(([^\\)]*)\\)/.exec(A)){let n;const g=i[1],r=i[2];switch(g){case"rgb":case"rgba":if(n=/^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(r))return e(n[4]),this.setRGB(Math.min(255,parseInt(n[1],10))/255,Math.min(255,parseInt(n[2],10))/255,Math.min(255,parseInt(n[3],10))/255,t);if(n=/^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(r))return e(n[4]),this.setRGB(Math.min(100,parseInt(n[1],10))/100,Math.min(100,parseInt(n[2],10))/100,Math.min(100,parseInt(n[3],10))/100,t);break;case"hsl":case"hsla":if(n=/^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(r))return e(n[4]),this.setHSL(parseFloat(n[1])/360,parseFloat(n[2])/100,parseFloat(n[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(i=/^\\#([A-Fa-f\\d]+)$/.exec(A)){const n=i[1],g=n.length;if(g===3)return this.setRGB(parseInt(n.charAt(0),16)/15,parseInt(n.charAt(1),16)/15,parseInt(n.charAt(2),16)/15,t);if(g===6)return this.setHex(parseInt(n,16),t);console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,t);return this}setColorName(A,t=fA){const e=Ye[A.toLowerCase()];return e!==void 0?this.setHex(e,t):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=vA(A.r),this.g=vA(A.g),this.b=vA(A.b),this}copyLinearToSRGB(A){return this.r=qA(A.r),this.g=qA(A.g),this.b=qA(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=fA){return yA.workingToColorSpace(eA.copy(this),A),Math.round(IA(eA.r*255,0,255))*65536+Math.round(IA(eA.g*255,0,255))*256+Math.round(IA(eA.b*255,0,255))}getHexString(A=fA){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,t=yA.workingColorSpace){yA.workingToColorSpace(eA.copy(this),t);const e=eA.r,i=eA.g,n=eA.b,g=Math.max(e,i,n),r=Math.min(e,i,n);let I,o;const a=(r+g)/2;if(r===g)I=0,o=0;else{const C=g-r;switch(o=a<=.5?C/(g+r):C/(2-g-r),g){case e:I=(i-n)/C+(i<n?6:0);break;case i:I=(n-e)/C+2;break;case n:I=(e-i)/C+4;break}I/=6}return A.h=I,A.s=o,A.l=a,A}getRGB(A,t=yA.workingColorSpace){return yA.workingToColorSpace(eA.copy(this),t),A.r=eA.r,A.g=eA.g,A.b=eA.b,A}getStyle(A=fA){yA.workingToColorSpace(eA.copy(this),A);const t=eA.r,e=eA.g,i=eA.b;return A!==fA?`color(${A} ${t.toFixed(3)} ${e.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(e*255)},${Math.round(i*255)})`}offsetHSL(A,t,e){return this.getHSL(YA),this.setHSL(YA.h+A,YA.s+t,YA.l+e)}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,t){return this.r=A.r+t.r,this.g=A.g+t.g,this.b=A.b+t.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,t){return this.r+=(A.r-this.r)*t,this.g+=(A.g-this.g)*t,this.b+=(A.b-this.b)*t,this}lerpColors(A,t,e){return this.r=A.r+(t.r-A.r)*e,this.g=A.g+(t.g-A.g)*e,this.b=A.b+(t.b-A.b)*e,this}lerpHSL(A,t){this.getHSL(YA),A.getHSL(ct);const e=bt(YA.h,ct.h,t),i=bt(YA.s,ct.s,t),n=bt(YA.l,ct.l,t);return this.setHSL(e,i,n),this}setFromVector3(A){return this.r=A.x,this.g=A.y,this.b=A.z,this}applyMatrix3(A){const t=this.r,e=this.g,i=this.b,n=A.elements;return this.r=n[0]*t+n[3]*e+n[6]*i,this.g=n[1]*t+n[4]*e+n[7]*i,this.b=n[2]*t+n[5]*e+n[8]*i,this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,t=0){return this.r=A[t],this.g=A[t+1],this.b=A[t+2],this}toArray(A=[],t=0){return A[t]=this.r,A[t+1]=this.g,A[t+2]=this.b,A}fromBufferAttribute(A,t){return this.r=A.getX(t),this.g=A.getY(t),this.b=A.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const eA=new Tt;Tt.NAMES=Ye,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:De}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=De);const Re=-12,_e=9,WA=Math.exp(-30),ks=11,Gs=11,be=1<<ks,Je=1<<Gs,Le=1;function Us(s){var n;let A=!1;const t=s.split(`\n`).map(g=>{const r=g.trimEnd();return A?r:r.length>0?(A=!0,r):null}).filter(g=>g!=null);for(;t.length>0&&t[t.length-1].length===0;)t.pop();if(t.length===0)return[];const e=(n=t[0].match(/^\\s*/))==null?void 0:n[0];if(!e)return t;const i=new RegExp(`^${e}`);return t.map(g=>g.replace(i,""))}function Ys(s){return Us(s).join(`\n`)}const vt=new Float32Array(1),ze=new Uint32Array(vt.buffer),qt="Float16Array"in globalThis,et=qt?new globalThis.Float16Array(1):null,He=new Uint16Array(et==null?void 0:et.buffer);function Rs(s){const A=Math.sqrt(s.reduce((t,e)=>t+e*e,0));return s.map(t=>t/A)}const PA=qt?_s:bs,$=qt?Js:Ls;function _s(s){return et[0]=s,He[0]}function bs(s){vt[0]=s;const A=ze[0],t=A>>31&1,e=A>>23&255,i=A&8388607,n=t<<15;if(e===255)return i!==0?n|32767:n|31744;const g=e-127+15;if(g>=31)return n|31744;if(g<=0){if(g<-10)return n;const I=(i|8388608)>>1-g+13;return n|I}const r=i>>13;return n|g<<10|r}function Js(s){return He[0]=s,et[0]}function Ls(s){const A=s>>15&1,t=s>>10&31,e=s&1023;let i;if(t===0)if(e===0)i=A<<31;else{let n=e,g=-14;for(;(n&1024)===0;)n<<=1,g--;n&=1023;const r=g+127,I=n<<13;i=A<<31|r<<23|I}else if(t===31)e===0?i=A<<31|2139095040:i=A<<31|2143289344;else{const n=t-15+127,g=e<<13;i=A<<31|n<<23|g}return ze[0]=i,vt[0]}function hA(s){return Math.max(0,Math.min(255,Math.round(s*255)))}function zs(s){const A=[],t=new Set;function e(i){i&&typeof i=="object"&&!t.has(i)&&(t.add(i),i instanceof ArrayBuffer?A.push(i):ArrayBuffer.isView(i)?A.push(i.buffer):Array.isArray(i)?i.forEach(e):Object.values(i).forEach(e))}return e(s),A}function Kt(s,A,t,e,i,n,g,r,I,o,a,C,Q,B,h,u,E){const c=(E==null?void 0:E.rgbMin)??0,l=((E==null?void 0:E.rgbMax)??1)-c,y=hA((B-c)/l),x=hA((h-c)/l),Y=hA((u-c)/l),N=hA(Q),m=Xe(qe.set(I,o,a,C)),w=m&255,R=m>>>8&255,D=m>>>16&255,p=(E==null?void 0:E.lnScaleMin)??Re,S=254/(((E==null?void 0:E.lnScaleMax)??_e)-p),_=n<WA?0:Math.min(255,Math.max(1,Math.round((Math.log(n)-p)*S)+1)),k=g<WA?0:Math.min(255,Math.max(1,Math.round((Math.log(g)-p)*S)+1)),T=r<WA?0:Math.min(255,Math.max(1,Math.round((Math.log(r)-p)*S)+1)),K=PA(t),v=PA(e),P=PA(i),Z=A*4;s[Z]=y|x<<8|Y<<16|N<<24,s[Z+1]=K|v<<16,s[Z+2]=P|w<<16|R<<24,s[Z+3]=_|k<<8|T<<16|D<<24}function Te(s,A,t,e,i){const n=PA(t),g=PA(e),r=PA(i),I=A*4;s[I+1]=n|g<<16,s[I+2]=r|s[I+2]&4294901760}function ve(s,A,t,e,i,n){const g=(n==null?void 0:n.lnScaleMin)??Re,I=254/(((n==null?void 0:n.lnScaleMax)??_e)-g),o=t<WA?0:Math.min(255,Math.max(1,Math.round((Math.log(t)-g)*I)+1)),a=e<WA?0:Math.min(255,Math.max(1,Math.round((Math.log(e)-g)*I)+1)),C=i<WA?0:Math.min(255,Math.max(1,Math.round((Math.log(i)-g)*I)+1)),Q=A*4;s[Q+3]=o|a<<8|C<<16|s[Q+3]&4278190080}const qe=new kA;function Ke(s,A,t,e,i,n){const g=Xe(qe.set(t,e,i,n)),r=g&255,I=g>>>8&255,o=g>>>16&255,a=A*4;s[a+2]=s[a+2]&65535|r<<16|I<<24,s[a+3]=s[a+3]&16777215|o<<24}function Hs(s,A,t,e,i,n,g){const r=(g==null?void 0:g.rgbMin)??0,o=((g==null?void 0:g.rgbMax)??1)-r,a=hA((t-r)/o),C=hA((e-r)/o),Q=hA((i-r)/o),B=hA(n),h=A*4;s[h]=a|C<<8|Q<<16|B<<24}function Ts(s,A,t,e,i,n){const g=(n==null?void 0:n.rgbMin)??0,I=((n==null?void 0:n.rgbMax)??1)-g,o=hA((t-g)/I),a=hA((e-g)/I),C=hA((i-g)/I),Q=A*4;s[Q]=o|a<<8|C<<16|s[Q]&4278190080}function vs(s,A,t){const e=hA(t),i=A*4;s[i]=s[i]&16777215|e<<24}new d,new d,new Tt;function qs(s){const A=be,t=Math.max(Le,Math.min(Je,Math.ceil(s/A))),e=Math.ceil(s/(A*t)),i=A*t*e;return{width:A,height:t,depth:e,maxSplats:i}}function lt(s){const A=be,t=Math.max(Le,Math.min(Je,Math.ceil(s/A))),e=Math.ceil(s/(A*t));return A*t*e}Ys(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);const Ks=new kA,Ze=new d;function Xe(s){const A=Ks.copy(s).normalize();A.w<0&&A.set(-A.x,-A.y,-A.z,-A.w);const t=2*Math.acos(A.w),e=Math.sqrt(A.x*A.x+A.y*A.y+A.z*A.z),i=e<1e-6?Ze.set(1,0,0):Ze.set(A.x,A.y,A.z).divideScalar(e),n=Math.abs(i.x)+Math.abs(i.y)+Math.abs(i.z);let g=i.x/n,r=i.y/n;if(i.z<0){const B=g;g=(1-Math.abs(r))*(g>=0?1:-1),r=(1-Math.abs(B))*(r>=0?1:-1)}const I=g*.5+.5,o=r*.5+.5,a=Math.round(I*255),C=Math.round(o*255);return Math.round(t*(255/Math.PI))<<16|C<<8|a}function ut(s,A,t,e){const i=Math.max(-127,Math.min(127,s*127)),n=Math.max(-127,Math.min(127,A*127)),g=Math.max(-127,Math.min(127,t*127)),r=Math.max(-127,Math.min(127,e*127));return i&255|(n&255)<<8|(g&255)<<16|(r&255)<<24}function ft(s,A,t,e){const i=(e==null?void 0:e.sh1Min)??-1,n=(e==null?void 0:e.sh1Max)??1,g=.5*(i+n),r=126/(n-i),I=A*2;for(let o=0;o<9;++o){const a=(t[o]-g)*r,C=Math.round(Math.max(-63,Math.min(63,a)))&127,Q=o*7,B=Q+7,h=Math.floor(Q/32),u=Q-h*32,E=C<<u&4294967295;if(s[I+h]|=E,B>h*32+32){const c=C>>>32-u&4294967295;s[I+h+1]|=c}}}function yt(s,A,t,e){const i=(e==null?void 0:e.sh2Min)??-1,n=(e==null?void 0:e.sh2Max)??1,g=.5*(i+n),r=2/(n-i);s[A*4+0]=ut((t[0]-g)*r,(t[1]-g)*r,(t[2]-g)*r,(t[3]-g)*r),s[A*4+1]=ut((t[4]-g)*r,(t[5]-g)*r,(t[6]-g)*r,(t[7]-g)*r),s[A*4+2]=ut((t[8]-g)*r,(t[9]-g)*r,(t[10]-g)*r,(t[11]-g)*r),s[A*4+3]=ut((t[12]-g)*r,(t[13]-g)*r,(t[14]-g)*r,0)}function wt(s,A,t,e){const i=(e==null?void 0:e.sh3Min)??-1,n=(e==null?void 0:e.sh3Max)??1,g=.5*(i+n),r=62/(n-i),I=A*4;for(let o=0;o<21;++o){const a=(t[o]-g)*r,C=Math.round(Math.max(-31,Math.min(31,a)))&63,Q=o*6,B=Q+6,h=Math.floor(Q/32),u=Q-h*32,E=C<<u&4294967295;if(s[I+h]|=E,B>h*32+32){const c=C>>>32-u&4294967295;s[I+h+1]|=c}}}function Zs(s,A){const t=[];let e=0,i=null;const n=new we((I,o)=>{if(t.push(I),e+=I.length,o||e>=A){const a=new Uint8Array(e);let C=0;for(const Q of t)a.set(Q,C),C+=Q.length;i=a.slice(0,A)}}),g=1024;let r=0;for(;i==null&&r<s.length;){const I=s.slice(r,r+g);n.push(I,!1),r+=g}if(i==null&&(n.push(new Uint8Array,!0),i==null))throw new Error("Failed to decompress partial gzip");return i}class Xs{constructor({fileBytes:A,chunkBytes:t=64*1024}){this.fileBytes=A,this.chunkBytes=t,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new we((e,i)=>{this.chunks.push(e),this.totalBytes+=e.length})}read(A){for(;this.totalBytes<A&&this.offset<this.fileBytes.length;){const n=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,n),!1),this.offset=n}if(this.totalBytes<A&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<A)throw new Error(`Unexpected EOF: needed ${A}, got ${this.totalBytes}`);const t=new Uint8Array(this.totalBytes);let e=0;for(const n of this.chunks)t.set(n,e),e+=n.length;const i=t.subarray(0,A);return this.chunks=[t.subarray(A)],this.totalBytes-=A,i}}function We(s,A,t){const e=Math.floor(s.length/32);if(e*32!==s.length)throw new Error("Invalid .splat file size");A(e);const i=new Float32Array(s.buffer);for(let n=0;n<e;++n){const g=n*32,r=n*8,I=i[r+0],o=i[r+1],a=i[r+2],C=i[r+3],Q=i[r+4],B=i[r+5],h=s[g+24]/255,u=s[g+25]/255,E=s[g+26]/255,c=s[g+27]/255,f=(s[g+28]-128)/128,l=(s[g+29]-128)/128,y=(s[g+30]-128)/128,x=(s[g+31]-128)/128;t(n,I,o,a,C,Q,B,l,y,x,f,c,h,u,E)}}function Ws(s,A){let t=0,e=0,i=new Uint32Array(0);return We(s,n=>{t=n,e=lt(t),i=new Uint32Array(e*4)},(n,g,r,I,o,a,C,Q,B,h,u,E,c,f,l)=>{Kt(i,n,g,r,I,o,a,C,Q,B,h,u,E,c,f,l,A)}),{packedArray:i,numSplats:t}}const mt={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},Pe={0:0,1:9,2:24,3:45};function Ps(s,A,t,e){var u;let g=0;const r=new DataView(s.buffer,g,4096);g+=4096;const I=r.getUint8(0),o=r.getUint8(1);if(I!==0||o<1)throw new Error(`Unsupported .ksplat version: ${I}.${o}`);const a=r.getUint32(4,!0);r.getUint32(16,!0);const C=r.getUint16(20,!0);if(C<0||C>2)throw new Error(`Invalid .ksplat compression level: ${C}`);const Q=r.getFloat32(36,!0)||-1.5,B=r.getFloat32(40,!0)||1.5;let h=4096+a*1024;for(let E=0;E<a;++E){let c=function(gA,U){if(C===0)return G.getFloat32(gA+J+U*4,!0);if(C===1)return $(G.getUint16(gA+J+U*2,!0));const lA=G.getUint8(gA+J+U)/255;return Q+lA*(B-Q)};const f=new DataView(s.buffer,g,1024);g+=1024;const l=f.getUint32(0,!0),y=f.getUint32(4,!0),x=f.getUint32(8,!0),Y=f.getUint32(12,!0),N=f.getFloat32(16,!0),m=f.getUint16(20,!0),w=(f.getUint32(24,!0)||((u=mt[C])==null?void 0:u.scaleRange))??1,R=f.getUint32(32,!0),D=R*x,p=f.getUint32(36,!0),F=p*4,S=m*Y+F,_=f.getUint16(40,!0),k=Pe[_],{bytesPerCenter:T,bytesPerScale:K,bytesPerRotation:v,bytesPerColor:P,bytesPerSphericalHarmonicsComponent:Z,scaleOffsetBytes:W,rotationOffsetBytes:z,colorOffsetBytes:q,sphericalHarmonicsOffsetBytes:J}=mt[C],b=T+K+v+P+k*Z,M=b*y,sA=M+S,iA=[0,3,6,1,4,7,2,5,8],oA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],rA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],aA=_>=1?new Float32Array(3*3):void 0,CA=_>=2?new Float32Array(5*3):void 0,MA=_>=3?new Float32Array(7*3):void 0,BA=N/2/w,EA=h+F,cA=h+S,G=new DataView(s.buffer,cA,M),nA=new Float32Array(s.buffer,EA,Y*3),j=new Uint32Array(s.buffer,h,p);let H=R,_A=D;for(let gA=0;gA<l;++gA){const U=gA*b;let lA;if(gA<D)lA=Math.floor(gA/x);else{const SA=j[H-R];gA>=_A+SA&&(H+=1,_A+=SA),lA=H}const AA=C===0?G.getFloat32(U+0,!0):(G.getUint16(U+0,!0)-w)*BA+nA[3*lA+0],L=C===0?G.getFloat32(U+4,!0):(G.getUint16(U+2,!0)-w)*BA+nA[3*lA+1],pA=C===0?G.getFloat32(U+8,!0):(G.getUint16(U+4,!0)-w)*BA+nA[3*lA+2],nt=C===0?G.getFloat32(U+W+0,!0):$(G.getUint16(U+W+0,!0)),gt=C===0?G.getFloat32(U+W+4,!0):$(G.getUint16(U+W+2,!0)),Ot=C===0?G.getFloat32(U+W+8,!0):$(G.getUint16(U+W+4,!0)),jt=C===0?G.getFloat32(U+z+0,!0):$(G.getUint16(U+z+0,!0)),$t=C===0?G.getFloat32(U+z+4,!0):$(G.getUint16(U+z+2,!0)),Ae=C===0?G.getFloat32(U+z+8,!0):$(G.getUint16(U+z+4,!0)),te=C===0?G.getFloat32(U+z+12,!0):$(G.getUint16(U+z+6,!0)),ee=G.getUint8(U+q+0)/255,se=G.getUint8(U+q+1)/255,ie=G.getUint8(U+q+2)/255,ne=G.getUint8(U+q+3)/255;if(t(gA,AA,L,pA,nt,gt,Ot,$t,Ae,te,jt,ne,ee,se,ie),_>=1&&aA){for(const[SA,HA]of iA.entries())aA[SA]=c(U,HA);if(CA)for(const[SA,HA]of oA.entries())CA[SA]=c(U,HA);if(MA)for(const[SA,HA]of rA.entries())MA[SA]=c(U,HA);e==null||e(gA,aA,CA,MA)}}h+=sA}}function Vs(s,A){var f;let i=0;const n=new DataView(s.buffer,i,4096);i+=4096;const g=n.getUint8(0),r=n.getUint8(1);if(g!==0||r<1)throw new Error(`Unsupported .ksplat version: ${g}.${r}`);const I=n.getUint32(4,!0),o=n.getUint32(16,!0),a=n.getUint16(20,!0);if(a<0||a>2)throw new Error(`Invalid .ksplat compression level: ${a}`);const C=n.getFloat32(36,!0)||-1.5,Q=n.getFloat32(40,!0)||1.5,B=o,h=lt(B),u=new Uint32Array(h*4),E={};let c=4096+I*1024;for(let l=0;l<I;++l){let y=function(AA,L){if(a===0)return H.getFloat32(AA+sA+L*4,!0);if(a===1)return $(H.getUint16(AA+sA+L*2,!0));const pA=H.getUint8(AA+sA+L)/255;return C+pA*(Q-C)};const x=new DataView(s.buffer,i,1024);i+=1024;const Y=x.getUint32(0,!0),N=x.getUint32(4,!0),m=x.getUint32(8,!0),w=x.getUint32(12,!0),R=x.getFloat32(16,!0),D=x.getUint16(20,!0),p=(x.getUint32(24,!0)||((f=mt[a])==null?void 0:f.scaleRange))??1,F=x.getUint32(32,!0),S=F*m,_=x.getUint32(36,!0),k=_*4,T=D*w+k,K=x.getUint16(40,!0),v=Pe[K],{bytesPerCenter:P,bytesPerScale:Z,bytesPerRotation:W,bytesPerColor:z,bytesPerSphericalHarmonicsComponent:q,scaleOffsetBytes:J,rotationOffsetBytes:b,colorOffsetBytes:M,sphericalHarmonicsOffsetBytes:sA}=mt[a],iA=P+Z+W+z+v*q,oA=iA*N,rA=oA+T,aA=[0,3,6,1,4,7,2,5,8],CA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],MA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],BA=K>=1?new Float32Array(3*3):void 0,EA=K>=2?new Float32Array(5*3):void 0,cA=K>=3?new Float32Array(7*3):void 0,G=R/2/p,nA=c+k,j=c+T,H=new DataView(s.buffer,j,oA),_A=new Float32Array(s.buffer,nA,w*3),gA=new Uint32Array(s.buffer,c,_);let U=F,lA=S;for(let AA=0;AA<Y;++AA){const L=AA*iA;let pA;if(AA<S)pA=Math.floor(AA/m);else{const bA=gA[U-F];AA>=lA+bA&&(U+=1,lA+=bA),pA=U}const nt=a===0?H.getFloat32(L+0,!0):(H.getUint16(L+0,!0)-p)*G+_A[3*pA+0],gt=a===0?H.getFloat32(L+4,!0):(H.getUint16(L+2,!0)-p)*G+_A[3*pA+1],Ot=a===0?H.getFloat32(L+8,!0):(H.getUint16(L+4,!0)-p)*G+_A[3*pA+2],jt=a===0?H.getFloat32(L+J+0,!0):$(H.getUint16(L+J+0,!0)),$t=a===0?H.getFloat32(L+J+4,!0):$(H.getUint16(L+J+2,!0)),Ae=a===0?H.getFloat32(L+J+8,!0):$(H.getUint16(L+J+4,!0)),te=a===0?H.getFloat32(L+b+0,!0):$(H.getUint16(L+b+0,!0)),ee=a===0?H.getFloat32(L+b+4,!0):$(H.getUint16(L+b+2,!0)),se=a===0?H.getFloat32(L+b+8,!0):$(H.getUint16(L+b+4,!0)),ie=a===0?H.getFloat32(L+b+12,!0):$(H.getUint16(L+b+6,!0)),ne=H.getUint8(L+M+0)/255,SA=H.getUint8(L+M+1)/255,HA=H.getUint8(L+M+2)/255,yi=H.getUint8(L+M+3)/255;if(Kt(u,AA,nt,gt,Ot,jt,$t,Ae,ee,se,ie,te,yi,ne,SA,HA,A),K>=1){if(BA){E.sh1||(E.sh1=new Uint32Array(B*2));for(const[bA,rt]of aA.entries())BA[bA]=y(L,rt);ft(E.sh1,AA,BA,A)}if(EA){E.sh2||(E.sh2=new Uint32Array(B*4));for(const[bA,rt]of CA.entries())EA[bA]=y(L,rt);yt(E.sh2,AA,EA,A)}if(cA){E.sh3||(E.sh3=new Uint32Array(B*4));for(const[bA,rt]of MA.entries())cA[bA]=y(L,rt);wt(E.sh3,AA,cA,A)}}}c+=rA}return{packedArray:u,numSplats:B,extra:E}}const Ve=["char","uchar","short","ushort","int","uint","float","double"],OA=class OA{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const t=new ReadableStream({start:g=>{g.enqueue(this.fileBytes.slice(0,65536)),g.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const e=`end_header\n`;for(;;){const{value:g,done:r}=await t.read();if(r)throw new Error("Failed to read header");this.header+=g;const I=this.header.indexOf(e);if(I>=0){this.header=this.header.slice(0,I+e.length);break}}const i=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,i),this.elements={};let n=null;this.comments=[],this.header.trim().split(`\n`).forEach((g,r)=>{const I=g.trim();if(r===0){if(I!=="ply")throw new Error("Invalid PLY header");return}if(I.length===0)return;const o=I.split(" ");switch(o[0]){case"format":if(o[1]==="binary_little_endian")this.littleEndian=!0;else if(o[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${o[1]}`);if(o[2]!=="1.0")throw new Error(`Unsupported PLY version: ${o[2]}`);break;case"end_header":break;case"comment":this.comments.push(I.slice(8));break;case"element":{const a=o[1];n={name:a,count:Number.parseInt(o[2]),properties:{}},this.elements[a]=n;break}case"property":if(n==null)throw new Error("Property must be inside an element");o[1]==="list"?n.properties[o[4]]={isList:!0,type:o[3],countType:o[2]}:n.properties[o[2]]={isList:!1,type:o[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let t=0;const e=this.data;if(e==null)throw new Error("No data to parse");for(const i in this.elements){const n=this.elements[i],{count:g,properties:r}=n,I=$s(r),o=Ai(r,this.littleEndian),a=A(n)??(()=>{});for(let C=0;C<g;C++)t=o(e,t,I),a(C,I)}}parseSplats(A,t){if(this.elements.vertex==null)throw new Error("No vertex element found");let e=!1;const i=[];let n=0,g=[],r=[],I=[],o,a,C;function Q(){const c=js[n];g=new Array(3).fill(null).flatMap((f,l)=>[0,1,2].map((y,x)=>l+x*c/3)),r=new Array(5).fill(null).flatMap((f,l)=>[0,1,2].map((y,x)=>3+l+x*c/3)),I=new Array(7).fill(null).flatMap((f,l)=>[0,1,2].map((y,x)=>8+l+x*c/3)),o=n>=1?new Float32Array(3*3):void 0,a=n>=2?new Float32Array(5*3):void 0,C=n>=3?new Float32Array(7*3):void 0}function B(c,f){if(!o)throw new Error("Missing sh1");const l=f.f_rest;for(let y=0;y<g.length;y++)o[y]=l[g[y]]*8/255-4;if(a)for(let y=0;y<r.length;y++)a[y]=l[r[y]]*8/255-4;if(C)for(let y=0;y<I.length;y++)C[y]=l[I[y]]*8/255-4;t==null||t(c,o,a,C)}function h(c){const{min_x:f,min_y:l,min_z:y,max_x:x,max_y:Y,max_z:N,min_scale_x:m,min_scale_y:w,min_scale_z:R,max_scale_x:D,max_scale_y:p,max_scale_z:F}=c.properties;if(!f||!l||!y||!x||!Y||!N||!m||!w||!R||!D||!p||!F)throw new Error("Missing PLY chunk properties");return e=!0,(S,_)=>{const{min_x:k,min_y:T,min_z:K,max_x:v,max_y:P,max_z:Z,min_scale_x:W,min_scale_y:z,min_scale_z:q,max_scale_x:J,max_scale_y:b,max_scale_z:M,min_r:sA,min_g:iA,min_b:oA,max_r:rA,max_g:aA,max_b:CA}=_;i.push({min_x:k,min_y:T,min_z:K,max_x:v,max_y:P,max_z:Z,min_scale_x:W,min_scale_y:z,min_scale_z:q,max_scale_x:J,max_scale_y:b,max_scale_z:M,min_r:sA,min_g:iA,min_b:oA,max_r:rA,max_g:aA,max_b:CA})}}function u(c){if(t&&c.name==="sh")return n=Xt(c.properties),Q(),B;if(c.name!=="vertex")return null;const{packed_position:f,packed_rotation:l,packed_scale:y,packed_color:x}=c.properties;if(!f||!l||!y||!x)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const Y=Math.sqrt(2);return(N,m)=>{const w=i[N>>>8];if(w==null)throw new Error("Missing PLY chunk");const{min_x:R,min_y:D,min_z:p,max_x:F,max_y:S,max_z:_,min_scale_x:k,min_scale_y:T,min_scale_z:K,max_scale_x:v,max_scale_y:P,max_scale_z:Z,min_r:W,min_g:z,min_b:q,max_r:J,max_g:b,max_b:M}=w,{packed_position:sA,packed_rotation:iA,packed_scale:oA,packed_color:rA}=m,aA=(sA>>>21&2047)/2047*(F-R)+R,CA=(sA>>>11&1023)/1023*(S-D)+D,MA=(sA&2047)/2047*(_-p)+p,BA=((iA>>>20&1023)/1023-.5)*Y,EA=((iA>>>10&1023)/1023-.5)*Y,cA=((iA&1023)/1023-.5)*Y,G=Math.sqrt(Math.max(0,1-BA*BA-EA*EA-cA*cA)),nA=iA>>>30,j=nA===0?BA:nA===1?G:EA,H=nA<=1?EA:nA===2?G:cA,_A=nA<=2?cA:G,gA=nA===0?G:BA,U=Math.exp((oA>>>21&2047)/2047*(v-k)+k),lA=Math.exp((oA>>>11&1023)/1023*(P-T)+T),AA=Math.exp((oA&2047)/2047*(Z-K)+K),L=(rA>>>24&255)/255*((J??1)-(W??0))+(W??0),pA=(rA>>>16&255)/255*((b??1)-(z??0))+(z??0),nt=(rA>>>8&255)/255*((M??1)-(q??0))+(q??0),gt=(rA&255)/255;A(N,aA,CA,MA,U,lA,AA,j,H,_A,gA,gt,L,pA,nt)}}const E=c=>{if(c.name==="chunk")return h(c);if(e)return u(c);if(c.name!=="vertex")return null;const{x:f,y:l,z:y,scale_0:x,scale_1:Y,scale_2:N,rot_0:m,rot_1:w,rot_2:R,rot_3:D,opacity:p,f_dc_0:F,f_dc_1:S,f_dc_2:_,red:k,green:T,blue:K,alpha:v}=c.properties;if(!f||!l||!y)throw new Error("Missing PLY properties: x, y, z");const P=x&&Y&&N,Z=m&&w&&R&&D,W=v!=null?Dt[v.type]:1,z=k!=null?Dt[k.type]:1,q=T!=null?Dt[T.type]:1,J=K!=null?Dt[K.type]:1;return n=Xt(c.properties),Q(),(b,M)=>{const sA=P?Math.exp(M.scale_0):OA.defaultPointScale,iA=P?Math.exp(M.scale_1):OA.defaultPointScale,oA=P?Math.exp(M.scale_2):OA.defaultPointScale,rA=Z?M.rot_1:0,aA=Z?M.rot_2:0,CA=Z?M.rot_3:0,MA=Z?M.rot_0:1,BA=p!=null?1/(1+Math.exp(-M.opacity)):v!=null?M.alpha/W:1,EA=F!=null?M.f_dc_0*xt+.5:k!=null?M.red/z:1,cA=S!=null?M.f_dc_1*xt+.5:T!=null?M.green/q:1,G=_!=null?M.f_dc_2*xt+.5:K!=null?M.blue/J:1;if(A(b,M.x,M.y,M.z,sA,iA,oA,rA,aA,CA,MA,BA,EA,cA,G),t&&o){const nA=M.f_rest;if(o)for(let j=0;j<g.length;j++)o[j]=nA[g[j]];if(a)for(let j=0;j<r.length;j++)a[j]=nA[r[j]];if(C)for(let j=0;j<I.length;j++)C[j]=nA[I[j]];t(b,o,a,C)}}};this.parseData(E)}injectRgba(A){let t=0;const e=this.data;if(e==null)throw new Error("No parsed data");if(A.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const i in this.elements){const n=this.elements[i],{count:g,properties:r}=n,I=[];let o=0;const a=i==="vertex";if(a){for(const C of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!r[C]||r[C].type!=="float")throw new Error(`Can\'t injectRgba due to property: ${C}`)}for(const[C,Q]of Object.entries(r))if(Q.isList)I.push(()=>{const B=VA[Q.countType](e,t,this.littleEndian);t+=mA[Q.countType],t+=B*mA[Q.type]});else{if(a)if(C==="f_dc_0"||C==="f_dc_1"||C==="f_dc_2"){const B=Number.parseInt(C.slice(5));I.push(()=>{const h=(A[o+B]/255-.5)/xt;Oe[Q.type](e,t,this.littleEndian,h)})}else C==="opacity"&&I.push(()=>{const B=Math.max(-100,Math.min(100,-Math.log(1/(A[o+3]/255)-1)));Oe[Q.type](e,t,this.littleEndian,B)});I.push(()=>{t+=mA[Q.type]})}for(let C=0;C<g;C++){for(const Q of I)Q();a&&(o+=4)}}}};OA.defaultPointScale=.001;let pt=OA;const xt=.28209479177387814,VA={char:(s,A,t)=>s.getInt8(A),uchar:(s,A,t)=>s.getUint8(A),short:(s,A,t)=>s.getInt16(A,t),ushort:(s,A,t)=>s.getUint16(A,t),int:(s,A,t)=>s.getInt32(A,t),uint:(s,A,t)=>s.getUint32(A,t),float:(s,A,t)=>s.getFloat32(A,t),double:(s,A,t)=>s.getFloat64(A,t)},Oe={char:(s,A,t,e)=>{s.setInt8(A,e)},uchar:(s,A,t,e)=>{s.setUint8(A,e)},short:(s,A,t,e)=>{s.setInt16(A,e,t)},ushort:(s,A,t,e)=>{s.setUint16(A,e,t)},int:(s,A,t,e)=>{s.setInt32(A,e,t)},uint:(s,A,t,e)=>{s.setUint32(A,e,t)},float:(s,A,t,e)=>{s.setFloat32(A,e,t)},double:(s,A,t,e)=>{s.setFloat64(A,e,t)}},mA={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},Dt={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},Os={0:0,9:1,24:2,45:3},js={0:0,1:9,2:24,3:45},Zt=/^f_rest_([0-9]{1,2})$/;function $s(s){const A={};for(const[t,e]of Object.entries(s))Zt.test(t)?A.f_rest=new Array(Xt(s)):A[t]=e.isList?[]:0;return A}function Ai(s,A){return si(s)?ii(s,A):ni(s,A)}const ti=(()=>{try{new Function("return 42;")}catch{return!1}return!0})(),ei=/^[a-zA-Z0-9_]+$/;function si(s){if(!ti)return!1;for(const[A,t]of Object.entries(s))if(!ei.test(A)||t.isList&&!Ve.includes(t.countType)||!Ve.includes(t.type))return!1;return!0}function ii(s,A){const t=["let list;"];for(const[i,n]of Object.entries(s)){const g=i.match(Zt);if(g){const r=+g[1];t.push(`\n        item.f_rest[${r}] = PARSE_FIELD[\'${n.type}\'](data, offset, ${A});\n        offset += ${mA[n.type]};\n      `)}else n.isList?t.push(`\n        list = item[\'${i}\'];\n        list.length = PARSE_FIELD[\'${n.countType}\'](data, offset, ${A});\n        offset += ${mA[n.countType]};\n        for (let i = 0; i < list.length; i++) {\n          list[i] = PARSE_FIELD[\'${n.type}\'](data, offset, ${A});\n          offset += ${mA[n.type]};\n        }\n      `):t.push(`\n        item[\'${i}\'] = PARSE_FIELD[\'${n.type}\'](data, offset, ${A});\n        offset += ${mA[n.type]};\n      `)}t.push("return offset;");const e=new Function("data","offset","item","PARSE_FIELD",t.join(`\n`));return(i,n,g)=>e(i,n,g,VA)}function ni(s,A){const t=[];for(const[e,i]of Object.entries(s)){const n=e.match(Zt);if(n){const g=+n[1];t.push((r,I,o)=>(o.f_rest[g]=VA[i.type](r,I,A),I+mA[i.type]))}else i.isList?t.push((g,r,I)=>{const o=I[e];o.length=VA[i.countType](g,r,A);let a=r+mA[i.countType];for(let C=0;C<o.length;C++)o[C]=VA[i.type](g,a,A),a+=mA[i.type];return a}):t.push((g,r,I)=>(I[e]=VA[i.type](g,r,A),r+mA[i.type]))}return(e,i,n)=>{let g=i;for(let r=0;r<t.length;r++)g=t[r](e,g,n);return g}}function Xt(s){let A=0;for(;s[`f_rest_${A}`];)A+=1;const t=Os[A];if(t==null)throw new Error(`Unsupported number of SH coefficients: ${A}`);return t}var st=(s=>(s.PLY="ply",s.SPZ="spz",s.SPLAT="splat",s.KSPLAT="ksplat",s.PCSOGS="pcsogs",s.PCSOGSZIP="pcsogszip",s))(st||{});function gi(s){const A=new DataView(s.buffer);if((A.getUint32(0,!0)&16777215)===7957616)return"ply";if((A.getUint32(0,!0)&16777215)===559903){const t=Zs(s,4);return new DataView(t.buffer).getUint32(0,!0)===1347635022?"spz":void 0}if(A.getUint32(0,!0)===67324752)return je(s)?"pcsogszip":void 0}function ri(s){const A=s.split(/[?#]/,1)[0],t=Math.max(A.lastIndexOf("/"),A.lastIndexOf("\\\\")),e=A.slice(t+1),i=e.lastIndexOf(".");return i<=0||i===e.length-1?"":e.slice(i+1).toLowerCase()}function Ii(s){const A=ri(s);if(A==="ply")return"ply";if(A==="spz")return"spz";if(A==="splat")return"splat";if(A==="ksplat")return"ksplat"}function oi(s){try{let A;if(typeof s=="string")A=s;else{const e=s instanceof ArrayBuffer?new Uint8Array(s):s;if(e.length>65536)return;A=new TextDecoder().decode(e)}const t=JSON.parse(A);if(!t||typeof t!="object"||Array.isArray(t))return;for(const e of["means","scales","quats","sh0"])if(!t[e]||typeof t[e]!="object"||Array.isArray(t[e])||!t[e].shape||!t[e].files||e!=="quats"&&(!t[e].mins||!t[e].maxs))return;return t}catch{return}}function je(s){try{const A=s instanceof ArrayBuffer?new Uint8Array(s):s;let t=null;const e=Fs(A,{filter:({name:n})=>n.split(/[\\\\/]/).pop()==="meta.json"?(t=n,!0):!1});if(!t)return;const i=oi(e[t]);return i?{name:t,json:i}:void 0}catch{return}}class ai{constructor({maxSplats:A=1}={}){this.numSplats=0,this.maxSplats=qs(A).maxSplats,this.centers=new Float32Array(this.maxSplats*3),this.scales=new Float32Array(this.maxSplats*3),this.quaternions=new Float32Array(this.maxSplats*4),this.opacities=new Float32Array(this.maxSplats),this.colors=new Float32Array(this.maxSplats*3)}pushSplat(){const A=this.numSplats;return this.ensureIndex(A),this.numSplats+=1,A}unpushSplat(A){if(A===this.numSplats-1)this.numSplats-=1;else throw new Error("Cannot unpush splat from non-last position")}ensureCapacity(A){if(A>this.maxSplats){const t=Math.max(A,this.maxSplats*2),e=new Float32Array(t*3),i=new Float32Array(t*3),n=new Float32Array(t*4),g=new Float32Array(t),r=new Float32Array(t*3);if(e.set(this.centers),i.set(this.scales),n.set(this.quaternions),g.set(this.opacities),r.set(this.colors),this.centers=e,this.scales=i,this.quaternions=n,this.opacities=g,this.colors=r,this.sh1){const I=new Float32Array(t*9);I.set(this.sh1),this.sh1=I}if(this.sh2){const I=new Float32Array(t*15);I.set(this.sh2),this.sh2=I}if(this.sh3){const I=new Float32Array(t*21);I.set(this.sh3),this.sh3=I}this.maxSplats=t}}ensureIndex(A){this.ensureCapacity(A+1)}setCenter(A,t,e,i){this.centers[A*3]=t,this.centers[A*3+1]=e,this.centers[A*3+2]=i}setScale(A,t,e,i){this.scales[A*3]=t,this.scales[A*3+1]=e,this.scales[A*3+2]=i}setQuaternion(A,t,e,i,n){this.quaternions[A*4]=t,this.quaternions[A*4+1]=e,this.quaternions[A*4+2]=i,this.quaternions[A*4+3]=n}setOpacity(A,t){this.opacities[A]=t}setColor(A,t,e,i){this.colors[A*3]=t,this.colors[A*3+1]=e,this.colors[A*3+2]=i}setSh1(A,t){this.sh1||(this.sh1=new Float32Array(this.maxSplats*9));for(let e=0;e<9;++e)this.sh1[A*9+e]=t[e]}setSh2(A,t){this.sh2||(this.sh2=new Float32Array(this.maxSplats*15));for(let e=0;e<15;++e)this.sh2[A*15+e]=t[e]}setSh3(A,t){this.sh3||(this.sh3=new Float32Array(this.maxSplats*21));for(let e=0;e<21;++e)this.sh3[A*21+e]=t[e]}}async function $e(s,A,t){if(s.quats.encoding!=="quaternion_packed")throw new Error("Unsupported quaternion encoding");const e=s.means.shape[0],i=lt(e),n=new Uint32Array(i*4),g={},r=Promise.all([it(A[s.means.files[0]]),it(A[s.means.files[1]])]).then(Q=>{for(let B=0;B<e;++B){const h=B*4,u=(Q[0][h+0]+(Q[1][h+0]<<8))/65535,E=(Q[0][h+1]+(Q[1][h+1]<<8))/65535,c=(Q[0][h+2]+(Q[1][h+2]<<8))/65535;let f=s.means.mins[0]+(s.means.maxs[0]-s.means.mins[0])*u,l=s.means.mins[1]+(s.means.maxs[1]-s.means.mins[1])*E,y=s.means.mins[2]+(s.means.maxs[2]-s.means.mins[2])*c;f=Math.sign(f)*(Math.exp(Math.abs(f))-1),l=Math.sign(l)*(Math.exp(Math.abs(l))-1),y=Math.sign(y)*(Math.exp(Math.abs(y))-1),Te(n,B,f,l,y)}}),I=it(A[s.scales.files[0]]).then(Q=>{const B=new Array(256).fill(0).map((E,c)=>s.scales.mins[0]+(s.scales.maxs[0]-s.scales.mins[0])*(c/255)).map(E=>Math.exp(E)),h=new Array(256).fill(0).map((E,c)=>s.scales.mins[1]+(s.scales.maxs[1]-s.scales.mins[1])*(c/255)).map(E=>Math.exp(E)),u=new Array(256).fill(0).map((E,c)=>s.scales.mins[2]+(s.scales.maxs[2]-s.scales.mins[2])*(c/255)).map(E=>Math.exp(E));for(let E=0;E<e;++E){const c=E*4;ve(n,E,B[Q[c+0]],h[Q[c+1]],u[Q[c+2]],t)}}),o=it(A[s.quats.files[0]]).then(Q=>{const B=Math.sqrt(2),h=new Array(256).fill(0).map((u,E)=>(E/255-.5)*B);for(let u=0;u<e;++u){const E=u*4,c=h[Q[E+0]],f=h[Q[E+1]],l=h[Q[E+2]],y=Math.sqrt(Math.max(0,1-c*c-f*f-l*l)),x=Q[E+3]-252,Y=x===0?c:x===1?y:f,N=x<=1?f:x===2?y:l,m=x<=2?l:y;Ke(n,u,Y,N,m,x===0?y:c)}}),a=it(A[s.sh0.files[0]]).then(Q=>{const B=.28209479177387814,h=new Array(256).fill(0).map((f,l)=>s.sh0.mins[0]+(s.sh0.maxs[0]-s.sh0.mins[0])*(l/255)).map(f=>B*f+.5),u=new Array(256).fill(0).map((f,l)=>s.sh0.mins[1]+(s.sh0.maxs[1]-s.sh0.mins[1])*(l/255)).map(f=>B*f+.5),E=new Array(256).fill(0).map((f,l)=>s.sh0.mins[2]+(s.sh0.maxs[2]-s.sh0.mins[2])*(l/255)).map(f=>B*f+.5),c=new Array(256).fill(0).map((f,l)=>s.sh0.mins[3]+(s.sh0.maxs[3]-s.sh0.mins[3])*(l/255)).map(f=>1/(1+Math.exp(-f)));for(let f=0;f<e;++f){const l=f*4;Hs(n,f,h[Q[l+0]],u[Q[l+1]],E[Q[l+2]],c[Q[l+3]],t)}}),C=[r,I,o,a];if(s.shN){const Q=s.shN.shape[1]>=45,B=s.shN.shape[1]>=24,h=s.shN.shape[1]>=9;h&&(g.sh1=new Uint32Array(e*2)),B&&(g.sh2=new Uint32Array(e*4)),Q&&(g.sh3=new Uint32Array(e*4));const u=new Float32Array(9),E=new Float32Array(15),c=new Float32Array(21),f=s.shN,l=Promise.all([Wt(A[s.shN.files[0]]),Wt(A[s.shN.files[1]])]).then(([y,x])=>{const Y=new Array(256).fill(0).map((N,m)=>f.mins+(f.maxs-f.mins)*(m/255));for(let N=0;N<e;++N){const m=N*4,w=x.rgba[m+0]+(x.rgba[m+1]<<8),R=(w&63)*15,p=(w>>>6)*y.width+R;for(let F=0;F<3;++F){if(h)for(let S=0;S<3;++S)u[S*3+F]=Y[y.rgba[(p+S)*4+F]];if(B)for(let S=0;S<5;++S)E[S*3+F]=Y[y.rgba[(p+3+S)*4+F]];if(Q)for(let S=0;S<7;++S)c[S*3+F]=Y[y.rgba[(p+8+S)*4+F]]}h&&ft(g.sh1,N,u,t),B&&yt(g.sh2,N,E,t),Q&&wt(g.sh3,N,c,t)}});C.push(l)}return await Promise.all(C),{packedArray:n,numSplats:e,extra:g}}let St=null;async function Wt(s){if(!St&&(St=new OffscreenCanvas(1,1).getContext("webgl2"),!St))throw new Error("Failed to create WebGL2 context");const A=new Blob([s]),t=await createImageBitmap(A,{premultiplyAlpha:"none"}),e=St,i=e.createTexture();e.bindTexture(e.TEXTURE_2D,i),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,!0),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST);const n=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,n),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,i,0);const g=new Uint8Array(t.width*t.height*4);return e.readPixels(0,0,t.width,t.height,e.RGBA,e.UNSIGNED_BYTE,g),e.deleteTexture(i),e.deleteFramebuffer(n),{rgba:g,width:t.width,height:t.height}}async function it(s){const{rgba:A}=await Wt(s);return A}async function Ci(s,A){var Q;const t=je(s);if(!t)throw new Error("Invalid PC SOGS zip file");const{name:e,json:i}=t,n=e.lastIndexOf("/"),g=e.lastIndexOf("\\\\"),r=e.slice(0,Math.max(n,g)+1),I=new Map,o=[...i.means.files,...i.scales.files,...i.quats.files,...i.sh0.files,...((Q=i.shN)==null?void 0:Q.files)??[]];for(const B of o)I.set(r+B,B);const a=await new Promise((B,h)=>{Ss(s,{filter:({name:u})=>I.has(u)},(u,E)=>{u?h(u):B(E)})}),C={};for(const[B,h]of I.entries())C[h]=a[B];return await $e(i,C,A)}class As{constructor({fileBytes:A}){this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A,this.reader=new Xs({fileBytes:this.fileBytes});const t=new DataView(this.reader.read(16).buffer);if(t.getUint32(0,!0)!==1347635022)throw new Error("Invalid SPZ file");if(this.version=t.getUint32(4,!0),this.version<1||this.version>3)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=t.getUint32(8,!0),this.shDegree=t.getUint8(12),this.fractionalBits=t.getUint8(13),this.flags=t.getUint8(14),this.flagAntiAlias=(this.flags&1)!==0,this.reserved=t.getUint8(15),this.parsed=!1}parseSplats(A,t,e,i,n,g){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,this.version===1){const r=this.reader.read(this.numSplats*3*2),I=new Uint16Array(r.buffer);for(let o=0;o<this.numSplats;o++){const a=o*3,C=$(I[a]),Q=$(I[a+1]),B=$(I[a+2]);A==null||A(o,C,Q,B)}}else if(this.version===2||this.version===3){const r=1<<this.fractionalBits,I=this.reader.read(this.numSplats*3*3);for(let o=0;o<this.numSplats;o++){const a=o*9,C=((I[a+2]<<24|I[a+1]<<16|I[a]<<8)>>8)/r,Q=((I[a+5]<<24|I[a+4]<<16|I[a+3]<<8)>>8)/r,B=((I[a+8]<<24|I[a+7]<<16|I[a+6]<<8)>>8)/r;A==null||A(o,C,Q,B)}}else throw new Error("Unreachable");{const r=this.reader.read(this.numSplats);for(let I=0;I<this.numSplats;I++)t==null||t(I,r[I]/255)}{const r=this.reader.read(this.numSplats*3),I=es/.15;for(let o=0;o<this.numSplats;o++){const a=o*3,C=(r[a]/255-.5)*I+.5,Q=(r[a+1]/255-.5)*I+.5,B=(r[a+2]/255-.5)*I+.5;e==null||e(o,C,Q,B)}}{const r=this.reader.read(this.numSplats*3);for(let I=0;I<this.numSplats;I++){const o=I*3,a=Math.exp(r[o]/16-10),C=Math.exp(r[o+1]/16-10),Q=Math.exp(r[o+2]/16-10);i==null||i(I,a,C,Q)}}if(this.version===3){const r=1/Math.sqrt(2),I=this.reader.read(this.numSplats*4);for(let o=0;o<this.numSplats;o++){const a=o*4,C=[0,0,0,0],Q=[I[a],I[a+1],I[a+2],I[a+3]],B=Q[0]+(Q[1]<<8)+(Q[2]<<16)+(Q[3]<<24),h=511,u=B>>>30;let E=B,c=0;for(let l=3;l>=0;--l)if(l!==u){const y=E&h,x=E>>>9&1;E=E>>>10,C[l]=r*(y/h),C[l]=x===0?C[l]:-C[l],c+=C[l]*C[l]}const f=1-c;C[u]=Math.sqrt(Math.max(f,0)),n==null||n(o,C[0],C[1],C[2],C[3])}}else{const r=this.reader.read(this.numSplats*3);for(let I=0;I<this.numSplats;I++){const o=I*3,a=r[o]/127.5-1,C=r[o+1]/127.5-1,Q=r[o+2]/127.5-1,B=Math.sqrt(Math.max(0,1-a*a-C*C-Q*Q));n==null||n(I,a,C,Q,B)}}if(g&&this.shDegree>=1){const r=new Float32Array(9),I=this.shDegree>=2?new Float32Array(5*3):void 0,o=this.shDegree>=3?new Float32Array(7*3):void 0,a=this.reader.read(this.numSplats*ts[this.shDegree]*3);let C=0;for(let Q=0;Q<this.numSplats;Q++){for(let B=0;B<9;++B)r[B]=(a[C+B]-128)/128;if(C+=9,I){for(let B=0;B<15;++B)I[B]=(a[C+B]-128)/128;C+=15}if(o){for(let B=0;B<21;++B)o[B]=(a[C+B]-128)/128;C+=21}g==null||g(Q,r,I,o)}}}}const ts={1:3,2:8,3:15},es=.28209479177387814,Bi=1347635022,Qi=3,hi=1;class RA{constructor({numSplats:A,shDegree:t,fractionalBits:e=12,flagAntiAlias:i=!0}){this.clippedCount=0;const n=20+(t>=1?9:0)+(t>=2?15:0)+(t>=3?21:0),g=16+A*n;this.buffer=new ArrayBuffer(g),this.view=new DataView(this.buffer),this.view.setUint32(0,Bi,!0),this.view.setUint32(4,Qi,!0),this.view.setUint32(8,A,!0),this.view.setUint8(12,t),this.view.setUint8(13,e),this.view.setUint8(14,i?hi:0),this.view.setUint8(15,0),this.numSplats=A,this.shDegree=t,this.fractionalBits=e,this.fraction=1<<e,this.flagAntiAlias=i}setCenter(A,t,e,i){const n=Math.round(t*this.fraction),g=Math.max(-8388607,Math.min(8388607,n)),r=Math.round(e*this.fraction),I=Math.max(-8388607,Math.min(8388607,r)),o=Math.round(i*this.fraction),a=Math.max(-8388607,Math.min(8388607,o));(n!==g||r!==I||o!==a)&&(this.clippedCount+=1);const B=16+A*9;this.view.setUint8(B,g&255),this.view.setUint8(B+1,g>>8&255),this.view.setUint8(B+2,g>>16&255),this.view.setUint8(B+3,I&255),this.view.setUint8(B+4,I>>8&255),this.view.setUint8(B+5,I>>16&255),this.view.setUint8(B+6,a&255),this.view.setUint8(B+7,a>>8&255),this.view.setUint8(B+8,a>>16&255)}setAlpha(A,t){const e=16+this.numSplats*9+A;this.view.setUint8(e,Math.max(0,Math.min(255,Math.round(t*255))))}static scaleRgb(A){const t=((A-.5)/(es/.15)+.5)*255;return Math.max(0,Math.min(255,Math.round(t)))}setRgb(A,t,e,i){const n=16+this.numSplats*10+A*3;this.view.setUint8(n,RA.scaleRgb(t)),this.view.setUint8(n+1,RA.scaleRgb(e)),this.view.setUint8(n+2,RA.scaleRgb(i))}setScale(A,t,e,i){const n=16+this.numSplats*13+A*3;this.view.setUint8(n,Math.max(0,Math.min(255,Math.round((Math.log(t)+10)*16)))),this.view.setUint8(n+1,Math.max(0,Math.min(255,Math.round((Math.log(e)+10)*16)))),this.view.setUint8(n+2,Math.max(0,Math.min(255,Math.round((Math.log(i)+10)*16))))}setQuat(A,...t){const e=16+this.numSplats*16+A*4,i=Rs(t);let n=0;for(let I=1;I<4;++I)Math.abs(i[I])>Math.abs(i[n])&&(n=I);const g=i[n]<0?1:0;let r=n;for(let I=0;I<4;++I)if(I!==n){const o=(i[I]<0?1:0)^g,a=Math.floor(511*(Math.abs(i[I])/Math.SQRT1_2)+.5);r=r<<10|o<<9|a}this.view.setUint8(e,r&255),this.view.setUint8(e+1,r>>8&255),this.view.setUint8(e+2,r>>16&255),this.view.setUint8(e+3,r>>>24&255)}static quantizeSh(A,t){const e=Math.round(A*128)+128,i=1<<8-t,n=Math.floor((e+i/2)/i)*i;return Math.max(0,Math.min(255,n))}setSh(A,t,e,i){const n=ts[this.shDegree]||0,g=16+this.numSplats*20+A*n*3;for(let r=0;r<9;++r)this.view.setUint8(g+r,RA.quantizeSh(t[r],5));if(e){const r=g+9;for(let I=0;I<15;++I)this.view.setUint8(r+I,RA.quantizeSh(e[I],4));if(i){const I=r+15;for(let o=0;o<21;++o)this.view.setUint8(I+o,RA.quantizeSh(i[o],4))}}}async finalize(){const A=new Uint8Array(this.buffer),e=new ReadableStream({async start(g){g.enqueue(A),g.close()}}).pipeThrough(new CompressionStream("gzip")),n=await new Response(e).arrayBuffer();return console.log("Compressed",A.length,"bytes to",n.byteLength,"bytes"),new Uint8Array(n)}}async function Ei(s){var a,C,Q;const A=new ai,{inputs:t,clipXyz:e,maxSh:i,fractionalBits:n=12,opacityThreshold:g}=s;for(const B of t){let h=function(m){return m.multiplyScalar(l),m.applyQuaternion(y),m.add(x),m},u=function(m){return m.multiplyScalar(l),m},E=function(m){return m.premultiply(y),m},c=function(m){return!Y||Y.containsPoint(m)},f=function(m){return g!==void 0?m>=g:!0};const l=((a=B.transform)==null?void 0:a.scale)??1,y=new kA().fromArray(((C=B.transform)==null?void 0:C.quaternion)??[0,0,0,1]),x=new d().fromArray(((Q=B.transform)==null?void 0:Q.translate)??[0,0,0]),Y=e?new Ue(new d().fromArray(e.min),new d().fromArray(e.max)):void 0;let N=B.fileType;switch(N||(N=gi(B.fileBytes),!N&&B.pathOrUrl&&(N=Ii(B.pathOrUrl))),N){case st.PLY:{const m=new pt({fileBytes:B.fileBytes});await m.parseHeader();let w=null;m.parseSplats((R,D,p,F,S,_,k,T,K,v,P,Z,W,z,q)=>{const J=h(new d(D,p,F));if(c(J)&&f(Z)){w=A.pushSplat(),A.setCenter(w,J.x,J.y,J.z);const b=u(new d(S,_,k));A.setScale(w,b.x,b.y,b.z);const M=E(new kA(T,K,v,P));A.setQuaternion(w,M.x,M.y,M.z,M.w),A.setOpacity(w,Z),A.setColor(w,W,z,q)}else w=null},(R,D,p,F)=>{D&&w!==null&&A.setSh1(w,D),p&&w!==null&&A.setSh2(w,p),F&&w!==null&&A.setSh3(w,F)});break}case st.SPZ:{const m=new As({fileBytes:B.fileBytes}),w=new Int32Array(m.numSplats);w.fill(-1);const R=new Float32Array(m.numSplats*3),D=new d;m.parseSplats((p,F,S,_)=>{const k=h(new d(F,S,_));R[p*3]=k.x,R[p*3+1]=k.y,R[p*3+2]=k.z},(p,F)=>{D.fromArray(R,p*3),c(D)&&f(F)&&(w[p]=A.pushSplat(),A.setCenter(w[p],D.x,D.y,D.z),A.setOpacity(w[p],F))},(p,F,S,_)=>{w[p]>=0&&A.setColor(w[p],F,S,_)},(p,F,S,_)=>{if(w[p]>=0){const k=u(new d(F,S,_));A.setScale(w[p],k.x,k.y,k.z)}},(p,F,S,_,k)=>{if(w[p]>=0){const T=E(new kA(F,S,_,k));A.setQuaternion(w[p],T.x,T.y,T.z,T.w)}},(p,F,S,_)=>{w[p]>=0&&(A.setSh1(w[p],F),S&&A.setSh2(w[p],S),_&&A.setSh3(w[p],_))});break}case st.SPLAT:We(B.fileBytes,m=>{},(m,w,R,D,p,F,S,_,k,T,K,v,P,Z,W)=>{const z=h(new d(w,R,D));if(c(z)&&f(v)){const q=A.pushSplat();A.setCenter(q,z.x,z.y,z.z);const J=u(new d(p,F,S));A.setScale(q,J.x,J.y,J.z);const b=E(new kA(_,k,T,K));A.setQuaternion(q,b.x,b.y,b.z,b.w),A.setOpacity(q,v),A.setColor(q,P,Z,W)}});break;case st.KSPLAT:{let m=null;Ps(B.fileBytes,w=>{},(w,R,D,p,F,S,_,k,T,K,v,P,Z,W,z)=>{const q=h(new d(R,D,p));if(c(q)&&f(P)){m=A.pushSplat(),A.setCenter(m,q.x,q.y,q.z);const J=u(new d(F,S,_));A.setScale(m,J.x,J.y,J.z);const b=E(new kA(k,T,K,v));A.setQuaternion(m,b.x,b.y,b.z,b.w),A.setOpacity(m,P),A.setColor(m,Z,W,z)}else m=null},(w,R,D,p)=>{m!==null&&(A.setSh1(m,R),D&&A.setSh2(m,D),p&&A.setSh3(m,p))});break}default:throw new Error(`transcodeSpz not implemented for ${N}`)}}const r=Math.min(i??3,A.sh3?3:A.sh2?2:A.sh1?1:0),I=new RA({numSplats:A.numSplats,shDegree:r,fractionalBits:n,flagAntiAlias:!0});for(let B=0;B<A.numSplats;++B){const h=B*3,u=B*4;I.setCenter(B,A.centers[h],A.centers[h+1],A.centers[h+2]),I.setScale(B,A.scales[h],A.scales[h+1],A.scales[h+2]),I.setQuat(B,A.quaternions[u],A.quaternions[u+1],A.quaternions[u+2],A.quaternions[u+3]),I.setAlpha(B,A.opacities[B]),I.setRgb(B,A.colors[h],A.colors[h+1],A.colors[h+2]),A.sh1&&r>=1&&I.setSh(B,A.sh1.slice(B*9,(B+1)*9),r>=2&&A.sh2?A.sh2.slice(B*15,(B+1)*15):void 0,r>=3&&A.sh3?A.sh3.slice(B*21,(B+1)*21):void 0)}return{fileBytes:await I.finalize(),clippedCount:I.clippedCount}}async function ss(s){const{name:A,args:t,id:e}=s.data;let i,n;try{switch(A){case"unpackPly":{const{packedArray:g,fileBytes:r,splatEncoding:I}=t,o=await ci({packedArray:g,fileBytes:r,splatEncoding:I});i={id:e,numSplats:o.numSplats,packedArray:o.packedArray,extra:o.extra};break}case"decodeSpz":{const{fileBytes:g,splatEncoding:r}=t,I=li(g,r);i={id:e,numSplats:I.numSplats,packedArray:I.packedArray,extra:I.extra};break}case"decodeAntiSplat":{const{fileBytes:g,splatEncoding:r}=t,I=Ws(g,r);i={id:e,numSplats:I.numSplats,packedArray:I.packedArray};break}case"decodeKsplat":{const{fileBytes:g,splatEncoding:r}=t,I=Vs(g,r);i={id:e,numSplats:I.numSplats,packedArray:I.packedArray,extra:I.extra};break}case"decodePcSogs":{const{fileBytes:g,extraFiles:r,splatEncoding:I}=t,o=JSON.parse(new TextDecoder().decode(g)),a=await $e(o,r,I);i={id:e,numSplats:a.numSplats,packedArray:a.packedArray,extra:a.extra};break}case"decodePcSogsZip":{const{fileBytes:g,splatEncoding:r}=t,I=await Ci(g,r);i={id:e,numSplats:I.numSplats,packedArray:I.packedArray,extra:I.extra};break}case"sortSplats":{const{totalSplats:g,readback:r,ordering:I}=t;i={id:e,readback:r,...ui({totalSplats:g,readback:r,ordering:I})};break}case"sortDoubleSplats":{const{numSplats:g,readback:r,ordering:I}=t;i={id:e,readback:r,ordering:I,activeSplats:rs(g,r,I)};break}case"sort32Splats":{const{numSplats:g,readback:r,ordering:I}=t;i={id:e,readback:r,ordering:I,activeSplats:Is(g,r,I)};break}case"transcodeSpz":{const g=t,r=await Ei(g);i={id:e,fileBytes:r,input:g};break}default:throw new Error(`Unknown name: ${A}`)}}catch(g){n=g,console.error(n)}self.postMessage({id:e,result:i,error:n},{transfer:zs(i)})}async function ci({packedArray:s,fileBytes:A,splatEncoding:t}){const e=new pt({fileBytes:A});await e.parseHeader();const i=e.numSplats,n={};return e.parseSplats((g,r,I,o,a,C,Q,B,h,u,E,c,f,l,y)=>{Kt(s,g,r,I,o,a,C,Q,B,h,u,E,c,f,l,y,t)},(g,r,I,o)=>{r&&(n.sh1||(n.sh1=new Uint32Array(i*2)),ft(n.sh1,g,r,t)),I&&(n.sh2||(n.sh2=new Uint32Array(i*4)),yt(n.sh2,g,I,t)),o&&(n.sh3||(n.sh3=new Uint32Array(i*4)),wt(n.sh3,g,o,t))}),{packedArray:s,numSplats:i,extra:n}}function li(s,A){const t=new As({fileBytes:s}),e=t.numSplats,i=lt(e),n=new Uint32Array(i*4),g={};return t.parseSplats((r,I,o,a)=>{Te(n,r,I,o,a)},(r,I)=>{vs(n,r,I)},(r,I,o,a)=>{Ts(n,r,I,o,a,A)},(r,I,o,a)=>{ve(n,r,I,o,a,A)},(r,I,o,a,C)=>{Ke(n,r,I,o,a,C)},(r,I,o,a)=>{I&&(g.sh1||(g.sh1=new Uint32Array(e*2)),ft(g.sh1,r,I,A)),o&&(g.sh2||(g.sh2=new Uint32Array(e*4)),yt(g.sh2,r,o,A)),a&&(g.sh3||(g.sh3=new Uint32Array(e*4)),wt(g.sh3,r,a,A))}),{packedArray:n,numSplats:e,extra:g}}const Pt=31744,Ft=Pt+1;let DA=null;function ui({totalSplats:s,readback:A,ordering:t}){DA||(DA=new Uint32Array(Ft)),DA.fill(0);const e=A.map(I=>new Uint32Array(I.buffer)),i=e[0].length,n=Math.ceil(s/i);let g=0;for(let I=0;I<n;++I){const o=e[I],a=Math.min(o.length,s-g);for(let C=0;C<a;++C){const Q=o[C]&32767;Q<Pt&&(DA[Q]+=1)}g+=a}let r=0;for(let I=0;I<Ft;++I){const o=r+DA[I];DA[I]=r,r=o}g=0;for(let I=0;I<n;++I){const o=e[I],a=Math.min(o.length,s-g);for(let C=0;C<a;++C){const Q=o[C]&32767;Q<Pt&&(t[DA[Q]]=g+C,DA[Q]+=1)}g+=a}if(DA[Ft-1]!==r)throw new Error(`Expected ${r} active splats but got ${DA[Ft-1]}`);return{activeSplats:r,ordering:t}}const Vt=[];function is(s){Vt.push(s)}async function fi(){self.addEventListener("message",is),await re(),self.removeEventListener("message",is),self.addEventListener("message",ss);for(const s of Vt)ss(s);Vt.length=0}fi().catch(console.error)})();\n//# sourceMappingURL=worker-BZGuPoka.js.map\n', ps = typeof self < "u" && self.Blob && new Blob([Xa], { type: "text/javascript;charset=utf-8" });
function qu(t) {
  let A;
  try {
    if (A = ps && (self.URL || self.webkitURL).createObjectURL(ps), !A) throw "";
    const e = new Worker(A, {
      name: t == null ? void 0 : t.name
    });
    return e.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(A);
    }), e;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(Xa),
      {
        name: t == null ? void 0 : t.name
      }
    );
  } finally {
    A && (self.URL || self.webkitURL).revokeObjectURL(A);
  }
}
class Hu {
  constructor() {
    this.messages = {}, this.messageIdNext = 0, this.worker = new qu(), this.worker.onmessage = (A) => this.onMessage(A);
  }
  makeMessageId() {
    return ++this.messageIdNext;
  }
  makeMessagePromiseId() {
    const A = this.makeMessageId(), e = new Promise((s, n) => {
      this.messages[A] = { resolve: s, reject: n };
    });
    return { id: A, promise: e };
  }
  onMessage(A) {
    const { id: e, result: s, error: n } = A.data, i = this.messages[e];
    i && (delete this.messages[e], n ? i.reject(n) : i.resolve(s));
  }
  // Invoke an RPC on the worker with the given name and arguments.
  // The normal usage of a worker is to run one activity at a time,
  // but this function allows for concurrent calls, tagging each request
  // with a unique message Id and awaiting a response to that same Id.
  // The method will automatically transfer any ArrayBuffers in the
  // arguments to the worker. If you'd like to transfer a copy of a
  // buffer then you must clone it before passing to this function.
  async call(A, e) {
    const { id: s, promise: n } = this.makeMessagePromiseId();
    return this.worker.postMessage(
      { name: A, args: e, id: s },
      { transfer: Hn(e) }
    ), n;
  }
}
let Oa = 4, he = 0;
const Wa = [], ja = [];
async function Ku() {
  const t = Wa.shift();
  if (t)
    return t;
  if (he < Oa) {
    const A = new Hu();
    return he += 1, A;
  }
  return new Promise((A) => {
    ja.push(A);
  });
}
function $u(t) {
  if (he > Oa) {
    he -= 1;
    return;
  }
  const A = ja.shift();
  if (A) {
    A(t);
    return;
  }
  Wa.push(t);
}
async function lt(t) {
  const A = await Ku();
  try {
    return await t(A);
  } finally {
    $u(A);
  }
}
class Vu extends wo {
  constructor(A) {
    super(A), this.fileLoader = new mo(A);
  }
  load(A, e, s, n) {
    const i = this.manager.resolveURL(
      (this.path ?? "") + (A ?? "")
    ), r = new Headers(this.requestHeader), a = this.withCredentials ? "include" : "same-origin", o = new Request(i, { headers: r, credentials: a });
    let c = this.fileType;
    this.manager.itemStart(i), ds(o, s).then(async (l) => {
      var B;
      const g = [
        new ProgressEvent("progress", {
          lengthComputable: !0,
          loaded: l.byteLength,
          total: l.byteLength
        })
      ];
      function I() {
        if (s) {
          const E = g.every((d) => d.lengthComputable || d.loaded === 0 && d.total === 0), p = g.reduce((d, y) => d + y.loaded, 0), f = g.reduce((d, y) => d + y.total, 0);
          s(
            new ProgressEvent("progress", {
              lengthComputable: E,
              loaded: p,
              total: f
            })
          );
        }
      }
      const h = {}, Q = [], C = cs(l);
      if (c === "pcsogs" && C === void 0)
        throw new Error("Invalid PC SOGS file");
      if (C !== void 0) {
        c = "pcsogs";
        for (const E of ["means", "scales", "quats", "sh0", "shN"]) {
          const p = C[E];
          if (p)
            for (const f of p.files) {
              const d = new URL(f, i).toString(), y = g.length;
              g.push(new ProgressEvent("progress")), this.manager.itemStart(d);
              const D = new Request(d, { headers: r, credentials: a }), x = ds(D, (w) => {
                g[y] = w, I();
              }).then((w) => {
                h[f] = w;
              }).catch((w) => {
                throw this.manager.itemError(d), w;
              }).finally(() => {
                this.manager.itemEnd(d);
              });
              Q.push(x);
            }
        }
      }
      if (await Promise.all(Q), e) {
        const E = ((B = this.packedSplats) == null ? void 0 : B.splatEncoding) ?? de, p = await to({
          input: l,
          extraFiles: h,
          fileType: c,
          pathOrUrl: i,
          splatEncoding: E
        });
        this.packedSplats ? (this.packedSplats.initialize(p), e(this.packedSplats)) : e(new VA(p));
      }
    }).catch((l) => {
      this.manager.itemError(i), n == null || n(l);
    }).finally(() => {
      this.manager.itemEnd(i);
    });
  }
  async loadAsync(A, e) {
    return new Promise((s, n) => {
      this.load(
        A,
        (i) => {
          s(i);
        },
        e,
        n
      );
    });
  }
  parse(A) {
    return new ft({ packedSplats: A });
  }
}
async function ds(t, A) {
  const e = await fetch(t);
  if (!e.ok)
    throw new Error(
      `${e.status} "${e.statusText}" fetching URL: ${t.url}`
    );
  if (!e.body)
    throw new Error(`Response body is null for URL: ${t.url}`);
  const s = e.body.getReader(), n = Number.parseInt(
    e.headers.get("Content-Length") || "0"
  ), i = Number.isNaN(n) ? 0 : n;
  let r = 0;
  const a = [];
  for (; ; ) {
    const { done: l, value: g } = await s.read();
    if (l)
      break;
    a.push(g), r += g.length, A && A(
      new ProgressEvent("progress", {
        lengthComputable: i !== 0,
        loaded: r,
        total: i
      })
    );
  }
  const o = new Uint8Array(r);
  let c = 0;
  for (const l of a)
    o.set(l, c), c += l.length;
  return o.buffer;
}
var _t = /* @__PURE__ */ ((t) => (t.PLY = "ply", t.SPZ = "spz", t.SPLAT = "splat", t.KSPLAT = "ksplat", t.PCSOGS = "pcsogs", t.PCSOGSZIP = "pcsogszip", t))(_t || {});
function Za(t) {
  const A = new DataView(t.buffer);
  if ((A.getUint32(0, !0) & 16777215) === 7957616)
    return "ply";
  if ((A.getUint32(0, !0) & 16777215) === 559903) {
    const e = Ai(t, 4);
    return new DataView(e.buffer).getUint32(0, !0) === 1347635022 ? "spz" : void 0;
  }
  if (A.getUint32(0, !0) === 67324752)
    return Xu(t) ? "pcsogszip" : void 0;
}
function Pu(t) {
  const A = t.split(/[?#]/, 1)[0], e = Math.max(
    A.lastIndexOf("/"),
    A.lastIndexOf("\\")
  ), s = A.slice(e + 1), n = s.lastIndexOf(".");
  return n <= 0 || n === s.length - 1 ? "" : s.slice(n + 1).toLowerCase();
}
function Ao(t) {
  const A = Pu(t);
  if (A === "ply")
    return "ply";
  if (A === "spz")
    return "spz";
  if (A === "splat")
    return "splat";
  if (A === "ksplat")
    return "ksplat";
}
function Xh(t) {
  return cs(t) !== void 0;
}
function cs(t) {
  try {
    let A;
    if (typeof t == "string")
      A = t;
    else {
      const s = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
      if (s.length > 65536)
        return;
      A = new TextDecoder().decode(s);
    }
    const e = JSON.parse(A);
    if (!e || typeof e != "object" || Array.isArray(e))
      return;
    for (const s of ["means", "scales", "quats", "sh0"])
      if (!e[s] || typeof e[s] != "object" || Array.isArray(e[s]) || !e[s].shape || !e[s].files || s !== "quats" && (!e[s].mins || !e[s].maxs))
        return;
    return e;
  } catch {
    return;
  }
}
function Xu(t) {
  try {
    const A = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
    let e = null;
    const s = Ko(A, {
      filter: ({ name: i }) => i.split(/[\\/]/).pop() === "meta.json" ? (e = i, !0) : !1
    });
    if (!e)
      return;
    const n = cs(s[e]);
    return n ? { name: e, json: n } : void 0;
  } catch {
    return;
  }
}
async function to({
  input: t,
  extraFiles: A,
  fileType: e,
  pathOrUrl: s,
  splatEncoding: n
}) {
  const i = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
  let r = e;
  switch (e || (r = Za(i), !r && s && (r = Ao(s))), r) {
    case "ply": {
      const a = new ue({ fileBytes: i });
      await a.parseHeader();
      const o = a.numSplats, c = mA(o).maxSplats, l = {
        fileBytes: i,
        packedArray: new Uint32Array(c * 4),
        splatEncoding: n
      };
      return await lt(async (g) => {
        const { packedArray: I, numSplats: h, extra: Q } = await g.call(
          "unpackPly",
          l
        );
        return { packedArray: I, numSplats: h, extra: Q };
      });
    }
    case "spz":
      return await lt(async (a) => {
        const { packedArray: o, numSplats: c, extra: l } = await a.call(
          "decodeSpz",
          {
            fileBytes: i,
            splatEncoding: n
          }
        );
        return { packedArray: o, numSplats: c, extra: l };
      });
    case "splat":
      return await lt(async (a) => {
        const { packedArray: o, numSplats: c } = await a.call(
          "decodeAntiSplat",
          {
            fileBytes: i,
            splatEncoding: n
          }
        );
        return { packedArray: o, numSplats: c };
      });
    case "ksplat":
      return await lt(async (a) => {
        const { packedArray: o, numSplats: c, extra: l } = await a.call(
          "decodeKsplat",
          { fileBytes: i, splatEncoding: n }
        );
        return { packedArray: o, numSplats: c, extra: l };
      });
    case "pcsogs":
      return await lt(async (a) => {
        const { packedArray: o, numSplats: c, extra: l } = await a.call(
          "decodePcSogs",
          { fileBytes: i, extraFiles: A, splatEncoding: n }
        );
        return { packedArray: o, numSplats: c, extra: l };
      });
    case "pcsogszip":
      return await lt(async (a) => {
        const { packedArray: o, numSplats: c, extra: l } = await a.call(
          "decodePcSogsZip",
          { fileBytes: i, splatEncoding: n }
        );
        return { packedArray: o, numSplats: c, extra: l };
      });
    default:
      throw new Error(`Unknown splat file type: ${r}`);
  }
}
class Ou {
  constructor({ maxSplats: A = 1 } = {}) {
    this.numSplats = 0, this.maxSplats = mA(A).maxSplats, this.centers = new Float32Array(this.maxSplats * 3), this.scales = new Float32Array(this.maxSplats * 3), this.quaternions = new Float32Array(this.maxSplats * 4), this.opacities = new Float32Array(this.maxSplats), this.colors = new Float32Array(this.maxSplats * 3);
  }
  pushSplat() {
    const A = this.numSplats;
    return this.ensureIndex(A), this.numSplats += 1, A;
  }
  unpushSplat(A) {
    if (A === this.numSplats - 1)
      this.numSplats -= 1;
    else
      throw new Error("Cannot unpush splat from non-last position");
  }
  ensureCapacity(A) {
    if (A > this.maxSplats) {
      const e = Math.max(A, this.maxSplats * 2), s = new Float32Array(e * 3), n = new Float32Array(e * 3), i = new Float32Array(e * 4), r = new Float32Array(e), a = new Float32Array(e * 3);
      if (s.set(this.centers), n.set(this.scales), i.set(this.quaternions), r.set(this.opacities), a.set(this.colors), this.centers = s, this.scales = n, this.quaternions = i, this.opacities = r, this.colors = a, this.sh1) {
        const o = new Float32Array(e * 9);
        o.set(this.sh1), this.sh1 = o;
      }
      if (this.sh2) {
        const o = new Float32Array(e * 15);
        o.set(this.sh2), this.sh2 = o;
      }
      if (this.sh3) {
        const o = new Float32Array(e * 21);
        o.set(this.sh3), this.sh3 = o;
      }
      this.maxSplats = e;
    }
  }
  ensureIndex(A) {
    this.ensureCapacity(A + 1);
  }
  setCenter(A, e, s, n) {
    this.centers[A * 3] = e, this.centers[A * 3 + 1] = s, this.centers[A * 3 + 2] = n;
  }
  setScale(A, e, s, n) {
    this.scales[A * 3] = e, this.scales[A * 3 + 1] = s, this.scales[A * 3 + 2] = n;
  }
  setQuaternion(A, e, s, n, i) {
    this.quaternions[A * 4] = e, this.quaternions[A * 4 + 1] = s, this.quaternions[A * 4 + 2] = n, this.quaternions[A * 4 + 3] = i;
  }
  setOpacity(A, e) {
    this.opacities[A] = e;
  }
  setColor(A, e, s, n) {
    this.colors[A * 3] = e, this.colors[A * 3 + 1] = s, this.colors[A * 3 + 2] = n;
  }
  setSh1(A, e) {
    this.sh1 || (this.sh1 = new Float32Array(this.maxSplats * 9));
    for (let s = 0; s < 9; ++s)
      this.sh1[A * 9 + s] = e[s];
  }
  setSh2(A, e) {
    this.sh2 || (this.sh2 = new Float32Array(this.maxSplats * 15));
    for (let s = 0; s < 15; ++s)
      this.sh2[A * 15 + s] = e[s];
  }
  setSh3(A, e) {
    this.sh3 || (this.sh3 = new Float32Array(this.maxSplats * 21));
    for (let s = 0; s < 21; ++s)
      this.sh3[A * 21 + s] = e[s];
  }
}
var Wu = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;
const de = {
  rgbMin: 0,
  rgbMax: 1,
  lnScaleMin: UA,
  lnScaleMax: GA,
  sh1Min: -1,
  sh1Max: 1,
  sh2Min: -1,
  sh2Max: 1,
  sh3Min: -1,
  sh3Max: 1
}, nA = class nA {
  constructor(A = {}) {
    this.maxSplats = 0, this.numSplats = 0, this.packedArray = null, this.isInitialized = !1, this.target = null, this.source = null, this.needsUpdate = !0, this.extra = {}, this.dyno = new ls({ packedSplats: this }), this.dynoRgbMinMaxLnScaleMinMax = new Nt({
      key: "rgbMinMaxLnScaleMinMax",
      value: new u.Vector4(0, 1, UA, GA),
      update: (e) => {
        var s, n, i, r;
        return e.set(
          ((s = this.splatEncoding) == null ? void 0 : s.rgbMin) ?? 0,
          ((n = this.splatEncoding) == null ? void 0 : n.rgbMax) ?? 1,
          ((i = this.splatEncoding) == null ? void 0 : i.lnScaleMin) ?? UA,
          ((r = this.splatEncoding) == null ? void 0 : r.lnScaleMax) ?? GA
        ), e;
      }
    }), this.dynoSh1MinMax = new zt({
      key: "sh1MinMax",
      value: new u.Vector2(-1, 1),
      update: (e) => {
        var s, n;
        return e.set(
          ((s = this.splatEncoding) == null ? void 0 : s.sh1Min) ?? -1,
          ((n = this.splatEncoding) == null ? void 0 : n.sh1Max) ?? 1
        ), e;
      }
    }), this.dynoSh2MinMax = new zt({
      key: "sh2MinMax",
      value: new u.Vector2(-1, 1),
      update: (e) => {
        var s, n;
        return e.set(
          ((s = this.splatEncoding) == null ? void 0 : s.sh2Min) ?? -1,
          ((n = this.splatEncoding) == null ? void 0 : n.sh2Max) ?? 1
        ), e;
      }
    }), this.dynoSh3MinMax = new zt({
      key: "sh3MinMax",
      value: new u.Vector2(-1, 1),
      update: (e) => {
        var s, n;
        return e.set(
          ((s = this.splatEncoding) == null ? void 0 : s.sh3Min) ?? -1,
          ((n = this.splatEncoding) == null ? void 0 : n.sh3Max) ?? 1
        ), e;
      }
    }), this.initialized = Promise.resolve(this), this.reinitialize(A);
  }
  reinitialize(A) {
    this.isInitialized = !1, this.extra = {}, this.splatEncoding = A.splatEncoding, A.url || A.fileBytes || A.construct ? this.initialized = this.asyncInitialize(A).then(() => (this.isInitialized = !0, this)) : (this.initialize(A), this.isInitialized = !0, this.initialized = Promise.resolve(this));
  }
  initialize(A) {
    A.packedArray ? (this.packedArray = A.packedArray, this.maxSplats = Math.floor(this.packedArray.length / 4), this.maxSplats = Math.floor(this.maxSplats / X) * X, this.numSplats = Math.min(
      this.maxSplats,
      A.numSplats ?? Number.POSITIVE_INFINITY
    )) : (this.maxSplats = A.maxSplats ?? 0, this.numSplats = 0), this.extra = A.extra ?? {};
  }
  async asyncInitialize(A) {
    const { url: e, fileBytes: s, construct: n } = A;
    if (e) {
      const i = new Vu();
      i.packedSplats = this, await i.loadAsync(e);
    } else if (s) {
      const i = await to({
        input: s,
        fileType: A.fileType,
        pathOrUrl: A.fileName ?? e,
        splatEncoding: A.splatEncoding ?? de
      });
      this.initialize(i);
    }
    if (n) {
      const i = n(this);
      i instanceof Promise && await i;
    }
  }
  // Call this when you are finished with the PackedSplats and want to free
  // any buffers it holds.
  dispose() {
    this.target && (this.target.dispose(), this.target = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
  // resize exponentially and copy over the original data.
  //
  // Typically you don't need to call this, because calling this.setSplat(index, ...)
  // and this.pushSplat(...) will automatically call ensureSplats() so we have
  // enough splats.
  ensureSplats(A) {
    const e = A <= this.maxSplats ? this.maxSplats : (
      // Grow exponentially to avoid frequent reallocations
      Math.max(A, 2 * this.maxSplats)
    ), s = this.packedArray ? this.packedArray.length / 4 : 0;
    if (!this.packedArray || e > s) {
      this.maxSplats = mA(e).maxSplats;
      const n = new Uint32Array(this.maxSplats * 4);
      this.packedArray && n.set(this.packedArray), this.packedArray = n;
    }
    return this.packedArray;
  }
  // Ensure the extra array for the given level is large enough to hold numSplats
  ensureSplatsSh(A, e) {
    let s, n;
    if (A === 0)
      return this.ensureSplats(e);
    if (A === 1)
      s = 2, n = "sh1";
    else if (A === 2)
      s = 4, n = "sh2";
    else if (A === 3)
      s = 4, n = "sh3";
    else
      throw new Error(`Invalid level: ${A}`);
    let i = this.extra[n] ? this.extra[n].length / s : 0;
    const r = e <= i ? i : Math.max(e, 2 * i);
    if (!this.extra[n] || r > i) {
      i = mA(r).maxSplats;
      const a = new Uint32Array(i * s);
      this.extra[n] && a.set(this.extra[n]), this.extra[n] = a;
    }
    return this.extra[n];
  }
  // Unpack the 16-byte Gsplat data at index into the Three.js components
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number 0..1, color: THREE.Color 0..1.
  getSplat(A) {
    if (!this.packedArray || A >= this.numSplats)
      throw new Error("Invalid index");
    return Je(this.packedArray, A, this.splatEncoding);
  }
  // Set all PackedSplat components at index with the provided Gsplat attributes
  // (can be the same objects returned by getSplat). Ensures there is capacity
  // for at least index+1 Gsplats.
  setSplat(A, e, s, n, i, r) {
    const a = this.ensureSplats(A + 1);
    Ye(
      a,
      A,
      e.x,
      e.y,
      e.z,
      s.x,
      s.y,
      s.z,
      n.x,
      n.y,
      n.z,
      n.w,
      i,
      r.r,
      r.g,
      r.b
    ), this.numSplats = Math.max(this.numSplats, A + 1);
  }
  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
  // construction where you just want to iterate and create a collection of Gsplats.
  pushSplat(A, e, s, n, i) {
    const r = this.ensureSplats(this.numSplats + 1);
    Ye(
      r,
      this.numSplats,
      A.x,
      A.y,
      A.z,
      e.x,
      e.y,
      e.z,
      s.x,
      s.y,
      s.z,
      s.w,
      n,
      i.r,
      i.g,
      i.b
    ), ++this.numSplats;
  }
  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
  // and invoke the callback function with the Gsplat attributes.
  forEachSplat(A) {
    if (!(!this.packedArray || !this.numSplats))
      for (let e = 0; e < this.numSplats; ++e) {
        const s = Je(this.packedArray, e, this.splatEncoding);
        A(
          e,
          s.center,
          s.scales,
          s.quaternion,
          s.opacity,
          s.color
        );
      }
  }
  // Ensures our PackedSplats.target render target has enough space to generate
  // maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate(A) {
    if (this.target && (A ?? 1) <= this.maxSplats)
      return !1;
    this.dispose();
    const e = mA(A ?? 1), { width: s, height: n, depth: i } = e;
    return this.maxSplats = e.maxSplats, this.target = new u.WebGLArrayRenderTarget(s, n, i, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: u.NearestFilter,
      minFilter: u.NearestFilter
    }), this.target.texture.format = u.RGBAIntegerFormat, this.target.texture.type = u.UnsignedIntType, this.target.texture.internalFormat = "RGBA32UI", this.target.scissorTest = !0, !0;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(A) {
    let e = 0;
    const s = A.map((n) => {
      const i = e, r = Math.ceil(n / X) * X;
      return e += r, { base: i, count: n };
    });
    return { maxSplats: e, mapping: s };
  }
  // Returns a THREE.DataArrayTexture representing the PackedSplats content as
  // a Uint32x4 data array texture (2048 x 2048 x depth in size)
  getTexture() {
    return this.target ? this.target.texture : this.source || this.packedArray ? this.maybeUpdateSource() : nA.getEmpty();
  }
  // Check if source texture needs to be created/updated
  maybeUpdateSource() {
    if (!this.packedArray)
      throw new Error("No packed splats");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: e, depth: s } = this.source.image;
        this.maxSplats !== A * e * s && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.packedArray.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.packedArray.buffer));
      else {
        const { width: A, height: e, depth: s } = mA(this.maxSplats);
        this.source = new u.DataArrayTexture(
          this.packedArray,
          A,
          e,
          s
        ), this.source.format = u.RGBAIntegerFormat, this.source.type = u.UnsignedIntType, this.source.internalFormat = "RGBA32UI", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!nA.emptySource) {
      const { width: A, height: e, depth: s, maxSplats: n } = mA(1), i = new Uint32Array(n * 4);
      nA.emptySource = new u.DataArrayTexture(
        i,
        A,
        e,
        s
      ), nA.emptySource.format = u.RGBAIntegerFormat, nA.emptySource.type = u.UnsignedIntType, nA.emptySource.internalFormat = "RGBA32UI", nA.emptySource.needsUpdate = !0;
    }
    return nA.emptySource;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let e = nA.generatorProgram.get(A);
    if (!e) {
      const n = vA(
        { index: "int" },
        { output: "uvec4" },
        ({ index: i }) => {
          A.inputs.index = i;
          const r = A.outputs.gsplat;
          return { output: sn(
            r,
            this.dynoRgbMinMaxLnScaleMinMax
          ) };
        }
      );
      nA.programTemplate || (nA.programTemplate = new is(
        Wu
      )), e = new ns({
        graph: n,
        inputs: { index: "index" },
        outputs: { output: "target" },
        template: nA.programTemplate
      }), Object.assign(e.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), nA.generatorProgram.set(A, e);
    }
    const s = e.prepareMaterial();
    return nA.fullScreenQuad.material = s, { program: e, material: s };
  }
  saveRenderState(A) {
    return {
      xrEnabled: A.xr.enabled,
      autoClear: A.autoClear
    };
  }
  resetRenderState(A, e) {
    A.setRenderTarget(null), A.xr.enabled = e.xrEnabled, A.autoClear = e.autoClear;
  }
  // Executes a dyno program specified by generator which is any DynoBlock that
  // maps { index: "int" } to { gsplat: Gsplat }. This is called in
  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for
  // SplatGenerator instances whose version is newer than what was generated
  // for it last time.
  generate({
    generator: A,
    base: e,
    count: s,
    renderer: n
  }) {
    if (!this.target)
      throw new Error("Target must be initialized with ensureSplats");
    if (e + s > this.maxSplats)
      throw new Error("Base + count exceeds maxSplats");
    const { program: i, material: r } = this.prepareProgramMaterial(A);
    i.update();
    const a = this.saveRenderState(n), o = Math.ceil((e + s) / X) * X, c = X * KA;
    for (r.uniforms.targetBase.value = e, r.uniforms.targetCount.value = s; e < o; ) {
      const l = Math.floor(e / c);
      r.uniforms.targetLayer.value = l;
      const g = l * c, I = Math.floor((e - g) / X), h = Math.min(
        KA,
        Math.ceil((o - g) / X)
      );
      this.target.scissor.set(
        0,
        I,
        X,
        h - I
      ), n.setRenderTarget(this.target, l), n.xr.enabled = !1, n.autoClear = !1, nA.fullScreenQuad.render(n), e += X * (h - I);
    }
    return this.resetRenderState(n, a), { nextBase: o };
  }
};
nA.emptySource = null, nA.programTemplate = null, nA.generatorProgram = /* @__PURE__ */ new Map(), nA.fullScreenQuad = new xs(
  new u.RawShaderMaterial({ visible: !1 })
);
let VA = nA;
class ls extends k {
  constructor({ packedSplats: A } = {}) {
    super({
      key: "packedSplats",
      type: jt,
      globals: () => [Ee],
      value: {
        texture: VA.getEmpty(),
        numSplats: 0,
        rgbMinMaxLnScaleMinMax: new u.Vector4(
          0,
          1,
          UA,
          GA
        )
      },
      update: (e) => {
        var s, n, i, r, a, o, c, l, g, I;
        return e.texture = ((s = this.packedSplats) == null ? void 0 : s.getTexture()) ?? VA.getEmpty(), e.numSplats = ((n = this.packedSplats) == null ? void 0 : n.numSplats) ?? 0, e.rgbMinMaxLnScaleMinMax.set(
          ((r = (i = this.packedSplats) == null ? void 0 : i.splatEncoding) == null ? void 0 : r.rgbMin) ?? 0,
          ((o = (a = this.packedSplats) == null ? void 0 : a.splatEncoding) == null ? void 0 : o.rgbMax) ?? 1,
          ((l = (c = this.packedSplats) == null ? void 0 : c.splatEncoding) == null ? void 0 : l.lnScaleMin) ?? UA,
          ((I = (g = this.packedSplats) == null ? void 0 : g.splatEncoding) == null ? void 0 : I.lnScaleMax) ?? GA
        ), e;
      }
    }), this.packedSplats = A;
  }
}
class Ve extends u.InstancedBufferGeometry {
  constructor(A, e) {
    super(), this.ordering = A, this.setAttribute("position", new u.BufferAttribute(ju, 3)), this.setIndex(new u.BufferAttribute(Zu, 1)), this._maxInstanceCount = A.length, this.instanceCount = e, this.attribute = new u.InstancedBufferAttribute(A, 1, !1, 1), this.attribute.setUsage(u.DynamicDrawUsage), this.setAttribute("splatIndex", this.attribute);
  }
  update(A, e) {
    this.ordering = A, this.attribute.array = A, this.instanceCount = e, this.attribute.addUpdateRange(0, e), this.attribute.needsUpdate = !0;
  }
}
const ju = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]), Zu = new Uint16Array([0, 1, 2, 0, 2, 3]), nt = class nt {
  constructor(A) {
    if (this.lastTime = null, this.encodeLinear = !1, this.superXY = 1, this.display = null, this.sorting = null, this.pending = null, this.sortingCheck = !1, this.readback16 = new Uint16Array(0), this.readback32 = new Uint32Array(0), this.spark = A.spark, this.camera = A.camera, this.viewToWorld = A.viewToWorld ?? new u.Matrix4(), A.target) {
      const { width: e, height: s, doubleBuffer: n } = A.target, i = Math.max(1, Math.min(4, A.target.superXY ?? 1));
      if (this.superXY = i, e * i > 8192 || s * i > 8192)
        throw new Error("Target size too large");
      this.target = new u.WebGLRenderTarget(
        e * i,
        s * i,
        {
          format: u.RGBAFormat,
          type: u.UnsignedByteType,
          colorSpace: u.SRGBColorSpace
        }
      ), n && (this.back = new u.WebGLRenderTarget(
        e * i,
        s * i,
        {
          format: u.RGBAFormat,
          type: u.UnsignedByteType,
          colorSpace: u.SRGBColorSpace
        }
      )), this.encodeLinear = !0;
    }
    this.onTextureUpdated = A.onTextureUpdated, this.sortRadial = A.sortRadial ?? !0, this.sortDistance = A.sortDistance, this.sortCoorient = A.sortCoorient, this.depthBias = A.depthBias, this.sort360 = A.sort360, this.sort32 = A.sort32, this.stochastic = A.stochastic ?? !1, this.orderingFreelist = new Kn({
      allocate: (e) => new Uint32Array(e),
      valid: (e, s) => e.length === s
    }), this.autoUpdate = !1, this.setAutoUpdate(A.autoUpdate ?? !1);
  }
  // Call this when you are done with the SparkViewpoint and want to
  // free up its resources (GPU targets, pixel buffers, etc.)
  dispose() {
    var A;
    this.setAutoUpdate(!1), this.target && (this.target.dispose(), this.target = void 0), this.back && (this.back.dispose(), this.back = void 0), this.display && (this.spark.releaseAccumulator(this.display.accumulator), this.display.geometry.dispose(), this.display = null), (A = this.pending) != null && A.accumulator && (this.spark.releaseAccumulator(this.pending.accumulator), this.pending = null);
  }
  // Use this function to change whether this viewpoint will auto-update
  // its sort order whenever the attached SparkRenderer updates the Gsplats.
  // Turn this on or off depending on whether you expect to do renders from
  // this viewpoint most frames.
  setAutoUpdate(A) {
    !this.autoUpdate && A ? this.spark.autoViewpoints.push(this) : this.autoUpdate && !A && (this.spark.autoViewpoints = this.spark.autoViewpoints.filter(
      (e) => e !== this
    )), this.autoUpdate = A;
  }
  // See below async prepareRenderPixels() for explanation of parameters.
  // Awaiting this method updates the Gsplats in the scene and performs a sort of the
  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()
  // call in the same tick.
  async prepare({
    scene: A,
    camera: e,
    viewToWorld: s,
    update: n,
    forceOrigin: i
  }) {
    var a;
    for (s ? this.viewToWorld = s : (this.camera = e ?? this.camera, this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone())); n ?? !0; ) {
      const o = i ? this.viewToWorld : void 0;
      if (this.spark.updateInternal({ scene: A, originToWorld: o }))
        break;
      await new Promise((l) => setTimeout(l, 10));
    }
    const r = this.spark.active;
    r !== ((a = this.display) == null ? void 0 : a.accumulator) && (this.spark.active.refCount += 1), await this.sortUpdate({ accumulator: r, viewToWorld: this.viewToWorld });
  }
  // Render out the viewpoint to the view target RGBA buffer.
  // Swaps buffers if doubleBuffer: true was set.
  // Calls onTextureUpdated(texture) with the resulting texture.
  renderTarget({
    scene: A,
    camera: e
  }) {
    var n;
    const s = this.back ?? this.target;
    if (!s)
      throw new Error("Must initialize SparkViewpoint with target");
    if (e = e ?? this.camera, !e)
      throw new Error("Must provide camera");
    if (e instanceof u.PerspectiveCamera) {
      const i = new u.PerspectiveCamera().copy(e, !1);
      i.aspect = s.width / s.height, i.updateProjectionMatrix(), e = i;
    }
    this.viewToWorld = e.matrixWorld.clone();
    try {
      this.spark.renderer.setRenderTarget(s), this.spark.prepareViewpoint(this), this.spark.renderer.render(A, e);
    } finally {
      this.spark.prepareViewpoint(this.spark.defaultView), this.spark.renderer.setRenderTarget(null);
    }
    s !== this.target && ([this.target, this.back] = [this.back, this.target]), (n = this.onTextureUpdated) == null || n.call(this, s.texture);
  }
  // Read back the previously rendered target image as a Uint8Array of packed
  // RGBA values (in that order). If superXY was set greater than 1 then
  // downsampling is performed in the target pixel array with simple averaging
  // to derive the returned pixel values. Subsequent calls to this.readTarget()
  // will reuse the same buffers to minimize memory allocations.
  async readTarget() {
    if (!this.target)
      throw new Error("Must initialize SparkViewpoint with target");
    const { width: A, height: e } = this.target, s = A * e * 4;
    (!this.superPixels || this.superPixels.length < s) && (this.superPixels = new Uint8Array(s)), await this.spark.renderer.readRenderTargetPixelsAsync(
      this.target,
      0,
      0,
      A,
      e,
      this.superPixels
    );
    const { superXY: n } = this;
    if (n === 1)
      return this.superPixels;
    const i = A / n, r = e / n, a = i * r * 4;
    (!this.pixels || this.pixels.length < a) && (this.pixels = new Uint8Array(a));
    const { superPixels: o, pixels: c } = this, l = n * n;
    for (let g = 0; g < r; g++) {
      const I = g * i;
      for (let h = 0; h < i; h++) {
        const Q = h * n;
        let C = 0, B = 0, E = 0, p = 0;
        for (let d = 0; d < n; d++) {
          const y = (g * n + d) * this.target.width;
          for (let D = 0; D < n; D++) {
            const x = (y + Q + D) * 4;
            C += o[x], B += o[x + 1], E += o[x + 2], p += o[x + 3];
          }
        }
        const f = (I + h) * 4;
        c[f] = C / l, c[f + 1] = B / l, c[f + 2] = E / l, c[f + 3] = p / l;
      }
    }
    return c;
  }
  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene
  // and any camera/viewToWorld viewpoint overrides. By default update is true,
  // which triggers its SparkRenderer to check and potentially update the Gsplats.
  // Setting update to false disables this and sorts the Gsplats as they are.
  // Setting forceOrigin (default: false) to true forces the view update to
  // recalculate the splats with this view origin, potentially altering any
  // view-dependent effects. If you expect view-dependent effects to play a role
  // in the rendering quality, enable this.
  //
  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),
  // this.renderTarget(...), and finally returns the result this.readTarget(),
  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially
  // downsampled if the superXY parameter was used). These steps can also be called
  // manually, for example if you need to alter the scene before and after
  // this.renderTarget(...) to hide UI elements from being rendered.
  async prepareRenderPixels({
    scene: A,
    camera: e,
    viewToWorld: s,
    update: n,
    forceOrigin: i
  }) {
    return await this.prepare({ scene: A, camera: e, viewToWorld: s, update: n, forceOrigin: i }), this.renderTarget({ scene: A, camera: e }), this.readTarget();
  }
  // This is called automatically by SparkRenderer, there is no need to call it!
  // The method cannot be private because then SparkRenderer would
  // not be able to call it.
  autoPoll({ accumulator: A }) {
    var i, r, a, o;
    this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone());
    let e = !1, s = !1;
    if (!this.display)
      e = !0;
    else if (A) {
      e = !0;
      const { mappingVersion: c } = this.display.accumulator;
      A.mappingVersion === c && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A, s = !0);
    }
    const n = ((i = this.sorting) == null ? void 0 : i.viewToWorld) ?? ((r = this.display) == null ? void 0 : r.viewToWorld);
    n && !ce({
      matrix1: this.viewToWorld,
      matrix2: n,
      // By default update sort each 1 cm
      maxDistance: this.sortDistance ?? 0.01,
      // By default for radial sort, update for intermittent movement so that
      // we bring back splats culled by being behind the camera.
      // For depth sort, small rotations can change sort order a lot, so
      // update sort for even small rotations.
      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999
    }) && (e = !0), e && (A && (A.refCount += 1), A && ((a = this.pending) != null && a.accumulator) && this.pending.accumulator !== ((o = this.display) == null ? void 0 : o.accumulator) && this.spark.releaseAccumulator(this.pending.accumulator), this.pending = { accumulator: A, viewToWorld: this.viewToWorld, displayed: s }, this.driveSort());
  }
  async driveSort() {
    var A;
    for (; ; ) {
      if (this.sorting || !this.pending)
        return;
      const { viewToWorld: e, displayed: s } = this.pending;
      let n = this.pending.accumulator ?? ((A = this.display) == null ? void 0 : A.accumulator);
      if (n || (n = this.spark.active, n.refCount += 1), this.pending = null, !n)
        throw new Error("No accumulator to sort");
      this.sorting = { viewToWorld: e }, await this.sortUpdate({ accumulator: n, viewToWorld: e, displayed: s }), this.sorting = null;
    }
  }
  async sortUpdate({
    accumulator: A,
    viewToWorld: e,
    displayed: s = !1
  }) {
    if (this.sortingCheck)
      throw new Error("Only one sort at a time");
    this.sortingCheck = !0, A = A ?? this.spark.active;
    const { numSplats: n, maxSplats: i } = A.splats;
    let r = 0, a = this.orderingFreelist.alloc(i);
    if (this.stochastic) {
      r = n;
      for (let o = 0; o < n; ++o)
        a[o] = o;
    } else if (n > 0) {
      const {
        reader: o,
        doubleSortReader: c,
        sort32Reader: l,
        dynoSortRadial: g,
        dynoOrigin: I,
        dynoDirection: h,
        dynoDepthBias: Q,
        dynoSort360: C,
        dynoSplats: B
      } = nt.makeSorter(), E = this.sort32 ?? !1;
      let p;
      if (E)
        this.readback32 = o.ensureBuffer(i, this.readback32), p = this.readback32;
      else {
        const w = Math.ceil(i / 2);
        this.readback16 = o.ensureBuffer(w, this.readback16), p = this.readback16;
      }
      const f = A.toWorld.clone().invert(), d = e.clone().premultiply(f);
      g.value = this.sort360 ? !0 : this.sortRadial, I.value.set(0, 0, 0).applyMatrix4(d), h.value.set(0, 0, -1).applyMatrix4(d).sub(I.value).normalize(), Q.value = this.depthBias ?? 1, C.value = this.sort360 ?? !1, B.packedSplats = A.splats;
      const y = E ? l : c, D = E ? n : Math.ceil(n / 2);
      await o.renderReadback({
        renderer: this.spark.renderer,
        reader: y,
        count: D,
        readback: p
      });
      const x = await lt(async (w) => {
        const m = E ? "sort32Splats" : "sortDoubleSplats";
        return w.call(m, {
          maxSplats: i,
          numSplats: n,
          readback: p,
          ordering: a
        });
      });
      E ? this.readback32 = x.readback : this.readback16 = x.readback, a = x.ordering, r = x.activeSplats;
    }
    this.updateDisplay({
      accumulator: A,
      viewToWorld: e,
      ordering: a,
      activeSplats: r,
      displayed: s
    }), this.sortingCheck = !1;
  }
  updateDisplay({
    accumulator: A,
    viewToWorld: e,
    ordering: s,
    activeSplats: n,
    displayed: i = !1
  }) {
    if (!this.display)
      this.display = {
        accumulator: A,
        viewToWorld: e,
        geometry: new Ve(s, n)
      };
    else {
      !i && A !== this.display.accumulator && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A), this.display.viewToWorld = e;
      const r = this.display.geometry.ordering;
      r.length === s.length ? this.display.geometry.update(s, n) : (this.display.geometry.dispose(), this.display.geometry = new Ve(s, n)), this.orderingFreelist.free(r);
    }
    this.spark.viewpoint === this && this.spark.prepareViewpoint(this);
  }
  static makeSorter() {
    if (!nt.dynos) {
      const A = new ge({ value: !0 }), e = new Ft({ value: new u.Vector3() }), s = new Ft({ value: new u.Vector3() }), n = new ht({ value: 1 }), i = new ge({ value: !1 }), r = new ls(), a = new le(), o = vA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: l }) => {
          if (!l)
            throw new Error("No index");
          const g = {
            sortRadial: A,
            sortOrigin: e,
            sortDirection: s,
            sortDepthBias: n,
            sort360: i
          }, I = iA(l, J("int", 2)), h = bt(r, I), Q = ke({ gsplat: h, ...g }), C = bt(
            r,
            BA(I, J("int", 1))
          ), B = ke({ gsplat: C, ...g }), E = $A({
            vectorType: "vec2",
            x: Q,
            y: B
          });
          return { rgba8: ze(ir(E)) };
        }
      ), c = vA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: l }) => {
          if (!l)
            throw new Error("No index");
          const g = {
            sortRadial: A,
            sortOrigin: e,
            sortDirection: s,
            sortDepthBias: n,
            sort360: i
          }, I = bt(r, l), h = ke({ gsplat: I, ...g });
          return { rgba8: ze(nr(h)) };
        }
      );
      nt.dynos = {
        dynoSortRadial: A,
        dynoOrigin: e,
        dynoDirection: s,
        dynoDepthBias: n,
        dynoSort360: i,
        dynoSplats: r,
        reader: a,
        doubleSortReader: o,
        sort32Reader: c
      };
    }
    return nt.dynos;
  }
};
nt.EMPTY_TEXTURE = new u.Texture(), nt.dynos = null;
let Ce = nt;
const Ah = hA(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);
function ke({
  gsplat: t,
  sortRadial: A,
  sortOrigin: e,
  sortDirection: s,
  sortDepthBias: n,
  sort360: i
}) {
  return Wt({
    inTypes: {
      gsplat: AA,
      sortRadial: "bool",
      sortOrigin: "vec3",
      sortDirection: "vec3",
      sortDepthBias: "float",
      sort360: "bool"
    },
    outTypes: { metric: "float" },
    globals: () => [bA, Ah],
    inputs: {
      gsplat: t,
      sortRadial: A,
      sortOrigin: e,
      sortDirection: s,
      sortDepthBias: n,
      sort360: i
    },
    statements: ({ inputs: r, outputs: a }) => {
      const {
        gsplat: o,
        sortRadial: c,
        sortOrigin: l,
        sortDirection: g,
        sortDepthBias: I,
        sort360: h
      } = r;
      return RA(`
        ${a.metric} = computeSort(${o}, ${c}, ${l}, ${g}, ${I}, ${h});
      `);
    }
  }).outputs.metric;
}
class Te {
  constructor() {
    this.splats = new VA(), this.toWorld = new u.Matrix4(), this.mapping = [], this.refCount = 0, this.splatsVersion = -1, this.mappingVersion = -1;
  }
  ensureGenerate(A) {
    this.splats.ensureGenerate(A) && (this.mapping = []);
  }
  // Generate all Gsplats from an array of generators
  generateSplats({
    renderer: A,
    modifier: e,
    generators: s,
    forceUpdate: n,
    originToWorld: i
  }) {
    const r = this.mapping.reduce((c, l) => (c.set(l.node, l), c), /* @__PURE__ */ new Map());
    let a = 0, o = 0;
    for (const { node: c, generator: l, version: g, base: I, count: h } of s) {
      const Q = r.get(c);
      if ((n || l !== (Q == null ? void 0 : Q.generator) || g !== (Q == null ? void 0 : Q.version) || I !== (Q == null ? void 0 : Q.base) || h !== (Q == null ? void 0 : Q.count)) && l && h > 0) {
        const C = e.apply(l);
        try {
          this.splats.generate({
            generator: C,
            base: I,
            count: h,
            renderer: A
          });
        } catch (B) {
          c.generator = void 0, c.generatorError = B;
        }
        a += 1;
      }
      o = Math.max(o, I + h);
    }
    return this.splats.numSplats = o, this.toWorld = i, this.mapping = s, a !== 0;
  }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  hasCorrespondence(A) {
    return this.mapping.length !== A.mapping.length ? !1 : this.mapping.every(({ node: e, base: s, count: n }, i) => {
      const {
        node: r,
        base: a,
        count: o
      } = A.mapping[i];
      return e === r && s === a && n === o;
    });
  }
}
var th = `const float LN_SCALE_MIN = -12.0;
const float LN_SCALE_MAX = 9.0;

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplatEncoding(
    vec3 center, vec3 scales, vec4 quaternion, vec4 rgba, vec4 rgbMinMaxLnScaleMinMax
) {
    float rgbMin = rgbMinMaxLnScaleMinMax.x;
    float rgbMax = rgbMinMaxLnScaleMinMax.y;
    vec3 encRgb = (rgba.rgb - vec3(rgbMin)) / (rgbMax - rgbMin);
    uvec4 uRgba = uvec4(round(clamp(vec4(encRgb, rgba.a) * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;
    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;
    float lnScaleScale = 254.0 / (lnScaleMax - lnScaleMin);
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - lnScaleMin) * lnScaleScale, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    return packSplatEncoding(center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));
}

void unpackSplatEncoding(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba, vec4 rgbMinMaxLnScaleMinMax) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    float rgbMin = rgbMinMaxLnScaleMinMax.x;
    float rgbMax = rgbMinMaxLnScaleMinMax.y;
    rgba = (vec4(uRgba) / 255.0);
    rgba.rgb = rgba.rgb * (rgbMax - rgbMin) + rgbMin;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    float lnScaleMin = rgbMinMaxLnScaleMinMax.z;
    float lnScaleMax = rgbMinMaxLnScaleMinMax.w;
    float lnScaleScale = (lnScaleMax - lnScaleMin) / 254.0;
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.x - 1u) * lnScaleScale),
        (uScales.y == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.y - 1u) * lnScaleScale),
        (uScales.z == 0u) ? 0.0 : exp(lnScaleMin + float(uScales.z - 1u) * lnScaleScale)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    unpackSplatEncoding(packed, center, scales, quaternion, rgba, vec4(0.0, 1.0, LN_SCALE_MIN, LN_SCALE_MAX));
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`, eh = `precision highp float;
precision highp int;

#include <splatDefines>

uniform float near;
uniform float far;
uniform bool encodeLinear;
uniform float time;
uniform bool debugFlag;
uniform float maxStdDev;
uniform float minAlpha;
uniform bool stochastic;
uniform bool disableFalloff;
uniform float falloff;

uniform bool splatTexEnable;
uniform sampler3D splatTexture;
uniform mat2 splatTexMul;
uniform vec2 splatTexAdd;
uniform float splatTexNear;
uniform float splatTexFar;
uniform float splatTexMid;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;
flat in uint vSplatIndex;

void main() {
    vec4 rgba = vRgba;

    float z = dot(vSplatUv, vSplatUv);
    if (!splatTexEnable) {
        if (z > (maxStdDev * maxStdDev)) {
            discard;
        }
    } else {
        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;
        float ndcZ = vNdc.z;
        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));
        float clampedFar = max(splatTexFar, splatTexNear);
        float clampedDepth = clamp(depth, splatTexNear, clampedFar);
        float logDepth = log2(clampedDepth + 1.0);
        float logNear = log2(splatTexNear + 1.0);
        float logFar = log2(clampedFar + 1.0);

        float texZ;
        if (splatTexMid > 0.0) {
            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);
            float logMid = log2(clampedMid + 1.0);
            texZ = (clampedDepth <= clampedMid) ?
                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :
                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);
        } else {
            texZ = (logDepth - logNear) / (logFar - logNear);
        }

        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));
        rgba *= modulate;
    }

    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);

    if (rgba.a < minAlpha) {
        discard;
    }
    if (encodeLinear) {
        rgba.rgb = srgbToLinear(rgba.rgb);
    }

    if (stochastic) {
        const bool STEADY = false;
        uint uTime = STEADY ? 0u : floatBitsToUint(time);
        uvec2 coord = uvec2(gl_FragCoord.xy);
        uint state = uTime + 0x9e3779b9u * coord.x + 0x85ebca6bu * coord.y + 0xc2b2ae35u * uint(vSplatIndex);
        state = state * 747796405u + 2891336453u;
        uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
        hash = (hash >> 22u) ^ hash;
        float rand = float(hash) / 4294967296.0;
        if (rand < rgba.a) {
            fragColor = vec4(rgba.rgb, 1.0);
        } else {
            discard;
        }
    } else {
        #ifdef PREMULTIPLIED_ALPHA
            fragColor = vec4(rgba.rgb * rgba.a, rgba.a);
        #else
            fragColor = rgba;
        #endif
    }
}`, sh = `precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;
flat out uint vSplatIndex;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float maxPixelRadius;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform float minAlpha;
uniform bool stochastic;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float focalDistance;
uniform float apertureAngle;
uniform float clipXY;
uniform float focalAdjustment;

uniform usampler2DArray packedSplats;
uniform vec4 rgbMinMaxLnScaleMinMax;

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }

    ivec3 texCoord;
    if (stochastic) {
        texCoord = ivec3(
            uint(gl_InstanceID) & SPLAT_TEX_WIDTH_MASK,
            (uint(gl_InstanceID) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
            (uint(gl_InstanceID) >> SPLAT_TEX_LAYER_BITS)
        );
    } else {
        if (splatIndex == 0xffffffffu) {
            
            return;
        }
        texCoord = ivec3(
            splatIndex & SPLAT_TEX_WIDTH_MASK,
            (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
            splatIndex >> SPLAT_TEX_LAYER_BITS
        );
    }
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplatEncoding(packed, center, scales, quaternion, rgba, rgbMinMaxLnScaleMinMax);

    if (rgba.a < minAlpha) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vSplatIndex = splatIndex;

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 scaledRenderSize = renderSize * focalAdjustment;
    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);

    mat3 J;
    if(isOrthographic) {
        J = mat3(
            focal.x, 0.0, 0.0,
            0.0, focal.y, 0.0,
            0.0, 0.0, 0.0
        );
    } else {
        float invZ = 1.0 / viewCenter.z;
        vec2 J1 = focal * invZ;
        vec2 J2 = -(J1 * viewCenter.xy) * invZ;
        J = mat3(
            J1.x, 0.0, J2.x,
            0.0, J1.y, J2.y,
            0.0, 0.0, 0.0
        );
    }

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    float fullBlurAmount = blurAmount;
    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {
        float focusRadius = maxPixelRadius;
        if (viewCenter.z < 0.0) {
            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);
            float apertureRadius = focal.x * tan(0.5 * apertureAngle);
            focusRadius = focusBlur * apertureRadius;
        }
        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(maxPixelRadius));
    }

    
    float detOrig = a * d - b * b;
    a += fullBlurAmount;
    d += fullBlurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < minAlpha) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = position.x * min(maxPixelRadius, maxStdDev * sqrt(eigen1));
    float scale2 = position.y * min(maxPixelRadius, maxStdDev * sqrt(eigen2));

    
    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
}`;
let Ne = null;
function nh() {
  return Ne || (u.ShaderChunk.splatDefines = th, Ne = {
    splatVertex: sh,
    splatFragment: eh
  }), Ne;
}
const ys = 5, oA = class oA extends u.Mesh {
  constructor(A) {
    const e = oA.makeUniforms(), s = nh(), n = A.premultipliedAlpha ?? !0, i = new u.ShaderMaterial({
      glslVersion: u.GLSL3,
      vertexShader: s.splatVertex,
      fragmentShader: s.splatFragment,
      uniforms: e,
      premultipliedAlpha: n,
      transparent: !0,
      depthTest: !0,
      depthWrite: !1,
      side: u.DoubleSide
    });
    super(ws, i), this.splatTexture = null, this.autoViewpoints = [], this.rotateToAccumulator = new Nt({ value: new u.Quaternion() }), this.translateToAccumulator = new Ft({ value: new u.Vector3() }), this.lastFrame = -1, this.lastUpdateTime = null, this.defaultCameras = [], this.lastStochastic = null, this.pendingUpdate = {
      scene: null,
      originToWorld: new u.Matrix4(),
      timeoutId: -1
    }, this.envViewpoint = null, this.frustumCulled = !1, this.renderer = A.renderer, this.material = i, this.uniforms = e;
    const r = vA(
      { gsplat: AA },
      { gsplat: AA },
      ({ gsplat: a }) => {
        if (!a)
          throw new Error("gsplat not defined");
        return a = As(a, {
          rotate: this.rotateToAccumulator,
          translate: this.translateToAccumulator
        }), { gsplat: a };
      }
    );
    this.modifier = new mu(r), this.premultipliedAlpha = n, this.autoUpdate = A.autoUpdate ?? !0, this.preUpdate = A.preUpdate ?? !1, this.needsUpdate = !1, this.originDistance = A.originDistance ?? 1, this.maxStdDev = A.maxStdDev ?? Math.sqrt(8), this.maxPixelRadius = A.maxPixelRadius ?? 512, this.minAlpha = A.minAlpha ?? 0.5 * (1 / 255), this.enable2DGS = A.enable2DGS ?? !1, this.preBlurAmount = A.preBlurAmount ?? 0, this.blurAmount = A.blurAmount ?? 0.3, this.focalDistance = A.focalDistance ?? 0, this.apertureAngle = A.apertureAngle ?? 0, this.falloff = A.falloff ?? 1, this.clipXY = A.clipXY ?? 1.4, this.focalAdjustment = A.focalAdjustment ?? 1, this.splatEncoding = A.splatEncoding ?? { ...de }, this.active = new Te(), this.accumulatorCount = 1, this.freeAccumulators = [];
    for (let a = 0; a < 1; ++a)
      this.freeAccumulators.push(new Te()), this.accumulatorCount += 1;
    this.defaultView = new Ce({
      ...A.view,
      autoUpdate: !0,
      spark: this
    }), this.viewpoint = this.defaultView, this.prepareViewpoint(this.viewpoint), this.clock = A.clock ? Vn(A.clock) : new u.Clock();
  }
  static makeUniforms() {
    return {
      // Size of render viewport in pixels
      renderSize: { value: new u.Vector2() },
      // Near and far plane distances
      near: { value: 0.1 },
      far: { value: 1e3 },
      // Total number of Gsplats in packedSplats to render
      numSplats: { value: 0 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new u.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new u.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Maximum pixel radius for splat rendering
      maxPixelRadius: { value: 512 },
      // Minimum alpha value for splat rendering
      minAlpha: { value: 0.00196078431372549 },
      // Enable stochastic splat rendering
      stochastic: { value: !1 },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: !1 },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Depth-of-field distance to focal plane
      focalDistance: { value: 0 },
      // Full-width angle of aperture opening (in radians)
      apertureAngle: { value: 0 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Debug renderSize scale factor
      focalAdjustment: { value: 1 },
      // Enable splat texture rendering
      splatTexEnable: { value: !1 },
      // Splat texture to render
      splatTexture: { type: "t", value: oA.EMPTY_SPLAT_TEXTURE },
      // Splat texture UV transform (multiply)
      splatTexMul: { value: new u.Matrix2() },
      // Splat texture UV transform (add)
      splatTexAdd: { value: new u.Vector2() },
      // Splat texture near plane distance
      splatTexNear: { value: 0.1 },
      // Splat texture far plane distance
      splatTexFar: { value: 1e3 },
      // Splat texture mid plane distance, or 0.0 to disable
      splatTexMid: { value: 0 },
      // Gsplat collection to render
      packedSplats: { type: "t", value: VA.getEmpty() },
      // Splat encoding ranges
      rgbMinMaxLnScaleMinMax: { value: new u.Vector4() },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: !1 },
      // Debug flag that alternates each frame
      debugFlag: { value: !1 }
    };
  }
  canAllocAccumulator() {
    return this.freeAccumulators.length > 0 || this.accumulatorCount < ys;
  }
  maybeAllocAccumulator() {
    let A = this.freeAccumulators.pop();
    if (A === void 0) {
      if (this.accumulatorCount >= ys)
        return null;
      A = new Te(), this.accumulatorCount += 1;
    }
    return A.refCount = 1, A;
  }
  releaseAccumulator(A) {
    A.refCount -= 1, A.refCount === 0 && this.freeAccumulators.push(A);
  }
  newViewpoint(A) {
    return new Ce({ ...A, spark: this });
  }
  onBeforeRender(A, e, s) {
    var h, Q;
    const n = this.time ?? this.clock.getElapsedTime(), i = n - (this.viewpoint.lastTime ?? n);
    this.viewpoint.lastTime = n;
    const r = A.info.render.frame, a = r !== this.lastFrame;
    this.lastFrame = r;
    const o = this.viewpoint;
    if (o === this.defaultView) {
      if (a)
        if (!A.xr.isPresenting)
          this.defaultView.viewToWorld = s.matrixWorld.clone(), this.defaultCameras = [this.defaultView.viewToWorld];
        else {
          const C = A.xr.getCamera().cameras;
          this.defaultCameras = C.map((B) => B.matrixWorld), this.defaultView.viewToWorld = ih(this.defaultCameras) ?? new u.Matrix4();
        }
      this.autoUpdate && this.update({ scene: e, viewToWorld: this.defaultView.viewToWorld });
    }
    if (a && (this.material.premultipliedAlpha !== this.premultipliedAlpha && (this.material.premultipliedAlpha = this.premultipliedAlpha, this.material.needsUpdate = !0), this.uniforms.time.value = n, this.uniforms.deltaTime.value = i, this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1, o.display && o.stochastic && (this.geometry.instanceCount = this.uniforms.numSplats.value)), o.target)
      this.uniforms.renderSize.value.set(
        o.target.width,
        o.target.height
      );
    else {
      const C = A.getDrawingBufferSize(
        this.uniforms.renderSize.value
      );
      if (C.x === 1 && C.y === 1) {
        const B = (h = A.xr.getSession()) == null ? void 0 : h.renderState.baseLayer;
        B && (C.x = B.framebufferWidth, C.y = B.framebufferHeight);
      }
    }
    const c = s;
    if (this.uniforms.near.value = c.near, this.uniforms.far.value = c.far, this.uniforms.encodeLinear.value = o.encodeLinear, this.uniforms.maxStdDev.value = this.maxStdDev, this.uniforms.maxPixelRadius.value = this.maxPixelRadius, this.uniforms.minAlpha.value = this.minAlpha, this.uniforms.stochastic.value = o.stochastic, this.uniforms.enable2DGS.value = this.enable2DGS, this.uniforms.preBlurAmount.value = this.preBlurAmount, this.uniforms.blurAmount.value = this.blurAmount, this.uniforms.focalDistance.value = this.focalDistance, this.uniforms.apertureAngle.value = this.apertureAngle, this.uniforms.falloff.value = this.falloff, this.uniforms.clipXY.value = this.clipXY, this.uniforms.focalAdjustment.value = this.focalAdjustment, this.lastStochastic !== !o.stochastic && (this.lastStochastic = !o.stochastic, this.material.transparent = !o.stochastic, this.material.depthWrite = o.stochastic, this.material.needsUpdate = !0), this.splatTexture) {
      const { enable: C, texture: B, multiply: E, add: p, near: f, far: d, mid: y } = this.splatTexture;
      C && B ? (this.uniforms.splatTexEnable.value = !0, this.uniforms.splatTexture.value = B, E ? this.uniforms.splatTexMul.value.fromArray(E.elements) : this.uniforms.splatTexMul.value.set(
        0.5 / this.maxStdDev,
        0,
        0,
        0.5 / this.maxStdDev
      ), this.uniforms.splatTexAdd.value.set((p == null ? void 0 : p.x) ?? 0.5, (p == null ? void 0 : p.y) ?? 0.5), this.uniforms.splatTexNear.value = f ?? this.uniforms.near.value, this.uniforms.splatTexFar.value = d ?? this.uniforms.far.value, this.uniforms.splatTexMid.value = y ?? 0) : (this.uniforms.splatTexEnable.value = !1, this.uniforms.splatTexture.value = oA.EMPTY_SPLAT_TEXTURE);
    } else
      this.uniforms.splatTexEnable.value = !1, this.uniforms.splatTexture.value = oA.EMPTY_SPLAT_TEXTURE;
    const l = ((Q = o.display) == null ? void 0 : Q.accumulator.toWorld) ?? new u.Matrix4(), g = s.matrixWorld.clone().invert();
    l.clone().premultiply(g).decompose(
      this.uniforms.renderToViewPos.value,
      this.uniforms.renderToViewQuat.value,
      new u.Vector3()
    );
  }
  // Update the uniforms for the given viewpoint.
  // Note that the client expects to be able to call render() at any point
  // to update the canvas, so we must switch the viewpoint back to
  // defaultView when we're finished.
  prepareViewpoint(A) {
    var e, s, n, i;
    if (this.viewpoint = A ?? this.viewpoint, this.viewpoint.display) {
      const { accumulator: r, geometry: a } = this.viewpoint.display;
      this.uniforms.numSplats.value = r.splats.numSplats, this.uniforms.packedSplats.value = r.splats.getTexture(), this.uniforms.rgbMinMaxLnScaleMinMax.value.set(
        ((e = r.splats.splatEncoding) == null ? void 0 : e.rgbMin) ?? 0,
        ((s = r.splats.splatEncoding) == null ? void 0 : s.rgbMax) ?? 1,
        ((n = r.splats.splatEncoding) == null ? void 0 : n.lnScaleMin) ?? UA,
        ((i = r.splats.splatEncoding) == null ? void 0 : i.lnScaleMax) ?? GA
      ), this.geometry = a, this.material.transparent = !this.viewpoint.stochastic, this.material.depthWrite = this.viewpoint.stochastic, this.material.needsUpdate = !0;
    } else
      this.uniforms.numSplats.value = 0, this.uniforms.packedSplats.value = VA.getEmpty(), this.geometry = ws;
  }
  // If spark.autoUpdate is false then you must manually call
  // spark.update({ scene }) to have the scene Gsplats be re-generated.
  update({
    scene: A,
    viewToWorld: e
  }) {
    const s = this.matrixWorld;
    this.preUpdate ? this.updateInternal({
      scene: A,
      originToWorld: s.clone(),
      viewToWorld: e
    }) : (this.pendingUpdate.scene = A, this.pendingUpdate.originToWorld.copy(s), this.pendingUpdate.timeoutId === -1 && (this.pendingUpdate.timeoutId = setTimeout(() => {
      const { scene: n, originToWorld: i } = this.pendingUpdate;
      this.pendingUpdate.scene = null, this.pendingUpdate.timeoutId = -1, this.updateInternal({
        scene: n,
        originToWorld: i,
        viewToWorld: e
      }) && this.renderer.getContext().flush();
    }, 1)));
  }
  updateInternal({
    scene: A,
    originToWorld: e,
    viewToWorld: s
  }) {
    var Q;
    if (!this.canAllocAccumulator())
      return !1;
    e || (e = this.active.toWorld), s = s ?? e.clone();
    const n = this.time ?? this.clock.getElapsedTime(), i = n - (this.lastUpdateTime ?? n);
    this.lastUpdateTime = n;
    const r = this.active.mapping.reduce((C, B) => (C.set(B.node, B), C), /* @__PURE__ */ new Map()), { generators: a, visibleGenerators: o, globalEdits: c } = this.compileScene(A);
    for (const C of a)
      (Q = C.frameUpdate) == null || Q.call(C, {
        object: C,
        time: n,
        deltaTime: i,
        viewToWorld: s,
        globalEdits: c
      });
    const l = new Set(o.map((C) => C.uuid));
    for (const C of a) {
      const B = r.get(C), p = C.generator && l.has(C.uuid) ? C.numSplats : 0;
      (this.needsUpdate || C.generator !== (B == null ? void 0 : B.generator) || p !== (B == null ? void 0 : B.count)) && C.updateVersion();
    }
    const g = !ce({
      matrix1: e,
      matrix2: this.active.toWorld,
      maxDistance: this.originDistance
    }), I = this.needsUpdate || g || a.length !== r.size || a.some((C) => {
      var B;
      return C.version !== ((B = r.get(C)) == null ? void 0 : B.version);
    });
    this.needsUpdate = !1;
    let h = null;
    if (I) {
      if (h = this.maybeAllocAccumulator(), !h)
        throw new Error("Unreachable");
      const C = !ce({
        matrix1: e,
        matrix2: this.active.toWorld,
        maxDistance: 1e-5,
        minCoorient: 0.99999
      }), E = o.map((x, w) => {
        const m = r.get(x);
        return m ? (
          // Sort by version deltas then by previous ordering in the mapping,
          // attempting to keep unchanging generators near the front
          // to improve our chances of avoiding a re-generation.
          [x.version - m.version, m.base, x]
        ) : [Number.POSITIVE_INFINITY, x.version, x];
      }).sort((x, w) => x[0] !== w[0] ? x[0] - w[0] : x[1] - w[1]).map(([x, w, m]) => m), p = E.map((x) => x.numSplats), { maxSplats: f, mapping: d } = h.splats.generateMapping(p), y = E.map((x, w) => {
        const { base: m, count: T } = d[w];
        return {
          node: x,
          generator: x.generator,
          version: x.version,
          base: m,
          count: T
        };
      });
      e.clone().invert().decompose(
        this.translateToAccumulator.value,
        this.rotateToAccumulator.value,
        new u.Vector3()
      ), h.ensureGenerate(f), h.splats.splatEncoding = { ...this.splatEncoding }, h.generateSplats({
        renderer: this.renderer,
        modifier: this.modifier,
        generators: y,
        forceUpdate: C,
        originToWorld: e
      }), h.splatsVersion = this.active.splatsVersion + 1;
      const D = h.hasCorrespondence(this.active);
      h.mappingVersion = this.active.mappingVersion + (D ? 0 : 1), this.releaseAccumulator(this.active), this.active = h, this.prepareViewpoint();
    }
    return setTimeout(() => {
      for (const C of this.autoViewpoints)
        C.autoPoll({ accumulator: h ?? void 0 });
    }, 1), !0;
  }
  compileScene(A) {
    const e = [];
    A.traverse((i) => {
      i instanceof Vt && e.push(i);
    });
    const s = [];
    A.traverseVisible((i) => {
      i instanceof Vt && s.push(i);
    });
    const n = /* @__PURE__ */ new Set();
    return A.traverseVisible((i) => {
      if (i instanceof Ie) {
        let r = i.parent;
        for (; r != null && !(r instanceof ft); )
          r = r.parent;
        r == null && n.add(i);
      }
    }), {
      generators: e,
      visibleGenerators: s,
      globalEdits: Array.from(n)
    };
  }
  // Renders out the scene to an environment map that can be used for
  // Image-based lighting or similar applications. First optionally updates Gsplats,
  // sorts them with respect to the provided worldCenter, renders 6 cube faces,
  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture
  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.
  async renderEnvMap({
    renderer: A,
    scene: e,
    worldCenter: s,
    size: n = 256,
    near: i = 0.1,
    far: r = 1e3,
    hideObjects: a = [],
    update: o = !1
  }) {
    var h, Q;
    if (this.envViewpoint || (this.envViewpoint = this.newViewpoint({ sort360: !0 })), !oA.cubeRender || oA.cubeRender.target.width !== n || oA.cubeRender.near !== i || oA.cubeRender.far !== r) {
      oA.cubeRender && oA.cubeRender.target.dispose();
      const C = new u.WebGLCubeRenderTarget(n, {
        format: u.RGBAFormat,
        generateMipmaps: !0,
        minFilter: u.LinearMipMapLinearFilter
      }), B = new u.CubeCamera(i, r, C);
      oA.cubeRender = { target: C, camera: B, near: i, far: r };
    }
    oA.pmrem || (oA.pmrem = new u.PMREMGenerator(A ?? this.renderer));
    const c = new u.Matrix4().setPosition(s);
    await ((h = this.envViewpoint) == null ? void 0 : h.prepare({ scene: e, viewToWorld: c, update: o }));
    const { target: l, camera: g } = oA.cubeRender;
    g.position.copy(s);
    const I = /* @__PURE__ */ new Map();
    for (const C of a)
      I.set(C, C.visible), C.visible = !1;
    this.prepareViewpoint(this.envViewpoint), g.update(A ?? this.renderer, e), this.prepareViewpoint(this.defaultView);
    for (const [C, B] of I.entries())
      C.visible = B;
    return (Q = oA.pmrem) == null ? void 0 : Q.fromCubemap(l.texture).texture;
  }
  // Utility function to recursively set the envMap property for any
  // THREE.MeshStandardMaterial within the subtree of root.
  recurseSetEnvMap(A, e) {
    A.traverse((s) => {
      if (s instanceof u.Mesh)
        if (Array.isArray(s.material))
          for (const n of s.material)
            n instanceof u.MeshStandardMaterial && (n.envMap = e);
        else
          s.material instanceof u.MeshStandardMaterial && (s.material.envMap = e);
    });
  }
  // Utility function that helps extract the Gsplat RGBA values from a
  // SplatGenerator, including the result of any real-time RGBA SDF edits applied
  // to a SplatMesh. This effectively "bakes" any computed RGBA values, which can
  // now be used as a pipeline input via SplatMesh.splatRgba to inject these
  // baked values into the Gsplat data.
  getRgba({
    generator: A,
    rgba: e
  }) {
    const s = this.active.mapping.find(({ node: n }) => n === A);
    if (!s)
      throw new Error("Generator not found");
    return e = e ?? new Ke(), e.fromPackedSplats({
      packedSplats: this.active.splats,
      base: s.base,
      count: s.count,
      renderer: this.renderer
    }), e;
  }
  // Utility function that builds on getRgba({ generator }) and additionally
  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA
  // in that byte order.
  async readRgba({
    generator: A,
    rgba: e
  }) {
    return e = this.getRgba({ generator: A, rgba: e }), e.read();
  }
};
oA.cubeRender = null, oA.pmrem = null, oA.EMPTY_SPLAT_TEXTURE = new u.Data3DTexture();
let Be = oA;
const ws = new Ve(new Uint32Array(1), 0);
vA(
  { packedSplats: jt, index: "int" },
  { gsplat: AA },
  ({ packedSplats: t, index: A }) => {
    if (!t || !A)
      throw new Error("Invalid input");
    return { gsplat: bt(t, A) };
  }
);
function ih(t) {
  if (t.length === 0)
    return null;
  const A = new u.Vector3(), e = new u.Quaternion(), s = new u.Vector3(), n = [], i = [];
  for (const r of t)
    r.decompose(A, e, s), n.push(A), i.push(e);
  return new u.Matrix4().compose(
    Xn(n),
    On(i),
    new u.Vector3(1, 1, 1)
  );
}
function rh(t, A, e) {
  const s = Math.floor(t.length / 32);
  if (s * 32 !== t.length)
    throw new Error("Invalid .splat file size");
  const n = new Float32Array(t.buffer);
  for (let i = 0; i < s; ++i) {
    const r = i * 32, a = i * 8, o = n[a + 0], c = n[a + 1], l = n[a + 2], g = n[a + 3], I = n[a + 4], h = n[a + 5], Q = t[r + 24] / 255, C = t[r + 25] / 255, B = t[r + 26] / 255, E = t[r + 27] / 255, p = (t[r + 28] - 128) / 128, f = (t[r + 29] - 128) / 128, d = (t[r + 30] - 128) / 128, y = (t[r + 31] - 128) / 128;
    e(
      i,
      o,
      c,
      l,
      g,
      I,
      h,
      f,
      d,
      y,
      p,
      E,
      Q,
      C,
      B
    );
  }
}
const ms = {
  0: {
    bytesPerCenter: 12,
    bytesPerScale: 12,
    bytesPerRotation: 16,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 4,
    scaleOffsetBytes: 12,
    rotationOffsetBytes: 24,
    colorOffsetBytes: 40,
    sphericalHarmonicsOffsetBytes: 44,
    scaleRange: 1
  },
  1: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 2,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  },
  2: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 1,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  }
}, ah = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function oh(t, A, e, s) {
  var C;
  let r = 0;
  const a = new DataView(t.buffer, r, 4096);
  r += 4096;
  const o = a.getUint8(0), c = a.getUint8(1);
  if (o !== 0 || c < 1)
    throw new Error(
      `Unsupported .ksplat version: ${o}.${c}`
    );
  const l = a.getUint32(4, !0);
  a.getUint32(16, !0);
  const g = a.getUint16(20, !0);
  if (g < 0 || g > 2)
    throw new Error(`Invalid .ksplat compression level: ${g}`);
  const I = a.getFloat32(36, !0) || -1.5, h = a.getFloat32(40, !0) || 1.5;
  let Q = 4096 + l * 1024;
  for (let B = 0; B < l; ++B) {
    let E = function(MA, z) {
      if (g === 0)
        return Y.getFloat32(
          MA + P + z * 4,
          !0
        );
      if (g === 1)
        return wA(
          Y.getUint16(
            MA + P + z * 2,
            !0
          )
        );
      const XA = Y.getUint8(MA + P + z) / 255;
      return I + XA * (h - I);
    };
    const p = new DataView(t.buffer, r, 1024);
    r += 1024;
    const f = p.getUint32(0, !0), d = p.getUint32(4, !0), y = p.getUint32(8, !0), D = p.getUint32(12, !0), x = p.getFloat32(16, !0), w = p.getUint16(20, !0), m = (p.getUint32(24, !0) || ((C = ms[g]) == null ? void 0 : C.scaleRange)) ?? 1, T = p.getUint32(32, !0), M = T * y, S = p.getUint32(36, !0), U = S * 4, F = w * D + U, b = p.getUint16(40, !0), N = ah[b], {
      bytesPerCenter: R,
      bytesPerScale: O,
      bytesPerRotation: _,
      bytesPerColor: eA,
      bytesPerSphericalHarmonicsComponent: H,
      scaleOffsetBytes: W,
      rotationOffsetBytes: L,
      colorOffsetBytes: j,
      sphericalHarmonicsOffsetBytes: P
    } = ms[g], Z = R + O + _ + eA + N * H, G = Z * d, fA = G + F, cA = [0, 3, 6, 1, 4, 7, 2, 5, 8], pA = [
      9,
      14,
      19,
      10,
      15,
      20,
      11,
      16,
      21,
      12,
      17,
      22,
      13,
      18,
      23
    ], dA = [
      24,
      31,
      38,
      25,
      32,
      39,
      26,
      33,
      40,
      27,
      34,
      41,
      28,
      35,
      42,
      29,
      36,
      43,
      30,
      37,
      44
    ], xA = b >= 1 ? new Float32Array(3 * 3) : void 0, CA = b >= 2 ? new Float32Array(5 * 3) : void 0, YA = b >= 3 ? new Float32Array(7 * 3) : void 0, SA = x / 2 / m, WA = Q + U, jA = Q + F, Y = new DataView(
      t.buffer,
      jA,
      G
    ), DA = new Float32Array(
      t.buffer,
      WA,
      D * 3
    ), lA = new Uint32Array(
      t.buffer,
      Q,
      S
    );
    let Gt = T, Ae = M;
    for (let MA = 0; MA < f; ++MA) {
      const z = MA * Z;
      let XA;
      if (MA < M)
        XA = Math.floor(MA / y);
      else {
        const ZA = lA[Gt - T];
        MA >= Ae + ZA && (Gt += 1, Ae += ZA), XA = Gt;
      }
      const ye = g === 0 ? Y.getFloat32(z + 0, !0) : (Y.getUint16(z + 0, !0) - m) * SA + DA[3 * XA + 0], we = g === 0 ? Y.getFloat32(z + 4, !0) : (Y.getUint16(z + 2, !0) - m) * SA + DA[3 * XA + 1], me = g === 0 ? Y.getFloat32(z + 8, !0) : (Y.getUint16(z + 4, !0) - m) * SA + DA[3 * XA + 2], xe = g === 0 ? Y.getFloat32(z + W + 0, !0) : wA(Y.getUint16(z + W + 0, !0)), Se = g === 0 ? Y.getFloat32(z + W + 4, !0) : wA(Y.getUint16(z + W + 2, !0)), co = g === 0 ? Y.getFloat32(z + W + 8, !0) : wA(Y.getUint16(z + W + 4, !0)), lo = g === 0 ? Y.getFloat32(z + L + 0, !0) : wA(
        Y.getUint16(z + L + 0, !0)
      ), Io = g === 0 ? Y.getFloat32(z + L + 4, !0) : wA(
        Y.getUint16(z + L + 2, !0)
      ), uo = g === 0 ? Y.getFloat32(z + L + 8, !0) : wA(
        Y.getUint16(z + L + 4, !0)
      ), ho = g === 0 ? Y.getFloat32(z + L + 12, !0) : wA(
        Y.getUint16(z + L + 6, !0)
      ), Co = Y.getUint8(z + j + 0) / 255, Bo = Y.getUint8(z + j + 1) / 255, Qo = Y.getUint8(z + j + 2) / 255, Eo = Y.getUint8(z + j + 3) / 255;
      if (e(
        MA,
        ye,
        we,
        me,
        xe,
        Se,
        co,
        Io,
        uo,
        ho,
        lo,
        Eo,
        Co,
        Bo,
        Qo
      ), b >= 1 && xA) {
        for (const [ZA, Rt] of cA.entries())
          xA[ZA] = E(z, Rt);
        if (CA)
          for (const [ZA, Rt] of pA.entries())
            CA[ZA] = E(z, Rt);
        if (YA)
          for (const [ZA, Rt] of dA.entries())
            YA[ZA] = E(z, Rt);
        s == null || s(MA, xA, CA, YA);
      }
    }
    Q += fA;
  }
}
class gh {
  constructor({ fileBytes: A }) {
    this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A, this.reader = new ti({ fileBytes: this.fileBytes });
    const e = new DataView(this.reader.read(16).buffer);
    if (e.getUint32(0, !0) !== 1347635022)
      throw new Error("Invalid SPZ file");
    if (this.version = e.getUint32(4, !0), this.version < 1 || this.version > 3)
      throw new Error(`Unsupported SPZ version: ${this.version}`);
    this.numSplats = e.getUint32(8, !0), this.shDegree = e.getUint8(12), this.fractionalBits = e.getUint8(13), this.flags = e.getUint8(14), this.flagAntiAlias = (this.flags & 1) !== 0, this.reserved = e.getUint8(15), this.parsed = !1;
  }
  parseSplats(A, e, s, n, i, r) {
    if (this.parsed)
      throw new Error("SPZ file already parsed");
    if (this.parsed = !0, this.version === 1) {
      const a = this.reader.read(this.numSplats * 3 * 2), o = new Uint16Array(a.buffer);
      for (let c = 0; c < this.numSplats; c++) {
        const l = c * 3, g = wA(o[l]), I = wA(o[l + 1]), h = wA(o[l + 2]);
        A == null || A(c, g, I, h);
      }
    } else if (this.version === 2 || this.version === 3) {
      const a = 1 << this.fractionalBits, o = this.reader.read(this.numSplats * 3 * 3);
      for (let c = 0; c < this.numSplats; c++) {
        const l = c * 9, g = ((o[l + 2] << 24 | o[l + 1] << 16 | o[l] << 8) >> 8) / a, I = ((o[l + 5] << 24 | o[l + 4] << 16 | o[l + 3] << 8) >> 8) / a, h = ((o[l + 8] << 24 | o[l + 7] << 16 | o[l + 6] << 8) >> 8) / a;
        A == null || A(c, g, I, h);
      }
    } else
      throw new Error("Unreachable");
    {
      const a = this.reader.read(this.numSplats);
      for (let o = 0; o < this.numSplats; o++)
        e == null || e(o, a[o] / 255);
    }
    {
      const a = this.reader.read(this.numSplats * 3), o = so / 0.15;
      for (let c = 0; c < this.numSplats; c++) {
        const l = c * 3, g = (a[l] / 255 - 0.5) * o + 0.5, I = (a[l + 1] / 255 - 0.5) * o + 0.5, h = (a[l + 2] / 255 - 0.5) * o + 0.5;
        s == null || s(c, g, I, h);
      }
    }
    {
      const a = this.reader.read(this.numSplats * 3);
      for (let o = 0; o < this.numSplats; o++) {
        const c = o * 3, l = Math.exp(a[c] / 16 - 10), g = Math.exp(a[c + 1] / 16 - 10), I = Math.exp(a[c + 2] / 16 - 10);
        n == null || n(o, l, g, I);
      }
    }
    if (this.version === 3) {
      const a = 1 / Math.sqrt(2), o = this.reader.read(this.numSplats * 4);
      for (let c = 0; c < this.numSplats; c++) {
        const l = c * 4, g = [0, 0, 0, 0], I = [
          o[l],
          o[l + 1],
          o[l + 2],
          o[l + 3]
        ], h = I[0] + (I[1] << 8) + (I[2] << 16) + (I[3] << 24), Q = 511, C = h >>> 30;
        let B = h, E = 0;
        for (let f = 3; f >= 0; --f)
          if (f !== C) {
            const d = B & Q, y = B >>> 9 & 1;
            B = B >>> 10, g[f] = a * (d / Q), g[f] = y === 0 ? g[f] : -g[f], E += g[f] * g[f];
          }
        const p = 1 - E;
        g[C] = Math.sqrt(Math.max(p, 0)), i == null || i(
          c,
          g[0],
          g[1],
          g[2],
          g[3]
        );
      }
    } else {
      const a = this.reader.read(this.numSplats * 3);
      for (let o = 0; o < this.numSplats; o++) {
        const c = o * 3, l = a[c] / 127.5 - 1, g = a[c + 1] / 127.5 - 1, I = a[c + 2] / 127.5 - 1, h = Math.sqrt(
          Math.max(0, 1 - l * l - g * g - I * I)
        );
        i == null || i(o, l, g, I, h);
      }
    }
    if (r && this.shDegree >= 1) {
      const a = new Float32Array(9), o = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0, c = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0, l = this.reader.read(
        this.numSplats * eo[this.shDegree] * 3
      );
      let g = 0;
      for (let I = 0; I < this.numSplats; I++) {
        for (let h = 0; h < 9; ++h)
          a[h] = (l[g + h] - 128) / 128;
        if (g += 9, o) {
          for (let h = 0; h < 15; ++h)
            o[h] = (l[g + h] - 128) / 128;
          g += 15;
        }
        if (c) {
          for (let h = 0; h < 21; ++h)
            c[h] = (l[g + h] - 128) / 128;
          g += 21;
        }
        r == null || r(I, a, o, c);
      }
    }
  }
}
const eo = { 1: 3, 2: 8, 3: 15 }, so = 0.28209479177387814, ch = 1347635022, lh = 3, Ih = 1;
class et {
  constructor({
    numSplats: A,
    shDegree: e,
    fractionalBits: s = 12,
    flagAntiAlias: n = !0
  }) {
    this.clippedCount = 0;
    const i = 20 + // Rotation
    (e >= 1 ? 9 : 0) + (e >= 2 ? 15 : 0) + (e >= 3 ? 21 : 0), r = 16 + A * i;
    this.buffer = new ArrayBuffer(r), this.view = new DataView(this.buffer), this.view.setUint32(0, ch, !0), this.view.setUint32(4, lh, !0), this.view.setUint32(8, A, !0), this.view.setUint8(12, e), this.view.setUint8(13, s), this.view.setUint8(14, n ? Ih : 0), this.view.setUint8(15, 0), this.numSplats = A, this.shDegree = e, this.fractionalBits = s, this.fraction = 1 << s, this.flagAntiAlias = n;
  }
  setCenter(A, e, s, n) {
    const i = Math.round(e * this.fraction), r = Math.max(-8388607, Math.min(8388607, i)), a = Math.round(s * this.fraction), o = Math.max(-8388607, Math.min(8388607, a)), c = Math.round(n * this.fraction), l = Math.max(-8388607, Math.min(8388607, c));
    (i !== r || a !== o || c !== l) && (this.clippedCount += 1);
    const h = 16 + A * 9;
    this.view.setUint8(h, r & 255), this.view.setUint8(h + 1, r >> 8 & 255), this.view.setUint8(h + 2, r >> 16 & 255), this.view.setUint8(h + 3, o & 255), this.view.setUint8(h + 4, o >> 8 & 255), this.view.setUint8(h + 5, o >> 16 & 255), this.view.setUint8(h + 6, l & 255), this.view.setUint8(h + 7, l >> 8 & 255), this.view.setUint8(h + 8, l >> 16 & 255);
  }
  setAlpha(A, e) {
    const s = 16 + this.numSplats * 9 + A;
    this.view.setUint8(
      s,
      Math.max(0, Math.min(255, Math.round(e * 255)))
    );
  }
  static scaleRgb(A) {
    const e = ((A - 0.5) / (so / 0.15) + 0.5) * 255;
    return Math.max(0, Math.min(255, Math.round(e)));
  }
  setRgb(A, e, s, n) {
    const i = 16 + this.numSplats * 10 + A * 3;
    this.view.setUint8(i, et.scaleRgb(e)), this.view.setUint8(i + 1, et.scaleRgb(s)), this.view.setUint8(i + 2, et.scaleRgb(n));
  }
  setScale(A, e, s, n) {
    const i = 16 + this.numSplats * 13 + A * 3;
    this.view.setUint8(
      i,
      Math.max(0, Math.min(255, Math.round((Math.log(e) + 10) * 16)))
    ), this.view.setUint8(
      i + 1,
      Math.max(0, Math.min(255, Math.round((Math.log(s) + 10) * 16)))
    ), this.view.setUint8(
      i + 2,
      Math.max(0, Math.min(255, Math.round((Math.log(n) + 10) * 16)))
    );
  }
  setQuat(A, ...e) {
    const s = 16 + this.numSplats * 16 + A * 4, n = qn(e);
    let i = 0;
    for (let o = 1; o < 4; ++o)
      Math.abs(n[o]) > Math.abs(n[i]) && (i = o);
    const r = n[i] < 0 ? 1 : 0;
    let a = i;
    for (let o = 0; o < 4; ++o)
      if (o !== i) {
        const c = (n[o] < 0 ? 1 : 0) ^ r, l = Math.floor(
          511 * (Math.abs(n[o]) / Math.SQRT1_2) + 0.5
        );
        a = a << 10 | c << 9 | l;
      }
    this.view.setUint8(s, a & 255), this.view.setUint8(s + 1, a >> 8 & 255), this.view.setUint8(s + 2, a >> 16 & 255), this.view.setUint8(s + 3, a >>> 24 & 255);
  }
  static quantizeSh(A, e) {
    const s = Math.round(A * 128) + 128, n = 1 << 8 - e, i = Math.floor((s + n / 2) / n) * n;
    return Math.max(0, Math.min(255, i));
  }
  setSh(A, e, s, n) {
    const i = eo[this.shDegree] || 0, r = 16 + this.numSplats * 20 + A * i * 3;
    for (let a = 0; a < 9; ++a)
      this.view.setUint8(r + a, et.quantizeSh(e[a], 5));
    if (s) {
      const a = r + 9;
      for (let o = 0; o < 15; ++o)
        this.view.setUint8(a + o, et.quantizeSh(s[o], 4));
      if (n) {
        const o = a + 15;
        for (let c = 0; c < 21; ++c)
          this.view.setUint8(o + c, et.quantizeSh(n[c], 4));
      }
    }
  }
  async finalize() {
    const A = new Uint8Array(this.buffer), s = new ReadableStream({
      async start(r) {
        r.enqueue(A), r.close();
      }
    }).pipeThrough(new CompressionStream("gzip")), i = await new Response(s).arrayBuffer();
    return console.log(
      "Compressed",
      A.length,
      "bytes to",
      i.byteLength,
      "bytes"
    ), new Uint8Array(i);
  }
}
async function Oh(t) {
  var l, g, I;
  const A = new Ou(), {
    inputs: e,
    clipXyz: s,
    maxSh: n,
    fractionalBits: i = 12,
    opacityThreshold: r
  } = t;
  for (const h of e) {
    let Q = function(w) {
      return w.multiplyScalar(f), w.applyQuaternion(d), w.add(y), w;
    }, C = function(w) {
      return w.multiplyScalar(f), w;
    }, B = function(w) {
      return w.premultiply(d), w;
    }, E = function(w) {
      return !D || D.containsPoint(w);
    }, p = function(w) {
      return r !== void 0 ? w >= r : !0;
    };
    const f = ((l = h.transform) == null ? void 0 : l.scale) ?? 1, d = new u.Quaternion().fromArray(
      ((g = h.transform) == null ? void 0 : g.quaternion) ?? [0, 0, 0, 1]
    ), y = new u.Vector3().fromArray(
      ((I = h.transform) == null ? void 0 : I.translate) ?? [0, 0, 0]
    ), D = s ? new u.Box3(
      new u.Vector3().fromArray(s.min),
      new u.Vector3().fromArray(s.max)
    ) : void 0;
    let x = h.fileType;
    switch (x || (x = Za(h.fileBytes), !x && h.pathOrUrl && (x = Ao(h.pathOrUrl))), x) {
      case _t.PLY: {
        const w = new ue({ fileBytes: h.fileBytes });
        await w.parseHeader();
        let m = null;
        w.parseSplats(
          (T, M, S, U, F, b, N, R, O, _, eA, H, W, L, j) => {
            const P = Q(new u.Vector3(M, S, U));
            if (E(P) && p(H)) {
              m = A.pushSplat(), A.setCenter(m, P.x, P.y, P.z);
              const Z = C(
                new u.Vector3(F, b, N)
              );
              A.setScale(m, Z.x, Z.y, Z.z);
              const G = B(
                new u.Quaternion(R, O, _, eA)
              );
              A.setQuaternion(
                m,
                G.x,
                G.y,
                G.z,
                G.w
              ), A.setOpacity(m, H), A.setColor(m, W, L, j);
            } else
              m = null;
          },
          (T, M, S, U) => {
            M && m !== null && A.setSh1(m, M), S && m !== null && A.setSh2(m, S), U && m !== null && A.setSh3(m, U);
          }
        );
        break;
      }
      case _t.SPZ: {
        const w = new gh({ fileBytes: h.fileBytes }), m = new Int32Array(w.numSplats);
        m.fill(-1);
        const T = new Float32Array(w.numSplats * 3), M = new u.Vector3();
        w.parseSplats(
          (S, U, F, b) => {
            const N = Q(new u.Vector3(U, F, b));
            T[S * 3] = N.x, T[S * 3 + 1] = N.y, T[S * 3 + 2] = N.z;
          },
          (S, U) => {
            M.fromArray(T, S * 3), E(M) && p(U) && (m[S] = A.pushSplat(), A.setCenter(m[S], M.x, M.y, M.z), A.setOpacity(m[S], U));
          },
          (S, U, F, b) => {
            m[S] >= 0 && A.setColor(m[S], U, F, b);
          },
          (S, U, F, b) => {
            if (m[S] >= 0) {
              const N = C(
                new u.Vector3(U, F, b)
              );
              A.setScale(m[S], N.x, N.y, N.z);
            }
          },
          (S, U, F, b, N) => {
            if (m[S] >= 0) {
              const R = B(
                new u.Quaternion(U, F, b, N)
              );
              A.setQuaternion(
                m[S],
                R.x,
                R.y,
                R.z,
                R.w
              );
            }
          },
          (S, U, F, b) => {
            m[S] >= 0 && (A.setSh1(m[S], U), F && A.setSh2(m[S], F), b && A.setSh3(m[S], b));
          }
        );
        break;
      }
      case _t.SPLAT:
        rh(
          h.fileBytes,
          (w) => {
          },
          (w, m, T, M, S, U, F, b, N, R, O, _, eA, H, W) => {
            const L = Q(new u.Vector3(m, T, M));
            if (E(L) && p(_)) {
              const j = A.pushSplat();
              A.setCenter(j, L.x, L.y, L.z);
              const P = C(
                new u.Vector3(S, U, F)
              );
              A.setScale(j, P.x, P.y, P.z);
              const Z = B(
                new u.Quaternion(b, N, R, O)
              );
              A.setQuaternion(
                j,
                Z.x,
                Z.y,
                Z.z,
                Z.w
              ), A.setOpacity(j, _), A.setColor(j, eA, H, W);
            }
          }
        );
        break;
      case _t.KSPLAT: {
        let w = null;
        oh(
          h.fileBytes,
          (m) => {
          },
          (m, T, M, S, U, F, b, N, R, O, _, eA, H, W, L) => {
            const j = Q(new u.Vector3(T, M, S));
            if (E(j) && p(eA)) {
              w = A.pushSplat(), A.setCenter(w, j.x, j.y, j.z);
              const P = C(
                new u.Vector3(U, F, b)
              );
              A.setScale(w, P.x, P.y, P.z);
              const Z = B(
                new u.Quaternion(N, R, O, _)
              );
              A.setQuaternion(
                w,
                Z.x,
                Z.y,
                Z.z,
                Z.w
              ), A.setOpacity(w, eA), A.setColor(w, H, W, L);
            } else
              w = null;
          },
          (m, T, M, S) => {
            w !== null && (A.setSh1(w, T), M && A.setSh2(w, M), S && A.setSh3(w, S));
          }
        );
        break;
      }
      default:
        throw new Error(`transcodeSpz not implemented for ${x}`);
    }
  }
  const a = Math.min(
    n ?? 3,
    A.sh3 ? 3 : A.sh2 ? 2 : A.sh1 ? 1 : 0
  ), o = new et({
    numSplats: A.numSplats,
    shDegree: a,
    fractionalBits: i,
    flagAntiAlias: !0
  });
  for (let h = 0; h < A.numSplats; ++h) {
    const Q = h * 3, C = h * 4;
    o.setCenter(
      h,
      A.centers[Q],
      A.centers[Q + 1],
      A.centers[Q + 2]
    ), o.setScale(
      h,
      A.scales[Q],
      A.scales[Q + 1],
      A.scales[Q + 2]
    ), o.setQuat(
      h,
      A.quaternions[C],
      A.quaternions[C + 1],
      A.quaternions[C + 2],
      A.quaternions[C + 3]
    ), o.setAlpha(h, A.opacities[h]), o.setRgb(
      h,
      A.colors[Q],
      A.colors[Q + 1],
      A.colors[Q + 2]
    ), A.sh1 && a >= 1 && o.setSh(
      h,
      A.sh1.slice(h * 9, (h + 1) * 9),
      a >= 2 && A.sh2 ? A.sh2.slice(h * 15, (h + 1) * 15) : void 0,
      a >= 3 && A.sh3 ? A.sh3.slice(h * 21, (h + 1) * 21) : void 0
    );
  }
  return { fileBytes: await o.finalize(), clippedCount: o.clippedCount };
}
class Wh {
  constructor(A) {
    this.mesh = A.mesh, this.numSplats = A.numSplats ?? this.mesh.numSplats;
    const { width: e, height: s, depth: n, maxSplats: i } = mA(this.numSplats);
    this.skinData = new Uint16Array(i * 4), this.skinTexture = new u.DataArrayTexture(
      this.skinData,
      e,
      s,
      n
    ), this.skinTexture.format = u.RGBAIntegerFormat, this.skinTexture.type = u.UnsignedShortType, this.skinTexture.internalFormat = "RGBA16UI", this.skinTexture.needsUpdate = !0, this.numBones = A.numBones ?? 256, this.boneData = new Float32Array(this.numBones * 16), this.boneTexture = new u.DataTexture(
      this.boneData,
      4,
      this.numBones,
      u.RGBAFormat,
      u.FloatType
    ), this.boneTexture.internalFormat = "RGBA32F", this.boneTexture.needsUpdate = !0, this.uniform = new k({
      key: "skinning",
      type: no,
      globals: () => [io],
      value: {
        numSplats: this.numSplats,
        numBones: this.numBones,
        skinTexture: this.skinTexture,
        boneTexture: this.boneTexture
      }
    });
  }
  // Apply the skeletal animation to a Gsplat in a dyno program.
  modify(A) {
    return hh(A, this.uniform);
  }
  // Set the "rest" pose for a bone with position and quaternion orientation.
  setRestQuatPos(A, e, s) {
    const n = A * 16;
    this.boneData[n + 0] = e.x, this.boneData[n + 1] = e.y, this.boneData[n + 2] = e.z, this.boneData[n + 3] = e.w, this.boneData[n + 4] = s.x, this.boneData[n + 5] = s.y, this.boneData[n + 6] = s.z, this.boneData[n + 7] = 0, this.boneData[n + 8] = 0, this.boneData[n + 9] = 0, this.boneData[n + 10] = 0, this.boneData[n + 11] = 1, this.boneData[n + 12] = 0, this.boneData[n + 13] = 0, this.boneData[n + 14] = 0, this.boneData[n + 15] = 0;
  }
  // Set the "current" position and orientation of a bone.
  setBoneQuatPos(A, e, s) {
    const n = A * 16, i = new u.Quaternion(
      this.boneData[n + 0],
      this.boneData[n + 1],
      this.boneData[n + 2],
      this.boneData[n + 3]
    ), r = new u.Vector3(
      this.boneData[n + 4],
      this.boneData[n + 5],
      this.boneData[n + 6]
    ), a = i.clone().invert(), o = s.clone().sub(r);
    o.applyQuaternion(a), a.multiply(e);
    const c = new u.Quaternion(
      o.x,
      o.y,
      o.z,
      0
    ).multiply(i);
    this.boneData[n + 8] = a.x, this.boneData[n + 9] = a.y, this.boneData[n + 10] = a.z, this.boneData[n + 11] = a.w, this.boneData[n + 12] = 0.5 * c.x, this.boneData[n + 13] = 0.5 * c.y, this.boneData[n + 14] = 0.5 * c.z, this.boneData[n + 15] = 0.5 * c.w;
  }
  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,
  // you can set the remaining weights to 0 (and index=0).
  setSplatBones(A, e, s) {
    const n = A * 4;
    this.skinData[n + 0] = Math.min(255, Math.max(0, Math.round(s.x * 255))) + (e.x << 8), this.skinData[n + 1] = Math.min(255, Math.max(0, Math.round(s.y * 255))) + (e.y << 8), this.skinData[n + 2] = Math.min(255, Math.max(0, Math.round(s.z * 255))) + (e.z << 8), this.skinData[n + 3] = Math.min(255, Math.max(0, Math.round(s.w * 255))) + (e.w << 8);
  }
  // Call this to indicate that the bones have changed and the Gsplats need to be
  // re-generated with updated skinning.
  updateBones() {
    this.boneTexture.needsUpdate = !0, this.mesh.needsUpdate = !0;
  }
}
const no = { type: "GsplatSkinning" }, io = hA(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`), uh = hA(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);
function hh(t, A) {
  return new V({
    inTypes: { gsplat: AA, skinning: no },
    outTypes: { gsplat: AA },
    globals: () => [io, uh],
    inputs: { gsplat: t, skinning: A },
    statements: ({ inputs: s, outputs: n }) => {
      const { skinning: i } = s, { gsplat: r } = n;
      return RA(`
        ${r} = ${s.gsplat};
        if (isGsplatActive(${r}.flags)) {
          applyGsplatSkinning(
            ${i}.numSplats, ${i}.numBones,
            ${i}.skinTexture, ${i}.boneTexture,
            ${r}.index, ${r}.center, ${r}.quaternion
          );
        }
      `);
    }
  }).outputs.gsplat;
}
function jh({
  // PackedSplats object to add splats to
  splats: t,
  // min and max box extents of the grid
  extents: A,
  // step size along each grid axis
  stepSize: e = 1,
  // spherical radius of each Gsplat
  pointRadius: s = 0.01,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  pointShadowScale: n = 2,
  // Gsplat opacity
  opacity: i = 1,
  // Gsplat color (THREE.Color) or function to set color for position:
  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)
  color: r
}) {
  const o = new u.Vector3(), c = new u.Vector3(), l = new u.Quaternion(0, 0, 0, 1);
  r == null && (r = (I, h) => I.set(
    0.55 + 0.45 * Math.cos(h.x * 1),
    0.55 + 0.45 * Math.cos(h.y * 1),
    0.55 + 0.45 * Math.cos(h.z * 1)
  ));
  const g = new u.Color();
  for (let I = A.min.z; I < A.max.z + 1e-6; I += e)
    for (let h = A.min.y; h < A.max.y + 1e-6; h += e)
      for (let Q = A.min.x; Q < A.max.x + 1e-6; Q += e) {
        o.set(Q, h, I);
        for (let C = 0; C < 2; ++C)
          c.setScalar(s * (C ? 1 : n)), C ? typeof r == "function" ? r(g, o) : g.copy(r) : g.setScalar(0), t.pushSplat(o, c, l, i, g);
      }
}
function Zh({
  // PackedSplats object to add splats to
  splats: t,
  // scale (Gsplat scale along axis)
  scale: A = 0.25,
  // radius of the axes (Gsplat scale orthogonal to axis)
  axisRadius: e = 75e-4,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  axisShadowScale: s = 2,
  // origins of the axes (default single axis at origin)
  origins: n = [new u.Vector3()]
}) {
  const i = new u.Vector3(), r = new u.Vector3(), a = new u.Quaternion(0, 0, 0, 1), o = new u.Color(), c = 1;
  for (const l of n)
    for (let g = 0; g < 3; ++g) {
      i.set(
        l.x + (g === 0 ? A : 0),
        l.y + (g === 1 ? A : 0),
        l.z + (g === 2 ? A : 0)
      );
      for (let I = 0; I < 2; ++I)
        r.set(
          (g === 0 ? A : e) * (I ? 1 : s),
          (g === 1 ? A : e) * (I ? 1 : s),
          (g === 2 ? A : e) * (I ? 1 : s)
        ), o.setRGB(
          I === 0 ? 0 : g === 0 ? 1 : 0,
          I === 0 ? 0 : g === 1 ? 1 : 0,
          I === 0 ? 0 : g === 2 ? 1 : 0
        ), t.pushSplat(i, r, a, c, o);
    }
}
function AC({
  // PackedSplats object to add splats to
  splats: t,
  // center of the sphere (default: origin)
  origin: A = new u.Vector3(),
  // radius of the sphere
  radius: e = 1,
  // maximum depth of recursion for subdividing the sphere
  // Warning: Gsplat count grows exponentially with depth
  maxDepth: s = 3,
  // filter function to apply to each point, for example to select
  // points in a certain direction or other function ((THREE.Vector3) => boolean)
  // (default: null)
  filter: n = null,
  // radius of each oriented Gsplat
  pointRadius: i = 0.02,
  // flatness of each oriented Gsplat
  pointThickness: r = 1e-3,
  // color of each Gsplat (THREE.Color) or function to set color for point:
  // ((THREE.Color, THREE.Vector3) => void) (default: white)
  color: a = new u.Color(1, 1, 1)
}) {
  const o = {};
  function c(C) {
    if (n && !n(C))
      return;
    const B = `${C.x},${C.y},${C.z}`;
    o[B] || (o[B] = C);
  }
  function l(C, B, E, p) {
    if (c(B), c(E), c(p), C >= s)
      return;
    const f = new u.Vector3().addVectors(B, E).normalize(), d = new u.Vector3().addVectors(E, p).normalize(), y = new u.Vector3().addVectors(p, B).normalize();
    l(C + 1, B, f, y), l(C + 1, f, E, d), l(C + 1, y, d, p), l(C + 1, f, d, y);
  }
  for (const C of [-1, 1])
    for (const B of [-1, 1])
      for (const E of [-1, 1]) {
        const p = new u.Vector3(C, 0, 0), f = new u.Vector3(0, B, 0), d = new u.Vector3(0, 0, E);
        l(0, p, f, d);
      }
  const g = Object.values(o), I = new u.Vector3(i, i, r), h = new u.Quaternion(), Q = typeof a == "function" ? new u.Color() : a;
  for (const C of g)
    h.setFromUnitVectors(new u.Vector3(0, 0, -1), C), typeof a == "function" && a(Q, C), C.multiplyScalar(e), C.add(A), t.pushSplat(C, I, h, 1, Q);
}
function tC({
  // text string to display
  text: t,
  // browser font to render text with (default: "Arial")
  font: A,
  // font size in pixels/Gsplats (default: 32)
  fontSize: e,
  // SplatMesh.recolor tint assuming white Gsplats (default: white)
  color: s,
  // Individual Gsplat color (default: white)
  rgb: n,
  // Gsplat radius (default: 0.8 covers 1-unit spacing well)
  dotRadius: i,
  // text alignment: "left", "center", "right", "start", "end" (default: "start")
  textAlign: r,
  // line spacing multiplier, lines delimited by "\n" (default: 1.0)
  lineHeight: a,
  // Coordinate scale in object-space (default: 1.0)
  objectScale: o
}) {
  A = A ?? "Arial", e = e ?? 32, s = s ?? new u.Color(1, 1, 1), i = i ?? 0.8, r = r ?? "start", a = a ?? 1, o = o ?? 1;
  const c = t.split(`
`), l = document.createElement("canvas"), g = l.getContext("2d");
  if (!g)
    throw new Error("Failed to create canvas context");
  g.font = `${e}px ${A}`, g.textAlign = r;
  const I = g.measureText(""), h = I.fontBoundingBoxAscent + I.fontBoundingBoxDescent;
  let Q = Number.POSITIVE_INFINITY, C = Number.NEGATIVE_INFINITY, B = Number.POSITIVE_INFINITY, E = Number.NEGATIVE_INFINITY;
  for (let F = 0; F < c.length; ++F) {
    const b = g.measureText(c[F]), N = h * a * F;
    Q = Math.min(Q, -b.actualBoundingBoxLeft), C = Math.max(C, b.actualBoundingBoxRight), B = Math.min(B, N - b.actualBoundingBoxAscent), E = Math.max(E, N + b.actualBoundingBoxDescent);
  }
  const p = Math.floor(Q), f = Math.floor(B), d = Math.ceil(C) - p, y = Math.ceil(E) - f;
  l.width = d, l.height = y, g.font = `${e}px ${A}`, g.textAlign = r, g.textBaseline = "alphabetic", g.fillStyle = "#FFFFFF";
  for (let F = 0; F < c.length; ++F) {
    const b = h * a * F - f;
    g.fillText(c[F], -p, b);
  }
  const D = g.getImageData(0, 0, d, y), x = new Uint8Array(D.data.buffer), w = new VA(), m = new u.Vector3(), T = new u.Vector3().setScalar(i * o), M = new u.Quaternion(0, 0, 0, 1);
  n = n ?? new u.Color(1, 1, 1);
  let S = 0;
  for (let F = 0; F < y; ++F)
    for (let b = 0; b < d; ++b) {
      const N = x[S + 3];
      if (N > 0) {
        const R = N / 255;
        m.set(b - 0.5 * (d - 1), 0.5 * (y - 1) - F, 0), m.multiplyScalar(o), w.pushSplat(m, T, M, R, n);
      }
      S += 4;
    }
  const U = new ft({ packedSplats: w });
  return U.recolor = s, U;
}
function eC({
  // URL of the image to convert to splats (example: `url: "./image.png"`)
  url: t,
  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)
  dotRadius: A,
  // Subsampling factor for the image. Higher values reduce resolution,
  // for example 2 will halve the width and height by averaging (default: 1)
  subXY: e,
  // Optional callback function to modify each Gsplat before it's added.
  // Return null to skip adding the Gsplat, or a number to set the opacity
  // and add the Gsplat with parameter values in the objects center, rgba etc. were
  // passed into the forEachSplat callback. Ending the callback in `return opacity;`
  // will retain the original opacity.
  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)
  forEachSplat: s
}) {
  return A = A ?? 0.8, e = Math.max(1, Math.floor(e ?? 1)), new ft({
    constructSplats: async (n) => new Promise((i, r) => {
      const a = new Image();
      a.crossOrigin = "anonymous", a.onerror = r, a.onload = () => {
        const { width: o, height: c } = a, l = document.createElement("canvas");
        l.width = o, l.height = c;
        const g = l.getContext("2d");
        if (!g) {
          r(new Error("Failed to create canvas context"));
          return;
        }
        g.imageSmoothingEnabled = !0, g.imageSmoothingQuality = "high";
        const I = Math.round(o / e), h = Math.round(c / e);
        g.drawImage(a, 0, 0, I, h);
        try {
          const Q = g.getImageData(0, 0, I, h), C = new Uint8Array(Q.data.buffer), B = new u.Vector3(), E = new u.Vector3().setScalar(A), p = new u.Quaternion(0, 0, 0, 1), f = new u.Color();
          let d = 0;
          for (let y = 0; y < h; ++y)
            for (let D = 0; D < I; ++D) {
              const x = d * 4, w = C[x + 3];
              if (w > 0) {
                let m = w / 255;
                f.set(
                  C[x + 0] / 255,
                  C[x + 1] / 255,
                  C[x + 2] / 255
                ), B.set(
                  D - 0.5 * (I - 1),
                  0.5 * (h - 1) - y,
                  0
                ), E.setScalar(A), p.set(0, 0, 0, 1);
                let T = !0;
                if (s) {
                  const M = s(
                    I,
                    h,
                    d,
                    B,
                    E,
                    p,
                    m,
                    f
                  );
                  m = M ?? m, T = M !== null;
                }
                T && n.pushSplat(B, E, p, m, f);
              }
              d += 1;
            }
          i();
        } catch (Q) {
          r(Q);
        }
      }, a.src = t;
    })
  });
}
function Ch({
  box: t,
  cells: A,
  dotScale: e,
  color: s,
  opacity: n
}) {
  A.x = Math.max(1, Math.round(A.x)), A.y = Math.max(1, Math.round(A.y)), A.z = Math.max(1, Math.round(A.z)), n = n ?? 1;
  const i = A.x * A.y * A.z, r = J("int", A.x), a = J("int", A.y);
  J("int", A.z);
  const o = qA(0), c = new Vt({
    numSplats: i,
    generator: vA(
      { index: "int" },
      { gsplat: AA },
      ({ index: g }) => {
        if (!g)
          throw new Error("index is undefined");
        const I = Le(g, r), h = re(g, r), Q = Le(h, a), C = re(h, a), B = $A({
          vectorType: "ivec3",
          x: I,
          y: Q,
          z: C
        }), E = sr(o), p = $A({ vectorType: "ivec2", x: g, y: E }), f = aa(p), d = J("vec3", t.min), y = J("vec3", t.max), D = Et(y, d), x = re(BA(Bt(B), f), J("vec3", A));
        let w, m, T;
        s ? (w = J("float", s.r), m = J("float", s.g), T = J("float", s.b)) : { r: w, g: m, b: T } = Qt(x).outputs;
        const M = $A({
          vectorType: "vec4",
          r: w,
          g: m,
          b: T,
          a: J("float", n)
        }), S = BA(d, iA(D, x)), U = Bt(J("float", e)), F = J("vec4", new u.Quaternion(0, 0, 0, 1));
        let b = rt({
          flags: oe("uint", "GSPLAT_FLAG_ACTIVE"),
          index: g,
          center: S,
          scales: U,
          quaternion: F,
          rgba: M
        });
        return b = l.applyGsplat(b), { gsplat: b };
      },
      {
        globals: () => [bA]
      }
    ),
    update: ({ time: g }) => {
      o.value = g, l.update(c), c.updateVersion();
    }
  }), l = new xt();
  return c;
}
const Bh = {
  box: new u.Box3(
    new u.Vector3(-1, -1, -1),
    new u.Vector3(1, 1, 1)
  ),
  density: 100,
  fallDirection: new u.Vector3(-1, -3, 1).normalize(),
  fallVelocity: 0.02,
  wanderScale: 0.04,
  wanderVariance: 2,
  color1: new u.Color(1, 1, 1),
  color2: new u.Color(0.5, 0.5, 1),
  minScale: 1e-3,
  maxScale: 5e-3,
  anisoScale: new u.Vector3(1, 1, 1)
}, Qh = {
  box: new u.Box3(
    new u.Vector3(-2, -1, -2),
    new u.Vector3(2, 5, 2)
  ),
  density: 10,
  fallDirection: new u.Vector3(0, -1, 0),
  fallVelocity: 2,
  wanderScale: 0.1,
  wanderVariance: 1,
  color1: new u.Color(1, 1, 1),
  color2: new u.Color(0.25, 0.25, 0.5),
  minScale: 5e-3,
  maxScale: 0.01,
  anisoScale: new u.Vector3(0.1, 1, 0.1)
};
function Eh({
  // min and max box extents of the snowBox
  box: t,
  // minimum y-coordinate to clamp particle position, which can be used to
  // fake hitting a ground plane and lingering there for a bit
  minY: A,
  // number of Gsplats to generate (default: calculated from box and density)
  numSplats: e,
  // density of Gsplats per unit volume (default: 100)
  density: s,
  // The xyz anisotropic scale of the Gsplat, which can be used for example
  // to elongate rain particles (default: (1, 1, 1))
  anisoScale: n,
  // Minimum Gsplat particle scale (default: 0.001)
  minScale: i,
  // Maximum Gsplat particle scale (default: 0.005)
  maxScale: r,
  // The average direction of fall (default: (0, -1, 0))
  fallDirection: a,
  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)
  fallVelocity: o,
  // The world scale of wandering overlay motion (default: 0.01)
  wanderScale: c,
  // Controls how uniformly the particles wander in sync, more variance mean
  // more randomness in the motion (default: 2)
  wanderVariance: l,
  // Color 1 of the two colors interpolated between (default: (1, 1, 1))
  color1: g,
  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))
  color2: I,
  // The base opacity of the Gsplats (default: 1)
  opacity: h,
  // Optional callback function to call each frame.
  onFrame: Q
}) {
  t = t ?? new u.Box3(new u.Vector3(-1, -1, -1), new u.Vector3(1, 1, 1));
  const C = (t.max.x - t.min.x) * (t.max.y - t.min.y) * (t.max.z - t.min.z);
  s = s ?? 100, e = e ?? Math.max(1, Math.min(1e6, Math.round(C * s)));
  const B = qA(i ?? 1e-3), E = qA(r ?? 5e-3), p = tt(
    ((n == null ? void 0 : n.clone()) ?? new u.Vector3(1, 1, 1)).normalize()
  ), f = tt(
    (a ?? new u.Vector3(0, -1, 0)).normalize()
  ), d = qA(o ?? 0.02), y = qA(c ?? 0.01), D = qA(l ?? 2), x = tt(g ?? new u.Color(1, 1, 1)), w = tt(I ?? new u.Color(0.5, 0.5, 1)), m = qA(h ?? 1), T = qA(0), M = tt(new u.Vector3(0, 0, 0)), S = tt(t.min), U = tt(t.max), F = qA(A ?? Number.NEGATIVE_INFINITY), b = Et(U, S), N = new Vt({
    numSplats: e,
    generator: vA(
      { index: "int" },
      { gsplat: AA },
      ({ index: O }) => {
        if (!O)
          throw new Error("index not defined");
        const _ = qe(O), eA = Qt(_).outputs.w;
        let H = Bt(_), W = ae(iA(eA, J("float", 100)));
        W = He(iA(oe("float", "PI"), W)), W = BA(B, iA(W, Et(E, B)));
        const L = iA(W, p), j = ae(iA(eA, J("float", 10))), P = ae(eA), Z = ri(x, w, P), G = iA(Z, j), fA = qe(
          $A({
            vectorType: "ivec2",
            x: O,
            y: J("int", 6837)
          })
        );
        let cA = Bt(fA), pA = iA(Qt(fA).outputs.w, D);
        pA = BA(T, pA), H = BA(H, M);
        const dA = ni(
          H,
          J("vec3", new u.Vector3(1, 1, 1))
        );
        H = BA(S, iA(b, dA));
        const xA = J("vec4", new u.Quaternion(0, 0, 0, 1));
        cA = He(BA(Bt(pA), cA)), cA = iA(cA, y);
        let CA = BA(H, cA), YA = Qt(CA).outputs.y;
        YA = ii(F, YA), CA = $A({ vector: CA, y: YA });
        let SA = rt({
          flags: oe("uint", "GSPLAT_FLAG_ACTIVE"),
          index: O,
          center: CA,
          scales: L,
          quaternion: xA,
          rgb: G,
          opacity: m
        });
        return SA = R.applyGsplat(SA), { gsplat: SA };
      },
      {
        globals: () => [bA]
      }
    ),
    update: ({ object: O, time: _, deltaTime: eA }) => {
      T.value = _, R.update(N);
      const H = f.value.clone().multiplyScalar(d.value * eA);
      M.value.add(H), O.visible = m.value > 0, Q == null || Q({ object: O, time: _, deltaTime: eA }), N.updateVersion();
    }
  }), R = new xt();
  return {
    snow: N,
    min: S,
    max: U,
    minY: F,
    color1: x,
    color2: w,
    opacity: m,
    fallVelocity: d,
    wanderVariance: D,
    wanderScale: y,
    fallDirection: f,
    minScale: B,
    maxScale: E,
    anisoScale: p
  };
}
const sC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_RAIN: Qh,
  DEFAULT_SNOW: Bh,
  snowBox: Eh,
  staticBox: Ch
}, Symbol.toStringTag, { value: "Module" }));
function ro(t) {
  return vA({ gsplat: AA }, { gsplat: AA }, ({ gsplat: A }) => {
    if (!A)
      throw new Error("No gsplat input");
    let e = Re(A);
    const s = t.applyGsplat(A), n = ut(s).outputs.center, i = Re(s), r = Gr(n, i), a = Yi(r, J("float", 0));
    e = os(a, as(e), e);
    const o = BA(
      iA(e, J("float", 0.5)),
      J("float", 0.5)
    );
    return A = rt({ gsplat: A, rgb: o }), { gsplat: A };
  });
}
function fh(t) {
  t.enableWorldToView = !0, t.worldModifier = ro(t.context.worldToView), t.updateGenerator();
}
function ao(t, A, e, s) {
  return vA({ gsplat: AA }, { gsplat: AA }, ({ gsplat: n }) => {
    if (!n)
      throw new Error("No gsplat input");
    let { center: i } = ut(n).outputs;
    i = t.apply(i);
    const { z: r } = Qt(i).outputs;
    let a = oa(as(r), A, e);
    return a = os(s, Et(J("float", 1), a), a), n = rt({ gsplat: n, r: a, g: a, b: a }), { gsplat: n };
  });
}
function ph(t, A, e, s) {
  t.enableWorldToView = !0;
  const n = J("float", A), i = J("float", e), r = J("bool", s ?? !1);
  return t.worldModifier = ao(
    t.context.worldToView,
    n,
    i,
    r
  ), t.updateGenerator(), {
    minDepth: n,
    maxDepth: i,
    reverse: r
  };
}
const nC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  makeDepthColorModifier: ao,
  makeNormalColorModifier: ro,
  setDepthColor: ph,
  setWorldNormalColor: fh
}, Symbol.toStringTag, { value: "Module" })), Kt = class Kt {
  static createButton(A, e = {}) {
    const s = navigator.xr;
    if (!s)
      return null;
    const n = s, i = document.createElement("button");
    A.xr.enabled = !0, A.xr.setReferenceSpaceType("local");
    function r() {
      let g = null;
      async function I(C) {
        console.log("onSessionStarted"), C.addEventListener("end", h), await A.xr.setSession(C), i.textContent = "EXIT VR", g = C;
      }
      function h() {
        console.log("onSessionEnded"), g == null || g.removeEventListener("end", h), i.textContent = "ENTER VR", g = null;
      }
      i.style.display = "", i.style.cursor = "pointer", i.style.left = "calc(50% - 100px)", i.style.width = "200px", i.style.height = "100px", i.textContent = "ENTER VR";
      const Q = {
        ...e,
        optionalFeatures: [
          // "local-floor",
          // "bounded-floor",
          // "layers",
          ...e.optionalFeatures || []
        ]
      };
      i.onmouseenter = () => {
        i.style.opacity = "1.0";
      }, i.onmouseleave = () => {
        i.style.opacity = "0.5";
      }, i.onclick = () => {
        g === null ? (console.log("requesting session"), n.requestSession("immersive-vr", Q).then(
          I
        )) : (console.log("ending session"), g.end());
      };
    }
    function a() {
      i.style.display = "none", i.style.cursor = "auto", i.style.left = "calc(50% - 75px)", i.style.width = "150px", i.onmouseenter = null, i.onmouseleave = null, i.onclick = null;
    }
    function o() {
      a(), i.textContent = "VR NOT SUPPORTED";
    }
    function c(g) {
      a(), console.warn(
        "Exception when trying to call xr.isSessionSupported",
        g
      ), i.textContent = "VR NOT ALLOWED";
    }
    function l(g) {
      g.style.position = "absolute", g.style.bottom = "20px", g.style.padding = "12px 6px", g.style.border = "1px solid #fff", g.style.borderRadius = "4px", g.style.background = "rgba(0,0,0,0.1)", g.style.color = "#fff", g.style.font = "normal 13px sans-serif", g.style.textAlign = "center", g.style.opacity = "0.5", g.style.outline = "none", g.style.zIndex = "999";
    }
    return i.id = "VRButton", i.style.display = "none", l(i), n.isSessionSupported("immersive-vr").then((g) => {
      g ? r() : o(), g && Kt.xrSessionIsGranted && i.click();
    }).catch(c), i;
  }
  static registerSessionGrantedListener() {
    const A = navigator.xr;
    if (!A)
      return null;
    const e = A;
    /WebXRViewer\//i.test(navigator.userAgent) || e.addEventListener("sessiongranted", () => {
      Kt.xrSessionIsGranted = !0;
    });
  }
};
Kt.xrSessionIsGranted = !1;
let Pe = Kt;
Pe.registerSessionGrantedListener();
const dh = 0.5, yh = 0.5, wh = 0;
var Is = /* @__PURE__ */ ((t) => (t.w = "wrist", t.t0 = "thumb-metacarpal", t.t1 = "thumb-phalanx-proximal", t.t2 = "thumb-phalanx-distal", t.t3 = "thumb-tip", t.i0 = "index-finger-metacarpal", t.i1 = "index-finger-phalanx-proximal", t.i2 = "index-finger-phalanx-intermediate", t.i3 = "index-finger-phalanx-distal", t.i4 = "index-finger-tip", t.m0 = "middle-finger-metacarpal", t.m1 = "middle-finger-phalanx-proximal", t.m2 = "middle-finger-phalanx-intermediate", t.m3 = "middle-finger-phalanx-distal", t.m4 = "middle-finger-tip", t.r0 = "ring-finger-metacarpal", t.r1 = "ring-finger-phalanx-proximal", t.r2 = "ring-finger-phalanx-intermediate", t.r3 = "ring-finger-phalanx-distal", t.r4 = "ring-finger-tip", t.p0 = "pinky-finger-metacarpal", t.p1 = "pinky-finger-phalanx-proximal", t.p2 = "pinky-finger-phalanx-intermediate", t.p3 = "pinky-finger-phalanx-distal", t.p4 = "pinky-finger-tip", t))(Is || {});
const oo = Object.keys(Is), iC = oo.length, rC = {
  w: 0,
  t0: 1,
  t1: 2,
  t2: 3,
  t3: 4,
  i0: 5,
  i1: 6,
  i2: 7,
  i3: 8,
  i4: 9,
  m0: 10,
  m1: 11,
  m2: 12,
  m3: 13,
  m4: 14,
  r0: 15,
  r1: 16,
  r2: 17,
  r3: 18,
  r4: 19,
  p0: 20,
  p1: 21,
  p2: 22,
  p3: 23,
  p4: 24
}, ne = {
  w: 0.02,
  t0: 0.02,
  t1: 0.014,
  t2: 0.0115,
  t3: 85e-4,
  i0: 0.022,
  i1: 0.012,
  i2: 85e-4,
  i3: 75e-4,
  i4: 65e-4,
  m0: 0.021,
  m1: 0.012,
  m2: 8e-3,
  m3: 75e-4,
  m4: 65e-4,
  r0: 0.019,
  r1: 0.011,
  r2: 75e-4,
  r3: 7e-3,
  r4: 6e-3,
  p0: 0.012,
  p1: 0.01,
  p2: 7e-3,
  p3: 65e-4,
  p4: 55e-4
}, mh = [
  ["w", "t0", "t1", "t2", "t3"],
  ["w", "i0", "i1", "i2", "i3", "i4"],
  ["w", "m0", "m1", "m2", "m3", "m4"],
  ["w", "r0", "r1", "r2", "r3", "r4"],
  ["w", "p0", "p1", "p2", "p3", "p4"]
], xh = [
  [8, 10, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6]
], aC = ["t3", "i4", "m4", "r4", "p4"], oC = ["i4", "m4", "r4", "p4"];
var go = /* @__PURE__ */ ((t) => (t.left = "left", t.right = "right", t))(go || {});
const Xe = Object.keys(go);
class gC {
  constructor() {
    this.hands = {}, this.last = {}, this.values = {}, this.tests = {}, this.lastTests = {}, this.updated = !1;
  }
  update({ xr: A, xrFrame: e }) {
    const s = A.getSession();
    if (!s)
      return;
    const n = A.getReferenceSpace();
    if (n && e.getJointPose) {
      this.last = this.hands, this.lastTests = this.tests, this.hands = {}, this.values = {}, this.tests = {};
      for (const i of s.inputSources) {
        if (!i.hand)
          continue;
        const r = i.handedness;
        this.hands[r] = {};
        for (const a of oo) {
          const o = i.hand.get(Is[a]);
          if (o) {
            const c = e.getJointPose(o, n);
            if (c) {
              const { position: l, orientation: g } = c.transform;
              this.hands[r][a] = {
                position: new _A(l.x, l.y, l.z),
                quaternion: new hs(
                  g.x,
                  g.y,
                  g.z,
                  g.w
                ),
                radius: c.radius || 1e-3
              };
            }
          }
        }
      }
      for (const i of Xe)
        for (const { key: r, value: a } of [
          { key: `${i}AllTips`, value: this.allTipsTouching(i) },
          {
            key: `${i}IndexThumb`,
            value: this.touching(i, "i4", i, "t3")
          },
          {
            key: `${i}MiddleThumb`,
            value: this.touching(i, "m4", i, "t3")
          },
          {
            key: `${i}RingThumb`,
            value: this.touching(i, "r4", i, "t3")
          },
          {
            key: `${i}PinkyThumb`,
            value: this.touching(i, "p4", i, "t3")
          },
          { key: `${i}TriTips`, value: this.triTipsTouching(i) }
        ])
          this.values[r] = a, this.tests[r] = a === 1 ? !0 : a === 0 ? !1 : this.lastTests[r] ?? !1;
    }
  }
  makeGhostMesh() {
    const A = new _A(), e = new _A(0.01, 0.01, 0.01), s = new hs(0, 0, 0, 1), n = new Cs(1, 1, 1), i = Math.PI * 3;
    new Cs(1, 1, 1);
    let r = 1;
    const a = new ft({
      onFrame: () => {
        let o = 0;
        for (const c of Xe) {
          const l = this.hands[c];
          for (const [g, I] of mh.entries())
            for (let h = 1; h < I.length; ++h) {
              const Q = xh[g][h - 1] * 2, C = h + 1 === I.length, B = l == null ? void 0 : l[I[h - 1]], E = l == null ? void 0 : l[I[h]];
              for (let p = 0; p < Q; ++p) {
                const f = (p + 0.5) / Q;
                if (r = 0, B && E) {
                  A.copy(B.position).lerp(E.position, f), s.copy(B.quaternion).slerp(E.quaternion, f);
                  const d = ne[I[h - 1]], y = ne[I[h]];
                  let D = (1 - f) * d + f * y;
                  C && f > 0.8 && (D *= Math.sqrt(1 - ((f - 0.8) / 0.2) ** 2)), e.set(0.65 * D, 0.5 * D, 3e-3), n.set(
                    0.55 + 0.45 * Math.sin(A.x * i),
                    0.55 + 0.45 * Math.sin(A.y * i),
                    0.55 + 0.45 * Math.sin(A.z * i)
                  ), c === "right" && n.set(1 - n.r, 1 - n.g, 1 - n.b), r = 0.75;
                }
                a.packedSplats.setSplat(
                  o,
                  A,
                  e,
                  s,
                  r,
                  n
                ), o += 1;
              }
            }
        }
        a.packedSplats.numSplats = o, a.packedSplats.needsUpdate = !0, a.numSplats = o, a.updateVersion();
      }
    });
    return a;
  }
  distance(A, e, s, n, i = !1) {
    const r = i ? this.last[A] : this.hands[A], a = i ? this.last[s] : this.hands[s], o = r == null ? void 0 : r[e], c = a == null ? void 0 : a[n];
    return !o || !c ? Number.POSITIVE_INFINITY : o.position.distanceTo(c.position);
  }
  separation(A, e, s, n, i = !1) {
    const r = this.distance(A, e, s, n, i);
    return r === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : r - ne[e] - ne[n];
  }
  touching(A, e, s, n, i = !1) {
    const r = this.separation(A, e, s, n, i);
    return r === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : 1 - Math.max(0, Math.min(1, r / 0.01 - wh));
  }
  allTipsTouching(A, e = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", e),
      this.touching(A, "i4", A, "m4", e),
      this.touching(A, "m4", A, "r4", e),
      this.touching(A, "r4", A, "p4", e)
      // this.touching(hand, "p4", hand, "t3", last),
    );
  }
  triTipsTouching(A, e = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", e),
      this.touching(A, "i4", A, "m4", e),
      this.touching(A, "m4", A, "t3", e)
    );
  }
}
class cC {
  constructor({
    xrHands: A,
    control: e,
    moveInertia: s,
    rotateInertia: n
  }) {
    this.lastGrip = {}, this.lastPivot = new _A(), this.rotateVelocity = 0, this.velocity = new _A(), this.xrHands = A, this.control = e, this.moveInertia = s ?? dh, this.rotateInertia = n ?? yh;
  }
  update(A) {
    var i, r, a, o, c;
    const e = {};
    for (const l of Xe) {
      const g = this.xrHands.hands[l];
      g && this.xrHands.tests[`${l}MiddleThumb`] && (e[l] = new _A().add(((i = g.t3) == null ? void 0 : i.position) ?? new _A()).add(((r = g.i4) == null ? void 0 : r.position) ?? new _A()).add(((a = g.m4) == null ? void 0 : a.position) ?? new _A()).add(((o = g.r4) == null ? void 0 : o.position) ?? new _A()).add(((c = g.p4) == null ? void 0 : c.position) ?? new _A()).multiplyScalar(1 / 5));
    }
    if (e.left && e.right && this.lastGrip.left && this.lastGrip.right) {
      const l = e.left.clone().add(e.right).multiplyScalar(0.5), g = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);
      this.lastPivot = l;
      const I = l.clone().applyMatrix4(this.control.matrix);
      I.sub(g.clone().applyMatrix4(this.control.matrix)), I.multiplyScalar(1 / A), this.velocity.lerp(I, 1 - Math.exp(-20 * A));
      const h = Math.atan2(e.left.z - l.z, e.left.x - l.x), Q = Math.atan2(
        this.lastGrip.left.z - g.z,
        this.lastGrip.left.x - g.x
      );
      let C = h - Q;
      C > Math.PI ? C -= Math.PI * 2 : C < -Math.PI && (C += Math.PI * 2);
      const B = C / A, E = Math.exp(-20 * A);
      this.rotateVelocity = this.rotateVelocity * E + B * (1 - E);
    } else if (this.rotateVelocity *= Math.exp(-A / this.rotateInertia), e.left && this.lastGrip.left) {
      const l = e.left.clone().applyMatrix4(this.control.matrix);
      l.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)), l.multiplyScalar(1 / A), this.velocity.lerp(l, 1 - Math.exp(-20 * A));
    } else if (e.right && this.lastGrip.right) {
      const l = e.right.clone().applyMatrix4(this.control.matrix);
      l.sub(
        this.lastGrip.right.clone().applyMatrix4(this.control.matrix)
      ), l.multiplyScalar(1 / A), this.velocity.lerp(l, 1 - Math.exp(-20 * A));
    } else
      this.velocity.multiplyScalar(Math.exp(-A / this.moveInertia));
    const s = this.lastPivot.clone().negate(), n = new De().makeTranslation(s).premultiply(new De().makeRotationY(this.rotateVelocity * A)).premultiply(new De().makeTranslation(this.lastPivot));
    this.control.matrix.multiply(n), this.control.matrix.decompose(
      this.control.position,
      this.control.quaternion,
      this.control.scale
    ), this.control.updateMatrixWorld(!0), this.control.position.sub(this.velocity.clone().multiplyScalar(A)), this.lastGrip = e;
  }
}
const Sh = 1, Dh = 2, Mh = 2e-3, vh = 6e-3, bh = 15e-4, Fh = 0.15, kh = 0.15, Th = 0.1, Nh = 2, Uh = 1, Gh = 200, Rh = 400, Yh = 50, Jh = {
  KeyW: new u.Vector3(0, 0, -1),
  KeyS: new u.Vector3(0, 0, 1),
  KeyA: new u.Vector3(-1, 0, 0),
  KeyD: new u.Vector3(1, 0, 0),
  KeyR: new u.Vector3(0, 1, 0),
  KeyF: new u.Vector3(0, -1, 0)
}, _h = {
  ArrowUp: new u.Vector3(0, 0, -1),
  ArrowDown: new u.Vector3(0, 0, 1),
  ArrowLeft: new u.Vector3(-1, 0, 0),
  ArrowRight: new u.Vector3(1, 0, 0),
  PageUp: new u.Vector3(0, 1, 0),
  PageDown: new u.Vector3(0, -1, 0)
}, Lh = {
  KeyQ: new u.Vector3(0, 0, 1),
  KeyE: new u.Vector3(0, 0, -1)
}, zh = {
  Home: new u.Vector3(0, -1, 0),
  End: new u.Vector3(0, 1, 0),
  Insert: new u.Vector3(-1, 0, 0),
  Delete: new u.Vector3(1, 0, 0)
};
class lC {
  constructor({ canvas: A }) {
    this.lastTime = 0, this.fpsMovement = new qh({}), this.pointerControls = new Hh({ canvas: A });
  }
  update(A) {
    const e = performance.now(), s = (e - (this.lastTime || e)) / 1e3;
    this.lastTime = e, this.fpsMovement.update(s, A), this.pointerControls.update(s, A);
  }
}
class qh {
  constructor({
    moveSpeed: A,
    rollSpeed: e,
    stickThreshold: s,
    rotateSpeed: n,
    keycodeMoveMapping: i,
    keycodeRotateMapping: r,
    gamepadMapping: a,
    capsMultiplier: o,
    shiftMultiplier: c,
    ctrlMultiplier: l,
    xr: g
  } = {}) {
    this.enable = !0, this.moveSpeed = A ?? Sh, this.rollSpeed = e ?? Dh, this.stickThreshold = s ?? Th, this.rotateSpeed = n ?? Nh, this.keycodeMoveMapping = i ?? {
      ...Jh,
      ..._h
    }, this.keycodeRotateMapping = r ?? {
      ...Lh,
      ...zh
    }, this.gamepadMapping = a ?? {
      4: "rollLeft",
      5: "rollRight",
      6: "ctrl",
      7: "shift"
    }, this.capsMultiplier = o ?? 10, this.shiftMultiplier = c ?? 5, this.ctrlMultiplier = l ?? 1 / 5, this.xr = g, this.keydown = {}, this.keycode = {}, document.addEventListener("keydown", (I) => {
      this.keydown[I.key] = !0, this.keycode[I.code] = !0;
    }), document.addEventListener("keyup", (I) => {
      this.keydown[I.key] = !1, this.keycode[I.code] = !1;
    }), window.addEventListener("blur", () => {
      this.keydown = {}, this.keycode = {};
    });
  }
  // Call this method in your render loop with `control` set to the object to control
  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`
  // in seconds since the last update.
  update(A, e) {
    var l, g;
    if (!this.enable)
      return;
    const s = [new u.Vector2(), new u.Vector2()], n = navigator.getGamepads()[0];
    n && (s[0].set(n.axes[0], n.axes[1]), s[1].set(n.axes[2], n.axes[3]));
    const i = (n == null ? void 0 : n.buttons.map((I) => I.pressed)) || [], r = Array.from(((g = (l = this.xr) == null ? void 0 : l.getSession()) == null ? void 0 : g.inputSources) ?? []);
    for (const I of r) {
      const h = I.gamepad;
      if (h)
        switch (I.handedness) {
          case "none": {
            s[0].x += h.axes[0], s[0].y += h.axes[1], s[1].x += h.axes[2], s[1].y += h.axes[3];
            break;
          }
          case "left": {
            s[0].x += h.axes[2], s[0].y += h.axes[3];
            break;
          }
          case "right": {
            s[1].x += h.axes[2], s[1].y += h.axes[3];
            break;
          }
        }
    }
    for (const I of s)
      I.x = Math.abs(I.x) >= this.stickThreshold ? I.x : 0, I.y = Math.abs(I.y) >= this.stickThreshold ? I.y : 0;
    const a = new u.Vector3(
      s[1].x,
      s[1].y,
      0
    ).multiplyScalar(this.rotateSpeed);
    for (const [I, h] of Object.entries(this.keycodeRotateMapping))
      this.keycode[I] && a.add(h);
    for (const I in this.gamepadMapping)
      if (i[Number.parseInt(I)])
        switch (this.gamepadMapping[I]) {
          case "rollLeft":
            a.z += 1;
            break;
          case "rollRight":
            a.z -= 1;
            break;
        }
    if (a.multiply(
      new u.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)
    ), a.manhattanLength() > 0) {
      a.multiplyScalar(A);
      const I = new u.Euler().setFromQuaternion(
        e.quaternion,
        "YXZ"
      );
      I.y -= a.x, I.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, I.x - a.y)
      ), I.z = Math.max(-Math.PI, Math.min(Math.PI, I.z + a.z)), e.quaternion.setFromEuler(I);
    }
    const o = new u.Vector3(s[0].x, 0, s[0].y);
    for (const [I, h] of Object.entries(this.keycodeMoveMapping))
      this.keycode[I] && o.add(h);
    let c = 1;
    this.keydown.CapsLock && (c *= this.capsMultiplier), (this.keycode.ShiftLeft || this.keycode.ShiftRight) && (c *= this.shiftMultiplier), (this.keycode.ControlLeft || this.keycode.ControlRight) && (c *= this.ctrlMultiplier);
    for (const I in this.gamepadMapping)
      if (i[Number.parseInt(I)])
        switch (this.gamepadMapping[I]) {
          case "shift":
            c *= this.shiftMultiplier;
            break;
          case "ctrl":
            c *= this.ctrlMultiplier;
            break;
        }
    o.applyQuaternion(e.quaternion), e.position.add(
      o.multiplyScalar(this.moveSpeed * c * A)
    );
  }
}
class Hh {
  constructor({
    // The HTML canvas element to attach pointer events to
    canvas: A,
    // Speed of rotation (default DEFAULT_ROTATE_SPEED)
    rotateSpeed: e,
    // Speed of sliding when dragging with right/middle mouse button or two fingers
    // (default DEFAULT_SLIDE_SPEED)
    slideSpeed: s,
    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)
    scrollSpeed: n,
    // Swap the direction of rotation and sliding (default: false)
    swapRotateSlide: i,
    // Reverse the direction of rotation (default: false)
    reverseRotate: r,
    // Reverse the direction of sliding (default: false)
    reverseSlide: a,
    // Reverse the direction of swipe gestures (default: false)
    reverseSwipe: o,
    // Reverse the direction of scroll wheel movement (default: false)
    reverseScroll: c,
    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)
    moveInertia: l,
    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)
    rotateInertia: g,
    // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)
    pointerRollScale: I,
    // Callback for double press events (default: () => {})
    doublePress: h
  }) {
    this.enable = !0, this.canvas = A, this.rotateSpeed = e ?? Mh, this.slideSpeed = s ?? vh, this.scrollSpeed = n ?? bh, this.swapRotateSlide = i ?? !1, this.reverseRotate = r ?? !1, this.reverseSlide = a ?? !1, this.reverseSwipe = o ?? !1, this.reverseScroll = c ?? !1, this.moveInertia = l ?? kh, this.rotateInertia = g ?? Fh, this.pointerRollScale = I ?? Uh, this.doublePress = h ?? (() => {
    }), this.doublePressLimitMs = Rh, this.doublePressDistance = Yh, this.lastUp = null, this.rotating = null, this.sliding = null, this.dualPress = !1, this.scroll = new u.Vector3(), this.rotateVelocity = new u.Vector3(), this.moveVelocity = new u.Vector3(), A.addEventListener("pointerdown", (C) => {
      const B = this.getPointerPosition(C), E = B.clone(), p = B.clone(), f = !this.swapRotateSlide && !this.rotating && (C.pointerType !== "mouse" || C.button === 0) || this.swapRotateSlide && this.sliding && !this.rotating && (C.pointerType !== "mouse" || C.button === 1), { pointerId: d, timeStamp: y } = C;
      if (f)
        this.rotating = { initial: E, last: p, position: B, pointerId: d, timeStamp: y }, A.setPointerCapture(C.pointerId), this.dualPress = !1;
      else if (!this.sliding) {
        const D = C.pointerType === "mouse" ? C.button : void 0;
        this.sliding = {
          initial: E,
          last: p,
          position: B,
          pointerId: d,
          button: D,
          timeStamp: y
        }, A.setPointerCapture(C.pointerId), this.dualPress = this.rotating != null && y - this.rotating.timeStamp < Gh;
      }
    });
    const Q = (C) => {
      var p, f;
      ((p = this.rotating) == null ? void 0 : p.pointerId) === C.pointerId ? (this.rotating = null, A.releasePointerCapture(C.pointerId), this.dualPress && this.sliding && (A.releasePointerCapture(this.sliding.pointerId), this.sliding = null)) : ((f = this.sliding) == null ? void 0 : f.pointerId) === C.pointerId && (this.sliding = null, A.releasePointerCapture(C.pointerId), this.dualPress && this.rotating && (A.releasePointerCapture(this.rotating.pointerId), this.rotating = null));
      const B = this.getPointerPosition(C), E = this.lastUp;
      if (this.lastUp = { position: B, time: C.timeStamp }, E && E.position.distanceTo(B) < this.doublePressDistance) {
        const y = C.timeStamp - E.time;
        y < this.doublePressLimitMs && (this.lastUp = null, this.doublePress({ position: B, intervalMs: y }));
      }
    };
    document.addEventListener("pointerup", Q), document.addEventListener("pointercancel", Q), document.addEventListener("pointermove", (C) => {
      var B, E;
      ((B = this.rotating) == null ? void 0 : B.pointerId) === C.pointerId ? this.rotating.position = this.getPointerPosition(C) : ((E = this.sliding) == null ? void 0 : E.pointerId) === C.pointerId && (this.sliding.position = this.getPointerPosition(C));
    }), A.addEventListener("contextmenu", (C) => {
      C.preventDefault();
    }), A.addEventListener("wheel", (C) => {
      this.scroll.add(
        new u.Vector3(C.deltaX, C.deltaY, C.deltaZ)
      ), C.preventDefault();
    });
  }
  getPointerPosition(A) {
    const e = this.canvas.getBoundingClientRect();
    return new u.Vector2(
      A.clientX - e.left,
      A.clientY - e.top
    );
  }
  update(A, e) {
    if (!this.enable)
      return;
    if (this.dualPress && this.rotating && this.sliding) {
      const n = [
        this.rotating.position.clone().sub(this.rotating.last),
        this.sliding.position.clone().sub(this.sliding.last)
      ], i = n[0].dot(n[1]);
      if (i >= 0.2) {
        const r = n[0].clone().add(n[1]), a = new u.Vector3(r.x, -r.y, 0);
        a.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1)), a.applyQuaternion(e.quaternion), e.position.add(a), this.moveVelocity = a.clone().multiplyScalar(1 / A);
      } else if (i <= -0.2) {
        const r = this.sliding.last.clone().sub(this.rotating.last), a = r.length();
        r.multiplyScalar(1 / a).normalize();
        const o = new u.Vector2(-r.y, r.x), c = [n[0].dot(r), n[1].dot(r)], l = [n[0].dot(o), n[1].dot(o)], g = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);
        let I = new u.Vector3();
        if (e instanceof u.Camera) {
          const p = new u.Vector2(
            g.x / this.canvas.clientWidth * 2 - 1,
            -(g.y / this.canvas.clientHeight) * 2 + 1
          ), f = new u.Raycaster();
          f.setFromCamera(p, e), I = f.ray.direction;
        }
        const h = c[1] - c[0], Q = I.multiplyScalar(h * this.slideSpeed);
        e.position.add(Q), this.moveVelocity = Q.clone().multiplyScalar(1 / A);
        const C = [
          Math.atan(l[0] / (-0.5 * a)),
          Math.atan(l[1] / (0.5 * a))
        ], B = 0.5 * (C[0] + C[1]) * this.pointerRollScale, E = new u.Euler().setFromQuaternion(
          e.quaternion,
          "YXZ"
        );
        E.z = Math.max(
          -Math.PI,
          Math.min(Math.PI, E.z + 0.5 * B)
        ), e.quaternion.setFromEuler(E);
      }
      this.rotating.last.copy(this.rotating.position), this.sliding.last.copy(this.sliding.position);
    } else {
      const n = new u.Vector3();
      if (this.rotating && !this.dualPress) {
        const r = this.rotating.position.clone().sub(this.rotating.last);
        this.rotating.last.copy(this.rotating.position), n.set(r.x, r.y, 0), n.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1)), this.rotateVelocity = n.clone().multiplyScalar(1 / A);
      } else
        this.rotateVelocity.multiplyScalar(
          Math.exp(-A / this.rotateInertia)
        ), n.addScaledVector(this.rotateVelocity, A);
      const i = new u.Euler().setFromQuaternion(
        e.quaternion,
        "YXZ"
      );
      if (i.y -= n.x, i.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, i.x - n.y)
      ), i.z *= Math.exp(-0 * A), e.quaternion.setFromEuler(i), this.sliding && !this.dualPress) {
        const r = this.sliding.position.clone().sub(this.sliding.last);
        this.sliding.last.copy(this.sliding.position);
        const a = this.sliding.button !== 2 ? new u.Vector3(r.x, 0, r.y) : new u.Vector3(r.x, -r.y, 0);
        a.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1)), a.applyQuaternion(e.quaternion), e.position.add(a), this.moveVelocity = a.clone().multiplyScalar(1 / A);
      } else
        this.moveVelocity.multiplyScalar(
          Math.exp(-A / this.moveInertia)
        ), e.position.addScaledVector(this.moveVelocity, A);
    }
    const s = this.scroll.multiplyScalar(this.scrollSpeed);
    s.set(s.x, s.z, s.y), this.reverseScroll && s.multiplyScalar(-1), s.applyQuaternion(e.quaternion), e.position.add(s), this.scroll.set(0, 0, 0);
  }
}
export {
  oC as FINGER_TIPS,
  qh as FpsMovement,
  Xe as HANDS,
  go as Hand,
  cC as HandMovement,
  oo as JOINT_IDS,
  rC as JOINT_INDEX,
  ne as JOINT_RADIUS,
  mh as JOINT_SEGMENTS,
  xh as JOINT_SEGMENT_STEPS,
  aC as JOINT_TIPS,
  Is as JointEnum,
  GA as LN_SCALE_MAX,
  UA as LN_SCALE_MIN,
  iC as NUM_JOINTS,
  VA as PackedSplats,
  ue as PlyReader,
  Hh as PointerControls,
  le as Readback,
  oc as Sint8ToFloat,
  lC as SparkControls,
  Be as SparkRenderer,
  Ce as SparkViewpoint,
  Te as SplatAccumulator,
  Ie as SplatEdit,
  fu as SplatEditRgbaBlendMode,
  du as SplatEditSdf,
  Qu as SplatEditSdfType,
  yu as SplatEdits,
  _t as SplatFileType,
  Vt as SplatGenerator,
  Vu as SplatLoader,
  ft as SplatMesh,
  mu as SplatModifier,
  Wh as SplatSkinning,
  xt as SplatTransformer,
  gh as SpzReader,
  et as SpzWriter,
  ac as Uint8ToFloat,
  Pe as VRButton,
  gC as XrHands,
  Zh as constructAxes,
  jh as constructGrid,
  AC as constructSpherePoints,
  $h as defines,
  Ph as dyno,
  Mc as flipPixels,
  ie as floatToSint8,
  FA as floatToUint8,
  wA as fromHalf,
  sC as generators,
  Za as getSplatFileType,
  eC as imageSplats,
  Sc as isAndroid,
  xc as isMobile,
  Dc as isOculus,
  Xh as isPcSogs,
  nC as modifiers,
  vc as pixelsToPngUrl,
  Ye as setPackedSplat,
  tC as textSplats,
  Ct as toHalf,
  Oh as transcodeSpz,
  Je as unpackSplat,
  to as unpackSplats,
  Vh as utils
};
//# sourceMappingURL=spark.module.min.js.map

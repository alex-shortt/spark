import * as n from "three";
import { Loader as _Q, FileLoader as $Q, Quaternion as jI, Vector3 as JA, Color as _I, Matrix4 as wI } from "three";
let zA;
const sg = typeof TextDecoder < "u" ? new TextDecoder("utf-8", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
typeof TextDecoder < "u" && sg.decode();
let kt = null;
function As() {
  return (kt === null || kt.byteLength === 0) && (kt = new Uint8Array(zA.memory.buffer)), kt;
}
function ts(t, A) {
  return t = t >>> 0, sg.decode(As().subarray(t, t + A));
}
function Is(t, A, I, g, B, i, e, Q, s, E, a) {
  return zA.raycast_splats(t, A, I, g, B, i, e, Q, s, E, a);
}
async function gs(t, A) {
  if (typeof Response == "function" && t instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming == "function")
      try {
        return await WebAssembly.instantiateStreaming(t, A);
      } catch (g) {
        if (t.headers.get("Content-Type") != "application/wasm")
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", g);
        else
          throw g;
      }
    const I = await t.arrayBuffer();
    return await WebAssembly.instantiate(I, A);
  } else {
    const I = await WebAssembly.instantiate(t, A);
    return I instanceof WebAssembly.Instance ? { instance: I, module: t } : I;
  }
}
function Bs() {
  const t = {};
  return t.wbg = {}, t.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {
    return A.buffer;
  }, t.wbg.__wbg_length_3b4f022188ae8db6 = function(A) {
    return A.length;
  }, t.wbg.__wbg_length_6ca527665d89694d = function(A) {
    return A.length;
  }, t.wbg.__wbg_length_8cfd2c6409af88ad = function(A) {
    return A.length;
  }, t.wbg.__wbg_new_9fee97a409b32b68 = function(A) {
    return new Uint16Array(A);
  }, t.wbg.__wbg_new_e3b321dcfef89fc7 = function(A) {
    return new Uint32Array(A);
  }, t.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(A, I, g) {
    return new Float32Array(A, I >>> 0, g >>> 0);
  }, t.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(A, I, g) {
    return new Uint32Array(A, I >>> 0, g >>> 0);
  }, t.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(A) {
    return new Float32Array(A >>> 0);
  }, t.wbg.__wbg_set_10bad9bee0e9c58b = function(A, I, g) {
    A.set(I, g >>> 0);
  }, t.wbg.__wbg_set_d23661d19148b229 = function(A, I, g) {
    A.set(I, g >>> 0);
  }, t.wbg.__wbg_set_f4f1f0daa30696fc = function(A, I, g) {
    A.set(I, g >>> 0);
  }, t.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(A, I, g) {
    return A.subarray(I >>> 0, g >>> 0);
  }, t.wbg.__wbg_subarray_769e1e0f81bb259b = function(A, I, g) {
    return A.subarray(I >>> 0, g >>> 0);
  }, t.wbg.__wbindgen_init_externref_table = function() {
    const A = zA.__wbindgen_export_0, I = A.grow(4);
    A.set(0, void 0), A.set(I + 0, void 0), A.set(I + 1, null), A.set(I + 2, !0), A.set(I + 3, !1);
  }, t.wbg.__wbindgen_memory = function() {
    return zA.memory;
  }, t.wbg.__wbindgen_throw = function(A, I) {
    throw new Error(ts(A, I));
  }, t;
}
function is(t, A) {
  return zA = t.exports, Cg.__wbindgen_wasm_module = A, kt = null, zA.__wbindgen_start(), zA;
}
async function Cg(t) {
  if (zA !== void 0) return zA;
  typeof t < "u" && (Object.getPrototypeOf(t) === Object.prototype ? { module_or_path: t } = t : console.warn("using deprecated parameters for the initialization function; pass a single object instead")), typeof t > "u" && (t = new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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", import.meta.url));
  const A = Bs();
  (typeof t == "string" || typeof Request == "function" && t instanceof Request || typeof URL == "function" && t instanceof URL) && (t = fetch(t));
  const { instance: I, module: g } = await gs(await t, A);
  return is(I, g);
}
const bA = -9, es = 9, WA = (es - bA) / 254, Qs = 11, ss = 11, j = 1 << Qs, It = 1 << ss, Eg = 1;
function ot(t) {
  return t === "bool" || t === "bvec2" || t === "bvec3" || t === "bvec4";
}
function rt(t) {
  return t === "int" || t === "uint" || t === "float";
}
function hA(t) {
  return t === "int" || t === "ivec2" || t === "ivec3" || t === "ivec4";
}
function lA(t) {
  return t === "uint" || t === "uvec2" || t === "uvec3" || t === "uvec4";
}
function bt(t) {
  return t === "float" || t === "vec2" || t === "vec3" || t === "vec4";
}
function ag(t) {
  return t === "mat2" || t === "mat2x2" || t === "mat2x3" || t === "mat2x4" || t === "mat3" || t === "mat3x2" || t === "mat3x3" || t === "mat3x4" || t === "mat4" || t === "mat4x2" || t === "mat4x3" || t === "mat4x4";
}
function it(t) {
  return bt(t) || ag(t);
}
function Gt(t) {
  return t === "vec2" || t === "ivec2" || t === "uvec2";
}
function St(t) {
  return t === "vec3" || t === "ivec3" || t === "uvec3";
}
function Tt(t) {
  return t === "vec4" || t === "ivec4" || t === "uvec4";
}
function Cs(t) {
  return Gt(t) || St(t) || Tt(t);
}
function et(t) {
  return t === "mat2" || t === "mat2x2";
}
function Qt(t) {
  return t === "mat3" || t === "mat3x3";
}
function st(t) {
  return t === "mat4" || t === "mat4x4";
}
function ng(t) {
  switch (t) {
    case "vec2":
      return "float";
    case "vec3":
      return "float";
    case "vec4":
      return "float";
    case "ivec2":
      return "int";
    case "ivec3":
      return "int";
    case "ivec4":
      return "int";
    case "uvec2":
      return "uint";
    case "uvec3":
      return "uint";
    case "uvec4":
      return "uint";
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
function og(t) {
  switch (t) {
    case "vec2":
    case "ivec2":
    case "uvec2":
      return 2;
    case "vec3":
    case "ivec3":
    case "uvec3":
      return 3;
    case "vec4":
    case "ivec4":
    case "uvec4":
      return 4;
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
function Es(t) {
  if (rt(t))
    return "float";
  if (Gt(t))
    return "vec2";
  if (St(t))
    return "vec3";
  if (Tt(t))
    return "vec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function rg(t) {
  if (rt(t))
    return "uint";
  if (Gt(t))
    return "uvec2";
  if (St(t))
    return "uvec3";
  if (Tt(t))
    return "uvec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function as(t) {
  if (rt(t))
    return "int";
  if (Gt(t))
    return "ivec2";
  if (St(t))
    return "ivec3";
  if (Tt(t))
    return "ivec4";
  throw new Error(`Invalid vector type: ${t}`);
}
function cg(t) {
  if (typeof t == "string")
    return t;
  if (typeof t == "object" && t.type)
    return t.type;
  throw new Error(`Invalid DynoType: ${String(t)}`);
}
function iA(t) {
  return Math.trunc(t).toString();
}
function eA(t) {
  return `${Math.max(0, Math.trunc(t)).toString()}u`;
}
function K(t) {
  return t === Number.POSITIVE_INFINITY ? "INFINITY" : t === Number.NEGATIVE_INFINITY ? "-INFINITY" : Number.isInteger(t) ? t.toFixed(1) : t.toString();
}
function z(t) {
  return t instanceof gt ? t.type : t.dynoOut().type;
}
class gt {
  constructor(A) {
    this.__isDynoValue = !0, this.type = A;
  }
}
class v extends gt {
  constructor(A, I) {
    super(A.outTypes[I]), this.dyno = A, this.key = I;
  }
}
class dt extends gt {
  constructor(A, I) {
    super(A), this.literal = I;
  }
  getLiteral() {
    return this.literal;
  }
}
function II(t, A) {
  return new dt(t, A);
}
class hg extends dt {
  constructor(A, I) {
    super(A, ""), this.value = I;
  }
  getLiteral() {
    const { type: A, value: I } = this;
    switch (A) {
      case "bool":
        return I ? "true" : "false";
      case "uint":
        return eA(I);
      case "int":
        return iA(I);
      case "float":
        return K(I);
      case "bvec2": {
        const g = I;
        return `bvec2(${g[0]}, ${g[1]})`;
      }
      case "uvec2": {
        if (I instanceof n.Vector2)
          return `uvec2(${eA(I.x)}, ${eA(I.y)})`;
        const g = I;
        return `uvec2(${eA(g[0])}, ${eA(g[1])})`;
      }
      case "ivec2": {
        if (I instanceof n.Vector2)
          return `ivec2(${iA(I.x)}, ${iA(I.y)})`;
        const g = I;
        return `ivec2(${iA(g[0])}, ${iA(g[1])})`;
      }
      case "vec2": {
        if (I instanceof n.Vector2)
          return `vec2(${K(I.x)}, ${K(I.y)})`;
        const g = I;
        return `vec2(${K(g[0])}, ${K(g[1])})`;
      }
      case "bvec3": {
        const g = I;
        return `bvec3(${g[0]}, ${g[1]}, ${g[2]})`;
      }
      case "uvec3": {
        if (I instanceof n.Vector3)
          return `uvec3(${eA(I.x)}, ${eA(I.y)}, ${eA(I.z)})`;
        const g = I;
        return `uvec3(${eA(g[0])}, ${eA(g[1])}, ${eA(g[2])})`;
      }
      case "ivec3": {
        if (I instanceof n.Vector3)
          return `ivec3(${iA(I.x)}, ${iA(I.y)}, ${iA(I.z)})`;
        const g = I;
        return `ivec3(${iA(g[0])}, ${iA(g[1])}, ${iA(g[2])})`;
      }
      case "vec3": {
        if (I instanceof n.Vector3)
          return `vec3(${K(I.x)}, ${K(I.y)}, ${K(I.z)})`;
        const g = I;
        return `vec3(${K(g[0])}, ${K(g[1])}, ${K(g[2])})`;
      }
      case "bvec4": {
        const g = I;
        return `bvec4(${g[0]}, ${g[1]}, ${g[2]}, ${g[3]})`;
      }
      case "uvec4": {
        if (I instanceof n.Vector4)
          return `uvec4(${eA(I.x)}, ${eA(I.y)}, ${eA(I.z)}, ${eA(I.w)})`;
        const g = I;
        return `uvec4(${eA(g[0])}, ${eA(g[1])}, ${eA(g[2])}, ${eA(g[3])})`;
      }
      case "ivec4": {
        if (I instanceof n.Vector4)
          return `ivec4(${iA(I.x)}, ${iA(I.y)}, ${iA(I.z)}, ${iA(I.w)})`;
        const g = I;
        return `ivec4(${iA(g[0])}, ${iA(g[1])}, ${iA(g[2])}, ${iA(g[3])})`;
      }
      case "vec4": {
        if (I instanceof n.Vector4)
          return `vec4(${K(I.x)}, ${K(I.y)}, ${K(I.z)}, ${K(I.w)})`;
        if (I instanceof n.Quaternion)
          return `vec4(${K(I.x)}, ${K(I.y)}, ${K(I.z)}, ${K(I.w)})`;
        const g = I;
        return `vec4(${K(g[0])}, ${K(g[1])}, ${K(g[2])}, ${K(g[3])})`;
      }
      case "mat2":
      case "mat2x2": {
        const g = I, B = g instanceof n.Matrix2 ? g.elements : I, i = new Array(4).fill(0).map((e, Q) => K(B[Q]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat2x3": {
        const g = I, B = new Array(6).fill(0).map((i, e) => K(g[e]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat2x4": {
        const g = I, B = new Array(8).fill(0).map((i, e) => K(g[e]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat3":
      case "mat3x3": {
        const g = I, B = g instanceof n.Matrix3 ? g.elements : I, i = new Array(9).fill(0).map((e, Q) => K(B[Q]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat3x2": {
        const g = I, B = new Array(6).fill(0).map((i, e) => K(g[e]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat3x4": {
        const g = I, B = new Array(12).fill(0).map((i, e) => K(g[e]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat4":
      case "mat4x4": {
        const g = I, B = g instanceof n.Matrix4 ? g.elements : I, i = new Array(16).fill(0).map((e, Q) => K(B[Q]));
        return `${A}(${i.join(", ")})`;
      }
      case "mat4x2": {
        const g = I, B = new Array(8).fill(0).map((i, e) => K(g[e]));
        return `${A}(${B.join(", ")})`;
      }
      case "mat4x3": {
        const g = I, B = new Array(12).fill(0).map((i, e) => K(g[e]));
        return `${A}(${B.join(", ")})`;
      }
      default:
        throw new Error(`Type not implemented: ${String(A)}`);
    }
  }
}
function q(t, A) {
  return new hg(t, A);
}
function xt(t) {
  const A = String(t);
  if (ot(t))
    return `${A}(false)`;
  if (it(t))
    return `${A}(0.0)`;
  if (hA(t))
    return `${A}(0)`;
  if (lA(t))
    return `${A}(0u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function ns(t) {
  const A = String(t);
  if (ot(t))
    return `${A}(true)`;
  if (it(t))
    return `${A}(1.0)`;
  if (hA(t))
    return `${A}(1)`;
  if (lA(t))
    return `${A}(1u)`;
  throw new Error(`Type not implemented: ${A}`);
}
function os(t) {
  const A = String(t);
  if (ot(t))
    return `${A}(true)`;
  if (it(t))
    return `${A}(-1.0)`;
  if (hA(t))
    return `${A}(-1)`;
  if (lA(t))
    return `${A}(0xFFFFFFFFu)`;
  throw new Error(`Type not implemented: ${A}`);
}
const $I = "    ";
class lg {
  constructor({ indent: A } = {}) {
    this.globals = /* @__PURE__ */ new Set(), this.statements = [], this.uniforms = {}, this.declares = /* @__PURE__ */ new Set(), this.updaters = [], this.sequence = 0, this.indent = $I, this.indent = A ?? $I;
  }
  nextSequence() {
    return this.sequence++;
  }
}
class W {
  constructor({
    inTypes: A,
    outTypes: I,
    inputs: g,
    update: B,
    globals: i,
    statements: e,
    generate: Q
  }) {
    this.inTypes = A ?? {}, this.outTypes = I ?? {}, this.inputs = g ?? {}, this.update = B, this.globals = i, this.statements = e, this.generate = Q ?? (({ inputs: s, outputs: E, compile: a }) => {
      var C, o;
      return {
        globals: (C = this.globals) == null ? void 0 : C.call(this, { inputs: s, outputs: E, compile: a }),
        statements: (o = this.statements) == null ? void 0 : o.call(this, { inputs: s, outputs: E, compile: a })
      };
    });
  }
  get outputs() {
    const A = {};
    for (const I in this.outTypes)
      A[I] = new v(this, I);
    return A;
  }
  apply(A) {
    return Object.assign(this.inputs, A), this.outputs;
  }
  compile({
    inputs: A,
    outputs: I,
    compile: g
  }) {
    const B = [
      `// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(I).join(", ")})`
    ], i = [];
    for (const E in I) {
      const a = I[E];
      a && !g.declares.has(a) && (g.declares.add(a), i.push(E));
    }
    const { globals: e, statements: Q, uniforms: s } = this.generate({
      inputs: A,
      outputs: I,
      compile: g
    });
    for (const E of e ?? [])
      g.globals.add(E);
    for (const E in s)
      g.uniforms[E] = s[E];
    this.update && g.updaters.push(this.update);
    for (const E of i) {
      const a = I[E];
      a && (g.uniforms[a] || B.push(`${TI(a, this.outTypes[E])};`));
    }
    return Q != null && Q.length && (B.push("{"), B.push(...Q.map((E) => g.indent + E)), B.push("}")), B;
  }
}
class qA extends W {
  constructor({
    inTypes: A,
    outTypes: I,
    inputs: g,
    update: B,
    globals: i,
    construct: e
  }) {
    super({
      inTypes: A,
      outTypes: I,
      inputs: g,
      update: B,
      globals: i,
      generate: (Q) => this.generateBlock(Q)
    }), this.construct = e;
  }
  generateBlock({
    inputs: A,
    outputs: I,
    compile: g
  }) {
    var h, c;
    const B = {}, i = {};
    for (const l in A)
      A[l] != null && (B[l] = new dt(this.inTypes[l], A[l]));
    for (const l in I)
      I[l] != null && (i[l] = new gt(this.outTypes[l]));
    const e = { roots: [] }, Q = this.construct(B, i, e);
    for (const l of ((h = this.globals) == null ? void 0 : h.call(this, { inputs: A, outputs: I, compile: g })) ?? [])
      g.globals.add(l);
    const s = [], E = /* @__PURE__ */ new Map();
    function a(l, u, D) {
      let y = E.get(l);
      if (!y) {
        y = {
          sequence: g.nextSequence(),
          outNames: /* @__PURE__ */ new Map(),
          newOuts: /* @__PURE__ */ new Set()
        }, E.set(l, y);
        for (const d in l.inputs) {
          let w = l.inputs[d];
          for (; w; ) {
            if (w instanceof gt) {
              w instanceof v && a(w.dyno, w.key);
              break;
            }
            w = w.dynoOut();
          }
        }
        s.push(l);
      }
      u && (D || y.newOuts.add(u), y.outNames.set(u, D ?? `${u}_${y.sequence}`));
    }
    for (const l of e.roots)
      a(l);
    for (const l in i) {
      let u = (Q == null ? void 0 : Q[l]) ?? i[l];
      for (; u; ) {
        if (u instanceof gt) {
          u instanceof v && a(u.dyno, u.key, I[l]);
          break;
        }
        u = u.dynoOut();
      }
      i[l] = u;
    }
    const C = [];
    for (const l of s) {
      const u = {}, D = {};
      for (const w in l.inputs) {
        let F = l.inputs[w];
        for (; F; ) {
          if (F instanceof gt) {
            if (F instanceof dt)
              u[w] = F.getLiteral();
            else if (F instanceof v) {
              const m = (c = E.get(F.dyno)) == null ? void 0 : c.outNames.get(F.key);
              if (!m)
                throw new Error(
                  `Source not found for ${F.dyno.constructor.name}.${F.key}`
                );
              u[w] = m;
            }
            break;
          }
          F = F.dynoOut();
        }
      }
      const y = E.get(l) ?? { outNames: /* @__PURE__ */ new Map() };
      for (const [w, F] of y.outNames.entries())
        D[w] = F;
      const d = l.compile({ inputs: u, outputs: D, compile: g });
      C.push(d);
    }
    const o = [];
    for (const l in I)
      i[l] instanceof dt && o.push(
        `${I[l]} = ${i[l].getLiteral()};`
      );
    return o.length > 0 && C.push(o), { statements: C.flatMap((l, u) => u === 0 ? l : ["", ...l]) };
  }
}
function MA(t, A, I, { update: g, globals: B } = {}) {
  return new qA({ inTypes: t, outTypes: A, construct: I, update: g, globals: B });
}
function Kt({
  inTypes: t,
  outTypes: A,
  inputs: I,
  update: g,
  globals: B,
  statements: i,
  generate: e
}) {
  return new W({
    inTypes: t,
    outTypes: A,
    inputs: I,
    update: g,
    globals: B,
    statements: i,
    generate: e
  });
}
function TI(t, A, I) {
  const g = typeof A == "string" ? A : A.type;
  if (!g)
    throw new Error(`Invalid DynoType: ${String(A)}`);
  return `${g} ${t}${I != null ? `[${I}]` : ""}`;
}
function UA(t) {
  var i;
  let A = !1;
  const I = t.split(`
`).map((e) => {
    const Q = e.trimEnd();
    return A ? Q : Q.length > 0 ? (A = !0, Q) : null;
  }).filter((e) => e != null);
  for (; I.length > 0 && I[I.length - 1].length === 0; )
    I.pop();
  if (I.length === 0)
    return [];
  const g = (i = I[0].match(/^\s*/)) == null ? void 0 : i[0];
  if (!g)
    return I;
  const B = new RegExp(`^${g}`);
  return I.map((e) => e.replace(B, ""));
}
function oA(t) {
  return UA(t).join(`
`);
}
class N extends W {
  constructor({
    a: A,
    outKey: I,
    outTypeFunc: g
  }) {
    const B = { a: z(A) }, i = g(z(A)), e = { [I]: i };
    super({ inTypes: B, outTypes: e, inputs: { a: A } }), this.outKey = I;
  }
  dynoOut() {
    return new v(this, this.outKey);
  }
}
class $ extends W {
  constructor({
    a: A,
    b: I,
    outKey: g,
    outTypeFunc: B
  }) {
    const i = { a: z(A), b: z(I) }, e = B(z(A), z(I)), Q = { [g]: e };
    super({ inTypes: i, outTypes: Q, inputs: { a: A, b: I } }), this.outKey = g;
  }
  dynoOut() {
    return new v(this, this.outKey);
  }
}
class ct extends W {
  constructor({
    a: A,
    b: I,
    c: g,
    outKey: B,
    outTypeFunc: i
  }) {
    const e = { a: z(A), b: z(I), c: z(g) }, Q = i(z(A), z(I), z(g)), s = { [B]: Q };
    super({ inTypes: e, outTypes: s, inputs: { a: A, b: I, c: g } }), this.outKey = B;
  }
  dynoOut() {
    return new v(this, this.outKey);
  }
}
const _ = { type: "Gsplat" }, qt = { type: "PackedSplats" }, rs = (t) => new Dg({ packedSplats: t }), Jt = (t, A) => new wg({ packedSplats: t, index: A }), ug = (t, A, I, g) => new dg({ packedSplats: t, index: A, base: I, count: g }), Ct = (t) => new pg({ gsplat: t }), Bt = ({
  gsplat: t,
  flags: A,
  index: I,
  center: g,
  scales: B,
  quaternion: i,
  rgba: e,
  rgb: Q,
  opacity: s,
  x: E,
  y: a,
  z: C,
  r: o,
  g: r,
  b: h
}) => new fg({
  gsplat: t,
  flags: A,
  index: I,
  center: g,
  scales: B,
  quaternion: i,
  rgba: e,
  rgb: Q,
  opacity: s,
  x: E,
  y: a,
  z: C,
  r: o,
  g: r,
  b: h
}), SI = (t) => new Gg({ gsplat: t }), KI = (t, {
  scale: A,
  rotate: I,
  translate: g,
  recolor: B
}) => new Sg({ gsplat: t, scale: A, rotate: I, translate: g, recolor: B }), NA = oA(`
  struct Gsplat {
    vec3 center;
    uint flags;
    vec3 scales;
    int index;
    vec4 quaternion;
    vec4 rgba;
  };
  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;

  bool isGsplatActive(uint flags) {
    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;
  }
`), nI = oA(`
  struct PackedSplats {
    usampler2DArray texture;
    int numSplats;
  };
`);
class Dg extends N {
  constructor({
    packedSplats: A
  }) {
    super({ a: A, outKey: "numSplats", outTypeFunc: () => "int" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.numSplats} = ${I.a}.numSplats;`
    ];
  }
}
const yg = oA(`
  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {
    if ((index >= 0) && (index < numSplats)) {
      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);
      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);
      return true;
    } else {
      return false;
    }
  }
`);
class wg extends W {
  constructor({
    packedSplats: A,
    index: I
  }) {
    super({
      inTypes: { packedSplats: qt, index: "int" },
      outTypes: { gsplat: _ },
      inputs: { packedSplats: A, index: I },
      globals: () => [NA, nI, yg],
      statements: ({ inputs: g, outputs: B }) => {
        const { gsplat: i } = B;
        if (!i)
          return [];
        const { packedSplats: e, index: Q } = g;
        let s;
        return e && Q ? s = UA(`
            if (readPackedSplat(${e}.texture, ${e}.numSplats, ${Q}, ${i})) {
              bool zeroSize = all(equal(${i}.scales, vec3(0.0, 0.0, 0.0)));
              ${i}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
            } else {
              ${i}.flags = 0u;
            }
          `) : s = [`${i}.flags = 0u;`], s.push(`${i}.index = ${Q ?? "0"};`), s;
      }
    });
  }
  dynoOut() {
    return new v(this, "gsplat");
  }
}
class dg extends W {
  constructor({
    packedSplats: A,
    index: I,
    base: g,
    count: B
  }) {
    super({
      inTypes: {
        packedSplats: qt,
        index: "int",
        base: "int",
        count: "int"
      },
      outTypes: { gsplat: _ },
      inputs: { packedSplats: A, index: I, base: g, count: B },
      globals: () => [NA, nI, yg],
      statements: ({ inputs: i, outputs: e }) => {
        const { gsplat: Q } = e;
        if (!Q)
          return [];
        const { packedSplats: s, index: E, base: a, count: C } = i;
        let o;
        return s && E && a && C ? o = UA(`
            ${Q}.flags = 0u;
            if ((${E} >= ${a}) && (${E} < (${a} + ${C}))) {
              if (readPackedSplat(${s}.texture, ${s}.numSplats, ${E}, ${Q})) {
                bool zeroSize = all(equal(${Q}.scales, vec3(0.0, 0.0, 0.0)));
                ${Q}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;
              }
            }
          `) : o = [`${Q}.flags = 0u;`], o.push(`${Q}.index = ${E ?? "0"};`), o;
      }
    });
  }
  dynoOut() {
    return new v(this, "gsplat");
  }
}
class pg extends W {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: _ },
      outTypes: {
        flags: "uint",
        active: "bool",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      inputs: { gsplat: A },
      globals: () => [NA],
      statements: ({ inputs: I, outputs: g }) => {
        const { gsplat: B } = I, {
          flags: i,
          active: e,
          index: Q,
          center: s,
          scales: E,
          quaternion: a,
          rgba: C,
          rgb: o,
          opacity: r,
          x: h,
          y: c,
          z: l,
          r: u,
          g: D,
          b: y
        } = g;
        return [
          i ? `${i} = ${B ? `${B}.flags` : "0u"};` : null,
          e ? `${e} = isGsplatActive(${B ? `${B}.flags` : "0u"});` : null,
          Q ? `${Q} = ${B ? `${B}.index` : "0"};` : null,
          s ? `${s} = ${B ? `${B}.center` : "vec3(0.0, 0.0, 0.0)"};` : null,
          E ? `${E} = ${B ? `${B}.scales` : "vec3(0.0, 0.0, 0.0)"};` : null,
          a ? `${a} = ${B ? `${B}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)"};` : null,
          C ? `${C} = ${B ? `${B}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)"};` : null,
          o ? `${o} = ${B ? `${B}.rgba.rgb` : "vec3(0.0, 0.0, 0.0)"};` : null,
          r ? `${r} = ${B ? `${B}.rgba.a` : "0.0"};` : null,
          h ? `${h} = ${B ? `${B}.center.x` : "0.0"};` : null,
          c ? `${c} = ${B ? `${B}.center.y` : "0.0"};` : null,
          l ? `${l} = ${B ? `${B}.center.z` : "0.0"};` : null,
          u ? `${u} = ${B ? `${B}.rgba.r` : "0.0"};` : null,
          D ? `${D} = ${B ? `${B}.rgba.g` : "0.0"};` : null,
          y ? `${y} = ${B ? `${B}.rgba.b` : "0.0"};` : null
        ].filter(Boolean);
      }
    });
  }
}
class fg extends W {
  constructor({
    gsplat: A,
    flags: I,
    index: g,
    center: B,
    scales: i,
    quaternion: e,
    rgba: Q,
    rgb: s,
    opacity: E,
    x: a,
    y: C,
    z: o,
    r,
    g: h,
    b: c
  }) {
    super({
      inTypes: {
        gsplat: _,
        flags: "uint",
        index: "int",
        center: "vec3",
        scales: "vec3",
        quaternion: "vec4",
        rgba: "vec4",
        rgb: "vec3",
        opacity: "float",
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      },
      outTypes: { gsplat: _ },
      inputs: {
        gsplat: A,
        flags: I,
        index: g,
        center: B,
        scales: i,
        quaternion: e,
        rgba: Q,
        rgb: s,
        opacity: E,
        x: a,
        y: C,
        z: o,
        r,
        g: h,
        b: c
      },
      globals: () => [NA],
      statements: ({ inputs: l, outputs: u }) => {
        const { gsplat: D } = u;
        if (!D)
          return [];
        const {
          gsplat: y,
          flags: d,
          index: w,
          center: F,
          scales: m,
          quaternion: f,
          rgba: p,
          rgb: R,
          opacity: S,
          x: G,
          y: Y,
          z: M,
          r: k,
          g: U,
          b: J
        } = l;
        return [
          `${D}.flags = ${d ?? (y ? `${y}.flags` : "0u")};`,
          `${D}.index = ${w ?? (y ? `${y}.index` : "0")};`,
          `${D}.center = ${F ?? (y ? `${y}.center` : "vec3(0.0, 0.0, 0.0)")};`,
          `${D}.scales = ${m ?? (y ? `${y}.scales` : "vec3(0.0, 0.0, 0.0)")};`,
          `${D}.quaternion = ${f ?? (y ? `${y}.quaternion` : "vec4(0.0, 0.0, 0.0, 1.0)")};`,
          `${D}.rgba = ${p ?? (y ? `${y}.rgba` : "vec4(0.0, 0.0, 0.0, 0.0)")};`,
          R ? `${D}.rgba.rgb = ${R};` : null,
          S ? `${D}.rgba.a = ${S};` : null,
          G ? `${D}.center.x = ${G};` : null,
          Y ? `${D}.center.y = ${Y};` : null,
          M ? `${D}.center.z = ${M};` : null,
          k ? `${D}.rgba.r = ${k};` : null,
          U ? `${D}.rgba.g = ${U};` : null,
          J ? `${D}.rgba.b = ${J};` : null
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new v(this, "gsplat");
  }
}
const Fg = oA(`
  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {
    float minScale = min(scales.x, min(scales.y, scales.z));
    vec3 normal;
    if (scales.z == minScale) {
      normal = vec3(0.0, 0.0, 1.0);
    } else if (scales.y == minScale) {
      normal = vec3(0.0, 1.0, 0.0);
    } else {
      normal = vec3(1.0, 0.0, 0.0);
    }
    return quatVec(quaternion, normal);
  }
`);
class Gg extends N {
  constructor({ gsplat: A }) {
    super({ a: A, outKey: "normal", outTypeFunc: () => "vec3" }), this.globals = () => [NA, Fg], this.statements = ({ inputs: I, outputs: g }) => [
      `${g.normal} = gsplatNormal(${I.a}.scales, ${I.a}.quaternion);`
    ];
  }
}
class Sg extends W {
  constructor({
    gsplat: A,
    scale: I,
    rotate: g,
    translate: B,
    recolor: i
  }) {
    super({
      inTypes: {
        gsplat: _,
        scale: "float",
        rotate: "vec4",
        translate: "vec3",
        recolor: "vec4"
      },
      outTypes: { gsplat: _ },
      inputs: { gsplat: A, scale: I, rotate: g, translate: B, recolor: i },
      globals: () => [NA],
      statements: ({ inputs: e, outputs: Q, compile: s }) => {
        const { gsplat: E } = Q;
        if (!E || !e.gsplat)
          return [];
        const { scale: a, rotate: C, translate: o, recolor: r } = e, h = s.indent;
        return [
          `${E} = ${e.gsplat};`,
          `if (isGsplatActive(${E}.flags)) {`,
          a ? `${h}${E}.center *= ${a};` : null,
          C ? `${h}${E}.center = quatVec(${C}, ${E}.center);` : null,
          o ? `${h}${E}.center += ${o};` : null,
          a ? `${h}${E}.scales *= ${a};` : null,
          C ? `${h}${E}.quaternion = quatQuat(${C}, ${E}.quaternion);` : null,
          r ? `${h}${E}.rgba *= ${r};` : null,
          "}"
        ].filter(Boolean);
      }
    });
  }
  dynoOut() {
    return new v(this, "gsplat");
  }
}
const Ng = (t) => new mg({ gsplat: t }), cs = (t) => new qI({ rgba8: t });
class mg extends W {
  constructor({ gsplat: A }) {
    super({
      inTypes: { gsplat: _ },
      inputs: { gsplat: A },
      globals: () => [NA],
      statements: ({ inputs: I, outputs: g }) => {
        const { output: B } = g;
        if (!B)
          return [];
        const { gsplat: i } = I;
        return i ? UA(`
            if (isGsplatActive(${i}.flags)) {
              ${B} = packSplat(${i}.center, ${i}.scales, ${i}.quaternion, ${i}.rgba);
            } else {
              ${B} = uvec4(0u, 0u, 0u, 0u);
            }
          `) : [`${B} = uvec4(0u, 0u, 0u, 0u);`];
      }
    });
  }
  dynoOut() {
    return new v(this, "output");
  }
}
class qI extends W {
  constructor({ rgba8: A }) {
    super({
      inTypes: { rgba8: "vec4" },
      inputs: { rgba8: A },
      statements: ({ inputs: I, outputs: g }) => [
        `target = ${I.rgba8 ?? "vec4(0.0, 0.0, 0.0, 0.0)"};`
      ]
    });
  }
  dynoOut() {
    return new v(this, "rgba8");
  }
}
const hs = (t, A, I) => new x({ key: t, type: A, value: I }), ls = (t = !1, A) => new gI({ key: A, value: t }), us = (t = 0, A) => new Mg({ key: A, value: t }), Ds = (t = 0, A) => new Ht({ key: A, value: t }), HA = (t = 0, A) => new Et({ key: A, value: t }), ys = (t, A) => new kg({ key: A, value: t }), ws = (t, A) => new xg({ key: A, value: t }), ds = (t, A) => new Rg({ key: A, value: t }), ps = (t, A) => new Ug({ key: A, value: t }), fs = (t, A) => new Yg({ key: A, value: t }), Fs = (t, A) => new Lg({ key: A, value: t }), Gs = (t, A) => new Jg({ key: A, value: t }), _A = (t, A) => new ft({ key: A, value: t }), Ss = (t, A) => new Hg({ key: A, value: t }), Ns = (t, A) => new bg({ key: A, value: t }), ms = (t, A) => new Tg({ key: A, value: t }), Ms = (t, A) => new vt({ key: A, value: t }), ks = (t, A) => new Kg({ key: A, value: t }), xs = (t, A) => new qg({ key: A, value: t }), Rs = (t, A) => new vg({ key: A, value: t }), Us = (t, A) => new Zg({ key: A, value: t }), Ys = (t, A) => new zg({ key: A, value: t }), Ls = (t, A) => new Wg({ key: A, value: t }), Js = (t, A) => new Og({ key: A, value: t }), Hs = (t, A) => new Vg({ key: A, value: t }), bs = (t, A) => new Pg({ key: A, value: t }), Ts = (t, A) => new Xg({ key: A, value: t }), Ks = (t, A) => new jg({ key: A, value: t }), qs = (t, A) => new _g({ key: A, value: t }), vs = (t, A) => new $g({ key: A, value: t }), Zs = (t, A) => new AB({ key: A, value: t }), zs = (t, A) => new tB({ key: A, value: t }), Ws = (t, A) => new Ut({ key: A, value: t }), Os = (t, A) => new IB({ key: t, value: A }), Vs = (t, A) => new gB({ key: A, value: t }), Ps = (t, A) => new BB({ key: A, value: t }), Xs = (t, A) => new iB({ key: A, value: t }), js = (t, A) => new eB({ key: A, value: t }), _s = (t, A) => new QB({ key: A, value: t }), $s = (t, A) => new sB({ key: A, value: t }), AC = (t, A) => new CB({ key: A, value: t }), tC = (t, A) => new EB({ key: A, value: t }), IC = (t, A) => new aB({ key: A, value: t }), gC = (t, A) => new nB({ key: A, value: t });
class x extends W {
  constructor({
    key: A,
    type: I,
    count: g,
    value: B,
    update: i,
    globals: e
  }) {
    A = A ?? "value", super({
      outTypes: { [A]: I },
      update: () => {
        if (i) {
          const Q = i(this.value);
          Q !== void 0 && (this.value = Q);
        }
        this.uniform.value = this.value;
      },
      generate: ({ inputs: Q, outputs: s }) => {
        const E = (e == null ? void 0 : e({ inputs: Q, outputs: s })) ?? [], a = {}, C = s[A];
        return C && (E.push(`uniform ${TI(C, I, g)};`), a[C] = this.uniform), { globals: E, uniforms: a };
      }
    }), this.type = I, this.count = g, this.value = B, this.uniform = { value: B }, this.outKey = A;
  }
  dynoOut() {
    return new v(this, this.outKey);
  }
}
class gI extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "bool", value: I, update: g });
  }
}
class Mg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "uint", value: I, update: g });
  }
}
class Ht extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "int", value: I, update: g });
  }
}
class Et extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "float", value: I, update: g });
  }
}
class kg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "bvec2", value: I, update: g });
  }
}
class xg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "uvec2", value: I, update: g });
  }
}
class Rg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "ivec2", value: I, update: g });
  }
}
class Ug extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "vec2", value: I, update: g });
  }
}
class Yg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "bvec3", value: I, update: g });
  }
}
class Lg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "uvec3", value: I, update: g });
  }
}
class Jg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "ivec3", value: I, update: g });
  }
}
class ft extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "vec3", value: I, update: g });
  }
}
class Hg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "bvec4", value: I, update: g });
  }
}
class bg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "uvec4", value: I, update: g });
  }
}
class Tg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "ivec4", value: I, update: g });
  }
}
class vt extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "vec4", value: I, update: g });
  }
}
class Kg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat2", value: I, update: g });
  }
}
class qg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat2x2", value: I, update: g });
  }
}
class vg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat2x3", value: I, update: g });
  }
}
class Zg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat2x4", value: I, update: g });
  }
}
class zg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat3", value: I, update: g });
  }
}
class Wg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat3x2", value: I, update: g });
  }
}
class Og extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat3x3", value: I, update: g });
  }
}
class Vg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat3x4", value: I, update: g });
  }
}
class Pg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat4", value: I, update: g });
  }
}
class Xg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat4x2", value: I, update: g });
  }
}
class jg extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat4x3", value: I, update: g });
  }
}
class _g extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "mat4x4", value: I, update: g });
  }
}
class $g extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "usampler2D", value: I, update: g });
  }
}
class AB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "isampler2D", value: I, update: g });
  }
}
class tB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler2D", value: I, update: g });
  }
}
class Ut extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "usampler2DArray", value: I, update: g });
  }
}
class IB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "isampler2DArray", value: I, update: g });
  }
}
class gB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler2DArray", value: I, update: g });
  }
}
class BB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "usampler3D", value: I, update: g });
  }
}
class iB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "isampler3D", value: I, update: g });
  }
}
class eB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler3D", value: I, update: g });
  }
}
class QB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "usamplerCube", value: I, update: g });
  }
}
class sB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "isamplerCube", value: I, update: g });
  }
}
class CB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "samplerCube", value: I, update: g });
  }
}
class EB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler2DShadow", value: I, update: g });
  }
}
class aB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "sampler2DArrayShadow", value: I, update: g });
  }
}
class nB extends x {
  constructor({
    key: A,
    value: I,
    update: g
  }) {
    super({ key: A, type: "samplerCubeShadow", value: I, update: g });
  }
}
var cA = Uint8Array, Dt = Uint16Array, BC = Int32Array, oB = new cA([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  /* unused */
  0,
  0,
  /* impossible */
  0
]), rB = new cA([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  /* unused */
  0,
  0
]), iC = new cA([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), cB = function(t, A) {
  for (var I = new Dt(31), g = 0; g < 31; ++g)
    I[g] = A += 1 << t[g - 1];
  for (var B = new BC(I[30]), g = 1; g < 30; ++g)
    for (var i = I[g]; i < I[g + 1]; ++i)
      B[i] = i - I[g] << 5 | g;
  return { b: I, r: B };
}, hB = cB(oB, 2), lB = hB.b, eC = hB.r;
lB[28] = 258, eC[258] = 28;
var QC = cB(rB, 0), sC = QC.b, NI = new Dt(32768);
for (var BA = 0; BA < 32768; ++BA) {
  var jA = (BA & 43690) >> 1 | (BA & 21845) << 1;
  jA = (jA & 52428) >> 2 | (jA & 13107) << 2, jA = (jA & 61680) >> 4 | (jA & 3855) << 4, NI[BA] = ((jA & 65280) >> 8 | (jA & 255) << 8) >> 1;
}
var Yt = function(t, A, I) {
  for (var g = t.length, B = 0, i = new Dt(A); B < g; ++B)
    t[B] && ++i[t[B] - 1];
  var e = new Dt(A);
  for (B = 1; B < A; ++B)
    e[B] = e[B - 1] + i[B - 1] << 1;
  var Q;
  if (I) {
    Q = new Dt(1 << A);
    var s = 15 - A;
    for (B = 0; B < g; ++B)
      if (t[B])
        for (var E = B << 4 | t[B], a = A - t[B], C = e[t[B] - 1]++ << a, o = C | (1 << a) - 1; C <= o; ++C)
          Q[NI[C] >> s] = E;
  } else
    for (Q = new Dt(g), B = 0; B < g; ++B)
      t[B] && (Q[B] = NI[e[t[B] - 1]++] >> 15 - t[B]);
  return Q;
}, Zt = new cA(288);
for (var BA = 0; BA < 144; ++BA)
  Zt[BA] = 8;
for (var BA = 144; BA < 256; ++BA)
  Zt[BA] = 9;
for (var BA = 256; BA < 280; ++BA)
  Zt[BA] = 7;
for (var BA = 280; BA < 288; ++BA)
  Zt[BA] = 8;
var uB = new cA(32);
for (var BA = 0; BA < 32; ++BA)
  uB[BA] = 5;
var CC = /* @__PURE__ */ Yt(Zt, 9, 1), EC = /* @__PURE__ */ Yt(uB, 5, 1), dI = function(t) {
  for (var A = t[0], I = 1; I < t.length; ++I)
    t[I] > A && (A = t[I]);
  return A;
}, LA = function(t, A, I) {
  var g = A / 8 | 0;
  return (t[g] | t[g + 1] << 8) >> (A & 7) & I;
}, pI = function(t, A) {
  var I = A / 8 | 0;
  return (t[I] | t[I + 1] << 8 | t[I + 2] << 16) >> (A & 7);
}, DB = function(t) {
  return (t + 7) / 8 | 0;
}, _t = function(t, A, I) {
  return (A == null || A < 0) && (A = 0), (I == null || I > t.length) && (I = t.length), new cA(t.subarray(A, I));
}, aC = [
  "unexpected EOF",
  "invalid block type",
  "invalid length/literal",
  "invalid distance",
  "stream finished",
  "no stream handler",
  ,
  "no callback",
  "invalid UTF-8 data",
  "extra field too long",
  "date not in range 1980-2099",
  "filename too long",
  "stream finishing",
  "invalid zip data"
  // determined by unknown compression method
], kA = function(t, A, I) {
  var g = new Error(A || aC[t]);
  if (g.code = t, Error.captureStackTrace && Error.captureStackTrace(g, kA), !I)
    throw g;
  return g;
}, nC = function(t, A, I, g) {
  var B = t.length, i = 0;
  if (!B || A.f && !A.l)
    return I || new cA(0);
  var e = !I, Q = e || A.i != 2, s = A.i;
  e && (I = new cA(B * 3));
  var E = function(wA) {
    var FA = I.length;
    if (wA > FA) {
      var rA = new cA(Math.max(FA * 2, wA));
      rA.set(I), I = rA;
    }
  }, a = A.f || 0, C = A.p || 0, o = A.b || 0, r = A.l, h = A.d, c = A.m, l = A.n, u = B * 8;
  do {
    if (!r) {
      a = LA(t, C, 1);
      var D = LA(t, C + 1, 3);
      if (C += 3, D)
        if (D == 1)
          r = CC, h = EC, c = 9, l = 5;
        else if (D == 2) {
          var F = LA(t, C, 31) + 257, m = LA(t, C + 10, 15) + 4, f = F + LA(t, C + 5, 31) + 1;
          C += 14;
          for (var p = new cA(f), R = new cA(19), S = 0; S < m; ++S)
            R[iC[S]] = LA(t, C + S * 3, 7);
          C += m * 3;
          for (var G = dI(R), Y = (1 << G) - 1, M = Yt(R, G, 1), S = 0; S < f; ) {
            var k = M[LA(t, C, Y)];
            C += k & 15;
            var y = k >> 4;
            if (y < 16)
              p[S++] = y;
            else {
              var U = 0, J = 0;
              for (y == 16 ? (J = 3 + LA(t, C, 3), C += 2, U = p[S - 1]) : y == 17 ? (J = 3 + LA(t, C, 7), C += 3) : y == 18 && (J = 11 + LA(t, C, 127), C += 7); J--; )
                p[S++] = U;
            }
          }
          var AA = p.subarray(0, F), Z = p.subarray(F);
          c = dI(AA), l = dI(Z), r = Yt(AA, c, 1), h = Yt(Z, l, 1);
        } else
          kA(1);
      else {
        var y = DB(C) + 4, d = t[y - 4] | t[y - 3] << 8, w = y + d;
        if (w > B) {
          s && kA(0);
          break;
        }
        Q && E(o + d), I.set(t.subarray(y, w), o), A.b = o += d, A.p = C = w * 8, A.f = a;
        continue;
      }
      if (C > u) {
        s && kA(0);
        break;
      }
    }
    Q && E(o + 131072);
    for (var gA = (1 << c) - 1, tA = (1 << l) - 1, V = C; ; V = C) {
      var U = r[pI(t, C) & gA], b = U >> 4;
      if (C += U & 15, C > u) {
        s && kA(0);
        break;
      }
      if (U || kA(2), b < 256)
        I[o++] = b;
      else if (b == 256) {
        V = C, r = null;
        break;
      } else {
        var P = b - 254;
        if (b > 264) {
          var S = b - 257, O = oB[S];
          P = LA(t, C, (1 << O) - 1) + lB[S], C += O;
        }
        var X = h[pI(t, C) & tA], L = X >> 4;
        X || kA(3), C += X & 15;
        var Z = sC[L];
        if (L > 3) {
          var O = rB[L];
          Z += pI(t, C) & (1 << O) - 1, C += O;
        }
        if (C > u) {
          s && kA(0);
          break;
        }
        Q && E(o + 131072);
        var DA = o + P;
        if (o < Z) {
          var CA = i - Z, yA = Math.min(Z, DA);
          for (CA + o < 0 && kA(3); o < yA; ++o)
            I[o] = g[CA + o];
        }
        for (; o < DA; ++o)
          I[o] = I[o - Z];
      }
    }
    A.l = r, A.p = V, A.b = o, A.f = a, r && (a = 1, A.m = c, A.d = h, A.n = l);
  } while (!a);
  return o != I.length && e ? _t(I, 0, o) : I.subarray(0, o);
}, oC = /* @__PURE__ */ new cA(0), rC = function(t) {
  (t[0] != 31 || t[1] != 139 || t[2] != 8) && kA(6, "invalid gzip data");
  var A = t[3], I = 10;
  A & 4 && (I += (t[10] | t[11] << 8) + 2);
  for (var g = (A >> 3 & 1) + (A >> 4 & 1); g > 0; g -= !t[I++])
    ;
  return I + (A & 2);
}, fI = /* @__PURE__ */ function() {
  function t(A, I) {
    typeof A == "function" && (I = A, A = {}), this.ondata = I;
    var g = A && A.dictionary && A.dictionary.subarray(-32768);
    this.s = { i: 0, b: g ? g.length : 0 }, this.o = new cA(32768), this.p = new cA(0), g && this.o.set(g);
  }
  return t.prototype.e = function(A) {
    if (this.ondata || kA(5), this.d && kA(4), !this.p.length)
      this.p = A;
    else if (A.length) {
      var I = new cA(this.p.length + A.length);
      I.set(this.p), I.set(A, this.p.length), this.p = I;
    }
  }, t.prototype.c = function(A) {
    this.s.i = +(this.d = A || !1);
    var I = this.s.b, g = nC(this.p, this.s, this.o);
    this.ondata(_t(g, I, this.s.b), this.d), this.o = _t(g, this.s.b - 32768), this.s.b = this.o.length, this.p = _t(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  }, t.prototype.push = function(A, I) {
    this.e(A), this.c(I);
  }, t;
}(), yB = /* @__PURE__ */ function() {
  function t(A, I) {
    this.v = 1, this.r = 0, fI.call(this, A, I);
  }
  return t.prototype.push = function(A, I) {
    if (fI.prototype.e.call(this, A), this.r += A.length, this.v) {
      var g = this.p.subarray(this.v - 1), B = g.length > 3 ? rC(g) : 4;
      if (B > g.length) {
        if (!I)
          return;
      } else this.v > 1 && this.onmember && this.onmember(this.r - g.length);
      this.p = g.subarray(B), this.v = 0;
    }
    fI.prototype.c.call(this, I), this.s.f && !this.s.l && !I && (this.v = DB(this.s.p) + 9, this.s = { i: 0 }, this.o = new cA(0), this.push(new cA(0), I));
  }, t;
}(), cC = typeof TextDecoder < "u" && /* @__PURE__ */ new TextDecoder(), hC = 0;
try {
  cC.decode(oC, { stream: !0 }), hC = 1;
} catch {
}
const zt = new Float32Array(1), oI = new Uint32Array(zt.buffer);
function lC(t) {
  return zt[0] = t, oI[0];
}
function uC(t) {
  return oI[0] = t, zt[0];
}
function at(t) {
  zt[0] = t;
  const A = oI[0], I = A >> 31 & 1, g = A >> 23 & 255, B = A & 8388607, i = I << 15;
  if (g === 255)
    return B !== 0 ? i | 32767 : i | 31744;
  const e = g - 127 + 15;
  if (e >= 31)
    return i | 31744;
  if (e <= 0) {
    if (e < -10)
      return i;
    const s = (B | 8388608) >> 1 - e + 13;
    return i | s;
  }
  const Q = B >> 13;
  return i | e << 10 | Q;
}
function dA(t) {
  const A = t >> 15 & 1, I = t >> 10 & 31, g = t & 1023;
  let B;
  if (I === 0)
    if (g === 0)
      B = A << 31;
    else {
      let i = g, e = -14;
      for (; (i & 1024) === 0; )
        i <<= 1, e--;
      i &= 1023;
      const Q = e + 127, s = i << 13;
      B = A << 31 | Q << 23 | s;
    }
  else if (I === 31)
    g === 0 ? B = A << 31 | 2139095040 : B = A << 31 | 2143289344;
  else {
    const i = I - 15 + 127, e = g << 13;
    B = A << 31 | i << 23 | e;
  }
  return oI[0] = B, zt[0];
}
function mA(t) {
  return Math.max(0, Math.min(255, Math.round(t * 255)));
}
function $t(t) {
  return Math.max(-127, Math.min(127, Math.round(t * 127)));
}
function DC(t) {
  return t / 255;
}
function yC(t) {
  return t / 127;
}
class wC {
  // Create a DataCache with a given function that fetches data not in the cache.
  constructor({
    asyncFetch: A,
    maxItems: I = 5
  }) {
    this.asyncFetch = A, this.maxItems = I, this.items = [];
  }
  // Fetch data for the key, returning cached data if available.
  async getFetch(A) {
    const I = this.items.findIndex((B) => B.key === A);
    if (I >= 0) {
      const B = this.items.splice(I, 1)[0];
      return this.items.push(B), B.data;
    }
    const g = await this.asyncFetch(A);
    for (this.items.push({ key: A, data: g }); this.items.length > this.maxItems; )
      this.items.shift();
    return g;
  }
}
function dC(t, A) {
  const I = Object.entries(t).map(([g, B]) => [
    g,
    A(B, g)
  ]);
  return Object.fromEntries(I);
}
function pC(t, A) {
  const I = Object.entries(t).map(([g, B]) => [g, A(B, g)]).filter(([g, B]) => B !== void 0);
  return Object.fromEntries(I);
}
function wB(t) {
  const A = [], I = /* @__PURE__ */ new Set();
  function g(B) {
    B && typeof B == "object" && !I.has(B) && (I.add(B), B instanceof ArrayBuffer ? A.push(B) : ArrayBuffer.isView(B) ? A.push(B.buffer) : Array.isArray(B) ? B.forEach(g) : Object.values(B).forEach(g));
  }
  return g(t), A;
}
function fC(t, A) {
  return new Array(t).fill(null).map((I, g) => A(g));
}
class dB {
  constructor({
    // Allocate a new item with the given args
    allocate: A,
    // Dispose of an item (optional, if GC is enough)
    dispose: I,
    // Check if an existing item in the list is valid for the given args,
    // allowing you to store heterogeneous items in the list.
    valid: g
  }) {
    this.items = [], this.allocate = A, this.dispose = I, this.valid = g;
  }
  // Allocate a new item from the free list, first checking if a existing item
  // on the freelist is valid for the given args.
  alloc(A) {
    for (; ; ) {
      const I = this.items.pop();
      if (!I)
        break;
      if (this.valid(I, A))
        return I;
      this.dispose && this.dispose(I);
    }
    return this.allocate(A);
  }
  free(A) {
    this.items.push(A);
  }
  disposeAll() {
    let A;
    for (A = this.items.pop(); A; )
      this.dispose && this.dispose(A), A = this.items.pop();
  }
}
function mI(t, A, I, g, B, i, e, Q, s, E, a, C, o, r, h, c) {
  const l = mA(r), u = mA(h), D = mA(c), y = mA(o), d = vI(
    new n.Quaternion(s, E, a, C)
  ), w = d & 255, F = d >>> 8 & 255, m = d >>> 16 & 255, f = i === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(i) - bA) / WA) + 1
    )
  ), p = e === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(e) - bA) / WA) + 1
    )
  ), R = Q === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(Q) - bA) / WA) + 1
    )
  ), S = at(I), G = at(g), Y = at(B), M = A * 4;
  t[M] = l | u << 8 | D << 16 | y << 24, t[M + 1] = S | G << 16, t[M + 2] = Y | w << 16 | F << 24, t[M + 3] = f | p << 8 | R << 16 | m << 24;
}
function FC(t, A, I, g, B) {
  const i = at(I), e = at(g), Q = at(B), s = A * 4;
  t[s + 1] = i | e << 16, t[s + 2] = Q | t[s + 2] & 4294901760;
}
function GC(t, A, I, g, B) {
  const i = I === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(I) - bA) / WA) + 1
    )
  ), e = g === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(g) - bA) / WA) + 1
    )
  ), Q = B === 0 ? 0 : Math.min(
    255,
    Math.max(
      0,
      Math.round((Math.log(B) - bA) / WA) + 1
    )
  ), s = A * 4;
  t[s + 3] = i | e << 8 | Q << 16 | t[s + 3] & 4278190080;
}
function SC(t, A, I, g, B, i) {
  const e = vI(
    new n.Quaternion(I, g, B, i)
  ), Q = e & 255, s = e >>> 8 & 255, E = e >>> 16 & 255, a = A * 4;
  t[a + 2] = t[a + 2] & 65535 | Q << 16 | s << 24, t[a + 3] = t[a + 3] & 16777215 | E << 24;
}
function NC(t, A, I, g, B, i) {
  const e = mA(I), Q = mA(g), s = mA(B), E = mA(i), a = A * 4;
  t[a] = e | Q << 8 | s << 16 | E << 24;
}
function mC(t, A, I, g, B) {
  const i = mA(I), e = mA(g), Q = mA(B), s = A * 4;
  t[s] = i | e << 8 | Q << 16 | t[s] & 4278190080;
}
function MC(t, A, I) {
  const g = mA(I), B = A * 4;
  t[B] = t[B] & 16777215 | g << 24;
}
const kC = new n.Vector3(), xC = new n.Vector3(), RC = new n.Quaternion(), UC = new n.Color(), YC = {
  center: kC,
  scales: xC,
  quaternion: RC,
  color: UC,
  opacity: 0
};
function MI(t, A) {
  const I = YC, g = A * 4, B = t[g], i = t[g + 1], e = t[g + 2], Q = t[g + 3];
  I.color.set(
    (B & 255) / 255,
    (B >>> 8 & 255) / 255,
    (B >>> 16 & 255) / 255
  ), I.opacity = (B >>> 24 & 255) / 255, I.center.set(
    dA(i & 65535),
    dA(i >>> 16 & 65535),
    dA(e & 65535)
  );
  const s = Q & 255;
  I.scales.x = s === 0 ? 0 : Math.exp(bA + (s - 1) * WA);
  const E = Q >>> 8 & 255;
  I.scales.y = E === 0 ? 0 : Math.exp(bA + (E - 1) * WA);
  const a = Q >>> 16 & 255;
  I.scales.z = a === 0 ? 0 : Math.exp(bA + (a - 1) * WA);
  const C = e >>> 16 & 65535 | Q >>> 8 & 16711680;
  return mB(C, I.quaternion), I;
}
function fA(t) {
  const A = j, I = Math.max(
    Eg,
    Math.min(It, Math.ceil(t / A))
  ), g = Math.ceil(t / (A * I)), B = A * I * g;
  return { width: A, height: I, depth: g, maxSplats: B };
}
function LC(t) {
  const A = j, I = Math.max(
    Eg,
    Math.min(It, Math.ceil(t / A))
  ), g = Math.ceil(t / (A * I));
  return A * I * g;
}
function JC() {
  return navigator.maxTouchPoints > 0 ? !0 : /Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile/.test(
    navigator.userAgent
  );
}
function HC() {
  return /Android/.test(navigator.userAgent);
}
function bC() {
  return /Oculus/.test(navigator.userAgent);
}
function TC(t, A, I) {
  const g = new Uint8Array(A * 4);
  for (let B = 0; B < I / 2; B++) {
    const i = B * A * 4, e = (I - 1 - B) * A * 4;
    g.set(t.subarray(i, i + A * 4)), t.set(
      t.subarray(e, e + A * 4),
      i
    ), t.set(g, e);
  }
  return t;
}
function KC(t, A, I) {
  const g = document.createElement("canvas");
  g.width = A, g.height = I;
  const B = g.getContext("2d");
  if (!B)
    throw new Error("Can't get 2d context");
  const i = B.createImageData(A, I);
  return i.data.set(t), B.putImageData(i, 0, 0), g.toDataURL("image/png");
}
function pB(t) {
  const A = new n.Clock(t.autoStart);
  return A.startTime = t.startTime, A.oldTime = t.oldTime, A.elapsedTime = t.elapsedTime, A.running = t.running, A;
}
function qC(t) {
  return Object.fromEntries(
    Object.entries(t).filter(([A, I]) => I !== void 0)
  );
}
const fB = oA(`
  precision highp float;

  in vec3 position;

  void main() {
    gl_Position = vec4(position.xy, 0.0, 1.0);
  }
`);
function FB(t) {
  const A = new n.Vector3();
  for (const I of t)
    A.add(I);
  return A.divideScalar(t.length);
}
function GB(t) {
  if (t.length === 0)
    return new n.Quaternion();
  const A = t[0].clone();
  for (let I = 1; I < t.length; I++)
    t[I].dot(t[0]) < 0 ? (A.x -= t[I].x, A.y -= t[I].y, A.z -= t[I].z, A.w -= t[I].w) : (A.x += t[I].x, A.y += t[I].y, A.z += t[I].z, A.w += t[I].w);
  return A.normalize();
}
function SB(t, A) {
  const I = new n.Vector3(0, 0, 0).applyMatrix4(t), g = new n.Vector3(0, 0, 0).applyMatrix4(A), B = new n.Vector3(0, 0, -1).applyMatrix4(t).sub(I).normalize(), i = new n.Vector3(0, 0, -1).applyMatrix4(A).sub(g).normalize(), e = I.distanceTo(g), Q = B.dot(i);
  return { distance: e, coincidence: Q };
}
function vC({
  matrix1: t,
  matrix2: A,
  maxDistance: I
}) {
  const g = new n.Vector3(0, 0, 0).applyMatrix4(t), B = new n.Vector3(0, 0, 0).applyMatrix4(A);
  return g.distanceTo(B) <= I;
}
function ZC({
  matrix1: t,
  matrix2: A,
  maxDistance: I,
  minCoincidence: g
}) {
  const { distance: B, coincidence: i } = SB(t, A);
  return B <= I && (g == null || i >= g);
}
function NB(t, A) {
  const [I, g] = [new n.Vector3(), new n.Quaternion()], [B, i] = [new n.Vector3(), new n.Quaternion()];
  t.decompose(I, g, new n.Vector3()), A.decompose(B, i, new n.Vector3());
  const e = I.distanceTo(B), Q = Math.abs(g.dot(i));
  return { distance: e, coorient: Q };
}
function BI({
  matrix1: t,
  matrix2: A,
  maxDistance: I,
  minCoorient: g
}) {
  const { distance: B, coorient: i } = NB(t, A);
  return B <= I && (g == null || i >= g);
}
function zC(t, A = 1e-3) {
  return Math.abs(t) < A ? 0 : Math.sign(t);
}
function WC(t) {
  const A = t.w < 0, I = $t(A ? -t.x : t.x), g = $t(A ? -t.y : t.y), B = $t(A ? -t.z : t.z), i = I & 255, e = g & 255, Q = B & 255;
  return i | e << 8 | Q << 16;
}
function OC(t, A) {
  const I = t << 24 >> 24, g = t << 16 >> 24, B = t << 8 >> 24;
  A.set(I / 127, g / 127, B / 127, 0);
  const i = A.x * A.x + A.y * A.y + A.z * A.z;
  return A.w = Math.sqrt(Math.max(0, 1 - i)), A;
}
function vI(t) {
  const A = t.clone().normalize();
  A.w < 0 && A.set(-A.x, -A.y, -A.z, -A.w);
  const I = 2 * Math.acos(A.w), g = Math.sqrt(
    A.x * A.x + A.y * A.y + A.z * A.z
  ), B = g < 1e-6 ? new n.Vector3(1, 0, 0) : new n.Vector3(A.x, A.y, A.z).divideScalar(g), i = Math.abs(B.x) + Math.abs(B.y) + Math.abs(B.z);
  let e = B.x / i, Q = B.y / i;
  if (B.z < 0) {
    const r = e;
    e = (1 - Math.abs(Q)) * (e >= 0 ? 1 : -1), Q = (1 - Math.abs(r)) * (Q >= 0 ? 1 : -1);
  }
  const s = e * 0.5 + 0.5, E = Q * 0.5 + 0.5, a = Math.round(s * 255), C = Math.round(E * 255);
  return Math.round(I * (255 / Math.PI)) << 16 | C << 8 | a;
}
function mB(t, A) {
  const I = t & 255, g = t >>> 8 & 255, B = t >>> 16 & 255, i = I / 255, e = g / 255;
  let Q = (i - 0.5) * 2, s = (e - 0.5) * 2;
  const E = 1 - (Math.abs(Q) + Math.abs(s)), a = Math.max(-E, 0);
  Q += Q >= 0 ? -a : a, s += s >= 0 ? -a : a;
  const C = new n.Vector3(Q, s, E).normalize(), r = B / 255 * Math.PI * 0.5, h = Math.sin(r), c = Math.cos(r);
  return A.set(C.x * h, C.y * h, C.z * h, c), A;
}
function VC(t) {
  const A = t.clone().normalize(), I = 2 * (A.w * A.x + A.y * A.z), g = 1 - 2 * (A.x * A.x + A.y * A.y), B = Math.atan2(I, g), i = 2 * (A.w * A.y - A.z * A.x), e = Math.abs(i) >= 1 ? Math.sign(i) * (Math.PI / 2) : Math.asin(i), Q = 2 * (A.w * A.z + A.x * A.y), s = 1 - 2 * (A.y * A.y + A.z * A.z), E = Math.atan2(Q, s), a = (B + Math.PI) / (2 * Math.PI), C = (e + Math.PI) / (2 * Math.PI), o = (E + Math.PI) / (2 * Math.PI), r = Math.round(a * 255), h = Math.round(C * 255);
  return Math.round(o * 255) << 16 | h << 8 | r;
}
function PC(t, A) {
  const I = t & 255, g = t >>> 8 & 255, B = t >>> 16 & 255, i = I / 255, e = g / 255, Q = B / 255, s = i * (2 * Math.PI) - Math.PI, E = e * (2 * Math.PI) - Math.PI, a = Q * (2 * Math.PI) - Math.PI, C = Math.cos(s * 0.5), o = Math.sin(s * 0.5), r = Math.cos(E * 0.5), h = Math.sin(E * 0.5), c = Math.cos(a * 0.5), l = Math.sin(a * 0.5);
  return A.w = C * r * c + o * h * l, A.x = o * r * c - C * h * l, A.y = C * h * c + o * r * l, A.z = C * r * l - o * h * c, A.normalize(), A;
}
function Ot(t, A, I, g) {
  const B = Math.max(-127, Math.min(127, t * 127)), i = Math.max(-127, Math.min(127, A * 127)), e = Math.max(-127, Math.min(127, I * 127)), Q = Math.max(-127, Math.min(127, g * 127));
  return B & 255 | (i & 255) << 8 | (e & 255) << 16 | (Q & 255) << 24;
}
function XC(t, A, I) {
  const g = A * 2;
  for (let B = 0; B < 9; ++B) {
    const i = Math.max(-63, Math.min(63, I[B] * 63)) & 127, e = B * 7, Q = e + 7, s = Math.floor(e / 32), E = e - s * 32, a = i << E & 4294967295;
    if (t[g + s] |= a, Q > s * 32 + 32) {
      const C = i >>> 32 - E & 4294967295;
      t[g + s + 1] |= C;
    }
  }
}
function jC(t, A, I) {
  t[A * 4 + 0] = Ot(
    I[0],
    I[1],
    I[2],
    I[3]
  ), t[A * 4 + 1] = Ot(
    I[4],
    I[5],
    I[6],
    I[7]
  ), t[A * 4 + 2] = Ot(
    I[8],
    I[9],
    I[10],
    I[11]
  ), t[A * 4 + 3] = Ot(
    I[12],
    I[13],
    I[14],
    0
  );
}
function _C(t, A, I) {
  const g = A * 4;
  for (let B = 0; B < 21; ++B) {
    const i = Math.max(-31, Math.min(31, I[B] * 31)) & 63, e = B * 6, Q = e + 6, s = Math.floor(e / 32), E = e - s * 32, a = i << E & 4294967295;
    if (t[g + s] |= a, Q > s * 32 + 32) {
      const C = i >>> 32 - E & 4294967295;
      t[g + s + 1] |= C;
    }
  }
}
function MB(t, A) {
  const I = [];
  let g = 0, B = null;
  const i = new yB((s, E) => {
    if (I.push(s), g += s.length, E || g >= A) {
      const a = new Uint8Array(g);
      let C = 0;
      for (const o of I)
        a.set(o, C), C += o.length;
      B = a.slice(0, A);
    }
  }), e = 1024;
  let Q = 0;
  for (; B == null && Q < t.length; ) {
    const s = t.slice(Q, Q + e);
    i.push(s, !1), Q += e;
  }
  if (B == null && (i.push(new Uint8Array(), !0), B == null))
    throw new Error("Failed to decompress partial gzip");
  return B;
}
class kB {
  constructor({
    fileBytes: A,
    chunkBytes: I = 64 * 1024
  }) {
    this.fileBytes = A, this.chunkBytes = I, this.offset = 0, this.chunks = [], this.totalBytes = 0, this.gunzip = new yB((g, B) => {
      this.chunks.push(g), this.totalBytes += g.length;
    });
  }
  read(A) {
    for (; this.totalBytes < A && this.offset < this.fileBytes.length; ) {
      const i = Math.min(
        this.offset + this.chunkBytes,
        this.fileBytes.length
      );
      this.gunzip.push(this.fileBytes.subarray(this.offset, i), !1), this.offset = i;
    }
    if (this.totalBytes < A && this.offset >= this.fileBytes.length && this.gunzip.push(new Uint8Array(0), !0), this.totalBytes < A)
      throw new Error(
        `Unexpected EOF: needed ${A}, got ${this.totalBytes}`
      );
    const I = new Uint8Array(this.totalBytes);
    let g = 0;
    for (const i of this.chunks)
      I.set(i, g), g += i.length;
    const B = I.subarray(0, A);
    return this.chunks = [I.subarray(A)], this.totalBytes -= A, B;
  }
}
const jo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DataCache: wC,
  FreeList: dB,
  GunzipReader: kB,
  IDENT_VERTEX_SHADER: fB,
  Sint8ToFloat: yC,
  Uint8ToFloat: DC,
  averagePositions: FB,
  averageQuaternions: GB,
  cloneClock: pB,
  coinciDist: SB,
  computeMaxSplats: LC,
  coorientDist: NB,
  decodeQuatEulerXyz888: PC,
  decodeQuatOctXy88R8: mB,
  decodeQuatXyz888: OC,
  decompressPartialGzip: MB,
  encodeQuatEulerXyz888: VC,
  encodeQuatOctXy88R8: vI,
  encodeQuatXyz888: WC,
  encodeSh1Rgb: XC,
  encodeSh2Rgb: jC,
  encodeSh3Rgb: _C,
  epsilonSign: zC,
  flipPixels: TC,
  floatBitsToUint: lC,
  floatToSint8: $t,
  floatToUint8: mA,
  fromHalf: dA,
  getArrayBuffers: wB,
  getTextureSize: fA,
  isAndroid: HC,
  isMobile: JC,
  isOculus: bC,
  mapFilterObject: pC,
  mapObject: dC,
  newArray: fC,
  omitUndefined: qC,
  pixelsToPngUrl: KC,
  setPackedSplat: mI,
  setPackedSplatCenter: FC,
  setPackedSplatOpacity: MC,
  setPackedSplatQuat: SC,
  setPackedSplatRgb: mC,
  setPackedSplatRgba: NC,
  setPackedSplatScales: GC,
  toHalf: at,
  uintBitsToFloat: uC,
  unpackSplat: MI,
  withinCoinciDist: ZC,
  withinCoorientDist: BI,
  withinDist: vC
}, Symbol.toStringTag, { value: "Module" }));
class ZI {
  constructor({
    graph: A,
    inputs: I,
    outputs: g,
    template: B
  }) {
    this.graph = A, this.template = B, this.inputs = I ?? {}, this.outputs = g ?? {};
    const i = new lg({ indent: this.template.indent });
    for (const Q in this.outputs)
      this.outputs[Q] && i.declares.add(this.outputs[Q]);
    const e = A.compile({
      inputs: this.inputs,
      outputs: this.outputs,
      compile: i
    });
    this.shader = B.generate({ globals: i.globals, statements: e }), this.uniforms = i.uniforms, this.updaters = i.updaters;
  }
  prepareMaterial() {
    return $C(this);
  }
  update() {
    for (const A of this.updaters)
      A();
  }
}
class zI {
  constructor(A) {
    const I = A.match(/^([ \t]*)\{\{\s*GLOBALS\s*\}\}/m), g = A.match(/^([ \t]*)\{\{\s*STATEMENTS\s*\}\}/m);
    if (!I || !g)
      throw new Error(
        "Template must contain {{ GLOBALS }} and {{ STATEMENTS }}"
      );
    this.before = A.substring(0, I.index), this.between = A.substring(
      I.index + I[0].length,
      g.index
    ), this.after = A.substring(
      g.index + g[0].length
    ), this.indent = g[1];
  }
  generate({
    globals: A,
    statements: I
  }) {
    return this.before + Array.from(A).join(`

`) + this.between + I.map((g) => this.indent + g).join(`
`) + this.after;
  }
}
const Ag = /* @__PURE__ */ new Map();
function $C(t) {
  let A = Ag.get(t);
  return A || (A = new n.RawShaderMaterial({
    glslVersion: n.GLSL3,
    vertexShader: fB,
    fragmentShader: t.shader,
    uniforms: t.uniforms
  }), Ag.set(t, A), A);
}
function WI(t, A, I = "add") {
  const g = () => {
    throw new Error(`Invalid ${I} types: ${t}, ${A}`);
  };
  if (t === A) return t;
  if (t === "int") {
    if (hA(A)) return A;
    g();
  }
  if (A === "int") {
    if (hA(t)) return t;
    g();
  }
  if (t === "uint") {
    if (lA(A)) return A;
    g();
  }
  if (A === "uint") {
    if (lA(t)) return t;
    g();
  }
  if (t === "float") {
    if (it(A)) return A;
    g();
  }
  if (A === "float") {
    if (it(t)) return t;
    g();
  }
  throw new Error(`Invalid ${I} types: ${t}, ${A}`);
}
function AE(t, A) {
  return WI(t, A, "sub");
}
function tE(t, A) {
  const I = () => {
    throw new Error(`Invalid mul types: ${t}, ${A}`);
  }, g = (B) => B;
  if (t === "int") {
    if (hA(A)) return g(A);
    I();
  }
  if (A === "int") {
    if (hA(t)) return g(t);
    I();
  }
  if (t === "uint") {
    if (lA(A)) return g(A);
    I();
  }
  if (A === "uint") {
    if (lA(t)) return g(t);
    I();
  }
  if (t === "float") {
    if (it(A)) return g(A);
    I();
  }
  if (A === "float") {
    if (it(t)) return g(t);
    I();
  }
  if (hA(t) || lA(t) || hA(A) || lA(A)) {
    if (t === A) return g(t);
    I();
  }
  if (t === "vec2") {
    if (A === "vec2" || et(A)) return g("vec2");
    if (A === "mat3x2") return g("vec3");
    if (A === "mat4x2") return g("vec4");
    I();
  }
  if (t === "vec3") {
    if (A === "mat2x3") return g("vec2");
    if (A === "vec3" || Qt(A)) return g("vec3");
    if (A === "mat4x3") return g("vec4");
    I();
  }
  if (t === "vec4") {
    if (A === "mat2x4") return g("vec2");
    if (A === "mat3x4") return g("vec3");
    if (A === "vec4" || st(A)) return g("vec4");
    I();
  }
  if (A === "vec2") {
    if (et(t)) return g("vec2");
    if (t === "mat2x3") return g("vec3");
    if (t === "mat2x4") return g("vec4");
    I();
  }
  if (A === "vec3") {
    if (t === "mat3x2") return g("vec2");
    if (Qt(t)) return g("vec3");
    if (t === "mat3x4") return g("vec4");
    I();
  }
  if (A === "vec4") {
    if (t === "mat4x2") return g("vec2");
    if (t === "mat4x3") return g("vec3");
    if (st(t)) return g("vec4");
    I();
  }
  if (et(t)) {
    if (et(A)) return g("mat2");
    if (A === "mat3x2") return g("mat3x2");
    if (A === "mat4x2") return g("mat4x2");
    I();
  }
  if (t === "mat2x3") {
    if (et(A)) return g("mat2x3");
    if (A === "mat3x2") return g("mat3");
    if (A === "mat4x2") return g("mat4x3");
    I();
  }
  if (t === "mat2x4") {
    if (et(A)) return g("mat2x4");
    if (A === "mat3x2") return g("mat3x4");
    if (A === "mat4x2") return g("mat4");
    I();
  }
  if (t === "mat3x2") {
    if (A === "mat2x3") return g("mat2");
    if (Qt(A)) return g("mat3x2");
    if (A === "mat4x3") return g("mat4x2");
    I();
  }
  if (Qt(t)) {
    if (A === "mat2x3") return g("mat2x3");
    if (Qt(A)) return g("mat3");
    if (A === "mat4x3") return g("mat4x3");
    I();
  }
  if (t === "mat3x4") {
    if (A === "mat2x3") return g("mat2x4");
    if (Qt(A)) return g("mat3x4");
    if (A === "mat4x3") return g("mat4");
    I();
  }
  if (t === "mat4x2") {
    if (A === "mat2x4") return g("mat2");
    if (A === "mat3x4") return g("mat3x2");
    if (st(A)) return g("mat4x2");
    I();
  }
  if (t === "mat4x3") {
    if (A === "mat2x4") return g("mat2x3");
    if (A === "mat3x4") return g("mat3");
    if (st(A)) return g("mat4x3");
    I();
  }
  if (st(t)) {
    if (A === "mat2x4") return g("mat2x4");
    if (A === "mat3x4") return g("mat3x4");
    if (st(A)) return g("mat4");
    I();
  }
  throw new Error(`Invalid mul types: ${t}, ${A}`);
}
function IE(t, A) {
  return WI(t, A, "div");
}
function gE(t, A) {
  if (t === A) return t;
  if (t === "int") {
    if (hA(A)) return A;
  } else if (A === "int") {
    if (hA(t)) return t;
  } else if (t === "uint") {
    if (lA(A)) return A;
  } else if (A === "uint" && lA(t))
    return t;
  throw new Error(`Invalid imod types: ${t}, ${A}`);
}
function BE(t, A) {
  if (t === A || A === "float") return t;
  throw new Error(`Invalid mod types: ${t}, ${A}`);
}
function iE(t) {
  return t;
}
function eE(t) {
  return t;
}
function QE(t) {
  return t;
}
function sE(t) {
  return t;
}
function CE(t) {
  return t;
}
function EE(t) {
  return t;
}
function aE(t) {
  return t;
}
function nE(t) {
  return t;
}
function oE(t) {
  return t;
}
function rE(t) {
  return t;
}
function cE(t) {
  return t;
}
function hE(t) {
  return t;
}
function lE(t) {
  return t;
}
function uE(t) {
  return t;
}
function DE(t) {
  return t;
}
function yE(t) {
  return t;
}
function xB(t, A, I = "min") {
  if (t === A) return t;
  if (A === "float") {
    if (bt(t)) return t;
  } else if (A === "int") {
    if (hA(t)) return t;
  } else if (A === "uint" && lA(t))
    return t;
  throw new Error(`Invalid ${I} types: ${t}, ${A}`);
}
function wE(t, A) {
  return xB(t, A, "max");
}
function dE(t, A, I) {
  if (A === "float") {
    if (bt(t)) return t;
  } else if (A === "int") {
    if (hA(t)) return t;
  } else if (A === "uint" && lA(t))
    return t;
  throw new Error(`Invalid clamp types: ${t}, ${A}`);
}
function pE(t, A, I) {
  if (I === t || I === "float" || I === "bool" && t === "float" || I === "bvec2" && t === "vec2" || I === "bvec3" && t === "vec3" || I === "bvec4" && t === "vec4") return t;
  throw new Error(`Invalid mix types: ${t}, ${A}, ${I}`);
}
function fE(t, A) {
  if (t === A || A === "float") return A;
  throw new Error(`Invalid step types: ${t}, ${A}`);
}
function FE(t, A, I) {
  if (t === A && (t === I || t === "float"))
    return I;
  throw new Error(`Invalid smoothstep types: ${t}, ${A}, ${I}`);
}
function RB(t, A = "isNan") {
  if (t === "float") return "bool";
  if (t === "vec2") return "bvec2";
  if (t === "vec3") return "bvec3";
  if (t === "vec4") return "bvec4";
  throw new Error(`Invalid ${A} types: ${t}`);
}
function GE(t) {
  return RB(t, "isInf");
}
const pA = (t, A) => new JB({ a: t, b: A }), Ft = (t, A) => new HB({ a: t, b: A }), nA = (t, A) => new bB({ a: t, b: A }), AI = (t, A) => new TB({ a: t, b: A }), kI = (t, A) => new KB({ a: t, b: A }), UB = (t, A) => new qB({ a: t, b: A }), SE = (t) => new vB({ a: t }).outputs, OI = (t) => new ZB({ a: t }), NE = (t) => new zB({ a: t }), mE = (t) => new WB({ a: t }), ME = (t) => new OB({ a: t }), kE = (t) => new VB({ a: t }), xE = (t) => new PB({ a: t }), RE = (t) => new XB({ a: t }), tI = (t) => new jB({ a: t }), UE = (t, A) => new _B({ a: t, b: A }), YE = (t) => new $B({ a: t }), LE = (t) => new Ai({ a: t }), JE = (t) => new ti({ a: t }), HE = (t) => new Ii({ a: t }), bE = (t) => new gi({ a: t }), TE = (t) => new Bi({ a: t }), KE = (t) => new ii({ a: t }), qE = (t, A) => new ei({ a: t, b: A }), YB = (t, A) => new Qi({ a: t, b: A }), vE = (t, A, I) => new si({ a: t, min: A, max: I }), LB = (t, A, I) => new Ci({ a: t, b: A, t: I }), ZE = (t, A) => new Ei({ edge: t, x: A }), zE = (t, A, I) => new ai({ edge0: t, edge1: A, x: I }), WE = (t) => new ni({ a: t }), OE = (t) => new oi({ a: t });
class JB extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "sum", outTypeFunc: WI }), this.statements = ({ inputs: g, outputs: B }) => [`${B.sum} = ${g.a} + ${g.b};`];
  }
}
class HB extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "difference", outTypeFunc: AE }), this.statements = ({ inputs: g, outputs: B }) => [`${B.difference} = ${g.a} - ${g.b};`];
  }
}
class bB extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "product", outTypeFunc: tE }), this.statements = ({ inputs: g, outputs: B }) => [`${B.product} = ${g.a} * ${g.b};`];
  }
}
class TB extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "quotient", outTypeFunc: IE }), this.statements = ({ inputs: g, outputs: B }) => [`${B.quotient} = ${g.a} / ${g.b};`];
  }
}
class KB extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "remainder", outTypeFunc: gE }), this.statements = ({ inputs: g, outputs: B }) => [`${B.remainder} = ${g.a} % ${g.b};`];
  }
}
class qB extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "remainder", outTypeFunc: BE }), this.statements = ({ inputs: g, outputs: B }) => [`${B.remainder} = mod(${g.a}, ${g.b});`];
  }
}
class vB extends W {
  constructor({ a: A }) {
    const I = { a: z(A) }, g = I.a, B = {
      fract: g,
      integer: g
    };
    super({ inTypes: I, outTypes: B, inputs: { a: A } }), this.statements = ({ inputs: i, outputs: e }) => [`${e.fract} = modf(${i.a}, ${e.integer});`];
  }
}
class ZB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "neg", outTypeFunc: iE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.neg} = -${I.a};`];
  }
}
class zB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "abs", outTypeFunc: eE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.abs} = abs(${I.a});`];
  }
}
class WB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "sign", outTypeFunc: QE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.sign} = sign(${I.a});`];
  }
}
class OB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "floor", outTypeFunc: sE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.floor} = floor(${I.a});`];
  }
}
class VB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "ceil", outTypeFunc: CE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.ceil} = ceil(${I.a});`];
  }
}
class PB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "trunc", outTypeFunc: EE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.trunc} = trunc(${I.a});`];
  }
}
class XB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "round", outTypeFunc: aE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.round} = round(${I.a});`];
  }
}
class jB extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "fract", outTypeFunc: nE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.fract} = fract(${I.a});`];
  }
}
class _B extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "power", outTypeFunc: oE }), this.statements = ({ inputs: g, outputs: B }) => [`${B.power} = pow(${g.a}, ${g.b});`];
  }
}
class $B extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp", outTypeFunc: rE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.exp} = exp(${I.a});`];
  }
}
class Ai extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "exp2", outTypeFunc: cE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.exp2} = exp2(${I.a});`];
  }
}
class ti extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "log", outTypeFunc: hE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.log} = log(${I.a});`];
  }
}
class Ii extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "log2", outTypeFunc: lE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.log2} = log2(${I.a});`];
  }
}
class gi extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqr", outTypeFunc: uE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.sqr} = ${I.a} * ${I.a};`];
  }
}
class Bi extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "sqrt", outTypeFunc: DE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.sqrt} = sqrt(${I.a});`];
  }
}
class ii extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "inversesqrt", outTypeFunc: yE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.inversesqrt} = inversesqrt(${I.a});`];
  }
}
class ei extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "min", outTypeFunc: xB }), this.statements = ({ inputs: g, outputs: B }) => [`${B.min} = min(${g.a}, ${g.b});`];
  }
}
class Qi extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "max", outTypeFunc: wE }), this.statements = ({ inputs: g, outputs: B }) => [`${B.max} = max(${g.a}, ${g.b});`];
  }
}
class si extends ct {
  constructor({
    a: A,
    min: I,
    max: g
  }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "clamp",
      outTypeFunc: dE
    }), this.statements = ({ inputs: B, outputs: i }) => {
      const { a: e, b: Q, c: s } = B;
      return [`${i.clamp} = clamp(${e}, ${Q}, ${s});`];
    };
  }
}
class Ci extends ct {
  constructor({ a: A, b: I, t: g }) {
    super({ a: A, b: I, c: g, outKey: "mix", outTypeFunc: pE }), this.statements = ({ inputs: B, outputs: i }) => {
      const { a: e, b: Q, c: s } = B;
      return [`${i.mix} = mix(${e}, ${Q}, ${s});`];
    };
  }
}
class Ei extends $ {
  constructor({ edge: A, x: I }) {
    super({
      a: A,
      b: I,
      outKey: "step",
      outTypeFunc: fE
    }), this.statements = ({ inputs: g, outputs: B }) => {
      const { a: i, b: e } = g;
      return [`${B.step} = step(${i}, ${e});`];
    };
  }
}
class ai extends ct {
  constructor({
    edge0: A,
    edge1: I,
    x: g
  }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "smoothstep",
      outTypeFunc: FE
    }), this.statements = ({ inputs: B, outputs: i }) => {
      const { a: e, b: Q, c: s } = B;
      return [`${i.smoothstep} = smoothstep(${e}, ${Q}, ${s});`];
    };
  }
}
class ni extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "isNan", outTypeFunc: RB }), this.statements = ({ inputs: I, outputs: g }) => [`${g.isNan} = isNan(${I.a});`];
  }
}
class oi extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "isInf", outTypeFunc: GE }), this.statements = ({ inputs: I, outputs: g }) => [`${g.isInf} = isInf(${I.a});`];
  }
}
const VE = (t, A) => new ci({ a: t, b: A }), PE = (t, A) => new hi({ a: t, b: A }), XE = (t, A) => new li({ a: t, b: A }), jE = (t) => new ui({ a: t }), _E = (t, A) => new Di({ a: t, b: A }), $E = (t, A) => new yi({ a: t, b: A }), Aa = (t, A) => new wi({ a: t, b: A }), ri = (t, A) => new di({ a: t, b: A }), ta = (t, A) => new pi({ a: t, b: A }), Ia = (t, A) => new fi({ a: t, b: A }), ga = (t) => new Fi({ a: t }), Ba = (t) => new Gi({ a: t }), VI = (t, A, I) => new Si({ cond: t, t: A, f: I }), ia = (t) => new mi({ a: t });
class ci extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (g, B) => g, outKey: "and" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.and === "bool" ? [`${B.and} = ${g.a} && ${g.b};`] : [`${B.and} = ${g.a} & ${g.b};`];
  }
}
class hi extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (g, B) => g, outKey: "or" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.or === "bool" ? [`${B.or} = ${g.a} || ${g.b};`] : [`${B.or} = ${g.a} | ${g.b};`];
  }
}
class li extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: (g, B) => g, outKey: "xor" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.xor === "bool" ? [`${B.xor} = ${g.a} ^^ ${g.b};`] : [`${B.xor} = ${g.a} ^ ${g.b};`];
  }
}
class ui extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "not" }), this.statements = ({ inputs: I, outputs: g }) => this.outTypes.not === "bool" ? [`${g.not} = !${I.a};`] : [`${g.not} = not(${I.a});`];
  }
}
class Di extends $ {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => rI(g, "lessThan"),
      outKey: "lessThan"
    }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.lessThan === "bool" ? [`${B.lessThan} = ${g.a} < ${g.b};`] : [`${B.lessThan} = lessThan(${g.a}, ${g.b});`];
  }
}
class yi extends $ {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => rI(g, "lessThanEqual"),
      outKey: "lessThanEqual"
    }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.lessThanEqual === "bool" ? [`${B.lessThanEqual} = ${g.a} <= ${g.b};`] : [
      `${B.lessThanEqual} = lessThanEqual(${g.a}, ${g.b});`
    ];
  }
}
class wi extends $ {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => rI(g, "greaterThan"),
      outKey: "greaterThan"
    }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.greaterThan === "bool" ? [`${B.greaterThan} = ${g.a} > ${g.b};`] : [
      `${B.greaterThan} = greaterThan(${g.a}, ${g.b});`
    ];
  }
}
class di extends $ {
  constructor({ a: A, b: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => rI(g, "greaterThanEqual"),
      outKey: "greaterThanEqual"
    }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.greaterThanEqual === "bool" ? [`${B.greaterThanEqual} = ${g.a} >= ${g.b};`] : [
      `${B.greaterThanEqual} = greaterThanEqual(${g.a}, ${g.b});`
    ];
  }
}
class pi extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: Ni, outKey: "equal" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.equal === "bool" ? [`${B.equal} = ${g.a} == ${g.b};`] : [`${B.equal} = equal(${g.a}, ${g.b});`];
  }
}
class fi extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outTypeFunc: ea, outKey: "notEqual" }), this.statements = ({ inputs: g, outputs: B }) => this.outTypes.notEqual === "bool" ? [`${B.notEqual} = ${g.a} != ${g.b};`] : [`${B.notEqual} = notEqual(${g.a}, ${g.b});`];
  }
}
class Fi extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "bool", outKey: "any" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.any} = any(${I.a});`];
  }
}
class Gi extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "bool", outKey: "all" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.all} = all(${I.a});`];
  }
}
class Si extends ct {
  constructor({
    cond: A,
    t: I,
    f: g
  }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "select",
      outTypeFunc: (B, i, e) => i
    }), this.statements = ({ inputs: B, outputs: i }) => {
      const { a: e, b: Q, c: s } = B;
      return [`${i.select} = (${e}) ? (${Q}) : (${s});`];
    };
  }
}
function rI(t, A) {
  if (rt(t))
    return "bool";
  if (t === "ivec2" || t === "uvec2" || t === "vec2")
    return "bvec2";
  if (t === "ivec3" || t === "uvec3" || t === "vec3")
    return "bvec3";
  if (t === "ivec4" || t === "uvec4" || t === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${t}`);
}
function Ni(t, A = "equal") {
  if (rt(t))
    return "bool";
  if (ot(t))
    return t;
  if (t === "ivec2" || t === "uvec2" || t === "vec2")
    return "bvec2";
  if (t === "ivec3" || t === "uvec3" || t === "vec3")
    return "bvec3";
  if (t === "ivec4" || t === "uvec4" || t === "vec4")
    return "bvec4";
  throw new Error(`Invalid ${A} type: ${t}`);
}
function ea(t) {
  return Ni(t, "notEqual");
}
function Qa(t) {
  if (ot(t))
    return "bool";
  if (hA(t))
    return "int";
  if (lA(t))
    return "uint";
  throw new Error(`Invalid compXor type: ${t}`);
}
class mi extends N {
  constructor({ a: A }) {
    const I = Qa(z(A));
    super({ a: A, outTypeFunc: (g) => I, outKey: "compXor" }), this.statements = ({ inputs: g, outputs: B }) => {
      if (rt(this.outTypes.compXor))
        return [`${B.compXor} = ${g.a};`];
      const e = (Gt(I) ? ["x", "y"] : St(I) ? ["x", "y", "z"] : ["x", "y", "z", "w"]).map((s) => `${g.a}.${s}`), Q = ot(I) ? "^^" : "^";
      return [`${B.compXor} = ${e.join(` ${Q} `)};`];
    };
  }
}
const sa = (t) => new Li({ value: t }), Ca = (t) => new Ji({ value: t }), Ea = (t) => new Hi({ value: t }), Mi = (t) => new bi({ value: t }), aa = (t) => new Ti({ value: t }), na = (t) => new Ki({ value: t }), oa = (t) => new qi({ value: t }), ra = (t) => new vi({ value: t }), ca = (t) => new Zi({ value: t }), ha = (t) => new zi({ value: t }), la = (t) => new Wi({ value: t }), ua = (t) => new Oi({ value: t }), Da = (t) => new Vi({ value: t }), ki = (t) => new Pi({ value: t }), nt = (t) => new Xi({ value: t }), xi = (t) => new ji({ value: t }), ya = (t) => new _i({ value: t }), wa = (t) => new $i({ value: t }), da = (t) => new Ae({ value: t }), Ri = (t) => new te({ value: t }), pa = (t) => new Ie({ value: t }), fa = (t) => new ge({ value: t }), Fa = (t) => new Be({ value: t }), Ga = (t) => new ie({ value: t }), Sa = (t) => new ee({ value: t }), Na = (t) => new Qe({ value: t }), ma = (t) => new se({ value: t }), Ui = (t) => new Ce({ value: t }), Ma = (t) => new Ee({ value: t }), Yi = (t) => new ae({ value: t });
class sA extends N {
  constructor({
    value: A,
    outType: I,
    outKey: g
  }) {
    super({ a: A, outTypeFunc: () => I, outKey: g }), this.statements = ({ inputs: B, outputs: i }) => [
      `${i[g]} = ${cg(I)}(${B.a});`
    ];
  }
}
class Li extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bool", outKey: "bool" });
  }
}
class Ji extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "int", outKey: "int" });
  }
}
class Hi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uint", outKey: "uint" });
  }
}
class bi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "float", outKey: "float" });
  }
}
class Ti extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec2", outKey: "bvec2" });
  }
}
class Ki extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec3", outKey: "bvec3" });
  }
}
class qi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "bvec4", outKey: "bvec4" });
  }
}
class vi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec2", outKey: "ivec2" });
  }
}
class Zi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec3", outKey: "ivec3" });
  }
}
class zi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "ivec4", outKey: "ivec4" });
  }
}
class Wi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec2", outKey: "uvec2" });
  }
}
class Oi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec3", outKey: "uvec3" });
  }
}
class Vi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "uvec4", outKey: "uvec4" });
  }
}
class Pi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec2", outKey: "vec2" });
  }
}
class Xi extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec3", outKey: "vec3" });
  }
}
class ji extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "vec4", outKey: "vec4" });
  }
}
class _i extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat2", outKey: "mat2" });
  }
}
class $i extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat3", outKey: "mat3" });
  }
}
class Ae extends sA {
  constructor({
    value: A
  }) {
    super({ value: A, outType: "mat4", outKey: "mat4" });
  }
}
class te extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "int", outTypeFunc: () => "int" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.int} = floatBitsToInt(${I.a});`];
  }
}
class Ie extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.uint} = floatBitsToUint(${I.a});`];
  }
}
class ge extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.float} = intBitsToFloat(${I.a});`];
  }
}
class Be extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "float", outTypeFunc: () => "float" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.float} = uintBitsToFloat(${I.a});`];
  }
}
class ie extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.uint} = packSnorm2x16(${I.a});`];
  }
}
class ee extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.vec2} = unpackSnorm2x16(${I.a});`];
  }
}
class Qe extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.uint} = packUnorm2x16(${I.a});`];
  }
}
class se extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.vec2} = unpackUnorm2x16(${I.a});`];
  }
}
class Ce extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "uint", outTypeFunc: () => "uint" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.uint} = packHalf2x16(${I.a});`];
  }
}
class Ee extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "vec2", outTypeFunc: () => "vec2" }), this.statements = ({ inputs: I, outputs: g }) => [`${g.vec2} = unpackHalf2x16(${I.a});`];
  }
}
class ae extends N {
  constructor({ value: A }) {
    super({ a: A, outKey: "rgba8", outTypeFunc: () => "vec4" }), this.statements = ({ inputs: I, outputs: g }) => [
      `uvec4 uRgba = uvec4(${I.a} & 0xffu, (${I.a} >> 8u) & 0xffu, (${I.a} >> 16u) & 0xffu, (${I.a} >> 24u) & 0xffu);`,
      `${g.rgba8} = vec4(uRgba) / 255.0;`
    ];
  }
}
const ka = (t) => new ce({ a: t }), xa = (t, A) => new he({ a: t, b: A }), ne = (t, A) => new le({ a: t, b: A }), Ra = (t, A) => new ue({ a: t, b: A }), oe = (t) => new De({ a: t }), Ua = (t, A, I) => new de({ a: t, b: A, c: I }), Ya = (t, A) => new pe({ incident: t, normal: A }), La = (t, A, I) => new fe({ incident: t, normal: A, eta: I }), pt = (t) => new Me({ vector: t }), TA = ({
  vector: t,
  vectorType: A,
  x: I,
  y: g,
  z: B,
  w: i,
  r: e,
  g: Q,
  b: s,
  a: E
}) => new ke({ vector: t, vectorType: A, x: I, y: g, z: B, w: i, r: e, g: Q, b: s, a: E }), Ja = (t) => new ye({ a: t }), re = (t, A) => new we({ a: t, b: A }), Ha = (t, A) => new xe({ vector: t, select: A }), ba = (t, A) => new Fe({ a: t, b: A }), Ta = (t, A) => new Ge({ a: t, b: A }), Ka = (t) => new Se({ a: t }), qa = (t) => new Ne({ a: t }), va = (t) => new me({ a: t });
class ce extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => "float", outKey: "length" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.length} = length(${I.a});`
    ];
  }
}
class he extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "distance", outTypeFunc: (g, B) => "float" }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.distance} = distance(${g.a}, ${g.b});`
    ];
  }
}
class le extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "dot", outTypeFunc: (g, B) => "float" }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.dot} = dot(${g.a}, ${g.b});`
    ];
  }
}
class ue extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "cross", outTypeFunc: (g, B) => "vec3" }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.cross} = cross(${g.a}, ${g.b});`
    ];
  }
}
class De extends N {
  constructor({ a: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "normalize" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.normalize} = normalize(${I.a});`
    ];
  }
}
function Za(t) {
  if (t === "vec3")
    return "vec2";
  if (t === "vec4")
    return "vec3";
  throw new Error("Invalid type");
}
class ye extends N {
  constructor({ a: A }) {
    super({
      a: A,
      outTypeFunc: (I) => Za(I),
      outKey: "projected"
    }), this.statements = ({ inputs: I, outputs: g }) => {
      if (this.inTypes.a === "vec3")
        return [`${g.projected} = ${I.a}.xy / ${I.a}.z;`];
      if (this.inTypes.a === "vec4")
        return [`${g.projected} = ${I.a}.xyz / ${I.a}.w;`];
      throw new Error("Invalid type");
    };
  }
}
function za(t) {
  if (t === "float") return "vec2";
  if (t === "vec2") return "vec3";
  if (t === "vec3") return "vec4";
  throw new Error("Invalid type");
}
class we extends $ {
  constructor({ a: A, b: I }) {
    const g = z(A), B = za(g);
    super({ a: A, b: I, outKey: "extend", outTypeFunc: () => B }), this.statements = ({ inputs: i, outputs: e }) => [
      `${e.extend} = ${B}(${i.a}, ${i.b});`
    ];
  }
}
class de extends ct {
  constructor({ a: A, b: I, c: g }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "forward",
      outTypeFunc: (B, i, e) => B
    }), this.statements = ({ inputs: B, outputs: i }) => [
      `${i.forward} = faceforward(${B.a}, ${B.b}, ${B.c});`
    ];
  }
}
class pe extends $ {
  constructor({
    incident: A,
    normal: I
  }) {
    super({
      a: A,
      b: I,
      outKey: "reflection",
      outTypeFunc: (g, B) => g
    }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.reflection} = reflect(${g.a}, ${g.b});`
    ];
  }
}
class fe extends ct {
  constructor({
    incident: A,
    normal: I,
    eta: g
  }) {
    super({
      a: A,
      b: I,
      c: g,
      outKey: "refraction",
      outTypeFunc: (B, i, e) => B
    }), this.statements = ({ inputs: B, outputs: i }) => [
      `${i.refraction} = refract(${B.a}, ${B.b}, ${B.c});`
    ];
  }
}
class Fe extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "product", outTypeFunc: (g, B) => g }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.product} = matrixCompMult(${A}, ${I});`
    ];
  }
}
function Wa(t, A) {
  if (t === "vec2") {
    if (A === "vec2") return "mat2";
    if (A === "vec3") return "mat3x2";
    if (A === "vec4") return "mat4x2";
  }
  if (t === "vec3") {
    if (A === "vec2") return "mat2x3";
    if (A === "vec3") return "mat3";
    if (A === "vec4") return "mat4x3";
  }
  if (t === "vec4") {
    if (A === "vec2") return "mat2x4";
    if (A === "vec3") return "mat3x4";
    if (A === "vec4") return "mat4";
  }
  throw new Error(`Invalid outer type: ${t}, ${A}`);
}
class Ge extends $ {
  constructor({ a: A, b: I }) {
    super({ a: A, b: I, outKey: "outer", outTypeFunc: Wa }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.outer} = outerProduct(${g.a}, ${g.b});`
    ];
  }
}
function Oa(t) {
  if (t === "mat2") return "mat2";
  if (t === "mat3") return "mat3";
  if (t === "mat4") return "mat4";
  if (t === "mat2x2") return "mat2x2";
  if (t === "mat2x3") return "mat3x2";
  if (t === "mat2x4") return "mat4x2";
  if (t === "mat3x2") return "mat2x3";
  if (t === "mat3x3") return "mat3x3";
  if (t === "mat3x4") return "mat4x3";
  if (t === "mat4x2") return "mat2x4";
  if (t === "mat4x3") return "mat3x4";
  if (t === "mat4x4") return "mat4x4";
  throw new Error(`Invalid transpose type: ${t}`);
}
class Se extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "transpose", outTypeFunc: Oa }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.transpose} = transpose(${I.a});`
    ];
  }
}
class Ne extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "det", outTypeFunc: (I) => "float" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.det} = determinant(${I.a});`
    ];
  }
}
class me extends N {
  constructor({ a: A }) {
    super({ a: A, outKey: "inverse", outTypeFunc: (I) => I }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.inverse} = inverse(${A});`
    ];
  }
}
function Va(t) {
  const A = (I) => I;
  switch (t) {
    case "vec2":
      return A({ x: "float", y: "float", r: "float", g: "float" });
    case "vec3":
      return A({
        x: "float",
        y: "float",
        z: "float",
        r: "float",
        g: "float",
        b: "float"
      });
    case "vec4":
      return A({
        x: "float",
        y: "float",
        z: "float",
        w: "float",
        r: "float",
        g: "float",
        b: "float",
        a: "float"
      });
    case "ivec2":
      return A({ x: "int", y: "int", r: "int", g: "int" });
    case "ivec3":
      return A({
        x: "int",
        y: "int",
        z: "int",
        r: "int",
        g: "int",
        b: "int"
      });
    case "ivec4":
      return A({
        x: "int",
        y: "int",
        z: "int",
        w: "int",
        r: "int",
        g: "int",
        b: "int",
        a: "int"
      });
    case "uvec2":
      return A({ x: "uint", y: "uint", r: "uint", g: "uint" });
    case "uvec3":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        r: "uint",
        g: "uint",
        b: "uint"
      });
    case "uvec4":
      return A({
        x: "uint",
        y: "uint",
        z: "uint",
        w: "uint",
        r: "uint",
        g: "uint",
        b: "uint",
        a: "uint"
      });
    default:
      throw new Error(`Invalid vector type: ${t}`);
  }
}
class Me extends W {
  constructor({ vector: A }) {
    const g = { vector: z(A) }, B = Va(g.vector);
    super({ inTypes: g, outTypes: B, inputs: { vector: A } }), this.statements = ({ inputs: i, outputs: e }) => {
      const { x: Q, y: s, z: E, w: a, r: C, g: o, b: r, a: h } = e, { vector: c } = i;
      return [
        Q ? `${Q} = ${c}.x;` : null,
        s ? `${s} = ${c}.y;` : null,
        E ? `${E} = ${c}.z;` : null,
        a ? `${a} = ${c}.w;` : null,
        C ? `${C} = ${c}.r;` : null,
        o ? `${o} = ${c}.g;` : null,
        r ? `${r} = ${c}.b;` : null,
        h ? `${h} = ${c}.a;` : null
      ].filter(Boolean);
    };
  }
}
class ke extends W {
  constructor({
    vector: A,
    vectorType: I,
    x: g,
    y: B,
    z: i,
    w: e,
    r: Q,
    g: s,
    b: E,
    a
  }) {
    if (!A && !I)
      throw new Error("Either vector or vectorType must be provided");
    const C = I ?? z(A), o = ng(C), r = og(C), h = {
      vector: C,
      x: o,
      y: o,
      r: o,
      g: o
    }, c = { vector: A, x: g, y: B, r: Q, g: s };
    r >= 3 && (Object.assign(h, { z: o, b: o }), Object.assign(c, { z: i, b: E })), r >= 4 && (Object.assign(h, { w: o, a: o }), Object.assign(c, { w: e, a })), super({ inTypes: h, outTypes: { vector: C }, inputs: c }), this.statements = ({ inputs: l, outputs: u }) => {
      const { vector: D } = u, {
        vector: y,
        x: d,
        y: w,
        z: F,
        w: m,
        r: f,
        g: p,
        b: R,
        a: S
      } = l, G = [
        `${D}.x = ${d ?? f ?? (y ? `${y}.x` : xt(o))};`,
        `${D}.y = ${w ?? p ?? (y ? `${y}.y` : xt(o))};`
      ];
      return r >= 3 && G.push(
        `${D}.z = ${F ?? R ?? (y ? `${y}.z` : xt(o))};`
      ), r >= 4 && G.push(
        `${D}.w = ${m ?? S ?? (y ? `${y}.w` : xt(o))};`
      ), G;
    };
  }
  dynoOut() {
    return new v(
      this,
      "vector"
    );
  }
}
function Pa(t, A) {
  let I = null;
  if (bt(t) ? I = A.length === 1 ? "float" : A.length === 2 ? "vec2" : A.length === 3 ? "vec3" : A.length === 4 ? "vec4" : null : hA(t) ? I = A.length === 1 ? "int" : A.length === 2 ? "ivec2" : A.length === 3 ? "ivec3" : A.length === 4 ? "ivec4" : null : lA(t) && (I = A.length === 1 ? "uint" : A.length === 2 ? "uvec2" : A.length === 3 ? "uvec3" : A.length === 4 ? "uvec4" : null), I == null)
    throw new Error(`Invalid swizzle: ${A}`);
  return I;
}
class xe extends N {
  constructor({ vector: A, select: I }) {
    super({
      a: A,
      outKey: "swizzle",
      outTypeFunc: (g) => Pa(g, I)
    }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.swizzle} = ${g.a}.${I};`
    ];
  }
}
const Xa = (t, A, I) => new be({ index: t, from: A, to: I }), ja = (t) => new Nt({ value: t }), _a = (t) => new xA({ state: t }), $a = (t) => new RA({ state: t }), Re = (t) => new Te({ value: t }), Ue = (t) => new Ke({ value: t }), Ye = (t) => new qe({ value: t }), Le = (t) => new ve({ value: t }), An = (t) => new Ze({ value: t }), tn = (t) => new ze({ value: t }), Je = (t) => new We({ value: t }), xI = (t) => new Oe({ value: t }), He = (t, A, I) => new Ve({ z: t, zNear: A, zFar: I }).outputs.depth;
class be extends W {
  constructor({
    from: A,
    to: I,
    index: g
  }) {
    super({
      inTypes: { from: "int", to: "int", index: "int" },
      outTypes: { index: "int" },
      inputs: { from: A, to: I, index: g },
      statements: ({ inputs: B, outputs: i }) => [
        `${i.index} = ${B.index} - ${B.from} + ${B.to};`
      ]
    });
  }
  dynoOut() {
    return new v(this, "index");
  }
}
class xA extends W {
  constructor({ state: A }) {
    const I = z(A);
    super({
      inTypes: { state: I },
      outTypes: { state: "uint" },
      inputs: { state: A },
      globals: () => [
        oA(`
          uint pcg_next(uint state) {
            return state * 747796405u + 2891336453u;
          }
        `)
      ],
      statements: ({ inputs: g, outputs: B }) => {
        const i = I === "uint" ? `${g.state}` : I === "int" ? `uint(${g.state})` : `floatBitsToUint(${g.state})`;
        return [`${B.state} = pcg_next(${i});`];
      }
    });
  }
  dynoOut() {
    return new v(this, "state");
  }
}
class RA extends W {
  constructor({ state: A }) {
    super({
      inTypes: { state: "uint" },
      outTypes: { hash: "uint" },
      inputs: { state: A },
      globals: () => [
        oA(`
          uint pcg_hash(uint state) {
            uint hash = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
            return (hash >> 22u) ^ hash;
          }
        `)
      ],
      statements: ({ inputs: I, outputs: g }) => [
        `${g.hash} = pcg_hash(${I.state});`
      ]
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class Nt extends W {
  constructor({ value: A }) {
    const I = z(A), g = rg(I);
    super({
      inTypes: { value: I },
      outTypes: { state: "uint" },
      inputs: { value: A },
      globals: () => [
        oA(`
          uint pcg_mix(uint value) {
            return value;
          }
          uint pcg_mix(uvec2 value) {
            return value.x + 0x9e3779b9u * value.y;
          }
          uint pcg_mix(uvec3 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z;
          }
          uint pcg_mix(uvec4 value) {
            return value.x + 0x9e3779b9u * value.y + 0x85ebca6bu * value.z + 0xc2b2ae35u * value.w;
          }
        `)
      ],
      statements: ({ inputs: B, outputs: i }) => {
        const e = lA(I) ? `${B.value}` : hA(I) ? `${g}(${B.value})` : `floatBitsToUint(${B.value})`;
        return [
          `${g} bits = ${e};`,
          `${i.state} = pcg_mix(bits);`
        ];
      }
    });
  }
  dynoOut() {
    return new v(this, "state");
  }
}
class Te extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: z(A) },
      outTypes: { hash: "uint" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let g = new Nt({ value: I }).outputs.state;
        return g = new xA({ state: g }).outputs.state, new RA({ state: g }).outputs;
      }
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class Ke extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: z(A) },
      outTypes: { hash: "uvec2" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let g = new Nt({ value: I }).outputs.state;
        g = new xA({ state: g }).outputs.state;
        const B = new RA({ state: g }).outputs.hash;
        g = new xA({ state: g }).outputs.state;
        const i = new RA({ state: g }).outputs.hash;
        return { hash: TA({ vectorType: "uvec2", x: B, y: i }) };
      }
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class qe extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: z(A) },
      outTypes: { hash: "uvec3" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let g = new Nt({ value: I }).outputs.state;
        g = new xA({ state: g }).outputs.state;
        const B = new RA({ state: g }).outputs.hash;
        g = new xA({ state: g }).outputs.state;
        const i = new RA({ state: g }).outputs.hash;
        g = new xA({ state: g }).outputs.state;
        const e = new RA({ state: g }).outputs.hash;
        return { hash: TA({ vectorType: "uvec3", x: B, y: i, z: e }) };
      }
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class ve extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: z(A) },
      outTypes: { hash: "uvec4" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        let g = new Nt({ value: I }).outputs.state;
        g = new xA({ state: g }).outputs.state;
        const B = new RA({ state: g }).outputs.hash;
        g = new xA({ state: g }).outputs.state;
        const i = new RA({ state: g }).outputs.hash;
        g = new xA({ state: g }).outputs.state;
        const e = new RA({ state: g }).outputs.hash;
        g = new xA({ state: g }).outputs.state;
        const Q = new RA({ state: g }).outputs.hash;
        return { hash: TA({ vectorType: "uvec4", x: B, y: i, z: e, w: Q }) };
      }
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class Ze extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: z(A) },
      outTypes: { hash: "float" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const g = Re(I);
        return { hash: nA(Mi(g), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class ze extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: z(A) },
      outTypes: { hash: "vec2" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const g = Ue(I);
        return { hash: nA(ki(g), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class We extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: z(A) },
      outTypes: { hash: "vec3" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const g = Ye(I);
        return { hash: nA(nt(g), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class Oe extends qA {
  constructor({ value: A }) {
    super({
      inTypes: { value: z(A) },
      outTypes: { hash: "vec4" },
      inputs: { value: A },
      construct: ({ value: I }) => {
        if (!I)
          throw new Error("value is required");
        const g = Le(I);
        return { hash: nA(xi(g), q("float", 1 / 2 ** 32)) };
      }
    });
  }
  dynoOut() {
    return new v(this, "hash");
  }
}
class Ve extends W {
  constructor({
    z: A,
    zNear: I,
    zFar: g
  }) {
    super({
      inTypes: { z: "float", zNear: "float", zFar: "float" },
      outTypes: { depth: "float" },
      inputs: { z: A, zNear: I, zFar: g },
      statements: ({ inputs: B, outputs: i }) => [
        `float clamped = clamp(${B.z}, ${B.zNear}, ${B.zFar});`,
        `${i.depth} = (log2(clamped + 1.0) - log2(${B.zNear} + 1.0)) / (log2(${B.zFar} + 1.0) - log2(${B.zNear} + 1.0));`
      ]
    });
  }
  dynoOut() {
    return new v(this, "depth");
  }
}
const Pe = (t, {
  scale: A,
  scales: I,
  rotate: g,
  translate: B
}) => new je({ position: t, scale: A, scales: I, rotate: g, translate: B }).outputs.position, Xe = (t, {
  scale: A,
  scales: I,
  rotate: g
}) => new _e({ dir: t, scale: A, scales: I, rotate: g }).outputs.dir, In = (t, { rotate: A }) => new $e({ quaternion: t, rotate: A }).outputs.quaternion;
class je extends W {
  constructor({
    position: A,
    scale: I,
    scales: g,
    rotate: B,
    translate: i
  }) {
    super({
      inTypes: {
        position: "vec3",
        scale: "float",
        scales: "vec3",
        rotate: "vec4",
        translate: "vec3"
      },
      outTypes: { position: "vec3" },
      inputs: { position: A, scale: I, scales: g, rotate: B, translate: i },
      statements: ({ inputs: e, outputs: Q }) => {
        const { position: s } = Q;
        if (!s)
          return [];
        const { scale: E, scales: a, rotate: C, translate: o } = e;
        return [
          `${s} = ${e.position ?? "vec3(0.0, 0.0, 0.0)"};`,
          E ? `${s} *= ${E};` : null,
          a ? `${s} *= ${a};` : null,
          C ? `${s} = quatVec(${C}, ${s});` : null,
          o ? `${s} += ${o};` : null
        ].filter(Boolean);
      }
    });
  }
}
class _e extends W {
  constructor({
    dir: A,
    scale: I,
    scales: g,
    rotate: B
  }) {
    super({
      inTypes: { dir: "vec3", scale: "float", scales: "vec3", rotate: "vec4" },
      outTypes: { dir: "vec3" },
      inputs: { dir: A, scale: I, scales: g, rotate: B },
      statements: ({ inputs: i, outputs: e }) => {
        const { dir: Q } = e;
        if (!Q)
          return [];
        const { scale: s, scales: E, rotate: a } = i;
        return [
          `${Q} = ${i.dir ?? "vec3(0.0, 0.0, 0.0)"};`,
          s ? `${Q} *= ${s};` : null,
          E ? `${Q} *= ${E};` : null,
          a ? `${Q} = quatVec(${a}, ${Q});` : null
        ].filter(Boolean);
      }
    });
  }
}
class $e extends W {
  constructor({
    quaternion: A,
    rotate: I
  }) {
    super({
      inTypes: { quaternion: "vec4", rotate: "vec4" },
      outTypes: { quaternion: "vec4" },
      inputs: { quaternion: A, rotate: I },
      statements: ({ inputs: g, outputs: B }) => {
        const { quaternion: i } = B;
        return i ? [
          `${i} = ${g.quaternion ?? "vec4(0.0, 0.0, 0.0, 1.0)"};`,
          I ? `${i} = quatQuat(${g.rotate}, ${i});` : null
        ].filter(Boolean) : [];
      }
    });
  }
}
const gn = () => {
  throw new Error("Not implemented");
}, Bn = () => {
  throw new Error("Not implemented");
}, en = () => {
  throw new Error("Not implemented");
}, Qn = () => {
  throw new Error("Not implemented");
}, sn = () => {
  throw new Error("Not implemented");
}, Cn = () => {
  throw new Error("Not implemented");
}, En = (t, A) => new AQ({ texture: t, lod: A }), an = (t, A, I) => new tQ({ texture: t, coord: A, bias: I }), nn = (t, A, I) => new IQ({ texture: t, coord: A, lod: I });
class AQ extends W {
  constructor({ texture: A, lod: I }) {
    const g = z(A);
    super({
      inTypes: { texture: g, lod: "int" },
      outTypes: { size: gQ(g) },
      inputs: { texture: A, lod: I },
      statements: ({ inputs: B, outputs: i }) => [
        `${i.size} = textureSize(${B.texture}, ${B.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new v(this, "size");
  }
}
class tQ extends W {
  constructor({
    texture: A,
    coord: I,
    bias: g
  }) {
    const B = z(A);
    super({
      inTypes: {
        texture: B,
        coord: on(B),
        bias: "float"
      },
      outTypes: { sample: BQ(B) },
      inputs: { texture: A, coord: I, bias: g },
      statements: ({ inputs: i, outputs: e }) => [
        `${e.sample} = texture(${i.texture}, ${i.coord}${i.bias ? `, ${i.bias}` : ""});`
      ]
    });
  }
  dynoOut() {
    return new v(this, "sample");
  }
}
class IQ extends W {
  constructor({
    texture: A,
    coord: I,
    lod: g
  }) {
    const B = z(A);
    super({
      inTypes: {
        texture: B,
        coord: gQ(B),
        lod: "int"
      },
      outTypes: { texel: BQ(B) },
      inputs: { texture: A, coord: I, lod: g },
      statements: ({ inputs: i, outputs: e }) => [
        `${e.texel} = texelFetch(${i.texture}, ${i.coord}, ${i.lod ?? "0"});`
      ]
    });
  }
  dynoOut() {
    return new v(this, "texel");
  }
}
function gQ(t) {
  switch (t) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DShadow":
    case "samplerCubeShadow":
      return "ivec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DArrayShadow":
      return "ivec3";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
function on(t) {
  switch (t) {
    case "sampler2D":
    case "usampler2D":
    case "isampler2D":
      return "vec2";
    case "sampler3D":
    case "usampler3D":
    case "isampler3D":
    case "samplerCube":
    case "usamplerCube":
    case "isamplerCube":
    case "sampler2DArray":
    case "usampler2DArray":
    case "isampler2DArray":
    case "sampler2DShadow":
      return "vec3";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "vec4";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
function BQ(t) {
  switch (t) {
    case "sampler2D":
    case "sampler2DArray":
    case "sampler3D":
    case "samplerCube":
    case "sampler2DShadow":
      return "vec4";
    case "usampler2D":
    case "usampler2DArray":
    case "usampler3D":
    case "usamplerCube":
      return "uvec4";
    case "isampler2D":
    case "isampler2DArray":
    case "isampler3D":
    case "isamplerCube":
      return "ivec4";
    case "samplerCubeShadow":
    case "sampler2DArrayShadow":
      return "float";
    default:
      throw new Error(`Invalid texture type: ${t}`);
  }
}
const rn = (t) => new iQ({ degrees: t }), cn = (t) => new eQ({ radians: t }), RI = (t) => new QQ({ radians: t }), hn = (t) => new sQ({ radians: t }), ln = (t) => new CQ({ radians: t }), un = (t) => new EQ({ sin: t }), Dn = (t) => new aQ({ cos: t }), yn = (t) => new nQ({ tan: t }), wn = (t, A) => new oQ({ y: t, x: A }), dn = (t) => new rQ({ x: t }), pn = (t) => new cQ({ x: t }), fn = (t) => new hQ({ x: t }), Fn = (t) => new lQ({ x: t }), Gn = (t) => new uQ({ x: t }), Sn = (t) => new DQ({ x: t });
class iQ extends N {
  constructor({ degrees: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "radians" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.radians} = radians(${I.a});`
    ];
  }
}
class eQ extends N {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "degrees" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.degrees} = degrees(${I.a});`
    ];
  }
}
class QQ extends N {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "sin" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.sin} = sin(${I.a});`
    ];
  }
}
class sQ extends N {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "cos" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.cos} = cos(${I.a});`
    ];
  }
}
class CQ extends N {
  constructor({ radians: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "tan" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.tan} = tan(${I.a});`
    ];
  }
}
class EQ extends N {
  constructor({ sin: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "asin" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.asin} = asin(${I.a});`
    ];
  }
}
class aQ extends N {
  constructor({ cos: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "acos" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.acos} = acos(${I.a});`
    ];
  }
}
class nQ extends N {
  constructor({ tan: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "atan" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.atan} = atan(${I.a});`
    ];
  }
}
class oQ extends $ {
  constructor({ y: A, x: I }) {
    super({
      a: A,
      b: I,
      outTypeFunc: (g, B) => g,
      outKey: "atan2"
    }), this.statements = ({ inputs: g, outputs: B }) => [
      `${B.atan2} = atan2(${g.a}, ${g.b});`
    ];
  }
}
class rQ extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "sinh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.sinh} = sinh(${I.a});`
    ];
  }
}
class cQ extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "cosh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.cosh} = cosh(${I.a});`
    ];
  }
}
class hQ extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "tanh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.tanh} = tanh(${I.a});`
    ];
  }
}
class lQ extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "asinh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.asinh} = asinh(${I.a});`
    ];
  }
}
class uQ extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "acosh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.acosh} = acosh(${I.a});`
    ];
  }
}
class DQ extends N {
  constructor({ x: A }) {
    super({ a: A, outTypeFunc: (I) => I, outKey: "atanh" }), this.statements = ({ inputs: I, outputs: g }) => [
      `${g.atanh} = atanh(${I.a});`
    ];
  }
}
const _o = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Abs: zB,
  Acos: aQ,
  Acosh: uQ,
  Add: JB,
  All: Gi,
  And: ci,
  Any: Fi,
  Asin: EQ,
  Asinh: lQ,
  Atan: nQ,
  Atan2: oQ,
  Atanh: DQ,
  BVec2: Ti,
  BVec3: Ki,
  BVec4: qi,
  BinaryOp: $,
  Bool: Li,
  Ceil: VB,
  Clamp: si,
  Combine: ke,
  CombineGsplat: fg,
  CompMult: Fe,
  CompXor: mi,
  Compilation: lg,
  Cos: sQ,
  Cosh: cQ,
  Cross: ue,
  Degrees: eQ,
  Determinant: Ne,
  Distance: he,
  Div: TB,
  Dot: le,
  Dyno: W,
  DynoBlock: qA,
  DynoBool: gI,
  DynoBvec2: kg,
  DynoBvec3: Yg,
  DynoBvec4: Hg,
  DynoConst: hg,
  DynoFloat: Et,
  DynoInt: Ht,
  DynoIsampler2D: AB,
  DynoIsampler2DArray: IB,
  DynoIsampler3D: iB,
  DynoIsamplerCube: sB,
  DynoIvec2: Rg,
  DynoIvec3: Jg,
  DynoIvec4: Tg,
  DynoLiteral: dt,
  DynoMat2: Kg,
  DynoMat2x2: qg,
  DynoMat2x3: vg,
  DynoMat2x4: Zg,
  DynoMat3: zg,
  DynoMat3x2: Wg,
  DynoMat3x3: Og,
  DynoMat3x4: Vg,
  DynoMat4: Pg,
  DynoMat4x2: Xg,
  DynoMat4x3: jg,
  DynoMat4x4: _g,
  DynoOutput: v,
  DynoProgram: ZI,
  DynoProgramTemplate: zI,
  DynoRemapIndex: be,
  DynoSampler2D: tB,
  DynoSampler2DArray: gB,
  DynoSampler2DArrayShadow: aB,
  DynoSampler2DShadow: EB,
  DynoSampler3D: eB,
  DynoSamplerCube: CB,
  DynoSamplerCubeShadow: nB,
  DynoUint: Mg,
  DynoUniform: x,
  DynoUsampler2D: $g,
  DynoUsampler2DArray: Ut,
  DynoUsampler3D: BB,
  DynoUsamplerCube: QB,
  DynoUvec2: xg,
  DynoUvec3: Lg,
  DynoUvec4: bg,
  DynoValue: gt,
  DynoVec2: Ug,
  DynoVec3: ft,
  DynoVec4: vt,
  Equal: pi,
  Exp: $B,
  Exp2: Ai,
  ExtendVec: we,
  FaceForward: de,
  Float: bi,
  FloatBitsToInt: te,
  FloatBitsToUint: Ie,
  Floor: OB,
  Fract: jB,
  GreaterThan: wi,
  GreaterThanEqual: di,
  Gsplat: _,
  GsplatNormal: Gg,
  Hash: Te,
  Hash2: Ke,
  Hash3: qe,
  Hash4: ve,
  HashFloat: Ze,
  HashVec2: ze,
  HashVec3: We,
  HashVec4: Oe,
  IMod: KB,
  IVec2: vi,
  IVec3: Zi,
  IVec4: zi,
  Int: Ji,
  IntBitsToFloat: ge,
  Inverse: me,
  InverseSqrt: ii,
  IsInf: oi,
  IsNan: ni,
  Length: ce,
  LessThan: Di,
  LessThanEqual: yi,
  Log: ti,
  Log2: Ii,
  Mat2: _i,
  Mat3: $i,
  Mat4: Ae,
  Max: Qi,
  Min: ei,
  Mix: Ci,
  Mod: qB,
  Modf: vB,
  Mul: bB,
  Neg: ZB,
  Normalize: De,
  NormalizedDepth: Ve,
  Not: ui,
  NotEqual: fi,
  NumPackedSplats: Dg,
  Or: hi,
  Outer: Ge,
  OutputPackedSplat: mg,
  OutputRgba8: qI,
  PackHalf2x16: Ce,
  PackSnorm2x16: ie,
  PackUnorm2x16: Qe,
  PcgHash: RA,
  PcgMix: Nt,
  PcgNext: xA,
  Pow: _B,
  ProjectH: ye,
  Radians: iQ,
  ReadPackedSplat: wg,
  ReadPackedSplatRange: dg,
  ReflectVec: pe,
  RefractVec: fe,
  Round: XB,
  Select: Si,
  Sign: WB,
  SimpleCast: sA,
  Sin: QQ,
  Sinh: rQ,
  Smoothstep: ai,
  Split: Me,
  SplitGsplat: pg,
  Sqr: gi,
  Sqrt: Bi,
  Step: Ei,
  Sub: HB,
  Swizzle: xe,
  TPackedSplats: qt,
  Tan: CQ,
  Tanh: hQ,
  TexelFetch: IQ,
  Texture: tQ,
  TextureSize: AQ,
  TransformDir: _e,
  TransformGsplat: Sg,
  TransformPosition: je,
  TransformQuaternion: $e,
  Transpose: Se,
  TrinaryOp: ct,
  Trunc: PB,
  UVec2: Wi,
  UVec3: Oi,
  UVec4: Vi,
  Uint: Hi,
  UintBitsToFloat: Be,
  UintToRgba8: ae,
  UnaryOp: N,
  UnpackHalf2x16: Ee,
  UnpackSnorm2x16: ee,
  UnpackUnorm2x16: se,
  Vec2: Pi,
  Vec3: Xi,
  Vec4: ji,
  Xor: li,
  abs: NE,
  acos: Dn,
  acosh: Gn,
  add: pA,
  all: Ba,
  and: VE,
  any: ga,
  arrayIndex: sn,
  arrayLength: Cn,
  asin: un,
  asinh: Fn,
  atan: yn,
  atan2: wn,
  atanh: Sn,
  bool: sa,
  bvec2: aa,
  bvec3: na,
  bvec4: oa,
  ceil: kE,
  clamp: vE,
  combine: TA,
  combineGsplat: Bt,
  comment: Qn,
  compMult: ba,
  compXor: ia,
  cos: hn,
  cosh: pn,
  cross: Ra,
  defineGsplat: NA,
  defineGsplatNormal: Fg,
  definePackedSplats: nI,
  degrees: cn,
  determinant: qa,
  distance: xa,
  div: AI,
  dot: ne,
  dyno: Kt,
  dynoBlock: MA,
  dynoBool: ls,
  dynoBvec2: ys,
  dynoBvec3: fs,
  dynoBvec4: Ss,
  dynoConst: q,
  dynoDeclare: TI,
  dynoFloat: HA,
  dynoFor: en,
  dynoIf: gn,
  dynoInt: Ds,
  dynoIsampler2D: Zs,
  dynoIsampler2DArray: Os,
  dynoIsampler3D: Xs,
  dynoIsamplerCube: $s,
  dynoIvec2: ds,
  dynoIvec3: Gs,
  dynoIvec4: ms,
  dynoLiteral: II,
  dynoMat2: ks,
  dynoMat2x2: xs,
  dynoMat2x3: Rs,
  dynoMat2x4: Us,
  dynoMat3: Ys,
  dynoMat3x2: Ls,
  dynoMat3x3: Js,
  dynoMat3x4: Hs,
  dynoMat4: bs,
  dynoMat4x2: Ts,
  dynoMat4x3: Ks,
  dynoMat4x4: qs,
  dynoSampler2D: zs,
  dynoSampler2DArray: Vs,
  dynoSampler2DArrayShadow: IC,
  dynoSampler2DShadow: tC,
  dynoSampler3D: js,
  dynoSamplerCube: AC,
  dynoSamplerCubeShadow: gC,
  dynoSwitch: Bn,
  dynoUint: us,
  dynoUsampler2D: vs,
  dynoUsampler2DArray: Ws,
  dynoUsampler3D: Ps,
  dynoUsamplerCube: _s,
  dynoUvec2: ws,
  dynoUvec3: Fs,
  dynoUvec4: Ns,
  dynoVec2: ps,
  dynoVec3: _A,
  dynoVec4: Ms,
  equal: ta,
  exp: YE,
  exp2: LE,
  extendVec: re,
  faceforward: Ua,
  float: Mi,
  floatBitsToInt: Ri,
  floatBitsToUint: pa,
  floor: ME,
  fract: tI,
  greaterThan: Aa,
  greaterThanEqual: ri,
  gsplatNormal: SI,
  hash: Re,
  hash2: Ue,
  hash3: Ye,
  hash4: Le,
  hashFloat: An,
  hashVec2: tn,
  hashVec3: Je,
  hashVec4: xI,
  imod: kI,
  int: Ca,
  intBitsToFloat: fa,
  inverse: va,
  inversesqrt: KE,
  isAllFloatType: it,
  isBoolType: ot,
  isFloatType: bt,
  isInf: OE,
  isIntType: hA,
  isMat2: et,
  isMat3: Qt,
  isMat4: st,
  isMatFloatType: ag,
  isNan: WE,
  isScalarType: rt,
  isUintType: lA,
  isVector2Type: Gt,
  isVector3Type: St,
  isVector4Type: Tt,
  isVectorType: Cs,
  ivec2: ra,
  ivec3: ca,
  ivec4: ha,
  length: ka,
  lessThan: _E,
  lessThanEqual: $E,
  literalNegOne: os,
  literalOne: ns,
  literalZero: xt,
  log: JE,
  log2: HE,
  mat2: ya,
  mat3: wa,
  mat4: da,
  max: YB,
  min: qE,
  mix: LB,
  mod: UB,
  modf: SE,
  mul: nA,
  neg: OI,
  normalize: oe,
  normalizedDepth: He,
  not: jE,
  notEqual: Ia,
  numPackedSplats: rs,
  numberAsFloat: K,
  numberAsInt: iA,
  numberAsUint: eA,
  or: PE,
  outer: Ta,
  outputPackedSplat: Ng,
  outputRgba8: cs,
  packHalf2x16: Ui,
  packSnorm2x16: Ga,
  packUnorm2x16: Na,
  pcgHash: $a,
  pcgMix: ja,
  pcgNext: _a,
  pow: UE,
  projectH: Ja,
  radians: rn,
  readPackedSplat: Jt,
  readPackedSplatRange: ug,
  reflectVec: Ya,
  refractVec: La,
  remapIndex: Xa,
  round: RE,
  sameSizeIvec: as,
  sameSizeUvec: rg,
  sameSizeVec: Es,
  select: VI,
  sign: mE,
  sin: RI,
  sinh: dn,
  smoothstep: zE,
  split: pt,
  splitGsplat: Ct,
  sqr: bE,
  sqrt: TE,
  step: ZE,
  sub: Ft,
  swizzle: Ha,
  tan: ln,
  tanh: fn,
  texelFetch: nn,
  texture: an,
  textureSize: En,
  transformDir: Xe,
  transformGsplat: KI,
  transformPos: Pe,
  transformQuat: In,
  transpose: Ka,
  trunc: xE,
  typeLiteral: cg,
  uint: Ea,
  uintBitsToFloat: Fa,
  uintToRgba8: Yi,
  uniform: hs,
  unindent: oA,
  unindentLines: UA,
  unpackHalf2x16: Ma,
  unpackSnorm2x16: Sa,
  unpackUnorm2x16: ma,
  uvec2: la,
  uvec3: ua,
  uvec4: Da,
  valType: z,
  vec2: ki,
  vec3: nt,
  vec4: xi,
  vectorDim: og,
  vectorElementType: ng,
  xor: XE
}, Symbol.toStringTag, { value: "Module" }));
var Nn = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out vec4 target;

{{ GLOBALS }}

void computeReadback(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        computeReadback(index);
    } else {
        target = vec4(0.0, 0.0, 0.0, 0.0);
    }
}`;
const EA = class EA {
  constructor({ renderer: A } = {}) {
    this.renderer = A, this.capacity = 0, this.count = 0;
  }
  dispose() {
    this.target && (this.target.dispose(), this.target = void 0);
  }
  // Ensure we have a buffer large enough for the readback of count indices.
  // Pass in previous bufer of the desired type.
  ensureBuffer(A, I) {
    const B = Math.ceil(Math.max(1, A) / j) * j * 4;
    if (I.byteLength >= B)
      return I;
    const i = new ArrayBuffer(B);
    if (I instanceof ArrayBuffer)
      return i;
    const e = I.constructor;
    return new e(i);
  }
  // Ensure our render target is large enough for the readback of capacity indices.
  ensureCapacity(A) {
    const { width: I, height: g, depth: B, maxSplats: i } = fA(A);
    (!this.target || i > this.capacity) && (this.dispose(), this.capacity = i, this.target = new n.WebGLArrayRenderTarget(I, g, B, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: n.NearestFilter,
      minFilter: n.NearestFilter
    }), this.target.texture.format = n.RGBAFormat, this.target.texture.type = n.UnsignedByteType, this.target.texture.internalFormat = "RGBA8", this.target.scissorTest = !0);
  }
  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let I = EA.readbackProgram.get(A);
    if (!I) {
      const B = MA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: i }) => (A.inputs.index = i, { rgba8: new qI({ rgba8: A.outputs.rgba8 }) })
      );
      EA.programTemplate || (EA.programTemplate = new zI(Nn)), I = new ZI({
        graph: B,
        inputs: { index: "index" },
        outputs: { rgba8: "target" },
        template: EA.programTemplate
      }), Object.assign(I.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), EA.readbackProgram.set(A, I);
    }
    const g = I.prepareMaterial();
    return EA.mesh.material = g, { program: I, material: g };
  }
  saveRenderState(A) {
    return {
      xrEnabled: A.xr.enabled,
      autoClear: A.autoClear
    };
  }
  resetRenderState(A, I) {
    A.setRenderTarget(null), A.xr.enabled = I.xrEnabled, A.autoClear = I.autoClear;
  }
  process({
    count: A,
    material: I
  }) {
    const g = this.renderer;
    if (!g)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const B = j * It;
    I.uniforms.targetBase.value = 0, I.uniforms.targetCount.value = A;
    let i = 0;
    for (; i < A; ) {
      const e = Math.floor(i / B), Q = e * B, s = Math.min(
        It,
        Math.ceil((A - Q) / j)
      );
      I.uniforms.targetLayer.value = e, this.target.scissor.set(0, 0, j, s), g.setRenderTarget(this.target, e), g.xr.enabled = !1, g.autoClear = !1, g.render(EA.scene, EA.camera), i += j * s;
    }
    this.count = A;
  }
  async read({
    readback: A
  }) {
    const I = this.renderer;
    if (!I)
      throw new Error("No renderer");
    if (!this.target)
      throw new Error("No target");
    const g = Math.ceil(this.count / j) * j;
    if (A.byteLength < g * 4)
      throw new Error(
        `Readback buffer too small: ${A.byteLength} < ${g * 4}`
      );
    const B = new Uint8Array(
      A instanceof ArrayBuffer ? A : A.buffer
    ), i = j * It;
    let e = 0;
    const Q = [];
    for (; e < this.count; ) {
      const s = Math.floor(e / i), E = s * i, a = Math.min(
        It,
        Math.ceil((this.count - E) / j)
      );
      I.setRenderTarget(this.target, s);
      const C = j * a * 4, o = B.subarray(
        E * 4,
        E * 4 + C
      ), r = I == null ? void 0 : I.readRenderTargetPixelsAsync(
        this.target,
        0,
        0,
        j,
        a,
        o
      );
      Q.push(r), e += j * a;
    }
    return Promise.all(Q).then(() => A);
  }
  // Perform render operation to run the Rgba8Readback program
  // but don't perform the readback yet.
  render({
    reader: A,
    count: I,
    renderer: g
  }) {
    if (this.renderer = g || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(I);
    const { program: B, material: i } = this.prepareProgramMaterial(A);
    B.update();
    const e = this.saveRenderState(this.renderer);
    this.process({ count: I, material: i }), this.resetRenderState(this.renderer, e);
  }
  // Perform a readback of the render target, returning a buffer of the
  // given type.
  async readback({
    readback: A
  }) {
    if (!this.renderer)
      throw new Error("No renderer");
    const I = this.saveRenderState(this.renderer), g = this.read({ readback: A });
    return this.resetRenderState(this.renderer, I), g;
  }
  // Perform a render and readback operation for the given Rgba8Readback,
  // and readback buffer (call ensureBuffer first).
  async renderReadback({
    reader: A,
    count: I,
    renderer: g,
    readback: B
  }) {
    if (this.renderer = g || this.renderer, !this.renderer)
      throw new Error("No renderer");
    this.ensureCapacity(I);
    const { program: i, material: e } = this.prepareProgramMaterial(A);
    i.update();
    const Q = this.saveRenderState(this.renderer);
    this.process({ count: I, material: e });
    const s = this.read({ readback: B });
    return this.resetRenderState(this.renderer, Q), s;
  }
  getTexture() {
    var A;
    return (A = this.target) == null ? void 0 : A.texture;
  }
};
EA.programTemplate = null, EA.readbackProgram = /* @__PURE__ */ new Map(), EA.geometry = new n.PlaneGeometry(2, 2), EA.mesh = new n.Mesh(
  EA.geometry,
  new n.RawShaderMaterial({ visible: !1 })
), EA.scene = new n.Scene().add(EA.mesh), EA.camera = new n.Camera();
let iI = EA;
const aA = class aA {
  constructor(A = {}) {
    this.capacity = 0, this.count = 0, this.array = null, this.readback = null, this.source = null, this.needsUpdate = !0, this.dyno = new x({
      key: "rgbaArray",
      type: yQ,
      globals: () => [wQ],
      value: {
        texture: aA.getEmpty(),
        count: 0
      },
      update: (I) => {
        var g;
        return I.texture = ((g = this.readback) == null ? void 0 : g.getTexture()) ?? this.source ?? aA.getEmpty(), I.count = this.count, I;
      }
    }), A.array ? (this.array = A.array, this.capacity = Math.floor(this.array.length / 4), this.capacity = Math.floor(this.capacity / j) * j, this.count = Math.min(
      this.capacity,
      A.count ?? Number.POSITIVE_INFINITY
    )) : (this.capacity = A.capacity ?? 0, this.count = 0);
  }
  // Free up resources
  dispose() {
    this.readback && (this.readback.dispose(), this.readback = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensure that our array is large enough to hold capacity RGBA8 values.
  ensureCapacity(A) {
    var I;
    if (!this.array || A > (((I = this.array) == null ? void 0 : I.length) ?? 0) / 4) {
      this.capacity = fA(A).maxSplats;
      const g = new Uint8Array(this.capacity * 4);
      this.array && g.set(this.array), this.array = g;
    }
    return this.array;
  }
  // Get the THREE.DataArrayTexture from either the readback or the source.
  getTexture() {
    var I;
    let A = (I = this.readback) == null ? void 0 : I.getTexture();
    return (this.source || this.array) && (A = this.maybeUpdateSource()), A ?? aA.getEmpty();
  }
  // Create or get a THREE.DataArrayTexture from the data array.
  maybeUpdateSource() {
    if (!this.array)
      throw new Error("No array");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: I, depth: g } = this.source.image;
        this.capacity !== A * I * g && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.array.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.array.buffer));
      else {
        const { width: A, height: I, depth: g } = fA(this.capacity);
        this.source = new n.DataArrayTexture(
          this.array,
          A,
          I,
          g
        ), this.source.format = n.RGBAFormat, this.source.type = n.UnsignedByteType, this.source.internalFormat = "RGBA8", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Generate the RGBA8 values from a Rgba8Readback dyno program.
  render({
    reader: A,
    count: I,
    renderer: g
  }) {
    this.readback || (this.readback = new iI({ renderer: g })), this.readback.render({ reader: A, count: I, renderer: g }), this.capacity = this.readback.capacity, this.count = this.readback.count;
  }
  // Extract the RGBA8 values from a PackedSplats collection.
  fromPackedSplats({
    packedSplats: A,
    base: I,
    count: g,
    renderer: B
  }) {
    const { dynoSplats: i, dynoBase: e, dynoCount: Q, reader: s } = aA.makeDynos();
    return i.packedSplats = A, e.value = I, Q.value = g, this.render({ reader: s, count: g, renderer: B }), this;
  }
  // Read back the RGBA8 values from the readback buffer.
  async read() {
    if (!this.readback)
      throw new Error("No readback");
    return (!this.array || this.array.length < this.count * 4) && (this.array = new Uint8Array(this.capacity * 4)), (await this.readback.readback({ readback: this.array })).subarray(0, this.count * 4);
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!aA.emptySource) {
      const A = new Uint8Array(4);
      aA.emptySource = new n.DataArrayTexture(A, 1, 1, 1), aA.emptySource.format = n.RGBAFormat, aA.emptySource.type = n.UnsignedByteType, aA.emptySource.internalFormat = "RGBA8", aA.emptySource.needsUpdate = !0;
    }
    return aA.emptySource;
  }
  // Create a dyno program that can extract RGBA8 values from a PackedSplats
  static makeDynos() {
    if (!aA.dynos) {
      const A = new PI(), I = new Ht({ value: 0 }), g = new Ht({ value: 0 }), B = MA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: i }) => {
          if (!i)
            throw new Error("index is undefined");
          i = pA(i, I);
          const e = ug(
            A,
            i,
            I,
            g
          );
          return { rgba8: Ct(e).outputs.rgba };
        }
      );
      aA.dynos = { dynoSplats: A, dynoBase: I, dynoCount: g, reader: B };
    }
    return aA.dynos;
  }
};
aA.emptySource = null, aA.dynos = null;
let UI = aA;
const yQ = { type: "RgbaArray" }, wQ = oA(`
  struct RgbaArray {
    sampler2DArray texture;
    int count;
  };
`);
function mn(t, A) {
  return new W({
    inTypes: { rgba: yQ, index: "int" },
    outTypes: { rgba: "vec4" },
    inputs: { rgba: t, index: A },
    globals: () => [wQ],
    statements: ({ inputs: g, outputs: B }) => UA(`
        if ((index >= 0) && (index < ${g.rgba}.count)) {
          ${B.rgba} = texelFetch(${g.rgba}.texture, splatTexCoord(index), 0);
        } else {
          ${B.rgba} = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `)
  }).outputs.rgba;
}
var Mn = /* @__PURE__ */ ((t) => (t.ALL = "all", t.PLANE = "plane", t.SPHERE = "sphere", t.BOX = "box", t.ELLIPSOID = "ellipsoid", t.CYLINDER = "cylinder", t.CAPSULE = "capsule", t.INFINITE_CONE = "infinite_cone", t))(Mn || {});
function kn(t) {
  switch (t) {
    case "all":
      return 0;
    case "plane":
      return 1;
    case "sphere":
      return 2;
    case "box":
      return 3;
    case "ellipsoid":
      return 4;
    case "cylinder":
      return 5;
    case "capsule":
      return 6;
    case "infinite_cone":
      return 7;
    default:
      throw new Error(`Unknown SDF type: ${t}`);
  }
}
var xn = /* @__PURE__ */ ((t) => (t.MULTIPLY = "multiply", t.SET_RGB = "set_rgb", t.ADD_RGBA = "add_rgba", t))(xn || {});
function Rn(t) {
  switch (t) {
    case "multiply":
      return 0;
    case "set_rgb":
      return 1;
    case "add_rgba":
      return 2;
    default:
      throw new Error(`Unknown blend mode: ${t}`);
  }
}
class Un extends n.Object3D {
  constructor(A = {}) {
    super();
    const { type: I, invert: g, opacity: B, color: i, displace: e, radius: Q } = A;
    this.type = I ?? "sphere", this.invert = g ?? !1, this.opacity = B ?? 1, this.color = i ?? new n.Color(1, 1, 1), this.displace = e ?? new n.Vector3(0, 0, 0), this.radius = Q ?? 0;
  }
}
const aI = class aI extends n.Object3D {
  constructor(A = {}) {
    const {
      name: I,
      rgbaBlendMode: g = "multiply",
      sdfSmooth: B = 0,
      softEdge: i = 0,
      invert: e = !1,
      sdfs: Q = null
    } = A;
    super(), this.rgbaBlendMode = g, this.sdfSmooth = B, this.softEdge = i, this.invert = e, this.sdfs = Q, this.ordering = aI.nextOrdering++, this.name = I ?? `Edit ${this.ordering}`;
  }
  addSdf(A) {
    this.sdfs == null && (this.sdfs = []), this.sdfs.includes(A) || this.sdfs.push(A);
  }
  removeSdf(A) {
    this.sdfs != null && (this.sdfs = this.sdfs.filter((I) => I !== A));
  }
};
aI.nextOrdering = 1;
let eI = aI;
class Yn {
  constructor({ maxSdfs: A, maxEdits: I }) {
    this.maxSdfs = Math.max(16, A ?? 0), this.numSdfs = 0, this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs), this.dynoSdfArray = new x({
      key: "sdfArray",
      type: dQ,
      globals: () => [pQ],
      value: {
        numSdfs: 0,
        sdfTexture: this.sdfTexture
      },
      update: (g) => (g.numSdfs = this.numSdfs, g.sdfTexture = this.sdfTexture, g)
    }), this.maxEdits = Math.max(16, I ?? 0), this.numEdits = 0, this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoNumEdits = new Ht({ value: 0 }), this.dynoEdits = this.newEdits(this.editData, this.maxEdits);
  }
  newSdfTexture(A, I) {
    const g = new n.DataTexture(
      A,
      8,
      I,
      n.RGBAIntegerFormat,
      n.UnsignedIntType
    );
    return g.internalFormat = "RGBA32UI", g.needsUpdate = !0, g;
  }
  newEdits(A, I) {
    return new x({
      key: "edits",
      type: "uvec4",
      count: I,
      globals: () => [fQ],
      value: A
    });
  }
  // Ensure our SDF texture and edits uniform array have enough capacity.
  // Reallocate if not.
  ensureCapacity({
    maxSdfs: A,
    maxEdits: I
  }) {
    let g = !1;
    return A > this.sdfTexture.image.height && (this.sdfTexture.dispose(), this.maxSdfs = Math.max(this.maxSdfs * 2, A), this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs)), I > (this.dynoEdits.count ?? 0) && (this.maxEdits = Math.max(this.maxEdits * 2, I), this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoEdits = this.newEdits(this.editData, this.maxEdits), g = !0), g;
  }
  updateEditData(A, I) {
    const g = this.editData[A] !== I;
    return this.editData[A] = I, g;
  }
  updateEditFloatData(A, I) {
    ht[0] = I;
    const g = this.editFloatData[A] !== ht[0];
    return g && (this.editFloatData[A] = ht[0]), g;
  }
  encodeEdit(A, {
    sdfFirst: I,
    sdfCount: g,
    invert: B,
    rgbaBlendMode: i,
    softEdge: e,
    sdfSmooth: Q
  }) {
    const s = A * 4;
    let E = !1;
    return E = this.updateEditData(s + 0, i | (B ? 256 : 0)) || E, E = this.updateEditData(s + 1, I | g << 16) || E, E = this.updateEditFloatData(s + 2, e) || E, E = this.updateEditFloatData(s + 3, Q) || E, E;
  }
  updateSdfData(A, I) {
    const g = this.sdfData[A] !== I;
    return this.sdfData[A] = I, g;
  }
  updateSdfFloatData(A, I) {
    ht[0] = I;
    const g = this.sdfFloatData[A] !== ht[0];
    return g && (this.sdfFloatData[A] = ht[0]), g;
  }
  encodeSdf(A, {
    sdfType: I,
    invert: g,
    center: B,
    quaternion: i,
    scale: e,
    sizes: Q
  }, s) {
    const E = A * 32, a = I | (g ? 256 : 0);
    let C = !1;
    C = this.updateSdfFloatData(E + 0, (B == null ? void 0 : B.x) ?? 0) || C, C = this.updateSdfFloatData(E + 1, (B == null ? void 0 : B.y) ?? 0) || C, C = this.updateSdfFloatData(E + 2, (B == null ? void 0 : B.z) ?? 0) || C, C = this.updateSdfData(E + 3, a) || C, C = this.updateSdfFloatData(E + 4, (i == null ? void 0 : i.x) ?? 0) || C, C = this.updateSdfFloatData(E + 5, (i == null ? void 0 : i.y) ?? 0) || C, C = this.updateSdfFloatData(E + 6, (i == null ? void 0 : i.z) ?? 0) || C, C = this.updateSdfFloatData(E + 7, (i == null ? void 0 : i.w) ?? 0) || C, C = this.updateSdfFloatData(E + 8, (e == null ? void 0 : e.x) ?? 0) || C, C = this.updateSdfFloatData(E + 9, (e == null ? void 0 : e.y) ?? 0) || C, C = this.updateSdfFloatData(E + 10, (e == null ? void 0 : e.z) ?? 0) || C, C = this.updateSdfData(E + 11, 0) || C, C = this.updateSdfFloatData(E + 12, (Q == null ? void 0 : Q.x) ?? 0) || C, C = this.updateSdfFloatData(E + 13, (Q == null ? void 0 : Q.y) ?? 0) || C, C = this.updateSdfFloatData(E + 14, (Q == null ? void 0 : Q.z) ?? 0) || C, C = this.updateSdfFloatData(E + 15, (Q == null ? void 0 : Q.w) ?? 0) || C;
    const o = Math.min(4, s.length);
    for (let r = 0; r < o; ++r) {
      const h = E + 16 + r * 4;
      C = this.updateSdfFloatData(h + 0, s[r].x) || C, C = this.updateSdfFloatData(h + 1, s[r].y) || C, C = this.updateSdfFloatData(h + 2, s[r].z) || C, C = this.updateSdfFloatData(h + 3, s[r].w) || C;
    }
    return C;
  }
  // Update the SDFs and edits from an array of SplatEdits and their
  // associated SplatEditSdfs, updating it for the dyno shader program.
  update(A) {
    const I = A.reduce((C, { sdfs: o }) => C + o.length, 0), g = this.ensureCapacity({
      maxEdits: A.length,
      maxSdfs: I
    }), B = [new n.Vector4(), new n.Vector4()], i = new n.Vector3(), e = new n.Quaternion(), Q = new n.Vector3(), s = new n.Vector4();
    let E = 0, a = g;
    A.length !== this.dynoNumEdits.value && (this.dynoNumEdits.value = A.length, this.numEdits = A.length, a = !0);
    for (const [C, { edit: o, sdfs: r }] of A.entries()) {
      a = this.encodeEdit(C, {
        sdfFirst: E,
        sdfCount: r.length,
        invert: o.invert,
        rgbaBlendMode: Rn(o.rgbaBlendMode),
        softEdge: o.softEdge,
        sdfSmooth: o.sdfSmooth
      }) || a;
      let h = !1;
      for (const c of r)
        s.set(c.scale.x, c.scale.y, c.scale.z, c.radius), c.scale.setScalar(1), c.updateMatrixWorld(), c.matrixWorld.clone().invert().decompose(i, e, Q), c.scale.set(s.x, s.y, s.z), c.updateMatrixWorld(), B[0].set(c.color.r, c.color.g, c.color.b, c.opacity), B[1].set(c.displace.x, c.displace.y, c.displace.z, 1), h = this.encodeSdf(
          E,
          {
            sdfType: kn(c.type),
            invert: c.invert,
            center: i,
            quaternion: e,
            scale: Q,
            sizes: s
          },
          B
        ) || h, E += 1;
      this.numSdfs = E, h && (this.sdfTexture.needsUpdate = !0), a || (a = h);
    }
    return { updated: a, dynoUpdated: g };
  }
  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.
  modify(A) {
    return Ln(
      A,
      this.dynoSdfArray,
      this.dynoNumEdits,
      this.dynoEdits
    );
  }
}
const dQ = { type: "SdfArray" }, pQ = oA(`
  struct SdfArray {
    int numSdfs;
    usampler2D sdfTexture;
  };

  void unpackSdfArray(
    usampler2D sdfTexture, int sdfIndex, out uint flags,
    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,
    int numValues, out vec4 values[4]
  ) {
    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);
    flags = temp.w;
    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);
    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);
    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));

    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);
    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));

    for (int i = 0; i < numValues; ++i) {
      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);
      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));
    }
  }

  const uint SDF_FLAG_TYPE = 0xFFu;
  const uint SDF_FLAG_INVERT = 1u << 8u;

  const uint SDF_TYPE_ALL = 0u;
  const uint SDF_TYPE_PLANE = 1u;
  const uint SDF_TYPE_SPHERE = 2u;
  const uint SDF_TYPE_BOX = 3u;
  const uint SDF_TYPE_ELLIPSOID = 4u;
  const uint SDF_TYPE_CYLINDER = 5u;
  const uint SDF_TYPE_CAPSULE = 6u;
  const uint SDF_TYPE_INFINITE_CONE = 7u;

  float evaluateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 outValues[4]
  ) {
    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;
    float maxExp = -1.0 / 0.0;
    for (int i = 0; i < numValues; ++i) {
        outValues[i] = vec4(0.0);
    }

    uint flags;
    vec3 center, scale;
    vec4 quaternion, sizes;
    vec4 values[4];

    int sdfLast = min(sdfFirst + sdfCount, numSdfs);
    for (int index = sdfFirst; index < sdfLast; ++index) {
      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);
      uint sdfType = flags & SDF_FLAG_TYPE;
      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;

      float distance;
      switch (sdfType) {
        case SDF_TYPE_ALL:
          distance = -1.0 / 0.0;
          break;
        case SDF_TYPE_PLANE: {
          distance = sdfPos.z;
          break;
        }
        case SDF_TYPE_SPHERE: {
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_BOX: {
          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;
          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;
          break;
        }
        case SDF_TYPE_ELLIPSOID: {
          vec3 sizes = sizes.xyz;
          float k0 = length(sdfPos / sizes);
          float k1 = length(sdfPos / dot(sizes, sizes));
          distance = k0 * (k0 - 1.0) / k1;
          break;
        }
        case SDF_TYPE_CYLINDER: {
          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;
          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
          break;
        }
        case SDF_TYPE_CAPSULE: {
          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);
          distance = length(sdfPos) - sizes.w;
          break;
        }
        case SDF_TYPE_INFINITE_CONE: {
          float angle = 0.25 * PI * sizes.w;
          vec2 c = vec2(sin(angle), cos(angle));
          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);
          float d = length(q - c * max(dot(q, c), 0.0));
          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);
          break;
        }
      }

      if ((flags & SDF_FLAG_INVERT) != 0u) {
        distance = -distance;
      }

      if (smoothK == 0.0) {
        if (distance < distanceAccum) {
          distanceAccum = distance;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] = values[i];
          }
        }
      } else {
        float scaledDistance = -distance / smoothK;
        if (scaledDistance > maxExp) {
          float scale = exp(maxExp - scaledDistance);
          distanceAccum *= scale;
          for (int i = 0; i < numValues; ++i) {
            outValues[i] *= scale;
          }
          maxExp = scaledDistance;
        }

        float weight = exp(scaledDistance - maxExp);
        distanceAccum += weight;
        for (int i = 0; i < numValues; ++i) {
          outValues[i] += weight * values[i];
        }
      }
    }

    if (smoothK == 0.0) {
      return distanceAccum;
    } else {
      // Very distant SDFs may result in 0 accumulation
      if (distanceAccum == 0.0) {
        return 1.0 / 0.0;
      }
      for (int i = 0; i < numValues; ++i) {
        outValues[i] /= distanceAccum;
      }
      return (-log(distanceAccum) - maxExp) * smoothK;
    }
  }

  float modulateSdfArray(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,
    float smoothK, int numValues, out vec4 values[4],
    float softEdge, bool invert
  ) {
    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);
    if (invert) {
      distance = -distance;
    }

    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)
      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);
  }
`), fQ = oA(`
  const uint EDIT_FLAG_BLEND = 0xFFu;
  const uint EDIT_BLEND_MULTIPLY = 0u;
  const uint EDIT_BLEND_SET_RGB = 1u;
  const uint EDIT_BLEND_ADD_RGBA = 2u;
  const uint EDIT_FLAG_INVERT = 0x100u;

  void decodeEdit(
    uvec4 packedEdit, out int sdfFirst, out int sdfCount,
    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth
  ) {
    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;
    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;

    sdfFirst = int(packedEdit.y & 0xFFFFu);
    sdfCount = int(packedEdit.y >> 16u);

    softEdge = uintBitsToFloat(packedEdit.z);
    sdfSmooth = uintBitsToFloat(packedEdit.w);
  }

  void applyRgbaDisplaceEdit(
    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,
    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba
  ) {
    vec4 values[4];
    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);
    // On Android, moving values[0] is necessary to work around a compiler bug.
    vec4 sdfRgba = values[0];
    vec4 sdfDisplaceScale = values[1];

    vec4 target;
    switch (rgbaBlendMode) {
      case EDIT_BLEND_MULTIPLY:
        target = rgba * sdfRgba;
        break;
      case EDIT_BLEND_SET_RGB:
        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);
        break;
      case EDIT_BLEND_ADD_RGBA:
        target = rgba + sdfRgba;
        break;
      default:
        // Debug output if blend mode not set
        target = vec4(fract(pos), 1.0);
    }
    rgba = mix(rgba, target, modulate);
    pos += sdfDisplaceScale.xyz * modulate;
  }

  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {
    int sdfFirst, sdfCount;
    bool invert;
    uint rgbaBlendMode;
    float softEdge, sdfSmooth;
    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);
    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);
  }
`);
function Ln(t, A, I, g) {
  return new W({
    inTypes: {
      gsplat: _,
      sdfArray: dQ,
      numEdits: "int",
      rgbaDisplaceEdits: "uvec4"
    },
    outTypes: { gsplat: _ },
    globals: () => [pQ, fQ],
    inputs: { gsplat: t, sdfArray: A, numEdits: I, rgbaDisplaceEdits: g },
    statements: ({ inputs: i, outputs: e }) => {
      const { sdfArray: Q, numEdits: s, rgbaDisplaceEdits: E } = i, { gsplat: a } = e;
      return UA(`
        ${a} = ${i.gsplat};
        if (isGsplatActive(${a}.flags)) {
          for (int editIndex = 0; editIndex < ${s}; ++editIndex) {
            applyPackedRgbaDisplaceEdit(
              ${E}[editIndex], ${Q}.sdfTexture, ${Q}.numSdfs,
              ${a}.center, ${a}.rgba
            );
          }
        }
      `);
    }
  }).outputs.gsplat;
}
const ht = new Float32Array(1);
class Jn {
  constructor(A) {
    this.modifier = A, this.cache = /* @__PURE__ */ new Map();
  }
  apply(A) {
    let I = this.cache.get(A);
    return I || (I = MA(
      { index: "int" },
      { gsplat: _ },
      ({ index: g }) => {
        const { gsplat: B } = A.apply({ index: g });
        return this.modifier.apply({ gsplat: B });
      }
    ), this.cache.set(A, I)), I;
  }
}
class yt {
  // Create the dyno uniforms that parameterize the transform, setting them
  // to initial values that are different from any valid transform.
  constructor() {
    this.scale = new Et({ value: Number.NEGATIVE_INFINITY }), this.rotate = new vt({
      value: new n.Quaternion(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    }), this.translate = new ft({
      value: new n.Vector3(
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY,
        Number.POSITIVE_INFINITY
      )
    });
  }
  // Apply the transform to a Vec3 position in a dyno program.
  apply(A) {
    return Pe(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  applyDir(A) {
    return Xe(A, {
      rotate: this.rotate
    });
  }
  // Apply the transform to a Gsplat in a dyno program.
  applyGsplat(A) {
    return KI(A, {
      scale: this.scale,
      rotate: this.rotate,
      translate: this.translate
    });
  }
  // Update the uniforms to match the given transform matrix.
  updateFromMatrix(A) {
    const I = new n.Vector3(), g = new n.Quaternion(), B = new n.Vector3();
    A.decompose(B, g, I);
    const i = (I.x + I.y + I.z) / 3;
    let e = !1;
    return i !== this.scale.value && (this.scale.value = i, e = !0), B.equals(this.translate.value) || (this.translate.value.copy(B), e = !0), g.equals(this.rotate.value) || (this.rotate.value.copy(g), e = !0), e;
  }
  // Update this transform to match the object's to-world transform.
  update(A) {
    return A.updateMatrixWorld(), this.updateFromMatrix(A.matrixWorld);
  }
}
class cI extends n.Object3D {
  constructor({
    numSplats: A,
    generator: I,
    construct: g,
    update: B
  }) {
    if (super(), this.numSplats = A ?? 0, this.generator = I, this.frameUpdate = B, this.version = 0, g) {
      const i = g(this);
      Object.assign(this, i);
    }
  }
  updateVersion() {
    this.version += 1;
  }
  set needsUpdate(A) {
    A && this.updateVersion();
  }
}
const At = class At extends cI {
  constructor(A = {}) {
    const I = new yt(), g = new yt(), B = new yt(), i = new yt(), e = new vt({
      value: new n.Vector4(
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY,
        Number.NEGATIVE_INFINITY
      )
    }), Q = new Et({ value: 0 }), s = new Et({ value: 0 }), E = {
      transform: I,
      viewToWorld: g,
      worldToView: B,
      viewToObject: i,
      recolor: e,
      time: Q,
      deltaTime: s
    };
    if (super({
      update: ({ time: a, deltaTime: C, viewToWorld: o, globalEdits: r }) => this.update({ time: a, deltaTime: C, viewToWorld: o, globalEdits: r })
    }), this.isInitialized = !1, this.recolor = new n.Color(1, 1, 1), this.opacity = 1, this.enableViewToObject = !1, this.enableViewToWorld = !1, this.enableWorldToView = !1, this.skinning = null, this.edits = null, this.rgbaDisplaceEdits = null, this.splatRgba = null, this.maxSh = 3, this.packedSplats = A.packedSplats ?? new KA(), this.numSplats = this.packedSplats.numSplats, this.editable = A.editable ?? !0, this.onFrame = A.onFrame, this.context = E, this.objectModifier = A.objectModifier, this.worldModifier = A.worldModifier, this.updateGenerator(), A.url || A.fileBytes || A.constructSplats || A.packedSplats && !A.packedSplats.isInitialized)
      this.initialized = this.asyncInitialize(A).then(async () => {
        if (this.updateGenerator(), this.isInitialized = !0, A.onLoad) {
          const a = A.onLoad(this);
          a instanceof Promise && await a;
        }
        return this;
      });
    else if (this.isInitialized = !0, this.initialized = Promise.resolve(this), A.onLoad) {
      const a = A.onLoad(this);
      a instanceof Promise && (this.initialized = a.then(() => this));
    }
  }
  async asyncInitialize(A) {
    const { url: I, fileBytes: g, fileType: B, fileName: i, maxSplats: e, constructSplats: Q } = A;
    if (I || g || Q) {
      const s = {
        url: I,
        fileBytes: g,
        fileType: B,
        fileName: i,
        maxSplats: e,
        construct: Q
      };
      this.packedSplats.reinitialize(s);
    }
    this.packedSplats && (await this.packedSplats.initialized, this.numSplats = this.packedSplats.numSplats, this.updateGenerator());
  }
  static async staticInitialize() {
    await Cg(), At.isStaticInitialized = !0;
  }
  // Creates a new Gsplat with the provided parameters (all values in "float" space,
  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,
  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential
  // doubling strategy to fit the new data, so it's fairly efficient to just
  // pushSplat(...) each Gsplat you want to create in a loop.
  pushSplat(A, I, g, B, i) {
    this.packedSplats.pushSplat(A, I, g, B, i);
  }
  // This method iterates over all Gsplats in this instance's packedSplats,
  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).
  // Note that the objects passed in as center etc. are the same for every callback
  // invocation: these objects are reused for efficiency. Changing these values has
  // no effect as they are decoded/unpacked copies of the underlying data. To update
  // the packedSplats, call .packedSplats.setSplat(index, center, scales,
  // quaternion, opacity, color).
  forEachSplat(A) {
    this.packedSplats.forEachSplat(A);
  }
  // Call this when you are finished with the SplatMesh and want to free
  // any buffers it holds (via packedSplats).
  dispose() {
    this.packedSplats.dispose();
  }
  constructGenerator(A) {
    const { transform: I, viewToObject: g, recolor: B } = A, i = MA(
      { index: "int" },
      { gsplat: _ },
      ({ index: e }) => {
        if (!e)
          throw new Error("index is undefined");
        let Q = Jt(this.packedSplats.dyno, e);
        if (this.maxSh >= 1) {
          const { sh1Texture: E, sh2Texture: a, sh3Texture: C } = this.ensureShTextures();
          if (E) {
            const o = g.translate, { center: r } = Ct(Q).outputs, h = oe(Ft(r, o));
            let c = Kn(Q, E, h);
            this.maxSh >= 2 && a && (c = pA(c, qn(Q, a, h))), this.maxSh >= 3 && C && (c = pA(c, vn(Q, C, h)));
            let { rgba: l } = Ct(Q).outputs;
            l = pA(l, re(c, q("float", 0))), Q = Bt({ gsplat: Q, rgba: l });
          }
        }
        if (this.splatRgba) {
          const E = mn(this.splatRgba.dyno, e);
          Q = Bt({ gsplat: Q, rgba: E });
        }
        this.skinning && (Q = this.skinning.modify(Q)), this.objectModifier && (Q = this.objectModifier.apply({ gsplat: Q }).gsplat), Q = I.applyGsplat(Q);
        const s = nA(B, Ct(Q).outputs.rgba);
        return Q = Bt({ gsplat: Q, rgba: s }), this.rgbaDisplaceEdits && (Q = this.rgbaDisplaceEdits.modify(Q)), this.worldModifier && (Q = this.worldModifier.apply({ gsplat: Q }).gsplat), { gsplat: Q };
      }
    );
    this.generator = i;
  }
  // Call this whenever something changes in the Gsplat processing pipeline,
  // for example changing maxSh or updating objectModifier or worldModifier.
  // Compiled generators are cached for efficiency and re-use when the same
  // pipeline structure emerges after successive changes.
  updateGenerator() {
    this.constructGenerator(this.context);
  }
  // This is called automatically by SparkRenderer and you should not have to
  // call it. It updates parameters for the generated pipeline and calls
  // updateGenerator() if the pipeline needs to change.
  update({
    time: A,
    viewToWorld: I,
    deltaTime: g,
    globalEdits: B
  }) {
    var l;
    this.numSplats = this.packedSplats.numSplats, this.context.time.value = A, this.context.deltaTime.value = g, At.dynoTime.value = A;
    const { transform: i, viewToObject: e, recolor: Q } = this.context;
    let s = i.update(this);
    this.context.viewToWorld.updateFromMatrix(I) && this.enableViewToWorld && (s = !0);
    const E = I.clone().invert();
    this.context.worldToView.updateFromMatrix(E) && this.enableWorldToView && (s = !0);
    const o = new n.Matrix4().compose(
      i.translate.value,
      i.rotate.value,
      new n.Vector3().setScalar(i.scale.value)
    ).invert().multiply(I);
    e.updateFromMatrix(o) && (this.enableViewToObject || this.packedSplats.extra.sh1) && (s = !0);
    const r = new n.Vector4(
      this.recolor.r,
      this.recolor.g,
      this.recolor.b,
      this.opacity
    );
    r.equals(Q.value) || (Q.value.copy(r), s = !0);
    const h = this.editable ? (this.edits ?? []).concat(B) : [];
    this.editable && !this.edits && this.traverseVisible((u) => {
      u instanceof eI && h.push(u);
    }), h.sort((u, D) => u.ordering - D.ordering);
    const c = h.map((u) => {
      if (u.sdfs != null)
        return { edit: u, sdfs: u.sdfs };
      const D = [];
      return u.traverseVisible((y) => {
        y instanceof Un && D.push(y);
      }), { edit: u, sdfs: D };
    });
    if (c.length > 0 && !this.rgbaDisplaceEdits) {
      const u = c.length, D = c.reduce(
        (y, d) => y + d.sdfs.length,
        0
      );
      this.rgbaDisplaceEdits = new Yn({
        maxEdits: u,
        maxSdfs: D
      }), this.updateGenerator();
    }
    if (this.rgbaDisplaceEdits) {
      const u = this.rgbaDisplaceEdits.update(c);
      s || (s = u.updated), u.dynoUpdated && this.updateGenerator();
    }
    s && this.updateVersion(), (l = this.onFrame) == null || l.call(this, { mesh: this, time: A, deltaTime: g });
  }
  // This method conforms to the standard THREE.Raycaster API, performing object-ray
  // intersections using this method to populate the provided intersects[] array
  // with each intersection point.
  raycast(A, I) {
    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats)
      return;
    const { near: g, far: B, ray: i } = A, e = this.matrixWorld.clone().invert(), Q = new n.Matrix3().setFromMatrix4(e), s = i.origin.clone().applyMatrix4(e), E = i.direction.clone().applyMatrix3(Q), a = new n.Vector3();
    e.decompose(new n.Vector3(), new n.Quaternion(), a), (a.x * a.y * a.z) ** (1 / 3);
    const o = Is(
      s.x,
      s.y,
      s.z,
      E.x,
      E.y,
      E.z,
      g,
      B,
      this.packedSplats.numSplats,
      this.packedSplats.packedArray,
      !0
    );
    for (const r of o) {
      const h = i.direction.clone().multiplyScalar(r).add(i.origin);
      I.push({
        distance: r,
        point: h,
        object: this
      });
    }
  }
  ensureShTextures() {
    if (!this.packedSplats.extra.sh1)
      return {};
    let A = this.packedSplats.extra.sh1Texture;
    if (!A) {
      let B = this.packedSplats.extra.sh1;
      const { width: i, height: e, depth: Q, maxSplats: s } = fA(
        B.length / 2
      );
      if (B.length < s * 2) {
        const a = new Uint32Array(s * 2);
        a.set(B), this.packedSplats.extra.sh1 = a, B = a;
      }
      const E = new n.DataArrayTexture(B, i, e, Q);
      E.format = n.RGIntegerFormat, E.type = n.UnsignedIntType, E.internalFormat = "RG32UI", E.needsUpdate = !0, A = new Ut({
        value: E,
        key: "sh1"
      }), this.packedSplats.extra.sh1Texture = A;
    }
    if (!this.packedSplats.extra.sh2)
      return { sh1Texture: A };
    let I = this.packedSplats.extra.sh2Texture;
    if (!I) {
      let B = this.packedSplats.extra.sh2;
      const { width: i, height: e, depth: Q, maxSplats: s } = fA(
        B.length / 4
      );
      if (B.length < s * 4) {
        const a = new Uint32Array(s * 4);
        a.set(B), this.packedSplats.extra.sh2 = a, B = a;
      }
      const E = new n.DataArrayTexture(B, i, e, Q);
      E.format = n.RGBAIntegerFormat, E.type = n.UnsignedIntType, E.internalFormat = "RGBA32UI", E.needsUpdate = !0, I = new Ut({
        value: E,
        key: "sh2"
      }), this.packedSplats.extra.sh2Texture = I;
    }
    if (!this.packedSplats.extra.sh3)
      return { sh1Texture: A, sh2Texture: I };
    let g = this.packedSplats.extra.sh3Texture;
    if (!g) {
      let B = this.packedSplats.extra.sh3;
      const { width: i, height: e, depth: Q, maxSplats: s } = fA(
        B.length / 4
      );
      if (B.length < s * 4) {
        const a = new Uint32Array(s * 4);
        a.set(B), this.packedSplats.extra.sh3 = a, B = a;
      }
      const E = new n.DataArrayTexture(B, i, e, Q);
      E.format = n.RGBAIntegerFormat, E.type = n.UnsignedIntType, E.internalFormat = "RGBA32UI", E.needsUpdate = !0, g = new Ut({
        value: E,
        key: "sh3"
      }), this.packedSplats.extra.sh3Texture = g;
    }
    return { sh1Texture: A, sh2Texture: I, sh3Texture: g };
  }
};
At.staticInitialized = At.staticInitialize(), At.isStaticInitialized = !1, At.dynoTime = new Et({ value: 0 });
let OA = At;
const Hn = oA(`
  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {
    // Extract sint7 values packed into 2 x uint32
    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;
    vec3 sh1_0 = vec3(ivec3(
      int(packed.x << 25u) >> 25,
      int(packed.x << 18u) >> 25,
      int(packed.x << 11u) >> 25
    )) / 63.0;
    vec3 sh1_1 = vec3(ivec3(
      int(packed.x << 4u) >> 25,
      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,
      int(packed.y << 22u) >> 25
    )) / 63.0;
    vec3 sh1_2 = vec3(ivec3(
      int(packed.y << 15u) >> 25,
      int(packed.y << 8u) >> 25,
      int(packed.y << 1u) >> 25
    )) / 63.0;

    return sh1_0 * (-0.4886025 * viewDir.y)
      + sh1_1 * (0.4886025 * viewDir.z)
      + sh1_2 * (-0.4886025 * viewDir.x);
  }
`), bn = oA(`
  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {
    // Extract sint8 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);
    vec3 sh2_0 = vec3(ivec3(
      int(packed.x << 24u) >> 24,
      int(packed.x << 16u) >> 24,
      int(packed.x << 8u) >> 24
    )) / 127.0;
    vec3 sh2_1 = vec3(ivec3(
      int(packed.x) >> 24,
      int(packed.y << 24u) >> 24,
      int(packed.y << 16u) >> 24
    )) / 127.0;
    vec3 sh2_2 = vec3(ivec3(
      int(packed.y << 8u) >> 24,
      int(packed.y) >> 24,
      int(packed.z << 24u) >> 24
    )) / 127.0;
    vec3 sh2_3 = vec3(ivec3(
      int(packed.z << 16u) >> 24,
      int(packed.z << 8u) >> 24,
      int(packed.z) >> 24
    )) / 127.0;
    vec3 sh2_4 = vec3(ivec3(
      int(packed.w << 24u) >> 24,
      int(packed.w << 16u) >> 24,
      int(packed.w << 8u) >> 24
    )) / 127.0;

    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)
      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)
      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))
      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)
      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));
  }
`), Tn = oA(`
  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {
    // Extract sint6 values packed into 4 x uint32
    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);
    vec3 sh3_0 = vec3(ivec3(
      int(packed.x << 26u) >> 26,
      int(packed.x << 20u) >> 26,
      int(packed.x << 14u) >> 26
    )) / 31.0;
    vec3 sh3_1 = vec3(ivec3(
      int(packed.x << 8u) >> 26,
      int(packed.x << 2u) >> 26,
      int((packed.x >> 4u) | (packed.y << 28u)) >> 26
    )) / 31.0;
    vec3 sh3_2 = vec3(ivec3(
      int(packed.y << 22u) >> 26,
      int(packed.y << 16u) >> 26,
      int(packed.y << 10u) >> 26
    )) / 31.0;
    vec3 sh3_3 = vec3(ivec3(
      int(packed.y << 4u) >> 26,
      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,
      int(packed.z << 24u) >> 26
    )) / 31.0;
    vec3 sh3_4 = vec3(ivec3(
      int(packed.z << 18u) >> 26,
      int(packed.z << 12u) >> 26,
      int(packed.z << 6u) >> 26
    )) / 31.0;
    vec3 sh3_5 = vec3(ivec3(
      int(packed.z) >> 26,
      int(packed.w << 26u) >> 26,
      int(packed.w << 20u) >> 26
    )) / 31.0;
    vec3 sh3_6 = vec3(ivec3(
      int(packed.w << 14u) >> 26,
      int(packed.w << 8u) >> 26,
      int(packed.w << 2u) >> 26
    )) / 31.0;

    float xx = viewDir.x * viewDir.x;
    float yy = viewDir.y * viewDir.y;
    float zz = viewDir.z * viewDir.z;
    float xy = viewDir.x * viewDir.y;
    float yz = viewDir.y * viewDir.z;
    float zx = viewDir.z * viewDir.x;

    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))
      + sh3_1 * (2.8906114 * xy * viewDir.z) +
      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))
      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))
      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))
      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))
      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));
  }
`);
function Kn(t, A, I) {
  return Kt({
    inTypes: { gsplat: _, sh1: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh1: A, viewDir: I },
    globals: () => [NA, Hn],
    statements: ({ inputs: g, outputs: B }) => UA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${B.rgb} = evaluateSH1(${g.gsplat}, ${g.sh1}, ${g.viewDir});
        } else {
          ${B.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function qn(t, A, I) {
  return Kt({
    inTypes: { gsplat: _, sh2: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh2: A, viewDir: I },
    globals: () => [NA, bn],
    statements: ({ inputs: g, outputs: B }) => UA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${B.rgb} = evaluateSH2(${g.gsplat}, ${g.sh2}, ${g.viewDir});
        } else {
          ${B.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
function vn(t, A, I) {
  return Kt({
    inTypes: { gsplat: _, sh3: "usampler2DArray", viewDir: "vec3" },
    outTypes: { rgb: "vec3" },
    inputs: { gsplat: t, sh3: A, viewDir: I },
    globals: () => [NA, Tn],
    statements: ({ inputs: g, outputs: B }) => UA(`
        if (isGsplatActive(${g.gsplat}.flags)) {
          ${B.rgb} = evaluateSH3(${g.gsplat}, ${g.sh3}, ${g.viewDir});
        } else {
          ${B.rgb} = vec3(0.0);
        }
      `)
  }).outputs.rgb;
}
const wt = class wt {
  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet
  constructor({ fileBytes: A }) {
    this.header = "", this.littleEndian = !0, this.elements = {}, this.comments = [], this.data = null, this.numSplats = 0, this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A;
  }
  // Identify and parse the PLY text header (assumed to be <64KB in size).
  // this.elements will contain all the elements in the file, typically
  // "vertex" contains the Gsplat data.
  async parseHeader() {
    const I = new ReadableStream({
      start: (e) => {
        e.enqueue(this.fileBytes.slice(0, 65536)), e.close();
      }
    }).pipeThrough(new TextDecoderStream()).getReader();
    this.header = "";
    const g = `end_header
`;
    for (; ; ) {
      const { value: e, done: Q } = await I.read();
      if (Q)
        throw new Error("Failed to read header");
      this.header += e;
      const s = this.header.indexOf(g);
      if (s >= 0) {
        this.header = this.header.slice(0, s + g.length);
        break;
      }
    }
    const B = new TextEncoder().encode(this.header).length;
    this.data = new DataView(this.fileBytes.buffer, B), this.elements = {};
    let i = null;
    this.comments = [], this.header.trim().split(`
`).forEach((e, Q) => {
      const s = e.trim();
      if (Q === 0) {
        if (s !== "ply")
          throw new Error("Invalid PLY header");
        return;
      }
      if (s.length === 0)
        return;
      const E = s.split(" ");
      switch (E[0]) {
        case "format":
          if (E[1] === "binary_little_endian")
            this.littleEndian = !0;
          else if (E[1] === "binary_big_endian")
            this.littleEndian = !1;
          else
            throw new Error(`Unsupported PLY format: ${E[1]}`);
          if (E[2] !== "1.0")
            throw new Error(`Unsupported PLY version: ${E[2]}`);
          break;
        case "end_header":
          break;
        case "comment":
          this.comments.push(s.slice(8));
          break;
        case "element": {
          const a = E[1];
          i = {
            name: a,
            count: Number.parseInt(E[2]),
            properties: {}
          }, this.elements[a] = i;
          break;
        }
        case "property":
          if (i == null)
            throw new Error("Property must be inside an element");
          E[1] === "list" ? i.properties[E[4]] = {
            isList: !0,
            type: E[3],
            countType: E[2]
          } : i.properties[E[2]] = {
            isList: !1,
            type: E[1]
          };
          break;
      }
    }), this.elements.vertex && (this.numSplats = this.elements.vertex.count);
  }
  parseData(A) {
    let I = 0;
    const g = this.data;
    if (g == null)
      throw new Error("No data to parse");
    for (const B in this.elements) {
      const i = this.elements[B], { count: e, properties: Q } = i, s = {}, E = [];
      for (const [C, o] of Object.entries(Q))
        o.isList ? (s[C] = [], E.push(() => {
          const r = s[C];
          r.length = Pt[o.countType](
            g,
            I,
            this.littleEndian
          ), I += lt[o.countType];
          for (let h = 0; h < r.length; h++)
            r[h] = Pt[o.type](
              g,
              I,
              this.littleEndian
            ), I += lt[o.type];
        })) : (s[C] = 0, E.push(() => {
          s[C] = Pt[o.type](
            g,
            I,
            this.littleEndian
          ), I += lt[o.type];
        }));
      const a = A(i) ?? (() => {
      });
      for (let C = 0; C < e; C++) {
        for (const o of E)
          o();
        a(C, s);
      }
    }
  }
  // Parse all the Gsplat data in the PLY file in go, invoking the given
  // callbacks for each Gsplat.
  parseSplats(A, I) {
    if (this.elements.vertex == null)
      throw new Error("No vertex element found");
    let g = !1;
    const B = [];
    let i = 0, e = [], Q = [], s = [], E, a, C;
    function o() {
      const u = zn[i];
      e = new Array(3).fill(null).flatMap(
        (D, y) => [0, 1, 2].map((d, w) => `f_rest_${y + w * u / 3}`)
      ), Q = new Array(5).fill(null).flatMap(
        (D, y) => [0, 1, 2].map((d, w) => `f_rest_${3 + y + w * u / 3}`)
      ), s = new Array(7).fill(null).flatMap(
        (D, y) => [0, 1, 2].map((d, w) => `f_rest_${8 + y + w * u / 3}`)
      ), E = i >= 1 ? new Float32Array(3 * 3) : void 0, a = i >= 2 ? new Float32Array(5 * 3) : void 0, C = i >= 3 ? new Float32Array(7 * 3) : void 0;
    }
    function r(u, D) {
      if (!E)
        throw new Error("Missing sh1");
      for (const [y, d] of e.entries())
        E[y] = D[d] * 8 / 255 - 4;
      if (a)
        for (const [y, d] of Q.entries())
          a[y] = D[d] * 8 / 255 - 4;
      if (C)
        for (const [y, d] of s.entries())
          C[y] = D[d] * 8 / 255 - 4;
      I == null || I(u, E, a, C);
    }
    function h(u) {
      const {
        min_x: D,
        min_y: y,
        min_z: d,
        max_x: w,
        max_y: F,
        max_z: m,
        min_scale_x: f,
        min_scale_y: p,
        min_scale_z: R,
        max_scale_x: S,
        max_scale_y: G,
        max_scale_z: Y
      } = u.properties;
      if (!D || !y || !d || !w || !F || !m || !f || !p || !R || !S || !G || !Y)
        throw new Error("Missing PLY chunk properties");
      return g = !0, (M, k) => {
        const {
          min_x: U,
          min_y: J,
          min_z: AA,
          max_x: Z,
          max_y: gA,
          max_z: tA,
          min_scale_x: V,
          min_scale_y: b,
          min_scale_z: P,
          max_scale_x: O,
          max_scale_y: X,
          max_scale_z: L,
          min_r: DA,
          min_g: CA,
          min_b: yA,
          max_r: wA,
          max_g: FA,
          max_b: rA
        } = k;
        B.push({
          min_x: U,
          min_y: J,
          min_z: AA,
          max_x: Z,
          max_y: gA,
          max_z: tA,
          min_scale_x: V,
          min_scale_y: b,
          min_scale_z: P,
          max_scale_x: O,
          max_scale_y: X,
          max_scale_z: L,
          min_r: DA,
          min_g: CA,
          min_b: yA,
          max_r: wA,
          max_g: FA,
          max_b: rA
        });
      };
    }
    function c(u) {
      if (I && u.name === "sh")
        return i = Ig(u.properties), o(), r;
      if (u.name !== "vertex")
        return null;
      const { packed_position: D, packed_rotation: y, packed_scale: d, packed_color: w } = u.properties;
      if (!D || !y || !d || !w)
        throw new Error(
          "Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color"
        );
      const F = Math.sqrt(2);
      return (m, f) => {
        const p = B[m >>> 8];
        if (p == null)
          throw new Error("Missing PLY chunk");
        const {
          min_x: R,
          min_y: S,
          min_z: G,
          max_x: Y,
          max_y: M,
          max_z: k,
          min_scale_x: U,
          min_scale_y: J,
          min_scale_z: AA,
          max_scale_x: Z,
          max_scale_y: gA,
          max_scale_z: tA,
          min_r: V,
          min_g: b,
          min_b: P,
          max_r: O,
          max_g: X,
          max_b: L
        } = p, { packed_position: DA, packed_rotation: CA, packed_scale: yA, packed_color: wA } = f, FA = (DA >>> 21 & 2047) / 2047 * (Y - R) + R, rA = (DA >>> 11 & 1023) / 1023 * (M - S) + S, YA = (DA & 2047) / 2047 * (k - G) + G, GA = ((CA >>> 20 & 1023) / 1023 - 0.5) * F, VA = ((CA >>> 10 & 1023) / 1023 - 0.5) * F, PA = ((CA & 1023) / 1023 - 0.5) * F, H = Math.sqrt(Math.max(0, 1 - GA * GA - VA * VA - PA * PA)), uA = CA >>> 30, vA = uA === 0 ? GA : uA === 1 ? H : VA, mt = uA <= 1 ? VA : uA === 2 ? H : PA, Wt = uA <= 2 ? PA : H, SA = uA === 0 ? H : GA, T = Math.exp(
          (yA >>> 21 & 2047) / 2047 * (Z - U) + U
        ), ZA = Math.exp(
          (yA >>> 11 & 1023) / 1023 * (gA - J) + J
        ), hI = Math.exp(
          (yA & 2047) / 2047 * (tA - AA) + AA
        ), lI = (wA >>> 24 & 255) / 255 * ((O ?? 1) - (V ?? 0)) + (V ?? 0), uI = (wA >>> 16 & 255) / 255 * ((X ?? 1) - (b ?? 0)) + (b ?? 0), DI = (wA >>> 8 & 255) / 255 * ((L ?? 1) - (P ?? 0)) + (P ?? 0), yI = (wA & 255) / 255;
        A(
          m,
          FA,
          rA,
          YA,
          T,
          ZA,
          hI,
          vA,
          mt,
          Wt,
          SA,
          yI,
          lI,
          uI,
          DI
        );
      };
    }
    const l = (u) => {
      if (u.name === "chunk")
        return h(u);
      if (g)
        return c(u);
      if (u.name !== "vertex")
        return null;
      const {
        x: D,
        y,
        z: d,
        scale_0: w,
        scale_1: F,
        scale_2: m,
        rot_0: f,
        rot_1: p,
        rot_2: R,
        rot_3: S,
        opacity: G,
        f_dc_0: Y,
        f_dc_1: M,
        f_dc_2: k,
        red: U,
        green: J,
        blue: AA,
        alpha: Z
      } = u.properties;
      if (!D || !y || !d)
        throw new Error("Missing PLY properties: x, y, z");
      const gA = w && F && m, tA = f && p && R && S, V = Z != null ? Xt[Z.type] : 1, b = U != null ? Xt[U.type] : 1, P = J != null ? Xt[J.type] : 1, O = AA != null ? Xt[AA.type] : 1;
      return i = Ig(u.properties), o(), (X, L) => {
        const DA = gA ? Math.exp(L.scale_0) : wt.defaultPointScale, CA = gA ? Math.exp(L.scale_1) : wt.defaultPointScale, yA = gA ? Math.exp(L.scale_2) : wt.defaultPointScale, wA = tA ? L.rot_1 : 0, FA = tA ? L.rot_2 : 0, rA = tA ? L.rot_3 : 0, YA = tA ? L.rot_0 : 1, GA = G != null ? 1 / (1 + Math.exp(-L.opacity)) : Z != null ? L.alpha / V : 1, VA = Y != null ? L.f_dc_0 * Vt + 0.5 : U != null ? L.red / b : 1, PA = M != null ? L.f_dc_1 * Vt + 0.5 : J != null ? L.green / P : 1, H = k != null ? L.f_dc_2 * Vt + 0.5 : AA != null ? L.blue / O : 1;
        if (A(
          X,
          L.x,
          L.y,
          L.z,
          DA,
          CA,
          yA,
          wA,
          FA,
          rA,
          YA,
          GA,
          VA,
          PA,
          H
        ), I && E) {
          if (E)
            for (const [uA, vA] of e.entries())
              E[uA] = L[vA];
          if (a)
            for (const [uA, vA] of Q.entries())
              a[uA] = L[vA];
          if (C)
            for (const [uA, vA] of s.entries())
              C[uA] = L[vA];
          I(X, E, a, C);
        }
      };
    };
    this.parseData(l);
  }
  // Inject RGBA values into original PLY file, which can be used to modify
  // the color/opacity of the Gsplats and write out the modified PLY file.
  injectRgba(A) {
    let I = 0;
    const g = this.data;
    if (g == null)
      throw new Error("No parsed data");
    if (A.length !== this.numSplats * 4)
      throw new Error("Invalid RGBA array length");
    for (const B in this.elements) {
      const i = this.elements[B], { count: e, properties: Q } = i, s = [];
      let E = 0;
      const a = B === "vertex";
      if (a) {
        for (const C of ["opacity", "f_dc_0", "f_dc_1", "f_dc_2"])
          if (!Q[C] || Q[C].type !== "float")
            throw new Error(`Can't injectRgba due to property: ${C}`);
      }
      for (const [C, o] of Object.entries(Q))
        if (o.isList)
          s.push(() => {
            const r = Pt[o.countType](
              g,
              I,
              this.littleEndian
            );
            I += lt[o.countType], I += r * lt[o.type];
          });
        else {
          if (a)
            if (C === "f_dc_0" || C === "f_dc_1" || C === "f_dc_2") {
              const r = Number.parseInt(
                C.slice(5)
              );
              s.push(() => {
                const h = (A[E + r] / 255 - 0.5) / Vt;
                tg[o.type](
                  g,
                  I,
                  this.littleEndian,
                  h
                );
              });
            } else C === "opacity" && s.push(() => {
              const r = Math.max(
                -100,
                Math.min(
                  100,
                  -Math.log(1 / (A[E + 3] / 255) - 1)
                )
              );
              tg[o.type](
                g,
                I,
                this.littleEndian,
                r
              );
            });
          s.push(() => {
            I += lt[o.type];
          });
        }
      for (let C = 0; C < e; C++) {
        for (const o of s)
          o();
        a && (E += 4);
      }
    }
  }
};
wt.defaultPointScale = 1e-3;
let QI = wt;
const Vt = 0.28209479177387814, Pt = {
  char: (t, A, I) => t.getInt8(A),
  uchar: (t, A, I) => t.getUint8(A),
  short: (t, A, I) => t.getInt16(A, I),
  ushort: (t, A, I) => t.getUint16(A, I),
  int: (t, A, I) => t.getInt32(A, I),
  uint: (t, A, I) => t.getUint32(A, I),
  float: (t, A, I) => t.getFloat32(A, I),
  double: (t, A, I) => t.getFloat64(A, I)
}, tg = {
  char: (t, A, I, g) => {
    t.setInt8(A, g);
  },
  uchar: (t, A, I, g) => {
    t.setUint8(A, g);
  },
  short: (t, A, I, g) => {
    t.setInt16(A, g, I);
  },
  ushort: (t, A, I, g) => {
    t.setUint16(A, g, I);
  },
  int: (t, A, I, g) => {
    t.setInt32(A, g, I);
  },
  uint: (t, A, I, g) => {
    t.setUint32(A, g, I);
  },
  float: (t, A, I, g) => {
    t.setFloat32(A, g, I);
  },
  double: (t, A, I, g) => {
    t.setFloat64(A, g, I);
  }
}, lt = {
  char: 1,
  uchar: 1,
  short: 2,
  ushort: 2,
  int: 4,
  uint: 4,
  float: 4,
  double: 8
}, Xt = {
  char: 127,
  uchar: 255,
  short: 32767,
  ushort: 65535,
  int: 2147483647,
  uint: 4294967295,
  float: 1,
  double: 1
}, Zn = {
  0: 0,
  9: 1,
  24: 2,
  45: 3
}, zn = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function Ig(t) {
  let A = 0;
  for (; t[`f_rest_${A}`]; )
    A += 1;
  const I = Zn[A];
  if (I == null)
    throw new Error(`Unsupported number of SH coefficients: ${A}`);
  return I;
}
const FQ = '(function(){"use strict";let rI;const Ht=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&Ht.decode();let xg=null;function Si(){return(xg===null||xg.byteLength===0)&&(xg=new Uint8Array(rI.memory.buffer)),xg}function Ni(E,A){return E=E>>>0,Ht.decode(Si().subarray(E,E+A))}function pi(E,A,I){return rI.sort_splats(E,A,I)>>>0}function Mi(E,A,I,g,B,t,Q,i,C,s,o){return rI.raycast_splats(E,A,I,g,B,t,Q,i,C,s,o)}async function ki(E,A){if(typeof Response=="function"&&E instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(E,A)}catch(g){if(E.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n",g);else throw g}const I=await E.arrayBuffer();return await WebAssembly.instantiate(I,A)}else{const I=await WebAssembly.instantiate(E,A);return I instanceof WebAssembly.Instance?{instance:I,module:E}:I}}function Ri(){const E={};return E.wbg={},E.wbg.__wbg_buffer_609cc3eee51ed158=function(A){return A.buffer},E.wbg.__wbg_length_3b4f022188ae8db6=function(A){return A.length},E.wbg.__wbg_length_6ca527665d89694d=function(A){return A.length},E.wbg.__wbg_length_8cfd2c6409af88ad=function(A){return A.length},E.wbg.__wbg_new_9fee97a409b32b68=function(A){return new Uint16Array(A)},E.wbg.__wbg_new_e3b321dcfef89fc7=function(A){return new Uint32Array(A)},E.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354=function(A,I,g){return new Float32Array(A,I>>>0,g>>>0)},E.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212=function(A,I,g){return new Uint32Array(A,I>>>0,g>>>0)},E.wbg.__wbg_newwithlength_5a5efe313cfd59f1=function(A){return new Float32Array(A>>>0)},E.wbg.__wbg_set_10bad9bee0e9c58b=function(A,I,g){A.set(I,g>>>0)},E.wbg.__wbg_set_d23661d19148b229=function(A,I,g){A.set(I,g>>>0)},E.wbg.__wbg_set_f4f1f0daa30696fc=function(A,I,g){A.set(I,g>>>0)},E.wbg.__wbg_subarray_3aaeec89bb2544f0=function(A,I,g){return A.subarray(I>>>0,g>>>0)},E.wbg.__wbg_subarray_769e1e0f81bb259b=function(A,I,g){return A.subarray(I>>>0,g>>>0)},E.wbg.__wbindgen_init_externref_table=function(){const A=rI.__wbindgen_export_0,I=A.grow(4);A.set(0,void 0),A.set(I+0,void 0),A.set(I+1,null),A.set(I+2,!0),A.set(I+3,!1)},E.wbg.__wbindgen_memory=function(){return rI.memory},E.wbg.__wbindgen_throw=function(A,I){throw new Error(Ni(A,I))},E}function mi(E,A){return rI=E.exports,vB.__wbindgen_wasm_module=A,xg=null,rI.__wbindgen_start(),rI}async function vB(E){if(rI!==void 0)return rI;typeof E<"u"&&(Object.getPrototypeOf(E)===Object.prototype?{module_or_path:E}=E:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof E>"u"&&(E=new URL("data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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",self.location.href));const A=Ri();(typeof E=="string"||typeof Request=="function"&&E instanceof Request||typeof URL=="function"&&E instanceof URL)&&(E=fetch(E));const{instance:I,module:g}=await ki(await E,A);return mi(I,g)}var kA=Uint8Array,Ig=Uint16Array,xi=Int32Array,bt=new kA([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Kt=new kA([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ui=new kA([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),qt=function(E,A){for(var I=new Ig(31),g=0;g<31;++g)I[g]=A+=1<<E[g-1];for(var B=new xi(I[30]),g=1;g<30;++g)for(var t=I[g];t<I[g+1];++t)B[t]=t-I[g]<<5|g;return{b:I,r:B}},Tt=qt(bt,2),Zt=Tt.b,Yi=Tt.r;Zt[28]=258,Yi[258]=28;for(var Ji=qt(Kt,0),Li=Ji.b,OB=new Ig(32768),eA=0;eA<32768;++eA){var RI=(eA&43690)>>1|(eA&21845)<<1;RI=(RI&52428)>>2|(RI&13107)<<2,RI=(RI&61680)>>4|(RI&3855)<<4,OB[eA]=((RI&65280)>>8|(RI&255)<<8)>>1}for(var Ug=function(E,A,I){for(var g=E.length,B=0,t=new Ig(A);B<g;++B)E[B]&&++t[E[B]-1];var Q=new Ig(A);for(B=1;B<A;++B)Q[B]=Q[B-1]+t[B-1]<<1;var i;if(I){i=new Ig(1<<A);var C=15-A;for(B=0;B<g;++B)if(E[B])for(var s=B<<4|E[B],o=A-E[B],e=Q[E[B]-1]++<<o,a=e|(1<<o)-1;e<=a;++e)i[OB[e]>>C]=s}else for(i=new Ig(g),B=0;B<g;++B)E[B]&&(i[B]=OB[Q[E[B]-1]++]>>15-E[B]);return i},Yg=new kA(288),eA=0;eA<144;++eA)Yg[eA]=8;for(var eA=144;eA<256;++eA)Yg[eA]=9;for(var eA=256;eA<280;++eA)Yg[eA]=7;for(var eA=280;eA<288;++eA)Yg[eA]=8;for(var zt=new kA(32),eA=0;eA<32;++eA)zt[eA]=5;var Hi=Ug(Yg,9,1),bi=Ug(zt,5,1),VB=function(E){for(var A=E[0],I=1;I<E.length;++I)E[I]>A&&(A=E[I]);return A},tI=function(E,A,I){var g=A/8|0;return(E[g]|E[g+1]<<8)>>(A&7)&I},XB=function(E,A){var I=A/8|0;return(E[I]|E[I+1]<<8|E[I+2]<<16)>>(A&7)},Wt=function(E){return(E+7)/8|0},gB=function(E,A,I){return(A==null||A<0)&&(A=0),(I==null||I>E.length)&&(I=E.length),new kA(E.subarray(A,I))},Ki=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],AI=function(E,A,I){var g=new Error(A||Ki[E]);if(g.code=E,Error.captureStackTrace&&Error.captureStackTrace(g,AI),!I)throw g;return g},qi=function(E,A,I,g){var B=E.length,t=0;if(!B||A.f&&!A.l)return I||new kA(0);var Q=!I,i=Q||A.i!=2,C=A.i;Q&&(I=new kA(B*3));var s=function(mA){var xA=I.length;if(mA>xA){var nA=new kA(Math.max(xA*2,mA));nA.set(I),I=nA}},o=A.f||0,e=A.p||0,a=A.b||0,n=A.l,r=A.d,D=A.m,l=A.n,y=B*8;do{if(!n){o=tI(E,e,1);var w=tI(E,e+1,3);if(e+=3,w)if(w==1)n=Hi,r=bi,D=9,l=5;else if(w==2){var x=tI(E,e,31)+257,k=tI(E,e+10,15)+4,S=x+tI(E,e+5,31)+1;e+=14;for(var N=new kA(S),H=new kA(19),U=0;U<k;++U)H[Ui[U]]=tI(E,e+U*3,7);e+=k*3;for(var m=VB(H),J=(1<<m)-1,K=Ug(H,m,1),U=0;U<S;){var z=K[tI(E,e,J)];e+=z&15;var u=z>>4;if(u<16)N[U++]=u;else{var T=0,W=0;for(u==16?(W=3+tI(E,e,3),e+=2,T=N[U-1]):u==17?(W=3+tI(E,e,7),e+=3):u==18&&(W=11+tI(E,e,127),e+=7);W--;)N[U++]=T}}var BA=N.subarray(0,x),AA=N.subarray(x);D=VB(BA),l=VB(AA),n=Ug(BA,D,1),r=Ug(AA,l,1)}else AI(1);else{var u=Wt(e)+4,G=E[u-4]|E[u-3]<<8,M=u+G;if(M>B){C&&AI(0);break}i&&s(a+G),I.set(E.subarray(u,M),a),A.b=a+=G,A.p=e=M*8,A.f=o;continue}if(e>y){C&&AI(0);break}}i&&s(a+131072);for(var CA=(1<<D)-1,QA=(1<<l)-1,EA=e;;EA=e){var T=n[XB(E,e)&CA],IA=T>>4;if(e+=T&15,e>y){C&&AI(0);break}if(T||AI(2),IA<256)I[a++]=IA;else if(IA==256){EA=e,n=null;break}else{var _=IA-254;if(IA>264){var U=IA-257,O=bt[U];_=tI(E,e,(1<<O)-1)+Zt[U],e+=O}var v=r[XB(E,e)&QA],Z=v>>4;v||AI(3),e+=v&15;var AA=Li[Z];if(Z>3){var O=Kt[Z];AA+=XB(E,e)&(1<<O)-1,e+=O}if(e>y){C&&AI(0);break}i&&s(a+131072);var RA=a+_;if(a<AA){var SA=t-AA,NA=Math.min(AA,RA);for(SA+a<0&&AI(3);a<NA;++a)I[a]=g[SA+a]}for(;a<RA;++a)I[a]=I[a-AA]}}A.l=n,A.p=EA,A.b=a,A.f=o,n&&(o=1,A.m=D,A.d=r,A.n=l)}while(!o);return a!=I.length&&Q?gB(I,0,a):I.subarray(0,a)},Ti=new kA(0),Zi=function(E){(E[0]!=31||E[1]!=139||E[2]!=8)&&AI(6,"invalid gzip data");var A=E[3],I=10;A&4&&(I+=(E[10]|E[11]<<8)+2);for(var g=(A>>3&1)+(A>>4&1);g>0;g-=!E[I++]);return I+(A&2)},PB=function(){function E(A,I){typeof A=="function"&&(I=A,A={}),this.ondata=I;var g=A&&A.dictionary&&A.dictionary.subarray(-32768);this.s={i:0,b:g?g.length:0},this.o=new kA(32768),this.p=new kA(0),g&&this.o.set(g)}return E.prototype.e=function(A){if(this.ondata||AI(5),this.d&&AI(4),!this.p.length)this.p=A;else if(A.length){var I=new kA(this.p.length+A.length);I.set(this.p),I.set(A,this.p.length),this.p=I}},E.prototype.c=function(A){this.s.i=+(this.d=A||!1);var I=this.s.b,g=qi(this.p,this.s,this.o);this.ondata(gB(g,I,this.s.b),this.d),this.o=gB(g,this.s.b-32768),this.s.b=this.o.length,this.p=gB(this.p,this.s.p/8|0),this.s.p&=7},E.prototype.push=function(A,I){this.e(A),this.c(I)},E}(),vt=function(){function E(A,I){this.v=1,this.r=0,PB.call(this,A,I)}return E.prototype.push=function(A,I){if(PB.prototype.e.call(this,A),this.r+=A.length,this.v){var g=this.p.subarray(this.v-1),B=g.length>3?Zi(g):4;if(B>g.length){if(!I)return}else this.v>1&&this.onmember&&this.onmember(this.r-g.length);this.p=g.subarray(B),this.v=0}PB.prototype.c.call(this,I),this.s.f&&!this.s.l&&!I&&(this.v=Wt(this.s.p)+9,this.s={i:0},this.o=new kA(0),this.push(new kA(0),I))},E}(),zi=typeof TextDecoder<"u"&&new TextDecoder,Wi=0;try{zi.decode(Ti,{stream:!0}),Wi=1}catch{}/**\n * @license\n * Copyright 2010-2024 Three.js Authors\n * SPDX-License-Identifier: MIT\n */const Ot="172",jB=0,vi=1,Vt=1,Xt=100,Pt=204,jt=205,_t=3,Oi=0,$t=300,AQ=1e3,Jg=1001,IQ=1002,mI=1003,gQ=1006,Vi=1008,BB=1009,WI=1014,Xi=1015,tB=1023,Pi=1031,gg=1033,BQ="",QI="srgb",tQ="srgb-linear",QQ="linear",_B="srgb",Bg=7680,iQ=519,CQ=35044,ji="300 es",Lg=2e3,EQ=2001;class Hg{addEventListener(A,I){this._listeners===void 0&&(this._listeners={});const g=this._listeners;g[A]===void 0&&(g[A]=[]),g[A].indexOf(I)===-1&&g[A].push(I)}hasEventListener(A,I){if(this._listeners===void 0)return!1;const g=this._listeners;return g[A]!==void 0&&g[A].indexOf(I)!==-1}removeEventListener(A,I){if(this._listeners===void 0)return;const B=this._listeners[A];if(B!==void 0){const t=B.indexOf(I);t!==-1&&B.splice(t,1)}}dispatchEvent(A){if(this._listeners===void 0)return;const g=this._listeners[A.type];if(g!==void 0){A.target=this;const B=g.slice(0);for(let t=0,Q=B.length;t<Q;t++)B[t].call(this,A);A.target=null}}}const JA=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];function bg(){const E=Math.random()*4294967295|0,A=Math.random()*4294967295|0,I=Math.random()*4294967295|0,g=Math.random()*4294967295|0;return(JA[E&255]+JA[E>>8&255]+JA[E>>16&255]+JA[E>>24&255]+"-"+JA[A&255]+JA[A>>8&255]+"-"+JA[A>>16&15|64]+JA[A>>24&255]+"-"+JA[I&63|128]+JA[I>>8&255]+"-"+JA[I>>16&255]+JA[I>>24&255]+JA[g&255]+JA[g>>8&255]+JA[g>>16&255]+JA[g>>24&255]).toLowerCase()}function $(E,A,I){return Math.max(A,Math.min(I,E))}function _i(E,A){return(E%A+A)%A}function $B(E,A,I){return(1-I)*E+I*A}function Kg(E,A){switch(A.constructor){case Float32Array:return E;case Uint32Array:return E/4294967295;case Uint16Array:return E/65535;case Uint8Array:return E/255;case Int32Array:return Math.max(E/2147483647,-1);case Int16Array:return Math.max(E/32767,-1);case Int8Array:return Math.max(E/127,-1);default:throw new Error("Invalid component type.")}}function ZA(E,A){switch(A.constructor){case Float32Array:return E;case Uint32Array:return Math.round(E*4294967295);case Uint16Array:return Math.round(E*65535);case Uint8Array:return Math.round(E*255);case Int32Array:return Math.round(E*2147483647);case Int16Array:return Math.round(E*32767);case Int8Array:return Math.round(E*127);default:throw new Error("Invalid component type.")}}class zA{constructor(A=0,I=0){zA.prototype.isVector2=!0,this.x=A,this.y=I}get width(){return this.x}set width(A){this.x=A}get height(){return this.y}set height(A){this.y=A}set(A,I){return this.x=A,this.y=I,this}setScalar(A){return this.x=A,this.y=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setComponent(A,I){switch(A){case 0:this.x=I;break;case 1:this.y=I;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y)}copy(A){return this.x=A.x,this.y=A.y,this}add(A){return this.x+=A.x,this.y+=A.y,this}addScalar(A){return this.x+=A,this.y+=A,this}addVectors(A,I){return this.x=A.x+I.x,this.y=A.y+I.y,this}addScaledVector(A,I){return this.x+=A.x*I,this.y+=A.y*I,this}sub(A){return this.x-=A.x,this.y-=A.y,this}subScalar(A){return this.x-=A,this.y-=A,this}subVectors(A,I){return this.x=A.x-I.x,this.y=A.y-I.y,this}multiply(A){return this.x*=A.x,this.y*=A.y,this}multiplyScalar(A){return this.x*=A,this.y*=A,this}divide(A){return this.x/=A.x,this.y/=A.y,this}divideScalar(A){return this.multiplyScalar(1/A)}applyMatrix3(A){const I=this.x,g=this.y,B=A.elements;return this.x=B[0]*I+B[3]*g+B[6],this.y=B[1]*I+B[4]*g+B[7],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this}clamp(A,I){return this.x=$(this.x,A.x,I.x),this.y=$(this.y,A.y,I.y),this}clampScalar(A,I){return this.x=$(this.x,A,I),this.y=$(this.y,A,I),this}clampLength(A,I){const g=this.length();return this.divideScalar(g||1).multiplyScalar($(g,A,I))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(A){return this.x*A.x+this.y*A.y}cross(A){return this.x*A.y-this.y*A.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(A){const I=Math.sqrt(this.lengthSq()*A.lengthSq());if(I===0)return Math.PI/2;const g=this.dot(A)/I;return Math.acos($(g,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const I=this.x-A.x,g=this.y-A.y;return I*I+g*g}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,I){return this.x+=(A.x-this.x)*I,this.y+=(A.y-this.y)*I,this}lerpVectors(A,I,g){return this.x=A.x+(I.x-A.x)*g,this.y=A.y+(I.y-A.y)*g,this}equals(A){return A.x===this.x&&A.y===this.y}fromArray(A,I=0){return this.x=A[I],this.y=A[I+1],this}toArray(A=[],I=0){return A[I]=this.x,A[I+1]=this.y,A}fromBufferAttribute(A,I){return this.x=A.getX(I),this.y=A.getY(I),this}rotateAround(A,I){const g=Math.cos(I),B=Math.sin(I),t=this.x-A.x,Q=this.y-A.y;return this.x=t*g-Q*B+A.x,this.y=t*B+Q*g+A.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class hI{constructor(A,I,g,B,t,Q,i,C,s){hI.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],A!==void 0&&this.set(A,I,g,B,t,Q,i,C,s)}set(A,I,g,B,t,Q,i,C,s){const o=this.elements;return o[0]=A,o[1]=B,o[2]=i,o[3]=I,o[4]=t,o[5]=C,o[6]=g,o[7]=Q,o[8]=s,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(A){const I=this.elements,g=A.elements;return I[0]=g[0],I[1]=g[1],I[2]=g[2],I[3]=g[3],I[4]=g[4],I[5]=g[5],I[6]=g[6],I[7]=g[7],I[8]=g[8],this}extractBasis(A,I,g){return A.setFromMatrix3Column(this,0),I.setFromMatrix3Column(this,1),g.setFromMatrix3Column(this,2),this}setFromMatrix4(A){const I=A.elements;return this.set(I[0],I[4],I[8],I[1],I[5],I[9],I[2],I[6],I[10]),this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,I){const g=A.elements,B=I.elements,t=this.elements,Q=g[0],i=g[3],C=g[6],s=g[1],o=g[4],e=g[7],a=g[2],n=g[5],r=g[8],D=B[0],l=B[3],y=B[6],w=B[1],u=B[4],G=B[7],M=B[2],x=B[5],k=B[8];return t[0]=Q*D+i*w+C*M,t[3]=Q*l+i*u+C*x,t[6]=Q*y+i*G+C*k,t[1]=s*D+o*w+e*M,t[4]=s*l+o*u+e*x,t[7]=s*y+o*G+e*k,t[2]=a*D+n*w+r*M,t[5]=a*l+n*u+r*x,t[8]=a*y+n*G+r*k,this}multiplyScalar(A){const I=this.elements;return I[0]*=A,I[3]*=A,I[6]*=A,I[1]*=A,I[4]*=A,I[7]*=A,I[2]*=A,I[5]*=A,I[8]*=A,this}determinant(){const A=this.elements,I=A[0],g=A[1],B=A[2],t=A[3],Q=A[4],i=A[5],C=A[6],s=A[7],o=A[8];return I*Q*o-I*i*s-g*t*o+g*i*C+B*t*s-B*Q*C}invert(){const A=this.elements,I=A[0],g=A[1],B=A[2],t=A[3],Q=A[4],i=A[5],C=A[6],s=A[7],o=A[8],e=o*Q-i*s,a=i*C-o*t,n=s*t-Q*C,r=I*e+g*a+B*n;if(r===0)return this.set(0,0,0,0,0,0,0,0,0);const D=1/r;return A[0]=e*D,A[1]=(B*s-o*g)*D,A[2]=(i*g-B*Q)*D,A[3]=a*D,A[4]=(o*I-B*C)*D,A[5]=(B*t-i*I)*D,A[6]=n*D,A[7]=(g*C-s*I)*D,A[8]=(Q*I-g*t)*D,this}transpose(){let A;const I=this.elements;return A=I[1],I[1]=I[3],I[3]=A,A=I[2],I[2]=I[6],I[6]=A,A=I[5],I[5]=I[7],I[7]=A,this}getNormalMatrix(A){return this.setFromMatrix4(A).invert().transpose()}transposeIntoArray(A){const I=this.elements;return A[0]=I[0],A[1]=I[3],A[2]=I[6],A[3]=I[1],A[4]=I[4],A[5]=I[7],A[6]=I[2],A[7]=I[5],A[8]=I[8],this}setUvTransform(A,I,g,B,t,Q,i){const C=Math.cos(t),s=Math.sin(t);return this.set(g*C,g*s,-g*(C*Q+s*i)+Q+A,-B*s,B*C,-B*(-s*Q+C*i)+i+I,0,0,1),this}scale(A,I){return this.premultiply(At.makeScale(A,I)),this}rotate(A){return this.premultiply(At.makeRotation(-A)),this}translate(A,I){return this.premultiply(At.makeTranslation(A,I)),this}makeTranslation(A,I){return A.isVector2?this.set(1,0,A.x,0,1,A.y,0,0,1):this.set(1,0,A,0,1,I,0,0,1),this}makeRotation(A){const I=Math.cos(A),g=Math.sin(A);return this.set(I,-g,0,g,I,0,0,0,1),this}makeScale(A,I){return this.set(A,0,0,0,I,0,0,0,1),this}equals(A){const I=this.elements,g=A.elements;for(let B=0;B<9;B++)if(I[B]!==g[B])return!1;return!0}fromArray(A,I=0){for(let g=0;g<9;g++)this.elements[g]=A[g+I];return this}toArray(A=[],I=0){const g=this.elements;return A[I]=g[0],A[I+1]=g[1],A[I+2]=g[2],A[I+3]=g[3],A[I+4]=g[4],A[I+5]=g[5],A[I+6]=g[6],A[I+7]=g[7],A[I+8]=g[8],A}clone(){return new this.constructor().fromArray(this.elements)}}const At=new hI;function $i(E){for(let A=E.length-1;A>=0;--A)if(E[A]>=65535)return!0;return!1}function sQ(E){return document.createElementNS("http://www.w3.org/1999/xhtml",E)}const eQ=new hI().set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),oQ=new hI().set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function AC(){const E={enabled:!0,workingColorSpace:tQ,spaces:{},convert:function(B,t,Q){return this.enabled===!1||t===Q||!t||!Q||(this.spaces[t].transfer===_B&&(B.r=lI(B.r),B.g=lI(B.g),B.b=lI(B.b)),this.spaces[t].primaries!==this.spaces[Q].primaries&&(B.applyMatrix3(this.spaces[t].toXYZ),B.applyMatrix3(this.spaces[Q].fromXYZ)),this.spaces[Q].transfer===_B&&(B.r=tg(B.r),B.g=tg(B.g),B.b=tg(B.b))),B},fromWorkingColorSpace:function(B,t){return this.convert(B,this.workingColorSpace,t)},toWorkingColorSpace:function(B,t){return this.convert(B,t,this.workingColorSpace)},getPrimaries:function(B){return this.spaces[B].primaries},getTransfer:function(B){return B===BQ?QQ:this.spaces[B].transfer},getLuminanceCoefficients:function(B,t=this.workingColorSpace){return B.fromArray(this.spaces[t].luminanceCoefficients)},define:function(B){Object.assign(this.spaces,B)},_getMatrix:function(B,t,Q){return B.copy(this.spaces[t].toXYZ).multiply(this.spaces[Q].fromXYZ)},_getDrawingBufferColorSpace:function(B){return this.spaces[B].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(B=this.workingColorSpace){return this.spaces[B].workingColorSpaceConfig.unpackColorSpace}},A=[.64,.33,.3,.6,.15,.06],I=[.2126,.7152,.0722],g=[.3127,.329];return E.define({[tQ]:{primaries:A,whitePoint:g,transfer:QQ,toXYZ:eQ,fromXYZ:oQ,luminanceCoefficients:I,workingColorSpaceConfig:{unpackColorSpace:QI},outputColorSpaceConfig:{drawingBufferColorSpace:QI}},[QI]:{primaries:A,whitePoint:g,transfer:_B,toXYZ:eQ,fromXYZ:oQ,luminanceCoefficients:I,outputColorSpaceConfig:{drawingBufferColorSpace:QI}}}),E}const iI=AC();function lI(E){return E<.04045?E*.0773993808:Math.pow(E*.9478672986+.0521327014,2.4)}function tg(E){return E<.0031308?E*12.92:1.055*Math.pow(E,.41666)-.055}let Qg;class IC{static getDataURL(A){if(/^data:/i.test(A.src)||typeof HTMLCanvasElement>"u")return A.src;let I;if(A instanceof HTMLCanvasElement)I=A;else{Qg===void 0&&(Qg=sQ("canvas")),Qg.width=A.width,Qg.height=A.height;const g=Qg.getContext("2d");A instanceof ImageData?g.putImageData(A,0,0):g.drawImage(A,0,0,A.width,A.height),I=Qg}return I.width>2048||I.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",A),I.toDataURL("image/jpeg",.6)):I.toDataURL("image/png")}static sRGBToLinear(A){if(typeof HTMLImageElement<"u"&&A instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&A instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&A instanceof ImageBitmap){const I=sQ("canvas");I.width=A.width,I.height=A.height;const g=I.getContext("2d");g.drawImage(A,0,0,A.width,A.height);const B=g.getImageData(0,0,A.width,A.height),t=B.data;for(let Q=0;Q<t.length;Q++)t[Q]=lI(t[Q]/255)*255;return g.putImageData(B,0,0),I}else if(A.data){const I=A.data.slice(0);for(let g=0;g<I.length;g++)I instanceof Uint8Array||I instanceof Uint8ClampedArray?I[g]=Math.floor(lI(I[g]/255)*255):I[g]=lI(I[g]);return{data:I,width:A.width,height:A.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),A}}let gC=0;class aQ{constructor(A=null){this.isSource=!0,Object.defineProperty(this,"id",{value:gC++}),this.uuid=bg(),this.data=A,this.dataReady=!0,this.version=0}set needsUpdate(A){A===!0&&this.version++}toJSON(A){const I=A===void 0||typeof A=="string";if(!I&&A.images[this.uuid]!==void 0)return A.images[this.uuid];const g={uuid:this.uuid,url:""},B=this.data;if(B!==null){let t;if(Array.isArray(B)){t=[];for(let Q=0,i=B.length;Q<i;Q++)B[Q].isDataTexture?t.push(It(B[Q].image)):t.push(It(B[Q]))}else t=It(B);g.url=t}return I||(A.images[this.uuid]=g),g}}function It(E){return typeof HTMLImageElement<"u"&&E instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&E instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&E instanceof ImageBitmap?IC.getDataURL(E):E.data?{data:Array.from(E.data),width:E.width,height:E.height,type:E.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let BC=0;class cI extends Hg{constructor(A=cI.DEFAULT_IMAGE,I=cI.DEFAULT_MAPPING,g=Jg,B=Jg,t=gQ,Q=Vi,i=tB,C=BB,s=cI.DEFAULT_ANISOTROPY,o=BQ){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:BC++}),this.uuid=bg(),this.name="",this.source=new aQ(A),this.mipmaps=[],this.mapping=I,this.channel=0,this.wrapS=g,this.wrapT=B,this.magFilter=t,this.minFilter=Q,this.anisotropy=s,this.format=i,this.internalFormat=null,this.type=C,this.offset=new zA(0,0),this.repeat=new zA(1,1),this.center=new zA(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new hI,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=o,this.userData={},this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(A=null){this.source.data=A}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(A){return this.name=A.name,this.source=A.source,this.mipmaps=A.mipmaps.slice(0),this.mapping=A.mapping,this.channel=A.channel,this.wrapS=A.wrapS,this.wrapT=A.wrapT,this.magFilter=A.magFilter,this.minFilter=A.minFilter,this.anisotropy=A.anisotropy,this.format=A.format,this.internalFormat=A.internalFormat,this.type=A.type,this.offset.copy(A.offset),this.repeat.copy(A.repeat),this.center.copy(A.center),this.rotation=A.rotation,this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrix.copy(A.matrix),this.generateMipmaps=A.generateMipmaps,this.premultiplyAlpha=A.premultiplyAlpha,this.flipY=A.flipY,this.unpackAlignment=A.unpackAlignment,this.colorSpace=A.colorSpace,this.renderTarget=A.renderTarget,this.isRenderTargetTexture=A.isRenderTargetTexture,this.userData=JSON.parse(JSON.stringify(A.userData)),this.needsUpdate=!0,this}toJSON(A){const I=A===void 0||typeof A=="string";if(!I&&A.textures[this.uuid]!==void 0)return A.textures[this.uuid];const g={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(A).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(g.userData=this.userData),I||(A.textures[this.uuid]=g),g}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(A){if(this.mapping!==$t)return A;if(A.applyMatrix3(this.matrix),A.x<0||A.x>1)switch(this.wrapS){case AQ:A.x=A.x-Math.floor(A.x);break;case Jg:A.x=A.x<0?0:1;break;case IQ:Math.abs(Math.floor(A.x)%2)===1?A.x=Math.ceil(A.x)-A.x:A.x=A.x-Math.floor(A.x);break}if(A.y<0||A.y>1)switch(this.wrapT){case AQ:A.y=A.y-Math.floor(A.y);break;case Jg:A.y=A.y<0?0:1;break;case IQ:Math.abs(Math.floor(A.y)%2)===1?A.y=Math.ceil(A.y)-A.y:A.y=A.y-Math.floor(A.y);break}return this.flipY&&(A.y=1-A.y),A}set needsUpdate(A){A===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(A){A===!0&&this.pmremVersion++}}cI.DEFAULT_IMAGE=null,cI.DEFAULT_MAPPING=$t,cI.DEFAULT_ANISOTROPY=1;class qA{constructor(A=0,I=0,g=0,B=1){qA.prototype.isVector4=!0,this.x=A,this.y=I,this.z=g,this.w=B}get width(){return this.z}set width(A){this.z=A}get height(){return this.w}set height(A){this.w=A}set(A,I,g,B){return this.x=A,this.y=I,this.z=g,this.w=B,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this.w=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setW(A){return this.w=A,this}setComponent(A,I){switch(A){case 0:this.x=I;break;case 1:this.y=I;break;case 2:this.z=I;break;case 3:this.w=I;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this.w=A.w!==void 0?A.w:1,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this.w+=A.w,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this.w+=A,this}addVectors(A,I){return this.x=A.x+I.x,this.y=A.y+I.y,this.z=A.z+I.z,this.w=A.w+I.w,this}addScaledVector(A,I){return this.x+=A.x*I,this.y+=A.y*I,this.z+=A.z*I,this.w+=A.w*I,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this.w-=A.w,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this.w-=A,this}subVectors(A,I){return this.x=A.x-I.x,this.y=A.y-I.y,this.z=A.z-I.z,this.w=A.w-I.w,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this.w*=A.w,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this.w*=A,this}applyMatrix4(A){const I=this.x,g=this.y,B=this.z,t=this.w,Q=A.elements;return this.x=Q[0]*I+Q[4]*g+Q[8]*B+Q[12]*t,this.y=Q[1]*I+Q[5]*g+Q[9]*B+Q[13]*t,this.z=Q[2]*I+Q[6]*g+Q[10]*B+Q[14]*t,this.w=Q[3]*I+Q[7]*g+Q[11]*B+Q[15]*t,this}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this.w/=A.w,this}divideScalar(A){return this.multiplyScalar(1/A)}setAxisAngleFromQuaternion(A){this.w=2*Math.acos(A.w);const I=Math.sqrt(1-A.w*A.w);return I<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=A.x/I,this.y=A.y/I,this.z=A.z/I),this}setAxisAngleFromRotationMatrix(A){let I,g,B,t;const C=A.elements,s=C[0],o=C[4],e=C[8],a=C[1],n=C[5],r=C[9],D=C[2],l=C[6],y=C[10];if(Math.abs(o-a)<.01&&Math.abs(e-D)<.01&&Math.abs(r-l)<.01){if(Math.abs(o+a)<.1&&Math.abs(e+D)<.1&&Math.abs(r+l)<.1&&Math.abs(s+n+y-3)<.1)return this.set(1,0,0,0),this;I=Math.PI;const u=(s+1)/2,G=(n+1)/2,M=(y+1)/2,x=(o+a)/4,k=(e+D)/4,S=(r+l)/4;return u>G&&u>M?u<.01?(g=0,B=.707106781,t=.707106781):(g=Math.sqrt(u),B=x/g,t=k/g):G>M?G<.01?(g=.707106781,B=0,t=.707106781):(B=Math.sqrt(G),g=x/B,t=S/B):M<.01?(g=.707106781,B=.707106781,t=0):(t=Math.sqrt(M),g=k/t,B=S/t),this.set(g,B,t,I),this}let w=Math.sqrt((l-r)*(l-r)+(e-D)*(e-D)+(a-o)*(a-o));return Math.abs(w)<.001&&(w=1),this.x=(l-r)/w,this.y=(e-D)/w,this.z=(a-o)/w,this.w=Math.acos((s+n+y-1)/2),this}setFromMatrixPosition(A){const I=A.elements;return this.x=I[12],this.y=I[13],this.z=I[14],this.w=I[15],this}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this.w=Math.min(this.w,A.w),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this.w=Math.max(this.w,A.w),this}clamp(A,I){return this.x=$(this.x,A.x,I.x),this.y=$(this.y,A.y,I.y),this.z=$(this.z,A.z,I.z),this.w=$(this.w,A.w,I.w),this}clampScalar(A,I){return this.x=$(this.x,A,I),this.y=$(this.y,A,I),this.z=$(this.z,A,I),this.w=$(this.w,A,I),this}clampLength(A,I){const g=this.length();return this.divideScalar(g||1).multiplyScalar($(g,A,I))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z+this.w*A.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,I){return this.x+=(A.x-this.x)*I,this.y+=(A.y-this.y)*I,this.z+=(A.z-this.z)*I,this.w+=(A.w-this.w)*I,this}lerpVectors(A,I,g){return this.x=A.x+(I.x-A.x)*g,this.y=A.y+(I.y-A.y)*g,this.z=A.z+(I.z-A.z)*g,this.w=A.w+(I.w-A.w)*g,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z&&A.w===this.w}fromArray(A,I=0){return this.x=A[I],this.y=A[I+1],this.z=A[I+2],this.w=A[I+3],this}toArray(A=[],I=0){return A[I]=this.x,A[I+1]=this.y,A[I+2]=this.z,A[I+3]=this.w,A}fromBufferAttribute(A,I){return this.x=A.getX(I),this.y=A.getY(I),this.z=A.getZ(I),this.w=A.getW(I),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class tC extends Hg{constructor(A=1,I=1,g={}){super(),this.isRenderTarget=!0,this.width=A,this.height=I,this.depth=1,this.scissor=new qA(0,0,A,I),this.scissorTest=!1,this.viewport=new qA(0,0,A,I);const B={width:A,height:I,depth:1};g=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:gQ,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},g);const t=new cI(B,g.mapping,g.wrapS,g.wrapT,g.magFilter,g.minFilter,g.format,g.type,g.anisotropy,g.colorSpace);t.flipY=!1,t.generateMipmaps=g.generateMipmaps,t.internalFormat=g.internalFormat,this.textures=[];const Q=g.count;for(let i=0;i<Q;i++)this.textures[i]=t.clone(),this.textures[i].isRenderTargetTexture=!0,this.textures[i].renderTarget=this;this.depthBuffer=g.depthBuffer,this.stencilBuffer=g.stencilBuffer,this.resolveDepthBuffer=g.resolveDepthBuffer,this.resolveStencilBuffer=g.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=g.depthTexture,this.samples=g.samples}get texture(){return this.textures[0]}set texture(A){this.textures[0]=A}set depthTexture(A){this._depthTexture!==null&&(this._depthTexture.renderTarget=null),A!==null&&(A.renderTarget=this),this._depthTexture=A}get depthTexture(){return this._depthTexture}setSize(A,I,g=1){if(this.width!==A||this.height!==I||this.depth!==g){this.width=A,this.height=I,this.depth=g;for(let B=0,t=this.textures.length;B<t;B++)this.textures[B].image.width=A,this.textures[B].image.height=I,this.textures[B].image.depth=g;this.dispose()}this.viewport.set(0,0,A,I),this.scissor.set(0,0,A,I)}clone(){return new this.constructor().copy(this)}copy(A){this.width=A.width,this.height=A.height,this.depth=A.depth,this.scissor.copy(A.scissor),this.scissorTest=A.scissorTest,this.viewport.copy(A.viewport),this.textures.length=0;for(let g=0,B=A.textures.length;g<B;g++)this.textures[g]=A.textures[g].clone(),this.textures[g].isRenderTargetTexture=!0,this.textures[g].renderTarget=this;const I=Object.assign({},A.texture.image);return this.texture.source=new aQ(I),this.depthBuffer=A.depthBuffer,this.stencilBuffer=A.stencilBuffer,this.resolveDepthBuffer=A.resolveDepthBuffer,this.resolveStencilBuffer=A.resolveStencilBuffer,A.depthTexture!==null&&(this.depthTexture=A.depthTexture.clone()),this.samples=A.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class QC extends tC{constructor(A=1,I=1,g={}){super(A,I,g),this.isWebGLRenderTarget=!0}}class xI extends cI{constructor(A=null,I=1,g=1,B=1){super(null),this.isDataArrayTexture=!0,this.image={data:A,width:I,height:g,depth:B},this.magFilter=mI,this.minFilter=mI,this.wrapR=Jg,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(A){this.layerUpdates.add(A)}clearLayerUpdates(){this.layerUpdates.clear()}}class nQ extends QC{constructor(A=1,I=1,g=1,B={}){super(A,I,B),this.isWebGLArrayRenderTarget=!0,this.depth=g,this.texture=new xI(null,A,I,g),this.texture.isRenderTargetTexture=!0}}class uA{constructor(A=0,I=0,g=0,B=1){this.isQuaternion=!0,this._x=A,this._y=I,this._z=g,this._w=B}static slerpFlat(A,I,g,B,t,Q,i){let C=g[B+0],s=g[B+1],o=g[B+2],e=g[B+3];const a=t[Q+0],n=t[Q+1],r=t[Q+2],D=t[Q+3];if(i===0){A[I+0]=C,A[I+1]=s,A[I+2]=o,A[I+3]=e;return}if(i===1){A[I+0]=a,A[I+1]=n,A[I+2]=r,A[I+3]=D;return}if(e!==D||C!==a||s!==n||o!==r){let l=1-i;const y=C*a+s*n+o*r+e*D,w=y>=0?1:-1,u=1-y*y;if(u>Number.EPSILON){const M=Math.sqrt(u),x=Math.atan2(M,y*w);l=Math.sin(l*x)/M,i=Math.sin(i*x)/M}const G=i*w;if(C=C*l+a*G,s=s*l+n*G,o=o*l+r*G,e=e*l+D*G,l===1-i){const M=1/Math.sqrt(C*C+s*s+o*o+e*e);C*=M,s*=M,o*=M,e*=M}}A[I]=C,A[I+1]=s,A[I+2]=o,A[I+3]=e}static multiplyQuaternionsFlat(A,I,g,B,t,Q){const i=g[B],C=g[B+1],s=g[B+2],o=g[B+3],e=t[Q],a=t[Q+1],n=t[Q+2],r=t[Q+3];return A[I]=i*r+o*e+C*n-s*a,A[I+1]=C*r+o*a+s*e-i*n,A[I+2]=s*r+o*n+i*a-C*e,A[I+3]=o*r-i*e-C*a-s*n,A}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get w(){return this._w}set w(A){this._w=A,this._onChangeCallback()}set(A,I,g,B){return this._x=A,this._y=I,this._z=g,this._w=B,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(A){return this._x=A.x,this._y=A.y,this._z=A.z,this._w=A.w,this._onChangeCallback(),this}setFromEuler(A,I=!0){const g=A._x,B=A._y,t=A._z,Q=A._order,i=Math.cos,C=Math.sin,s=i(g/2),o=i(B/2),e=i(t/2),a=C(g/2),n=C(B/2),r=C(t/2);switch(Q){case"XYZ":this._x=a*o*e+s*n*r,this._y=s*n*e-a*o*r,this._z=s*o*r+a*n*e,this._w=s*o*e-a*n*r;break;case"YXZ":this._x=a*o*e+s*n*r,this._y=s*n*e-a*o*r,this._z=s*o*r-a*n*e,this._w=s*o*e+a*n*r;break;case"ZXY":this._x=a*o*e-s*n*r,this._y=s*n*e+a*o*r,this._z=s*o*r+a*n*e,this._w=s*o*e-a*n*r;break;case"ZYX":this._x=a*o*e-s*n*r,this._y=s*n*e+a*o*r,this._z=s*o*r-a*n*e,this._w=s*o*e+a*n*r;break;case"YZX":this._x=a*o*e+s*n*r,this._y=s*n*e+a*o*r,this._z=s*o*r-a*n*e,this._w=s*o*e-a*n*r;break;case"XZY":this._x=a*o*e-s*n*r,this._y=s*n*e-a*o*r,this._z=s*o*r+a*n*e,this._w=s*o*e+a*n*r;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+Q)}return I===!0&&this._onChangeCallback(),this}setFromAxisAngle(A,I){const g=I/2,B=Math.sin(g);return this._x=A.x*B,this._y=A.y*B,this._z=A.z*B,this._w=Math.cos(g),this._onChangeCallback(),this}setFromRotationMatrix(A){const I=A.elements,g=I[0],B=I[4],t=I[8],Q=I[1],i=I[5],C=I[9],s=I[2],o=I[6],e=I[10],a=g+i+e;if(a>0){const n=.5/Math.sqrt(a+1);this._w=.25/n,this._x=(o-C)*n,this._y=(t-s)*n,this._z=(Q-B)*n}else if(g>i&&g>e){const n=2*Math.sqrt(1+g-i-e);this._w=(o-C)/n,this._x=.25*n,this._y=(B+Q)/n,this._z=(t+s)/n}else if(i>e){const n=2*Math.sqrt(1+i-g-e);this._w=(t-s)/n,this._x=(B+Q)/n,this._y=.25*n,this._z=(C+o)/n}else{const n=2*Math.sqrt(1+e-g-i);this._w=(Q-B)/n,this._x=(t+s)/n,this._y=(C+o)/n,this._z=.25*n}return this._onChangeCallback(),this}setFromUnitVectors(A,I){let g=A.dot(I)+1;return g<Number.EPSILON?(g=0,Math.abs(A.x)>Math.abs(A.z)?(this._x=-A.y,this._y=A.x,this._z=0,this._w=g):(this._x=0,this._y=-A.z,this._z=A.y,this._w=g)):(this._x=A.y*I.z-A.z*I.y,this._y=A.z*I.x-A.x*I.z,this._z=A.x*I.y-A.y*I.x,this._w=g),this.normalize()}angleTo(A){return 2*Math.acos(Math.abs($(this.dot(A),-1,1)))}rotateTowards(A,I){const g=this.angleTo(A);if(g===0)return this;const B=Math.min(1,I/g);return this.slerp(A,B),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(A){return this._x*A._x+this._y*A._y+this._z*A._z+this._w*A._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let A=this.length();return A===0?(this._x=0,this._y=0,this._z=0,this._w=1):(A=1/A,this._x=this._x*A,this._y=this._y*A,this._z=this._z*A,this._w=this._w*A),this._onChangeCallback(),this}multiply(A){return this.multiplyQuaternions(this,A)}premultiply(A){return this.multiplyQuaternions(A,this)}multiplyQuaternions(A,I){const g=A._x,B=A._y,t=A._z,Q=A._w,i=I._x,C=I._y,s=I._z,o=I._w;return this._x=g*o+Q*i+B*s-t*C,this._y=B*o+Q*C+t*i-g*s,this._z=t*o+Q*s+g*C-B*i,this._w=Q*o-g*i-B*C-t*s,this._onChangeCallback(),this}slerp(A,I){if(I===0)return this;if(I===1)return this.copy(A);const g=this._x,B=this._y,t=this._z,Q=this._w;let i=Q*A._w+g*A._x+B*A._y+t*A._z;if(i<0?(this._w=-A._w,this._x=-A._x,this._y=-A._y,this._z=-A._z,i=-i):this.copy(A),i>=1)return this._w=Q,this._x=g,this._y=B,this._z=t,this;const C=1-i*i;if(C<=Number.EPSILON){const n=1-I;return this._w=n*Q+I*this._w,this._x=n*g+I*this._x,this._y=n*B+I*this._y,this._z=n*t+I*this._z,this.normalize(),this}const s=Math.sqrt(C),o=Math.atan2(s,i),e=Math.sin((1-I)*o)/s,a=Math.sin(I*o)/s;return this._w=Q*e+this._w*a,this._x=g*e+this._x*a,this._y=B*e+this._y*a,this._z=t*e+this._z*a,this._onChangeCallback(),this}slerpQuaternions(A,I,g){return this.copy(A).slerp(I,g)}random(){const A=2*Math.PI*Math.random(),I=2*Math.PI*Math.random(),g=Math.random(),B=Math.sqrt(1-g),t=Math.sqrt(g);return this.set(B*Math.sin(A),B*Math.cos(A),t*Math.sin(I),t*Math.cos(I))}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._w===this._w}fromArray(A,I=0){return this._x=A[I],this._y=A[I+1],this._z=A[I+2],this._w=A[I+3],this._onChangeCallback(),this}toArray(A=[],I=0){return A[I]=this._x,A[I+1]=this._y,A[I+2]=this._z,A[I+3]=this._w,A}fromBufferAttribute(A,I){return this._x=A.getX(I),this._y=A.getY(I),this._z=A.getZ(I),this._w=A.getW(I),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class f{constructor(A=0,I=0,g=0){f.prototype.isVector3=!0,this.x=A,this.y=I,this.z=g}set(A,I,g){return g===void 0&&(g=this.z),this.x=A,this.y=I,this.z=g,this}setScalar(A){return this.x=A,this.y=A,this.z=A,this}setX(A){return this.x=A,this}setY(A){return this.y=A,this}setZ(A){return this.z=A,this}setComponent(A,I){switch(A){case 0:this.x=I;break;case 1:this.y=I;break;case 2:this.z=I;break;default:throw new Error("index is out of range: "+A)}return this}getComponent(A){switch(A){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+A)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(A){return this.x=A.x,this.y=A.y,this.z=A.z,this}add(A){return this.x+=A.x,this.y+=A.y,this.z+=A.z,this}addScalar(A){return this.x+=A,this.y+=A,this.z+=A,this}addVectors(A,I){return this.x=A.x+I.x,this.y=A.y+I.y,this.z=A.z+I.z,this}addScaledVector(A,I){return this.x+=A.x*I,this.y+=A.y*I,this.z+=A.z*I,this}sub(A){return this.x-=A.x,this.y-=A.y,this.z-=A.z,this}subScalar(A){return this.x-=A,this.y-=A,this.z-=A,this}subVectors(A,I){return this.x=A.x-I.x,this.y=A.y-I.y,this.z=A.z-I.z,this}multiply(A){return this.x*=A.x,this.y*=A.y,this.z*=A.z,this}multiplyScalar(A){return this.x*=A,this.y*=A,this.z*=A,this}multiplyVectors(A,I){return this.x=A.x*I.x,this.y=A.y*I.y,this.z=A.z*I.z,this}applyEuler(A){return this.applyQuaternion(rQ.setFromEuler(A))}applyAxisAngle(A,I){return this.applyQuaternion(rQ.setFromAxisAngle(A,I))}applyMatrix3(A){const I=this.x,g=this.y,B=this.z,t=A.elements;return this.x=t[0]*I+t[3]*g+t[6]*B,this.y=t[1]*I+t[4]*g+t[7]*B,this.z=t[2]*I+t[5]*g+t[8]*B,this}applyNormalMatrix(A){return this.applyMatrix3(A).normalize()}applyMatrix4(A){const I=this.x,g=this.y,B=this.z,t=A.elements,Q=1/(t[3]*I+t[7]*g+t[11]*B+t[15]);return this.x=(t[0]*I+t[4]*g+t[8]*B+t[12])*Q,this.y=(t[1]*I+t[5]*g+t[9]*B+t[13])*Q,this.z=(t[2]*I+t[6]*g+t[10]*B+t[14])*Q,this}applyQuaternion(A){const I=this.x,g=this.y,B=this.z,t=A.x,Q=A.y,i=A.z,C=A.w,s=2*(Q*B-i*g),o=2*(i*I-t*B),e=2*(t*g-Q*I);return this.x=I+C*s+Q*e-i*o,this.y=g+C*o+i*s-t*e,this.z=B+C*e+t*o-Q*s,this}project(A){return this.applyMatrix4(A.matrixWorldInverse).applyMatrix4(A.projectionMatrix)}unproject(A){return this.applyMatrix4(A.projectionMatrixInverse).applyMatrix4(A.matrixWorld)}transformDirection(A){const I=this.x,g=this.y,B=this.z,t=A.elements;return this.x=t[0]*I+t[4]*g+t[8]*B,this.y=t[1]*I+t[5]*g+t[9]*B,this.z=t[2]*I+t[6]*g+t[10]*B,this.normalize()}divide(A){return this.x/=A.x,this.y/=A.y,this.z/=A.z,this}divideScalar(A){return this.multiplyScalar(1/A)}min(A){return this.x=Math.min(this.x,A.x),this.y=Math.min(this.y,A.y),this.z=Math.min(this.z,A.z),this}max(A){return this.x=Math.max(this.x,A.x),this.y=Math.max(this.y,A.y),this.z=Math.max(this.z,A.z),this}clamp(A,I){return this.x=$(this.x,A.x,I.x),this.y=$(this.y,A.y,I.y),this.z=$(this.z,A.z,I.z),this}clampScalar(A,I){return this.x=$(this.x,A,I),this.y=$(this.y,A,I),this.z=$(this.z,A,I),this}clampLength(A,I){const g=this.length();return this.divideScalar(g||1).multiplyScalar($(g,A,I))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(A){return this.x*A.x+this.y*A.y+this.z*A.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(A){return this.normalize().multiplyScalar(A)}lerp(A,I){return this.x+=(A.x-this.x)*I,this.y+=(A.y-this.y)*I,this.z+=(A.z-this.z)*I,this}lerpVectors(A,I,g){return this.x=A.x+(I.x-A.x)*g,this.y=A.y+(I.y-A.y)*g,this.z=A.z+(I.z-A.z)*g,this}cross(A){return this.crossVectors(this,A)}crossVectors(A,I){const g=A.x,B=A.y,t=A.z,Q=I.x,i=I.y,C=I.z;return this.x=B*C-t*i,this.y=t*Q-g*C,this.z=g*i-B*Q,this}projectOnVector(A){const I=A.lengthSq();if(I===0)return this.set(0,0,0);const g=A.dot(this)/I;return this.copy(A).multiplyScalar(g)}projectOnPlane(A){return gt.copy(this).projectOnVector(A),this.sub(gt)}reflect(A){return this.sub(gt.copy(A).multiplyScalar(2*this.dot(A)))}angleTo(A){const I=Math.sqrt(this.lengthSq()*A.lengthSq());if(I===0)return Math.PI/2;const g=this.dot(A)/I;return Math.acos($(g,-1,1))}distanceTo(A){return Math.sqrt(this.distanceToSquared(A))}distanceToSquared(A){const I=this.x-A.x,g=this.y-A.y,B=this.z-A.z;return I*I+g*g+B*B}manhattanDistanceTo(A){return Math.abs(this.x-A.x)+Math.abs(this.y-A.y)+Math.abs(this.z-A.z)}setFromSpherical(A){return this.setFromSphericalCoords(A.radius,A.phi,A.theta)}setFromSphericalCoords(A,I,g){const B=Math.sin(I)*A;return this.x=B*Math.sin(g),this.y=Math.cos(I)*A,this.z=B*Math.cos(g),this}setFromCylindrical(A){return this.setFromCylindricalCoords(A.radius,A.theta,A.y)}setFromCylindricalCoords(A,I,g){return this.x=A*Math.sin(I),this.y=g,this.z=A*Math.cos(I),this}setFromMatrixPosition(A){const I=A.elements;return this.x=I[12],this.y=I[13],this.z=I[14],this}setFromMatrixScale(A){const I=this.setFromMatrixColumn(A,0).length(),g=this.setFromMatrixColumn(A,1).length(),B=this.setFromMatrixColumn(A,2).length();return this.x=I,this.y=g,this.z=B,this}setFromMatrixColumn(A,I){return this.fromArray(A.elements,I*4)}setFromMatrix3Column(A,I){return this.fromArray(A.elements,I*3)}setFromEuler(A){return this.x=A._x,this.y=A._y,this.z=A._z,this}setFromColor(A){return this.x=A.r,this.y=A.g,this.z=A.b,this}equals(A){return A.x===this.x&&A.y===this.y&&A.z===this.z}fromArray(A,I=0){return this.x=A[I],this.y=A[I+1],this.z=A[I+2],this}toArray(A=[],I=0){return A[I]=this.x,A[I+1]=this.y,A[I+2]=this.z,A}fromBufferAttribute(A,I){return this.x=A.getX(I),this.y=A.getY(I),this.z=A.getZ(I),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const A=Math.random()*Math.PI*2,I=Math.random()*2-1,g=Math.sqrt(1-I*I);return this.x=g*Math.cos(A),this.y=I,this.z=g*Math.sin(A),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const gt=new f,rQ=new uA;class ig{constructor(A=new f(1/0,1/0,1/0),I=new f(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=A,this.max=I}set(A,I){return this.min.copy(A),this.max.copy(I),this}setFromArray(A){this.makeEmpty();for(let I=0,g=A.length;I<g;I+=3)this.expandByPoint(CI.fromArray(A,I));return this}setFromBufferAttribute(A){this.makeEmpty();for(let I=0,g=A.count;I<g;I++)this.expandByPoint(CI.fromBufferAttribute(A,I));return this}setFromPoints(A){this.makeEmpty();for(let I=0,g=A.length;I<g;I++)this.expandByPoint(A[I]);return this}setFromCenterAndSize(A,I){const g=CI.copy(I).multiplyScalar(.5);return this.min.copy(A).sub(g),this.max.copy(A).add(g),this}setFromObject(A,I=!1){return this.makeEmpty(),this.expandByObject(A,I)}clone(){return new this.constructor().copy(this)}copy(A){return this.min.copy(A.min),this.max.copy(A.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(A){return this.isEmpty()?A.set(0,0,0):A.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(A){return this.isEmpty()?A.set(0,0,0):A.subVectors(this.max,this.min)}expandByPoint(A){return this.min.min(A),this.max.max(A),this}expandByVector(A){return this.min.sub(A),this.max.add(A),this}expandByScalar(A){return this.min.addScalar(-A),this.max.addScalar(A),this}expandByObject(A,I=!1){A.updateWorldMatrix(!1,!1);const g=A.geometry;if(g!==void 0){const t=g.getAttribute("position");if(I===!0&&t!==void 0&&A.isInstancedMesh!==!0)for(let Q=0,i=t.count;Q<i;Q++)A.isMesh===!0?A.getVertexPosition(Q,CI):CI.fromBufferAttribute(t,Q),CI.applyMatrix4(A.matrixWorld),this.expandByPoint(CI);else A.boundingBox!==void 0?(A.boundingBox===null&&A.computeBoundingBox(),QB.copy(A.boundingBox)):(g.boundingBox===null&&g.computeBoundingBox(),QB.copy(g.boundingBox)),QB.applyMatrix4(A.matrixWorld),this.union(QB)}const B=A.children;for(let t=0,Q=B.length;t<Q;t++)this.expandByObject(B[t],I);return this}containsPoint(A){return A.x>=this.min.x&&A.x<=this.max.x&&A.y>=this.min.y&&A.y<=this.max.y&&A.z>=this.min.z&&A.z<=this.max.z}containsBox(A){return this.min.x<=A.min.x&&A.max.x<=this.max.x&&this.min.y<=A.min.y&&A.max.y<=this.max.y&&this.min.z<=A.min.z&&A.max.z<=this.max.z}getParameter(A,I){return I.set((A.x-this.min.x)/(this.max.x-this.min.x),(A.y-this.min.y)/(this.max.y-this.min.y),(A.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(A){return A.max.x>=this.min.x&&A.min.x<=this.max.x&&A.max.y>=this.min.y&&A.min.y<=this.max.y&&A.max.z>=this.min.z&&A.min.z<=this.max.z}intersectsSphere(A){return this.clampPoint(A.center,CI),CI.distanceToSquared(A.center)<=A.radius*A.radius}intersectsPlane(A){let I,g;return A.normal.x>0?(I=A.normal.x*this.min.x,g=A.normal.x*this.max.x):(I=A.normal.x*this.max.x,g=A.normal.x*this.min.x),A.normal.y>0?(I+=A.normal.y*this.min.y,g+=A.normal.y*this.max.y):(I+=A.normal.y*this.max.y,g+=A.normal.y*this.min.y),A.normal.z>0?(I+=A.normal.z*this.min.z,g+=A.normal.z*this.max.z):(I+=A.normal.z*this.max.z,g+=A.normal.z*this.min.z),I<=-A.constant&&g>=-A.constant}intersectsTriangle(A){if(this.isEmpty())return!1;this.getCenter(qg),iB.subVectors(this.max,qg),Cg.subVectors(A.a,qg),Eg.subVectors(A.b,qg),sg.subVectors(A.c,qg),UI.subVectors(Eg,Cg),YI.subVectors(sg,Eg),vI.subVectors(Cg,sg);let I=[0,-UI.z,UI.y,0,-YI.z,YI.y,0,-vI.z,vI.y,UI.z,0,-UI.x,YI.z,0,-YI.x,vI.z,0,-vI.x,-UI.y,UI.x,0,-YI.y,YI.x,0,-vI.y,vI.x,0];return!Bt(I,Cg,Eg,sg,iB)||(I=[1,0,0,0,1,0,0,0,1],!Bt(I,Cg,Eg,sg,iB))?!1:(CB.crossVectors(UI,YI),I=[CB.x,CB.y,CB.z],Bt(I,Cg,Eg,sg,iB))}clampPoint(A,I){return I.copy(A).clamp(this.min,this.max)}distanceToPoint(A){return this.clampPoint(A,CI).distanceTo(A)}getBoundingSphere(A){return this.isEmpty()?A.makeEmpty():(this.getCenter(A.center),A.radius=this.getSize(CI).length()*.5),A}intersect(A){return this.min.max(A.min),this.max.min(A.max),this.isEmpty()&&this.makeEmpty(),this}union(A){return this.min.min(A.min),this.max.max(A.max),this}applyMatrix4(A){return this.isEmpty()?this:(yI[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(A),yI[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(A),yI[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(A),yI[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(A),yI[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(A),yI[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(A),yI[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(A),yI[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(A),this.setFromPoints(yI),this)}translate(A){return this.min.add(A),this.max.add(A),this}equals(A){return A.min.equals(this.min)&&A.max.equals(this.max)}}const yI=[new f,new f,new f,new f,new f,new f,new f,new f],CI=new f,QB=new ig,Cg=new f,Eg=new f,sg=new f,UI=new f,YI=new f,vI=new f,qg=new f,iB=new f,CB=new f,OI=new f;function Bt(E,A,I,g,B){for(let t=0,Q=E.length-3;t<=Q;t+=3){OI.fromArray(E,t);const i=B.x*Math.abs(OI.x)+B.y*Math.abs(OI.y)+B.z*Math.abs(OI.z),C=A.dot(OI),s=I.dot(OI),o=g.dot(OI);if(Math.max(-Math.max(C,s,o),Math.min(C,s,o))>i)return!1}return!0}const iC=new ig,Tg=new f,tt=new f;class hQ{constructor(A=new f,I=-1){this.isSphere=!0,this.center=A,this.radius=I}set(A,I){return this.center.copy(A),this.radius=I,this}setFromPoints(A,I){const g=this.center;I!==void 0?g.copy(I):iC.setFromPoints(A).getCenter(g);let B=0;for(let t=0,Q=A.length;t<Q;t++)B=Math.max(B,g.distanceToSquared(A[t]));return this.radius=Math.sqrt(B),this}copy(A){return this.center.copy(A.center),this.radius=A.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(A){return A.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(A){return A.distanceTo(this.center)-this.radius}intersectsSphere(A){const I=this.radius+A.radius;return A.center.distanceToSquared(this.center)<=I*I}intersectsBox(A){return A.intersectsSphere(this)}intersectsPlane(A){return Math.abs(A.distanceToPoint(this.center))<=this.radius}clampPoint(A,I){const g=this.center.distanceToSquared(A);return I.copy(A),g>this.radius*this.radius&&(I.sub(this.center).normalize(),I.multiplyScalar(this.radius).add(this.center)),I}getBoundingBox(A){return this.isEmpty()?(A.makeEmpty(),A):(A.set(this.center,this.center),A.expandByScalar(this.radius),A)}applyMatrix4(A){return this.center.applyMatrix4(A),this.radius=this.radius*A.getMaxScaleOnAxis(),this}translate(A){return this.center.add(A),this}expandByPoint(A){if(this.isEmpty())return this.center.copy(A),this.radius=0,this;Tg.subVectors(A,this.center);const I=Tg.lengthSq();if(I>this.radius*this.radius){const g=Math.sqrt(I),B=(g-this.radius)*.5;this.center.addScaledVector(Tg,B/g),this.radius+=B}return this}union(A){return A.isEmpty()?this:this.isEmpty()?(this.copy(A),this):(this.center.equals(A.center)===!0?this.radius=Math.max(this.radius,A.radius):(tt.subVectors(A.center,this.center).setLength(A.radius),this.expandByPoint(Tg.copy(A.center).add(tt)),this.expandByPoint(Tg.copy(A.center).sub(tt))),this)}equals(A){return A.center.equals(this.center)&&A.radius===this.radius}clone(){return new this.constructor().copy(this)}}const dI=new f,Qt=new f,EB=new f,JI=new f,it=new f,sB=new f,Ct=new f;class CC{constructor(A=new f,I=new f(0,0,-1)){this.origin=A,this.direction=I}set(A,I){return this.origin.copy(A),this.direction.copy(I),this}copy(A){return this.origin.copy(A.origin),this.direction.copy(A.direction),this}at(A,I){return I.copy(this.origin).addScaledVector(this.direction,A)}lookAt(A){return this.direction.copy(A).sub(this.origin).normalize(),this}recast(A){return this.origin.copy(this.at(A,dI)),this}closestPointToPoint(A,I){I.subVectors(A,this.origin);const g=I.dot(this.direction);return g<0?I.copy(this.origin):I.copy(this.origin).addScaledVector(this.direction,g)}distanceToPoint(A){return Math.sqrt(this.distanceSqToPoint(A))}distanceSqToPoint(A){const I=dI.subVectors(A,this.origin).dot(this.direction);return I<0?this.origin.distanceToSquared(A):(dI.copy(this.origin).addScaledVector(this.direction,I),dI.distanceToSquared(A))}distanceSqToSegment(A,I,g,B){Qt.copy(A).add(I).multiplyScalar(.5),EB.copy(I).sub(A).normalize(),JI.copy(this.origin).sub(Qt);const t=A.distanceTo(I)*.5,Q=-this.direction.dot(EB),i=JI.dot(this.direction),C=-JI.dot(EB),s=JI.lengthSq(),o=Math.abs(1-Q*Q);let e,a,n,r;if(o>0)if(e=Q*C-i,a=Q*i-C,r=t*o,e>=0)if(a>=-r)if(a<=r){const D=1/o;e*=D,a*=D,n=e*(e+Q*a+2*i)+a*(Q*e+a+2*C)+s}else a=t,e=Math.max(0,-(Q*a+i)),n=-e*e+a*(a+2*C)+s;else a=-t,e=Math.max(0,-(Q*a+i)),n=-e*e+a*(a+2*C)+s;else a<=-r?(e=Math.max(0,-(-Q*t+i)),a=e>0?-t:Math.min(Math.max(-t,-C),t),n=-e*e+a*(a+2*C)+s):a<=r?(e=0,a=Math.min(Math.max(-t,-C),t),n=a*(a+2*C)+s):(e=Math.max(0,-(Q*t+i)),a=e>0?t:Math.min(Math.max(-t,-C),t),n=-e*e+a*(a+2*C)+s);else a=Q>0?-t:t,e=Math.max(0,-(Q*a+i)),n=-e*e+a*(a+2*C)+s;return g&&g.copy(this.origin).addScaledVector(this.direction,e),B&&B.copy(Qt).addScaledVector(EB,a),n}intersectSphere(A,I){dI.subVectors(A.center,this.origin);const g=dI.dot(this.direction),B=dI.dot(dI)-g*g,t=A.radius*A.radius;if(B>t)return null;const Q=Math.sqrt(t-B),i=g-Q,C=g+Q;return C<0?null:i<0?this.at(C,I):this.at(i,I)}intersectsSphere(A){return this.distanceSqToPoint(A.center)<=A.radius*A.radius}distanceToPlane(A){const I=A.normal.dot(this.direction);if(I===0)return A.distanceToPoint(this.origin)===0?0:null;const g=-(this.origin.dot(A.normal)+A.constant)/I;return g>=0?g:null}intersectPlane(A,I){const g=this.distanceToPlane(A);return g===null?null:this.at(g,I)}intersectsPlane(A){const I=A.distanceToPoint(this.origin);return I===0||A.normal.dot(this.direction)*I<0}intersectBox(A,I){let g,B,t,Q,i,C;const s=1/this.direction.x,o=1/this.direction.y,e=1/this.direction.z,a=this.origin;return s>=0?(g=(A.min.x-a.x)*s,B=(A.max.x-a.x)*s):(g=(A.max.x-a.x)*s,B=(A.min.x-a.x)*s),o>=0?(t=(A.min.y-a.y)*o,Q=(A.max.y-a.y)*o):(t=(A.max.y-a.y)*o,Q=(A.min.y-a.y)*o),g>Q||t>B||((t>g||isNaN(g))&&(g=t),(Q<B||isNaN(B))&&(B=Q),e>=0?(i=(A.min.z-a.z)*e,C=(A.max.z-a.z)*e):(i=(A.max.z-a.z)*e,C=(A.min.z-a.z)*e),g>C||i>B)||((i>g||g!==g)&&(g=i),(C<B||B!==B)&&(B=C),B<0)?null:this.at(g>=0?g:B,I)}intersectsBox(A){return this.intersectBox(A,dI)!==null}intersectTriangle(A,I,g,B,t){it.subVectors(I,A),sB.subVectors(g,A),Ct.crossVectors(it,sB);let Q=this.direction.dot(Ct),i;if(Q>0){if(B)return null;i=1}else if(Q<0)i=-1,Q=-Q;else return null;JI.subVectors(this.origin,A);const C=i*this.direction.dot(sB.crossVectors(JI,sB));if(C<0)return null;const s=i*this.direction.dot(it.cross(JI));if(s<0||C+s>Q)return null;const o=-i*JI.dot(Ct);return o<0?null:this.at(o/Q,t)}applyMatrix4(A){return this.origin.applyMatrix4(A),this.direction.transformDirection(A),this}equals(A){return A.origin.equals(this.origin)&&A.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class LA{constructor(A,I,g,B,t,Q,i,C,s,o,e,a,n,r,D,l){LA.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],A!==void 0&&this.set(A,I,g,B,t,Q,i,C,s,o,e,a,n,r,D,l)}set(A,I,g,B,t,Q,i,C,s,o,e,a,n,r,D,l){const y=this.elements;return y[0]=A,y[4]=I,y[8]=g,y[12]=B,y[1]=t,y[5]=Q,y[9]=i,y[13]=C,y[2]=s,y[6]=o,y[10]=e,y[14]=a,y[3]=n,y[7]=r,y[11]=D,y[15]=l,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new LA().fromArray(this.elements)}copy(A){const I=this.elements,g=A.elements;return I[0]=g[0],I[1]=g[1],I[2]=g[2],I[3]=g[3],I[4]=g[4],I[5]=g[5],I[6]=g[6],I[7]=g[7],I[8]=g[8],I[9]=g[9],I[10]=g[10],I[11]=g[11],I[12]=g[12],I[13]=g[13],I[14]=g[14],I[15]=g[15],this}copyPosition(A){const I=this.elements,g=A.elements;return I[12]=g[12],I[13]=g[13],I[14]=g[14],this}setFromMatrix3(A){const I=A.elements;return this.set(I[0],I[3],I[6],0,I[1],I[4],I[7],0,I[2],I[5],I[8],0,0,0,0,1),this}extractBasis(A,I,g){return A.setFromMatrixColumn(this,0),I.setFromMatrixColumn(this,1),g.setFromMatrixColumn(this,2),this}makeBasis(A,I,g){return this.set(A.x,I.x,g.x,0,A.y,I.y,g.y,0,A.z,I.z,g.z,0,0,0,0,1),this}extractRotation(A){const I=this.elements,g=A.elements,B=1/eg.setFromMatrixColumn(A,0).length(),t=1/eg.setFromMatrixColumn(A,1).length(),Q=1/eg.setFromMatrixColumn(A,2).length();return I[0]=g[0]*B,I[1]=g[1]*B,I[2]=g[2]*B,I[3]=0,I[4]=g[4]*t,I[5]=g[5]*t,I[6]=g[6]*t,I[7]=0,I[8]=g[8]*Q,I[9]=g[9]*Q,I[10]=g[10]*Q,I[11]=0,I[12]=0,I[13]=0,I[14]=0,I[15]=1,this}makeRotationFromEuler(A){const I=this.elements,g=A.x,B=A.y,t=A.z,Q=Math.cos(g),i=Math.sin(g),C=Math.cos(B),s=Math.sin(B),o=Math.cos(t),e=Math.sin(t);if(A.order==="XYZ"){const a=Q*o,n=Q*e,r=i*o,D=i*e;I[0]=C*o,I[4]=-C*e,I[8]=s,I[1]=n+r*s,I[5]=a-D*s,I[9]=-i*C,I[2]=D-a*s,I[6]=r+n*s,I[10]=Q*C}else if(A.order==="YXZ"){const a=C*o,n=C*e,r=s*o,D=s*e;I[0]=a+D*i,I[4]=r*i-n,I[8]=Q*s,I[1]=Q*e,I[5]=Q*o,I[9]=-i,I[2]=n*i-r,I[6]=D+a*i,I[10]=Q*C}else if(A.order==="ZXY"){const a=C*o,n=C*e,r=s*o,D=s*e;I[0]=a-D*i,I[4]=-Q*e,I[8]=r+n*i,I[1]=n+r*i,I[5]=Q*o,I[9]=D-a*i,I[2]=-Q*s,I[6]=i,I[10]=Q*C}else if(A.order==="ZYX"){const a=Q*o,n=Q*e,r=i*o,D=i*e;I[0]=C*o,I[4]=r*s-n,I[8]=a*s+D,I[1]=C*e,I[5]=D*s+a,I[9]=n*s-r,I[2]=-s,I[6]=i*C,I[10]=Q*C}else if(A.order==="YZX"){const a=Q*C,n=Q*s,r=i*C,D=i*s;I[0]=C*o,I[4]=D-a*e,I[8]=r*e+n,I[1]=e,I[5]=Q*o,I[9]=-i*o,I[2]=-s*o,I[6]=n*e+r,I[10]=a-D*e}else if(A.order==="XZY"){const a=Q*C,n=Q*s,r=i*C,D=i*s;I[0]=C*o,I[4]=-e,I[8]=s*o,I[1]=a*e+D,I[5]=Q*o,I[9]=n*e-r,I[2]=r*e-n,I[6]=i*o,I[10]=D*e+a}return I[3]=0,I[7]=0,I[11]=0,I[12]=0,I[13]=0,I[14]=0,I[15]=1,this}makeRotationFromQuaternion(A){return this.compose(EC,A,sC)}lookAt(A,I,g){const B=this.elements;return XA.subVectors(A,I),XA.lengthSq()===0&&(XA.z=1),XA.normalize(),LI.crossVectors(g,XA),LI.lengthSq()===0&&(Math.abs(g.z)===1?XA.x+=1e-4:XA.z+=1e-4,XA.normalize(),LI.crossVectors(g,XA)),LI.normalize(),eB.crossVectors(XA,LI),B[0]=LI.x,B[4]=eB.x,B[8]=XA.x,B[1]=LI.y,B[5]=eB.y,B[9]=XA.y,B[2]=LI.z,B[6]=eB.z,B[10]=XA.z,this}multiply(A){return this.multiplyMatrices(this,A)}premultiply(A){return this.multiplyMatrices(A,this)}multiplyMatrices(A,I){const g=A.elements,B=I.elements,t=this.elements,Q=g[0],i=g[4],C=g[8],s=g[12],o=g[1],e=g[5],a=g[9],n=g[13],r=g[2],D=g[6],l=g[10],y=g[14],w=g[3],u=g[7],G=g[11],M=g[15],x=B[0],k=B[4],S=B[8],N=B[12],H=B[1],U=B[5],m=B[9],J=B[13],K=B[2],z=B[6],T=B[10],W=B[14],BA=B[3],AA=B[7],CA=B[11],QA=B[15];return t[0]=Q*x+i*H+C*K+s*BA,t[4]=Q*k+i*U+C*z+s*AA,t[8]=Q*S+i*m+C*T+s*CA,t[12]=Q*N+i*J+C*W+s*QA,t[1]=o*x+e*H+a*K+n*BA,t[5]=o*k+e*U+a*z+n*AA,t[9]=o*S+e*m+a*T+n*CA,t[13]=o*N+e*J+a*W+n*QA,t[2]=r*x+D*H+l*K+y*BA,t[6]=r*k+D*U+l*z+y*AA,t[10]=r*S+D*m+l*T+y*CA,t[14]=r*N+D*J+l*W+y*QA,t[3]=w*x+u*H+G*K+M*BA,t[7]=w*k+u*U+G*z+M*AA,t[11]=w*S+u*m+G*T+M*CA,t[15]=w*N+u*J+G*W+M*QA,this}multiplyScalar(A){const I=this.elements;return I[0]*=A,I[4]*=A,I[8]*=A,I[12]*=A,I[1]*=A,I[5]*=A,I[9]*=A,I[13]*=A,I[2]*=A,I[6]*=A,I[10]*=A,I[14]*=A,I[3]*=A,I[7]*=A,I[11]*=A,I[15]*=A,this}determinant(){const A=this.elements,I=A[0],g=A[4],B=A[8],t=A[12],Q=A[1],i=A[5],C=A[9],s=A[13],o=A[2],e=A[6],a=A[10],n=A[14],r=A[3],D=A[7],l=A[11],y=A[15];return r*(+t*C*e-B*s*e-t*i*a+g*s*a+B*i*n-g*C*n)+D*(+I*C*n-I*s*a+t*Q*a-B*Q*n+B*s*o-t*C*o)+l*(+I*s*e-I*i*n-t*Q*e+g*Q*n+t*i*o-g*s*o)+y*(-B*i*o-I*C*e+I*i*a+B*Q*e-g*Q*a+g*C*o)}transpose(){const A=this.elements;let I;return I=A[1],A[1]=A[4],A[4]=I,I=A[2],A[2]=A[8],A[8]=I,I=A[6],A[6]=A[9],A[9]=I,I=A[3],A[3]=A[12],A[12]=I,I=A[7],A[7]=A[13],A[13]=I,I=A[11],A[11]=A[14],A[14]=I,this}setPosition(A,I,g){const B=this.elements;return A.isVector3?(B[12]=A.x,B[13]=A.y,B[14]=A.z):(B[12]=A,B[13]=I,B[14]=g),this}invert(){const A=this.elements,I=A[0],g=A[1],B=A[2],t=A[3],Q=A[4],i=A[5],C=A[6],s=A[7],o=A[8],e=A[9],a=A[10],n=A[11],r=A[12],D=A[13],l=A[14],y=A[15],w=e*l*s-D*a*s+D*C*n-i*l*n-e*C*y+i*a*y,u=r*a*s-o*l*s-r*C*n+Q*l*n+o*C*y-Q*a*y,G=o*D*s-r*e*s+r*i*n-Q*D*n-o*i*y+Q*e*y,M=r*e*C-o*D*C-r*i*a+Q*D*a+o*i*l-Q*e*l,x=I*w+g*u+B*G+t*M;if(x===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const k=1/x;return A[0]=w*k,A[1]=(D*a*t-e*l*t-D*B*n+g*l*n+e*B*y-g*a*y)*k,A[2]=(i*l*t-D*C*t+D*B*s-g*l*s-i*B*y+g*C*y)*k,A[3]=(e*C*t-i*a*t-e*B*s+g*a*s+i*B*n-g*C*n)*k,A[4]=u*k,A[5]=(o*l*t-r*a*t+r*B*n-I*l*n-o*B*y+I*a*y)*k,A[6]=(r*C*t-Q*l*t-r*B*s+I*l*s+Q*B*y-I*C*y)*k,A[7]=(Q*a*t-o*C*t+o*B*s-I*a*s-Q*B*n+I*C*n)*k,A[8]=G*k,A[9]=(r*e*t-o*D*t-r*g*n+I*D*n+o*g*y-I*e*y)*k,A[10]=(Q*D*t-r*i*t+r*g*s-I*D*s-Q*g*y+I*i*y)*k,A[11]=(o*i*t-Q*e*t-o*g*s+I*e*s+Q*g*n-I*i*n)*k,A[12]=M*k,A[13]=(o*D*B-r*e*B+r*g*a-I*D*a-o*g*l+I*e*l)*k,A[14]=(r*i*B-Q*D*B-r*g*C+I*D*C+Q*g*l-I*i*l)*k,A[15]=(Q*e*B-o*i*B+o*g*C-I*e*C-Q*g*a+I*i*a)*k,this}scale(A){const I=this.elements,g=A.x,B=A.y,t=A.z;return I[0]*=g,I[4]*=B,I[8]*=t,I[1]*=g,I[5]*=B,I[9]*=t,I[2]*=g,I[6]*=B,I[10]*=t,I[3]*=g,I[7]*=B,I[11]*=t,this}getMaxScaleOnAxis(){const A=this.elements,I=A[0]*A[0]+A[1]*A[1]+A[2]*A[2],g=A[4]*A[4]+A[5]*A[5]+A[6]*A[6],B=A[8]*A[8]+A[9]*A[9]+A[10]*A[10];return Math.sqrt(Math.max(I,g,B))}makeTranslation(A,I,g){return A.isVector3?this.set(1,0,0,A.x,0,1,0,A.y,0,0,1,A.z,0,0,0,1):this.set(1,0,0,A,0,1,0,I,0,0,1,g,0,0,0,1),this}makeRotationX(A){const I=Math.cos(A),g=Math.sin(A);return this.set(1,0,0,0,0,I,-g,0,0,g,I,0,0,0,0,1),this}makeRotationY(A){const I=Math.cos(A),g=Math.sin(A);return this.set(I,0,g,0,0,1,0,0,-g,0,I,0,0,0,0,1),this}makeRotationZ(A){const I=Math.cos(A),g=Math.sin(A);return this.set(I,-g,0,0,g,I,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(A,I){const g=Math.cos(I),B=Math.sin(I),t=1-g,Q=A.x,i=A.y,C=A.z,s=t*Q,o=t*i;return this.set(s*Q+g,s*i-B*C,s*C+B*i,0,s*i+B*C,o*i+g,o*C-B*Q,0,s*C-B*i,o*C+B*Q,t*C*C+g,0,0,0,0,1),this}makeScale(A,I,g){return this.set(A,0,0,0,0,I,0,0,0,0,g,0,0,0,0,1),this}makeShear(A,I,g,B,t,Q){return this.set(1,g,t,0,A,1,Q,0,I,B,1,0,0,0,0,1),this}compose(A,I,g){const B=this.elements,t=I._x,Q=I._y,i=I._z,C=I._w,s=t+t,o=Q+Q,e=i+i,a=t*s,n=t*o,r=t*e,D=Q*o,l=Q*e,y=i*e,w=C*s,u=C*o,G=C*e,M=g.x,x=g.y,k=g.z;return B[0]=(1-(D+y))*M,B[1]=(n+G)*M,B[2]=(r-u)*M,B[3]=0,B[4]=(n-G)*x,B[5]=(1-(a+y))*x,B[6]=(l+w)*x,B[7]=0,B[8]=(r+u)*k,B[9]=(l-w)*k,B[10]=(1-(a+D))*k,B[11]=0,B[12]=A.x,B[13]=A.y,B[14]=A.z,B[15]=1,this}decompose(A,I,g){const B=this.elements;let t=eg.set(B[0],B[1],B[2]).length();const Q=eg.set(B[4],B[5],B[6]).length(),i=eg.set(B[8],B[9],B[10]).length();this.determinant()<0&&(t=-t),A.x=B[12],A.y=B[13],A.z=B[14],EI.copy(this);const s=1/t,o=1/Q,e=1/i;return EI.elements[0]*=s,EI.elements[1]*=s,EI.elements[2]*=s,EI.elements[4]*=o,EI.elements[5]*=o,EI.elements[6]*=o,EI.elements[8]*=e,EI.elements[9]*=e,EI.elements[10]*=e,I.setFromRotationMatrix(EI),g.x=t,g.y=Q,g.z=i,this}makePerspective(A,I,g,B,t,Q,i=Lg){const C=this.elements,s=2*t/(I-A),o=2*t/(g-B),e=(I+A)/(I-A),a=(g+B)/(g-B);let n,r;if(i===Lg)n=-(Q+t)/(Q-t),r=-2*Q*t/(Q-t);else if(i===EQ)n=-Q/(Q-t),r=-Q*t/(Q-t);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+i);return C[0]=s,C[4]=0,C[8]=e,C[12]=0,C[1]=0,C[5]=o,C[9]=a,C[13]=0,C[2]=0,C[6]=0,C[10]=n,C[14]=r,C[3]=0,C[7]=0,C[11]=-1,C[15]=0,this}makeOrthographic(A,I,g,B,t,Q,i=Lg){const C=this.elements,s=1/(I-A),o=1/(g-B),e=1/(Q-t),a=(I+A)*s,n=(g+B)*o;let r,D;if(i===Lg)r=(Q+t)*e,D=-2*e;else if(i===EQ)r=t*e,D=-1*e;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+i);return C[0]=2*s,C[4]=0,C[8]=0,C[12]=-a,C[1]=0,C[5]=2*o,C[9]=0,C[13]=-n,C[2]=0,C[6]=0,C[10]=D,C[14]=-r,C[3]=0,C[7]=0,C[11]=0,C[15]=1,this}equals(A){const I=this.elements,g=A.elements;for(let B=0;B<16;B++)if(I[B]!==g[B])return!1;return!0}fromArray(A,I=0){for(let g=0;g<16;g++)this.elements[g]=A[g+I];return this}toArray(A=[],I=0){const g=this.elements;return A[I]=g[0],A[I+1]=g[1],A[I+2]=g[2],A[I+3]=g[3],A[I+4]=g[4],A[I+5]=g[5],A[I+6]=g[6],A[I+7]=g[7],A[I+8]=g[8],A[I+9]=g[9],A[I+10]=g[10],A[I+11]=g[11],A[I+12]=g[12],A[I+13]=g[13],A[I+14]=g[14],A[I+15]=g[15],A}}const eg=new f,EI=new LA,EC=new f(0,0,0),sC=new f(1,1,1),LI=new f,eB=new f,XA=new f,cQ=new LA,DQ=new uA;class VI{constructor(A=0,I=0,g=0,B=VI.DEFAULT_ORDER){this.isEuler=!0,this._x=A,this._y=I,this._z=g,this._order=B}get x(){return this._x}set x(A){this._x=A,this._onChangeCallback()}get y(){return this._y}set y(A){this._y=A,this._onChangeCallback()}get z(){return this._z}set z(A){this._z=A,this._onChangeCallback()}get order(){return this._order}set order(A){this._order=A,this._onChangeCallback()}set(A,I,g,B=this._order){return this._x=A,this._y=I,this._z=g,this._order=B,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(A){return this._x=A._x,this._y=A._y,this._z=A._z,this._order=A._order,this._onChangeCallback(),this}setFromRotationMatrix(A,I=this._order,g=!0){const B=A.elements,t=B[0],Q=B[4],i=B[8],C=B[1],s=B[5],o=B[9],e=B[2],a=B[6],n=B[10];switch(I){case"XYZ":this._y=Math.asin($(i,-1,1)),Math.abs(i)<.9999999?(this._x=Math.atan2(-o,n),this._z=Math.atan2(-Q,t)):(this._x=Math.atan2(a,s),this._z=0);break;case"YXZ":this._x=Math.asin(-$(o,-1,1)),Math.abs(o)<.9999999?(this._y=Math.atan2(i,n),this._z=Math.atan2(C,s)):(this._y=Math.atan2(-e,t),this._z=0);break;case"ZXY":this._x=Math.asin($(a,-1,1)),Math.abs(a)<.9999999?(this._y=Math.atan2(-e,n),this._z=Math.atan2(-Q,s)):(this._y=0,this._z=Math.atan2(C,t));break;case"ZYX":this._y=Math.asin(-$(e,-1,1)),Math.abs(e)<.9999999?(this._x=Math.atan2(a,n),this._z=Math.atan2(C,t)):(this._x=0,this._z=Math.atan2(-Q,s));break;case"YZX":this._z=Math.asin($(C,-1,1)),Math.abs(C)<.9999999?(this._x=Math.atan2(-o,s),this._y=Math.atan2(-e,t)):(this._x=0,this._y=Math.atan2(i,n));break;case"XZY":this._z=Math.asin(-$(Q,-1,1)),Math.abs(Q)<.9999999?(this._x=Math.atan2(a,s),this._y=Math.atan2(i,t)):(this._x=Math.atan2(-o,n),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+I)}return this._order=I,g===!0&&this._onChangeCallback(),this}setFromQuaternion(A,I,g){return cQ.makeRotationFromQuaternion(A),this.setFromRotationMatrix(cQ,I,g)}setFromVector3(A,I=this._order){return this.set(A.x,A.y,A.z,I)}reorder(A){return DQ.setFromEuler(this),this.setFromQuaternion(DQ,A)}equals(A){return A._x===this._x&&A._y===this._y&&A._z===this._z&&A._order===this._order}fromArray(A){return this._x=A[0],this._y=A[1],this._z=A[2],A[3]!==void 0&&(this._order=A[3]),this._onChangeCallback(),this}toArray(A=[],I=0){return A[I]=this._x,A[I+1]=this._y,A[I+2]=this._z,A[I+3]=this._order,A}_onChange(A){return this._onChangeCallback=A,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}VI.DEFAULT_ORDER="XYZ";class eC{constructor(){this.mask=1}set(A){this.mask=(1<<A|0)>>>0}enable(A){this.mask|=1<<A|0}enableAll(){this.mask=-1}toggle(A){this.mask^=1<<A|0}disable(A){this.mask&=~(1<<A|0)}disableAll(){this.mask=0}test(A){return(this.mask&A.mask)!==0}isEnabled(A){return(this.mask&(1<<A|0))!==0}}let oC=0;const lQ=new f,og=new uA,wI=new LA,oB=new f,Zg=new f,aC=new f,nC=new uA,yQ=new f(1,0,0),dQ=new f(0,1,0),wQ=new f(0,0,1),uQ={type:"added"},rC={type:"removed"},ag={type:"childadded",child:null},Et={type:"childremoved",child:null};class WA extends Hg{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:oC++}),this.uuid=bg(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=WA.DEFAULT_UP.clone();const A=new f,I=new VI,g=new uA,B=new f(1,1,1);function t(){g.setFromEuler(I,!1)}function Q(){I.setFromQuaternion(g,void 0,!1)}I._onChange(t),g._onChange(Q),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:A},rotation:{configurable:!0,enumerable:!0,value:I},quaternion:{configurable:!0,enumerable:!0,value:g},scale:{configurable:!0,enumerable:!0,value:B},modelViewMatrix:{value:new LA},normalMatrix:{value:new hI}}),this.matrix=new LA,this.matrixWorld=new LA,this.matrixAutoUpdate=WA.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=WA.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new eC,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(A){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(A),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(A){return this.quaternion.premultiply(A),this}setRotationFromAxisAngle(A,I){this.quaternion.setFromAxisAngle(A,I)}setRotationFromEuler(A){this.quaternion.setFromEuler(A,!0)}setRotationFromMatrix(A){this.quaternion.setFromRotationMatrix(A)}setRotationFromQuaternion(A){this.quaternion.copy(A)}rotateOnAxis(A,I){return og.setFromAxisAngle(A,I),this.quaternion.multiply(og),this}rotateOnWorldAxis(A,I){return og.setFromAxisAngle(A,I),this.quaternion.premultiply(og),this}rotateX(A){return this.rotateOnAxis(yQ,A)}rotateY(A){return this.rotateOnAxis(dQ,A)}rotateZ(A){return this.rotateOnAxis(wQ,A)}translateOnAxis(A,I){return lQ.copy(A).applyQuaternion(this.quaternion),this.position.add(lQ.multiplyScalar(I)),this}translateX(A){return this.translateOnAxis(yQ,A)}translateY(A){return this.translateOnAxis(dQ,A)}translateZ(A){return this.translateOnAxis(wQ,A)}localToWorld(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(this.matrixWorld)}worldToLocal(A){return this.updateWorldMatrix(!0,!1),A.applyMatrix4(wI.copy(this.matrixWorld).invert())}lookAt(A,I,g){A.isVector3?oB.copy(A):oB.set(A,I,g);const B=this.parent;this.updateWorldMatrix(!0,!1),Zg.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?wI.lookAt(Zg,oB,this.up):wI.lookAt(oB,Zg,this.up),this.quaternion.setFromRotationMatrix(wI),B&&(wI.extractRotation(B.matrixWorld),og.setFromRotationMatrix(wI),this.quaternion.premultiply(og.invert()))}add(A){if(arguments.length>1){for(let I=0;I<arguments.length;I++)this.add(arguments[I]);return this}return A===this?(console.error("THREE.Object3D.add: object can\'t be added as a child of itself.",A),this):(A&&A.isObject3D?(A.removeFromParent(),A.parent=this,this.children.push(A),A.dispatchEvent(uQ),ag.child=A,this.dispatchEvent(ag),ag.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",A),this)}remove(A){if(arguments.length>1){for(let g=0;g<arguments.length;g++)this.remove(arguments[g]);return this}const I=this.children.indexOf(A);return I!==-1&&(A.parent=null,this.children.splice(I,1),A.dispatchEvent(rC),Et.child=A,this.dispatchEvent(Et),Et.child=null),this}removeFromParent(){const A=this.parent;return A!==null&&A.remove(this),this}clear(){return this.remove(...this.children)}attach(A){return this.updateWorldMatrix(!0,!1),wI.copy(this.matrixWorld).invert(),A.parent!==null&&(A.parent.updateWorldMatrix(!0,!1),wI.multiply(A.parent.matrixWorld)),A.applyMatrix4(wI),A.removeFromParent(),A.parent=this,this.children.push(A),A.updateWorldMatrix(!1,!0),A.dispatchEvent(uQ),ag.child=A,this.dispatchEvent(ag),ag.child=null,this}getObjectById(A){return this.getObjectByProperty("id",A)}getObjectByName(A){return this.getObjectByProperty("name",A)}getObjectByProperty(A,I){if(this[A]===I)return this;for(let g=0,B=this.children.length;g<B;g++){const Q=this.children[g].getObjectByProperty(A,I);if(Q!==void 0)return Q}}getObjectsByProperty(A,I,g=[]){this[A]===I&&g.push(this);const B=this.children;for(let t=0,Q=B.length;t<Q;t++)B[t].getObjectsByProperty(A,I,g);return g}getWorldPosition(A){return this.updateWorldMatrix(!0,!1),A.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Zg,A,aC),A}getWorldScale(A){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Zg,nC,A),A}getWorldDirection(A){this.updateWorldMatrix(!0,!1);const I=this.matrixWorld.elements;return A.set(I[8],I[9],I[10]).normalize()}raycast(){}traverse(A){A(this);const I=this.children;for(let g=0,B=I.length;g<B;g++)I[g].traverse(A)}traverseVisible(A){if(this.visible===!1)return;A(this);const I=this.children;for(let g=0,B=I.length;g<B;g++)I[g].traverseVisible(A)}traverseAncestors(A){const I=this.parent;I!==null&&(A(I),I.traverseAncestors(A))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(A){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||A)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,A=!0);const I=this.children;for(let g=0,B=I.length;g<B;g++)I[g].updateMatrixWorld(A)}updateWorldMatrix(A,I){const g=this.parent;if(A===!0&&g!==null&&g.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),I===!0){const B=this.children;for(let t=0,Q=B.length;t<Q;t++)B[t].updateWorldMatrix(!1,!0)}}toJSON(A){const I=A===void 0||typeof A=="string",g={};I&&(A={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},g.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const B={};B.uuid=this.uuid,B.type=this.type,this.name!==""&&(B.name=this.name),this.castShadow===!0&&(B.castShadow=!0),this.receiveShadow===!0&&(B.receiveShadow=!0),this.visible===!1&&(B.visible=!1),this.frustumCulled===!1&&(B.frustumCulled=!1),this.renderOrder!==0&&(B.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(B.userData=this.userData),B.layers=this.layers.mask,B.matrix=this.matrix.toArray(),B.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(B.matrixAutoUpdate=!1),this.isInstancedMesh&&(B.type="InstancedMesh",B.count=this.count,B.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(B.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(B.type="BatchedMesh",B.perObjectFrustumCulled=this.perObjectFrustumCulled,B.sortObjects=this.sortObjects,B.drawRanges=this._drawRanges,B.reservedRanges=this._reservedRanges,B.visibility=this._visibility,B.active=this._active,B.bounds=this._bounds.map(i=>({boxInitialized:i.boxInitialized,boxMin:i.box.min.toArray(),boxMax:i.box.max.toArray(),sphereInitialized:i.sphereInitialized,sphereRadius:i.sphere.radius,sphereCenter:i.sphere.center.toArray()})),B.maxInstanceCount=this._maxInstanceCount,B.maxVertexCount=this._maxVertexCount,B.maxIndexCount=this._maxIndexCount,B.geometryInitialized=this._geometryInitialized,B.geometryCount=this._geometryCount,B.matricesTexture=this._matricesTexture.toJSON(A),this._colorsTexture!==null&&(B.colorsTexture=this._colorsTexture.toJSON(A)),this.boundingSphere!==null&&(B.boundingSphere={center:B.boundingSphere.center.toArray(),radius:B.boundingSphere.radius}),this.boundingBox!==null&&(B.boundingBox={min:B.boundingBox.min.toArray(),max:B.boundingBox.max.toArray()}));function t(i,C){return i[C.uuid]===void 0&&(i[C.uuid]=C.toJSON(A)),C.uuid}if(this.isScene)this.background&&(this.background.isColor?B.background=this.background.toJSON():this.background.isTexture&&(B.background=this.background.toJSON(A).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(B.environment=this.environment.toJSON(A).uuid);else if(this.isMesh||this.isLine||this.isPoints){B.geometry=t(A.geometries,this.geometry);const i=this.geometry.parameters;if(i!==void 0&&i.shapes!==void 0){const C=i.shapes;if(Array.isArray(C))for(let s=0,o=C.length;s<o;s++){const e=C[s];t(A.shapes,e)}else t(A.shapes,C)}}if(this.isSkinnedMesh&&(B.bindMode=this.bindMode,B.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(t(A.skeletons,this.skeleton),B.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const i=[];for(let C=0,s=this.material.length;C<s;C++)i.push(t(A.materials,this.material[C]));B.material=i}else B.material=t(A.materials,this.material);if(this.children.length>0){B.children=[];for(let i=0;i<this.children.length;i++)B.children.push(this.children[i].toJSON(A).object)}if(this.animations.length>0){B.animations=[];for(let i=0;i<this.animations.length;i++){const C=this.animations[i];B.animations.push(t(A.animations,C))}}if(I){const i=Q(A.geometries),C=Q(A.materials),s=Q(A.textures),o=Q(A.images),e=Q(A.shapes),a=Q(A.skeletons),n=Q(A.animations),r=Q(A.nodes);i.length>0&&(g.geometries=i),C.length>0&&(g.materials=C),s.length>0&&(g.textures=s),o.length>0&&(g.images=o),e.length>0&&(g.shapes=e),a.length>0&&(g.skeletons=a),n.length>0&&(g.animations=n),r.length>0&&(g.nodes=r)}return g.object=B,g;function Q(i){const C=[];for(const s in i){const o=i[s];delete o.metadata,C.push(o)}return C}}clone(A){return new this.constructor().copy(this,A)}copy(A,I=!0){if(this.name=A.name,this.up.copy(A.up),this.position.copy(A.position),this.rotation.order=A.rotation.order,this.quaternion.copy(A.quaternion),this.scale.copy(A.scale),this.matrix.copy(A.matrix),this.matrixWorld.copy(A.matrixWorld),this.matrixAutoUpdate=A.matrixAutoUpdate,this.matrixWorldAutoUpdate=A.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=A.matrixWorldNeedsUpdate,this.layers.mask=A.layers.mask,this.visible=A.visible,this.castShadow=A.castShadow,this.receiveShadow=A.receiveShadow,this.frustumCulled=A.frustumCulled,this.renderOrder=A.renderOrder,this.animations=A.animations.slice(),this.userData=JSON.parse(JSON.stringify(A.userData)),I===!0)for(let g=0;g<A.children.length;g++){const B=A.children[g];this.add(B.clone())}return this}}WA.DEFAULT_UP=new f(0,1,0),WA.DEFAULT_MATRIX_AUTO_UPDATE=!0,WA.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const sI=new f,uI=new f,st=new f,fI=new f,ng=new f,rg=new f,fQ=new f,et=new f,ot=new f,at=new f,nt=new qA,rt=new qA,ht=new qA;class eI{constructor(A=new f,I=new f,g=new f){this.a=A,this.b=I,this.c=g}static getNormal(A,I,g,B){B.subVectors(g,I),sI.subVectors(A,I),B.cross(sI);const t=B.lengthSq();return t>0?B.multiplyScalar(1/Math.sqrt(t)):B.set(0,0,0)}static getBarycoord(A,I,g,B,t){sI.subVectors(B,I),uI.subVectors(g,I),st.subVectors(A,I);const Q=sI.dot(sI),i=sI.dot(uI),C=sI.dot(st),s=uI.dot(uI),o=uI.dot(st),e=Q*s-i*i;if(e===0)return t.set(0,0,0),null;const a=1/e,n=(s*C-i*o)*a,r=(Q*o-i*C)*a;return t.set(1-n-r,r,n)}static containsPoint(A,I,g,B){return this.getBarycoord(A,I,g,B,fI)===null?!1:fI.x>=0&&fI.y>=0&&fI.x+fI.y<=1}static getInterpolation(A,I,g,B,t,Q,i,C){return this.getBarycoord(A,I,g,B,fI)===null?(C.x=0,C.y=0,"z"in C&&(C.z=0),"w"in C&&(C.w=0),null):(C.setScalar(0),C.addScaledVector(t,fI.x),C.addScaledVector(Q,fI.y),C.addScaledVector(i,fI.z),C)}static getInterpolatedAttribute(A,I,g,B,t,Q){return nt.setScalar(0),rt.setScalar(0),ht.setScalar(0),nt.fromBufferAttribute(A,I),rt.fromBufferAttribute(A,g),ht.fromBufferAttribute(A,B),Q.setScalar(0),Q.addScaledVector(nt,t.x),Q.addScaledVector(rt,t.y),Q.addScaledVector(ht,t.z),Q}static isFrontFacing(A,I,g,B){return sI.subVectors(g,I),uI.subVectors(A,I),sI.cross(uI).dot(B)<0}set(A,I,g){return this.a.copy(A),this.b.copy(I),this.c.copy(g),this}setFromPointsAndIndices(A,I,g,B){return this.a.copy(A[I]),this.b.copy(A[g]),this.c.copy(A[B]),this}setFromAttributeAndIndices(A,I,g,B){return this.a.fromBufferAttribute(A,I),this.b.fromBufferAttribute(A,g),this.c.fromBufferAttribute(A,B),this}clone(){return new this.constructor().copy(this)}copy(A){return this.a.copy(A.a),this.b.copy(A.b),this.c.copy(A.c),this}getArea(){return sI.subVectors(this.c,this.b),uI.subVectors(this.a,this.b),sI.cross(uI).length()*.5}getMidpoint(A){return A.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(A){return eI.getNormal(this.a,this.b,this.c,A)}getPlane(A){return A.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(A,I){return eI.getBarycoord(A,this.a,this.b,this.c,I)}getInterpolation(A,I,g,B,t){return eI.getInterpolation(A,this.a,this.b,this.c,I,g,B,t)}containsPoint(A){return eI.containsPoint(A,this.a,this.b,this.c)}isFrontFacing(A){return eI.isFrontFacing(this.a,this.b,this.c,A)}intersectsBox(A){return A.intersectsTriangle(this)}closestPointToPoint(A,I){const g=this.a,B=this.b,t=this.c;let Q,i;ng.subVectors(B,g),rg.subVectors(t,g),et.subVectors(A,g);const C=ng.dot(et),s=rg.dot(et);if(C<=0&&s<=0)return I.copy(g);ot.subVectors(A,B);const o=ng.dot(ot),e=rg.dot(ot);if(o>=0&&e<=o)return I.copy(B);const a=C*e-o*s;if(a<=0&&C>=0&&o<=0)return Q=C/(C-o),I.copy(g).addScaledVector(ng,Q);at.subVectors(A,t);const n=ng.dot(at),r=rg.dot(at);if(r>=0&&n<=r)return I.copy(t);const D=n*s-C*r;if(D<=0&&s>=0&&r<=0)return i=s/(s-r),I.copy(g).addScaledVector(rg,i);const l=o*r-n*e;if(l<=0&&e-o>=0&&n-r>=0)return fQ.subVectors(t,B),i=(e-o)/(e-o+(n-r)),I.copy(B).addScaledVector(fQ,i);const y=1/(l+D+a);return Q=D*y,i=a*y,I.copy(g).addScaledVector(ng,Q).addScaledVector(rg,i)}equals(A){return A.a.equals(this.a)&&A.b.equals(this.b)&&A.c.equals(this.c)}}const GQ={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},HI={h:0,s:0,l:0},aB={h:0,s:0,l:0};function ct(E,A,I){return I<0&&(I+=1),I>1&&(I-=1),I<1/6?E+(A-E)*6*I:I<1/2?A:I<2/3?E+(A-E)*6*(2/3-I):E}class XI{constructor(A,I,g){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(A,I,g)}set(A,I,g){if(I===void 0&&g===void 0){const B=A;B&&B.isColor?this.copy(B):typeof B=="number"?this.setHex(B):typeof B=="string"&&this.setStyle(B)}else this.setRGB(A,I,g);return this}setScalar(A){return this.r=A,this.g=A,this.b=A,this}setHex(A,I=QI){return A=Math.floor(A),this.r=(A>>16&255)/255,this.g=(A>>8&255)/255,this.b=(A&255)/255,iI.toWorkingColorSpace(this,I),this}setRGB(A,I,g,B=iI.workingColorSpace){return this.r=A,this.g=I,this.b=g,iI.toWorkingColorSpace(this,B),this}setHSL(A,I,g,B=iI.workingColorSpace){if(A=_i(A,1),I=$(I,0,1),g=$(g,0,1),I===0)this.r=this.g=this.b=g;else{const t=g<=.5?g*(1+I):g+I-g*I,Q=2*g-t;this.r=ct(Q,t,A+1/3),this.g=ct(Q,t,A),this.b=ct(Q,t,A-1/3)}return iI.toWorkingColorSpace(this,B),this}setStyle(A,I=QI){function g(t){t!==void 0&&parseFloat(t)<1&&console.warn("THREE.Color: Alpha component of "+A+" will be ignored.")}let B;if(B=/^(\\w+)\\(([^\\)]*)\\)/.exec(A)){let t;const Q=B[1],i=B[2];switch(Q){case"rgb":case"rgba":if(t=/^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(i))return g(t[4]),this.setRGB(Math.min(255,parseInt(t[1],10))/255,Math.min(255,parseInt(t[2],10))/255,Math.min(255,parseInt(t[3],10))/255,I);if(t=/^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(i))return g(t[4]),this.setRGB(Math.min(100,parseInt(t[1],10))/100,Math.min(100,parseInt(t[2],10))/100,Math.min(100,parseInt(t[3],10))/100,I);break;case"hsl":case"hsla":if(t=/^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*,\\s*(\\d*\\.?\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(i))return g(t[4]),this.setHSL(parseFloat(t[1])/360,parseFloat(t[2])/100,parseFloat(t[3])/100,I);break;default:console.warn("THREE.Color: Unknown color model "+A)}}else if(B=/^\\#([A-Fa-f\\d]+)$/.exec(A)){const t=B[1],Q=t.length;if(Q===3)return this.setRGB(parseInt(t.charAt(0),16)/15,parseInt(t.charAt(1),16)/15,parseInt(t.charAt(2),16)/15,I);if(Q===6)return this.setHex(parseInt(t,16),I);console.warn("THREE.Color: Invalid hex color "+A)}else if(A&&A.length>0)return this.setColorName(A,I);return this}setColorName(A,I=QI){const g=GQ[A.toLowerCase()];return g!==void 0?this.setHex(g,I):console.warn("THREE.Color: Unknown color "+A),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(A){return this.r=A.r,this.g=A.g,this.b=A.b,this}copySRGBToLinear(A){return this.r=lI(A.r),this.g=lI(A.g),this.b=lI(A.b),this}copyLinearToSRGB(A){return this.r=tg(A.r),this.g=tg(A.g),this.b=tg(A.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(A=QI){return iI.fromWorkingColorSpace(HA.copy(this),A),Math.round($(HA.r*255,0,255))*65536+Math.round($(HA.g*255,0,255))*256+Math.round($(HA.b*255,0,255))}getHexString(A=QI){return("000000"+this.getHex(A).toString(16)).slice(-6)}getHSL(A,I=iI.workingColorSpace){iI.fromWorkingColorSpace(HA.copy(this),I);const g=HA.r,B=HA.g,t=HA.b,Q=Math.max(g,B,t),i=Math.min(g,B,t);let C,s;const o=(i+Q)/2;if(i===Q)C=0,s=0;else{const e=Q-i;switch(s=o<=.5?e/(Q+i):e/(2-Q-i),Q){case g:C=(B-t)/e+(B<t?6:0);break;case B:C=(t-g)/e+2;break;case t:C=(g-B)/e+4;break}C/=6}return A.h=C,A.s=s,A.l=o,A}getRGB(A,I=iI.workingColorSpace){return iI.fromWorkingColorSpace(HA.copy(this),I),A.r=HA.r,A.g=HA.g,A.b=HA.b,A}getStyle(A=QI){iI.fromWorkingColorSpace(HA.copy(this),A);const I=HA.r,g=HA.g,B=HA.b;return A!==QI?`color(${A} ${I.toFixed(3)} ${g.toFixed(3)} ${B.toFixed(3)})`:`rgb(${Math.round(I*255)},${Math.round(g*255)},${Math.round(B*255)})`}offsetHSL(A,I,g){return this.getHSL(HI),this.setHSL(HI.h+A,HI.s+I,HI.l+g)}add(A){return this.r+=A.r,this.g+=A.g,this.b+=A.b,this}addColors(A,I){return this.r=A.r+I.r,this.g=A.g+I.g,this.b=A.b+I.b,this}addScalar(A){return this.r+=A,this.g+=A,this.b+=A,this}sub(A){return this.r=Math.max(0,this.r-A.r),this.g=Math.max(0,this.g-A.g),this.b=Math.max(0,this.b-A.b),this}multiply(A){return this.r*=A.r,this.g*=A.g,this.b*=A.b,this}multiplyScalar(A){return this.r*=A,this.g*=A,this.b*=A,this}lerp(A,I){return this.r+=(A.r-this.r)*I,this.g+=(A.g-this.g)*I,this.b+=(A.b-this.b)*I,this}lerpColors(A,I,g){return this.r=A.r+(I.r-A.r)*g,this.g=A.g+(I.g-A.g)*g,this.b=A.b+(I.b-A.b)*g,this}lerpHSL(A,I){this.getHSL(HI),A.getHSL(aB);const g=$B(HI.h,aB.h,I),B=$B(HI.s,aB.s,I),t=$B(HI.l,aB.l,I);return this.setHSL(g,B,t),this}setFromVector3(A){return this.r=A.x,this.g=A.y,this.b=A.z,this}applyMatrix3(A){const I=this.r,g=this.g,B=this.b,t=A.elements;return this.r=t[0]*I+t[3]*g+t[6]*B,this.g=t[1]*I+t[4]*g+t[7]*B,this.b=t[2]*I+t[5]*g+t[8]*B,this}equals(A){return A.r===this.r&&A.g===this.g&&A.b===this.b}fromArray(A,I=0){return this.r=A[I],this.g=A[I+1],this.b=A[I+2],this}toArray(A=[],I=0){return A[I]=this.r,A[I+1]=this.g,A[I+2]=this.b,A}fromBufferAttribute(A,I){return this.r=A.getX(I),this.g=A.getY(I),this.b=A.getZ(I),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const HA=new XI;XI.NAMES=GQ;let hC=0;class FQ extends Hg{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:hC++}),this.uuid=bg(),this.name="",this.type="Material",this.blending=Vt,this.side=jB,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=Pt,this.blendDst=jt,this.blendEquation=Xt,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new XI(0,0,0),this.blendAlpha=0,this.depthFunc=_t,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=iQ,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=Bg,this.stencilZFail=Bg,this.stencilZPass=Bg,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(A){this._alphaTest>0!=A>0&&this.version++,this._alphaTest=A}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(A){if(A!==void 0)for(const I in A){const g=A[I];if(g===void 0){console.warn(`THREE.Material: parameter \'${I}\' has value of undefined.`);continue}const B=this[I];if(B===void 0){console.warn(`THREE.Material: \'${I}\' is not a property of THREE.${this.type}.`);continue}B&&B.isColor?B.set(g):B&&B.isVector3&&g&&g.isVector3?B.copy(g):this[I]=g}}toJSON(A){const I=A===void 0||typeof A=="string";I&&(A={textures:{},images:{}});const g={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};g.uuid=this.uuid,g.type=this.type,this.name!==""&&(g.name=this.name),this.color&&this.color.isColor&&(g.color=this.color.getHex()),this.roughness!==void 0&&(g.roughness=this.roughness),this.metalness!==void 0&&(g.metalness=this.metalness),this.sheen!==void 0&&(g.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(g.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(g.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(g.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(g.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(g.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(g.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(g.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(g.shininess=this.shininess),this.clearcoat!==void 0&&(g.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(g.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(g.clearcoatMap=this.clearcoatMap.toJSON(A).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(g.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(A).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(g.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(A).uuid,g.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(g.dispersion=this.dispersion),this.iridescence!==void 0&&(g.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(g.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(g.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(g.iridescenceMap=this.iridescenceMap.toJSON(A).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(g.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(A).uuid),this.anisotropy!==void 0&&(g.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(g.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(g.anisotropyMap=this.anisotropyMap.toJSON(A).uuid),this.map&&this.map.isTexture&&(g.map=this.map.toJSON(A).uuid),this.matcap&&this.matcap.isTexture&&(g.matcap=this.matcap.toJSON(A).uuid),this.alphaMap&&this.alphaMap.isTexture&&(g.alphaMap=this.alphaMap.toJSON(A).uuid),this.lightMap&&this.lightMap.isTexture&&(g.lightMap=this.lightMap.toJSON(A).uuid,g.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(g.aoMap=this.aoMap.toJSON(A).uuid,g.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(g.bumpMap=this.bumpMap.toJSON(A).uuid,g.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(g.normalMap=this.normalMap.toJSON(A).uuid,g.normalMapType=this.normalMapType,g.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(g.displacementMap=this.displacementMap.toJSON(A).uuid,g.displacementScale=this.displacementScale,g.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(g.roughnessMap=this.roughnessMap.toJSON(A).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(g.metalnessMap=this.metalnessMap.toJSON(A).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(g.emissiveMap=this.emissiveMap.toJSON(A).uuid),this.specularMap&&this.specularMap.isTexture&&(g.specularMap=this.specularMap.toJSON(A).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(g.specularIntensityMap=this.specularIntensityMap.toJSON(A).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(g.specularColorMap=this.specularColorMap.toJSON(A).uuid),this.envMap&&this.envMap.isTexture&&(g.envMap=this.envMap.toJSON(A).uuid,this.combine!==void 0&&(g.combine=this.combine)),this.envMapRotation!==void 0&&(g.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(g.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(g.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(g.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(g.gradientMap=this.gradientMap.toJSON(A).uuid),this.transmission!==void 0&&(g.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(g.transmissionMap=this.transmissionMap.toJSON(A).uuid),this.thickness!==void 0&&(g.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(g.thicknessMap=this.thicknessMap.toJSON(A).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(g.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(g.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(g.size=this.size),this.shadowSide!==null&&(g.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(g.sizeAttenuation=this.sizeAttenuation),this.blending!==Vt&&(g.blending=this.blending),this.side!==jB&&(g.side=this.side),this.vertexColors===!0&&(g.vertexColors=!0),this.opacity<1&&(g.opacity=this.opacity),this.transparent===!0&&(g.transparent=!0),this.blendSrc!==Pt&&(g.blendSrc=this.blendSrc),this.blendDst!==jt&&(g.blendDst=this.blendDst),this.blendEquation!==Xt&&(g.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(g.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(g.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(g.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(g.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(g.blendAlpha=this.blendAlpha),this.depthFunc!==_t&&(g.depthFunc=this.depthFunc),this.depthTest===!1&&(g.depthTest=this.depthTest),this.depthWrite===!1&&(g.depthWrite=this.depthWrite),this.colorWrite===!1&&(g.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(g.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==iQ&&(g.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(g.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(g.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==Bg&&(g.stencilFail=this.stencilFail),this.stencilZFail!==Bg&&(g.stencilZFail=this.stencilZFail),this.stencilZPass!==Bg&&(g.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(g.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(g.rotation=this.rotation),this.polygonOffset===!0&&(g.polygonOffset=!0),this.polygonOffsetFactor!==0&&(g.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(g.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(g.linewidth=this.linewidth),this.dashSize!==void 0&&(g.dashSize=this.dashSize),this.gapSize!==void 0&&(g.gapSize=this.gapSize),this.scale!==void 0&&(g.scale=this.scale),this.dithering===!0&&(g.dithering=!0),this.alphaTest>0&&(g.alphaTest=this.alphaTest),this.alphaHash===!0&&(g.alphaHash=!0),this.alphaToCoverage===!0&&(g.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(g.premultipliedAlpha=!0),this.forceSinglePass===!0&&(g.forceSinglePass=!0),this.wireframe===!0&&(g.wireframe=!0),this.wireframeLinewidth>1&&(g.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(g.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(g.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(g.flatShading=!0),this.visible===!1&&(g.visible=!1),this.toneMapped===!1&&(g.toneMapped=!1),this.fog===!1&&(g.fog=!1),Object.keys(this.userData).length>0&&(g.userData=this.userData);function B(t){const Q=[];for(const i in t){const C=t[i];delete C.metadata,Q.push(C)}return Q}if(I){const t=B(A.textures),Q=B(A.images);t.length>0&&(g.textures=t),Q.length>0&&(g.images=Q)}return g}clone(){return new this.constructor().copy(this)}copy(A){this.name=A.name,this.blending=A.blending,this.side=A.side,this.vertexColors=A.vertexColors,this.opacity=A.opacity,this.transparent=A.transparent,this.blendSrc=A.blendSrc,this.blendDst=A.blendDst,this.blendEquation=A.blendEquation,this.blendSrcAlpha=A.blendSrcAlpha,this.blendDstAlpha=A.blendDstAlpha,this.blendEquationAlpha=A.blendEquationAlpha,this.blendColor.copy(A.blendColor),this.blendAlpha=A.blendAlpha,this.depthFunc=A.depthFunc,this.depthTest=A.depthTest,this.depthWrite=A.depthWrite,this.stencilWriteMask=A.stencilWriteMask,this.stencilFunc=A.stencilFunc,this.stencilRef=A.stencilRef,this.stencilFuncMask=A.stencilFuncMask,this.stencilFail=A.stencilFail,this.stencilZFail=A.stencilZFail,this.stencilZPass=A.stencilZPass,this.stencilWrite=A.stencilWrite;const I=A.clippingPlanes;let g=null;if(I!==null){const B=I.length;g=new Array(B);for(let t=0;t!==B;++t)g[t]=I[t].clone()}return this.clippingPlanes=g,this.clipIntersection=A.clipIntersection,this.clipShadows=A.clipShadows,this.shadowSide=A.shadowSide,this.colorWrite=A.colorWrite,this.precision=A.precision,this.polygonOffset=A.polygonOffset,this.polygonOffsetFactor=A.polygonOffsetFactor,this.polygonOffsetUnits=A.polygonOffsetUnits,this.dithering=A.dithering,this.alphaTest=A.alphaTest,this.alphaHash=A.alphaHash,this.alphaToCoverage=A.alphaToCoverage,this.premultipliedAlpha=A.premultipliedAlpha,this.forceSinglePass=A.forceSinglePass,this.visible=A.visible,this.toneMapped=A.toneMapped,this.userData=JSON.parse(JSON.stringify(A.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(A){A===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class cC extends FQ{constructor(A){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new XI(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new VI,this.combine=Oi,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(A)}copy(A){return super.copy(A),this.color.copy(A.color),this.map=A.map,this.lightMap=A.lightMap,this.lightMapIntensity=A.lightMapIntensity,this.aoMap=A.aoMap,this.aoMapIntensity=A.aoMapIntensity,this.specularMap=A.specularMap,this.alphaMap=A.alphaMap,this.envMap=A.envMap,this.envMapRotation.copy(A.envMapRotation),this.combine=A.combine,this.reflectivity=A.reflectivity,this.refractionRatio=A.refractionRatio,this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.wireframeLinecap=A.wireframeLinecap,this.wireframeLinejoin=A.wireframeLinejoin,this.fog=A.fog,this}}const cA=new f,nB=new zA;class hg{constructor(A,I,g=!1){if(Array.isArray(A))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=A,this.itemSize=I,this.count=A!==void 0?A.length/I:0,this.normalized=g,this.usage=CQ,this.updateRanges=[],this.gpuType=Xi,this.version=0}onUploadCallback(){}set needsUpdate(A){A===!0&&this.version++}setUsage(A){return this.usage=A,this}addUpdateRange(A,I){this.updateRanges.push({start:A,count:I})}clearUpdateRanges(){this.updateRanges.length=0}copy(A){return this.name=A.name,this.array=new A.array.constructor(A.array),this.itemSize=A.itemSize,this.count=A.count,this.normalized=A.normalized,this.usage=A.usage,this.gpuType=A.gpuType,this}copyAt(A,I,g){A*=this.itemSize,g*=I.itemSize;for(let B=0,t=this.itemSize;B<t;B++)this.array[A+B]=I.array[g+B];return this}copyArray(A){return this.array.set(A),this}applyMatrix3(A){if(this.itemSize===2)for(let I=0,g=this.count;I<g;I++)nB.fromBufferAttribute(this,I),nB.applyMatrix3(A),this.setXY(I,nB.x,nB.y);else if(this.itemSize===3)for(let I=0,g=this.count;I<g;I++)cA.fromBufferAttribute(this,I),cA.applyMatrix3(A),this.setXYZ(I,cA.x,cA.y,cA.z);return this}applyMatrix4(A){for(let I=0,g=this.count;I<g;I++)cA.fromBufferAttribute(this,I),cA.applyMatrix4(A),this.setXYZ(I,cA.x,cA.y,cA.z);return this}applyNormalMatrix(A){for(let I=0,g=this.count;I<g;I++)cA.fromBufferAttribute(this,I),cA.applyNormalMatrix(A),this.setXYZ(I,cA.x,cA.y,cA.z);return this}transformDirection(A){for(let I=0,g=this.count;I<g;I++)cA.fromBufferAttribute(this,I),cA.transformDirection(A),this.setXYZ(I,cA.x,cA.y,cA.z);return this}set(A,I=0){return this.array.set(A,I),this}getComponent(A,I){let g=this.array[A*this.itemSize+I];return this.normalized&&(g=Kg(g,this.array)),g}setComponent(A,I,g){return this.normalized&&(g=ZA(g,this.array)),this.array[A*this.itemSize+I]=g,this}getX(A){let I=this.array[A*this.itemSize];return this.normalized&&(I=Kg(I,this.array)),I}setX(A,I){return this.normalized&&(I=ZA(I,this.array)),this.array[A*this.itemSize]=I,this}getY(A){let I=this.array[A*this.itemSize+1];return this.normalized&&(I=Kg(I,this.array)),I}setY(A,I){return this.normalized&&(I=ZA(I,this.array)),this.array[A*this.itemSize+1]=I,this}getZ(A){let I=this.array[A*this.itemSize+2];return this.normalized&&(I=Kg(I,this.array)),I}setZ(A,I){return this.normalized&&(I=ZA(I,this.array)),this.array[A*this.itemSize+2]=I,this}getW(A){let I=this.array[A*this.itemSize+3];return this.normalized&&(I=Kg(I,this.array)),I}setW(A,I){return this.normalized&&(I=ZA(I,this.array)),this.array[A*this.itemSize+3]=I,this}setXY(A,I,g){return A*=this.itemSize,this.normalized&&(I=ZA(I,this.array),g=ZA(g,this.array)),this.array[A+0]=I,this.array[A+1]=g,this}setXYZ(A,I,g,B){return A*=this.itemSize,this.normalized&&(I=ZA(I,this.array),g=ZA(g,this.array),B=ZA(B,this.array)),this.array[A+0]=I,this.array[A+1]=g,this.array[A+2]=B,this}setXYZW(A,I,g,B,t){return A*=this.itemSize,this.normalized&&(I=ZA(I,this.array),g=ZA(g,this.array),B=ZA(B,this.array),t=ZA(t,this.array)),this.array[A+0]=I,this.array[A+1]=g,this.array[A+2]=B,this.array[A+3]=t,this}onUpload(A){return this.onUploadCallback=A,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const A={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(A.name=this.name),this.usage!==CQ&&(A.usage=this.usage),A}}class DC extends hg{constructor(A,I,g){super(new Uint16Array(A),I,g)}}class lC extends hg{constructor(A,I,g){super(new Uint32Array(A),I,g)}}class rB extends hg{constructor(A,I,g){super(new Float32Array(A),I,g)}}let yC=0;const II=new LA,Dt=new WA,cg=new f,PA=new ig,zg=new ig,fA=new f;class hB extends Hg{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:yC++}),this.uuid=bg(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(A){return Array.isArray(A)?this.index=new($i(A)?lC:DC)(A,1):this.index=A,this}setIndirect(A){return this.indirect=A,this}getIndirect(){return this.indirect}getAttribute(A){return this.attributes[A]}setAttribute(A,I){return this.attributes[A]=I,this}deleteAttribute(A){return delete this.attributes[A],this}hasAttribute(A){return this.attributes[A]!==void 0}addGroup(A,I,g=0){this.groups.push({start:A,count:I,materialIndex:g})}clearGroups(){this.groups=[]}setDrawRange(A,I){this.drawRange.start=A,this.drawRange.count=I}applyMatrix4(A){const I=this.attributes.position;I!==void 0&&(I.applyMatrix4(A),I.needsUpdate=!0);const g=this.attributes.normal;if(g!==void 0){const t=new hI().getNormalMatrix(A);g.applyNormalMatrix(t),g.needsUpdate=!0}const B=this.attributes.tangent;return B!==void 0&&(B.transformDirection(A),B.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(A){return II.makeRotationFromQuaternion(A),this.applyMatrix4(II),this}rotateX(A){return II.makeRotationX(A),this.applyMatrix4(II),this}rotateY(A){return II.makeRotationY(A),this.applyMatrix4(II),this}rotateZ(A){return II.makeRotationZ(A),this.applyMatrix4(II),this}translate(A,I,g){return II.makeTranslation(A,I,g),this.applyMatrix4(II),this}scale(A,I,g){return II.makeScale(A,I,g),this.applyMatrix4(II),this}lookAt(A){return Dt.lookAt(A),Dt.updateMatrix(),this.applyMatrix4(Dt.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(cg).negate(),this.translate(cg.x,cg.y,cg.z),this}setFromPoints(A){const I=this.getAttribute("position");if(I===void 0){const g=[];for(let B=0,t=A.length;B<t;B++){const Q=A[B];g.push(Q.x,Q.y,Q.z||0)}this.setAttribute("position",new rB(g,3))}else{const g=Math.min(A.length,I.count);for(let B=0;B<g;B++){const t=A[B];I.setXYZ(B,t.x,t.y,t.z||0)}A.length>I.count&&console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),I.needsUpdate=!0}return this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new ig);const A=this.attributes.position,I=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new f(-1/0,-1/0,-1/0),new f(1/0,1/0,1/0));return}if(A!==void 0){if(this.boundingBox.setFromBufferAttribute(A),I)for(let g=0,B=I.length;g<B;g++){const t=I[g];PA.setFromBufferAttribute(t),this.morphTargetsRelative?(fA.addVectors(this.boundingBox.min,PA.min),this.boundingBox.expandByPoint(fA),fA.addVectors(this.boundingBox.max,PA.max),this.boundingBox.expandByPoint(fA)):(this.boundingBox.expandByPoint(PA.min),this.boundingBox.expandByPoint(PA.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error(\'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.\',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new hQ);const A=this.attributes.position,I=this.morphAttributes.position;if(A&&A.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new f,1/0);return}if(A){const g=this.boundingSphere.center;if(PA.setFromBufferAttribute(A),I)for(let t=0,Q=I.length;t<Q;t++){const i=I[t];zg.setFromBufferAttribute(i),this.morphTargetsRelative?(fA.addVectors(PA.min,zg.min),PA.expandByPoint(fA),fA.addVectors(PA.max,zg.max),PA.expandByPoint(fA)):(PA.expandByPoint(zg.min),PA.expandByPoint(zg.max))}PA.getCenter(g);let B=0;for(let t=0,Q=A.count;t<Q;t++)fA.fromBufferAttribute(A,t),B=Math.max(B,g.distanceToSquared(fA));if(I)for(let t=0,Q=I.length;t<Q;t++){const i=I[t],C=this.morphTargetsRelative;for(let s=0,o=i.count;s<o;s++)fA.fromBufferAttribute(i,s),C&&(cg.fromBufferAttribute(A,s),fA.add(cg)),B=Math.max(B,g.distanceToSquared(fA))}this.boundingSphere.radius=Math.sqrt(B),isNaN(this.boundingSphere.radius)&&console.error(\'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.\',this)}}computeTangents(){const A=this.index,I=this.attributes;if(A===null||I.position===void 0||I.normal===void 0||I.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const g=I.position,B=I.normal,t=I.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new hg(new Float32Array(4*g.count),4));const Q=this.getAttribute("tangent"),i=[],C=[];for(let S=0;S<g.count;S++)i[S]=new f,C[S]=new f;const s=new f,o=new f,e=new f,a=new zA,n=new zA,r=new zA,D=new f,l=new f;function y(S,N,H){s.fromBufferAttribute(g,S),o.fromBufferAttribute(g,N),e.fromBufferAttribute(g,H),a.fromBufferAttribute(t,S),n.fromBufferAttribute(t,N),r.fromBufferAttribute(t,H),o.sub(s),e.sub(s),n.sub(a),r.sub(a);const U=1/(n.x*r.y-r.x*n.y);isFinite(U)&&(D.copy(o).multiplyScalar(r.y).addScaledVector(e,-n.y).multiplyScalar(U),l.copy(e).multiplyScalar(n.x).addScaledVector(o,-r.x).multiplyScalar(U),i[S].add(D),i[N].add(D),i[H].add(D),C[S].add(l),C[N].add(l),C[H].add(l))}let w=this.groups;w.length===0&&(w=[{start:0,count:A.count}]);for(let S=0,N=w.length;S<N;++S){const H=w[S],U=H.start,m=H.count;for(let J=U,K=U+m;J<K;J+=3)y(A.getX(J+0),A.getX(J+1),A.getX(J+2))}const u=new f,G=new f,M=new f,x=new f;function k(S){M.fromBufferAttribute(B,S),x.copy(M);const N=i[S];u.copy(N),u.sub(M.multiplyScalar(M.dot(N))).normalize(),G.crossVectors(x,N);const U=G.dot(C[S])<0?-1:1;Q.setXYZW(S,u.x,u.y,u.z,U)}for(let S=0,N=w.length;S<N;++S){const H=w[S],U=H.start,m=H.count;for(let J=U,K=U+m;J<K;J+=3)k(A.getX(J+0)),k(A.getX(J+1)),k(A.getX(J+2))}}computeVertexNormals(){const A=this.index,I=this.getAttribute("position");if(I!==void 0){let g=this.getAttribute("normal");if(g===void 0)g=new hg(new Float32Array(I.count*3),3),this.setAttribute("normal",g);else for(let a=0,n=g.count;a<n;a++)g.setXYZ(a,0,0,0);const B=new f,t=new f,Q=new f,i=new f,C=new f,s=new f,o=new f,e=new f;if(A)for(let a=0,n=A.count;a<n;a+=3){const r=A.getX(a+0),D=A.getX(a+1),l=A.getX(a+2);B.fromBufferAttribute(I,r),t.fromBufferAttribute(I,D),Q.fromBufferAttribute(I,l),o.subVectors(Q,t),e.subVectors(B,t),o.cross(e),i.fromBufferAttribute(g,r),C.fromBufferAttribute(g,D),s.fromBufferAttribute(g,l),i.add(o),C.add(o),s.add(o),g.setXYZ(r,i.x,i.y,i.z),g.setXYZ(D,C.x,C.y,C.z),g.setXYZ(l,s.x,s.y,s.z)}else for(let a=0,n=I.count;a<n;a+=3)B.fromBufferAttribute(I,a+0),t.fromBufferAttribute(I,a+1),Q.fromBufferAttribute(I,a+2),o.subVectors(Q,t),e.subVectors(B,t),o.cross(e),g.setXYZ(a+0,o.x,o.y,o.z),g.setXYZ(a+1,o.x,o.y,o.z),g.setXYZ(a+2,o.x,o.y,o.z);this.normalizeNormals(),g.needsUpdate=!0}}normalizeNormals(){const A=this.attributes.normal;for(let I=0,g=A.count;I<g;I++)fA.fromBufferAttribute(A,I),fA.normalize(),A.setXYZ(I,fA.x,fA.y,fA.z)}toNonIndexed(){function A(i,C){const s=i.array,o=i.itemSize,e=i.normalized,a=new s.constructor(C.length*o);let n=0,r=0;for(let D=0,l=C.length;D<l;D++){i.isInterleavedBufferAttribute?n=C[D]*i.data.stride+i.offset:n=C[D]*o;for(let y=0;y<o;y++)a[r++]=s[n++]}return new hg(a,o,e)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const I=new hB,g=this.index.array,B=this.attributes;for(const i in B){const C=B[i],s=A(C,g);I.setAttribute(i,s)}const t=this.morphAttributes;for(const i in t){const C=[],s=t[i];for(let o=0,e=s.length;o<e;o++){const a=s[o],n=A(a,g);C.push(n)}I.morphAttributes[i]=C}I.morphTargetsRelative=this.morphTargetsRelative;const Q=this.groups;for(let i=0,C=Q.length;i<C;i++){const s=Q[i];I.addGroup(s.start,s.count,s.materialIndex)}return I}toJSON(){const A={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(A.uuid=this.uuid,A.type=this.type,this.name!==""&&(A.name=this.name),Object.keys(this.userData).length>0&&(A.userData=this.userData),this.parameters!==void 0){const C=this.parameters;for(const s in C)C[s]!==void 0&&(A[s]=C[s]);return A}A.data={attributes:{}};const I=this.index;I!==null&&(A.data.index={type:I.array.constructor.name,array:Array.prototype.slice.call(I.array)});const g=this.attributes;for(const C in g){const s=g[C];A.data.attributes[C]=s.toJSON(A.data)}const B={};let t=!1;for(const C in this.morphAttributes){const s=this.morphAttributes[C],o=[];for(let e=0,a=s.length;e<a;e++){const n=s[e];o.push(n.toJSON(A.data))}o.length>0&&(B[C]=o,t=!0)}t&&(A.data.morphAttributes=B,A.data.morphTargetsRelative=this.morphTargetsRelative);const Q=this.groups;Q.length>0&&(A.data.groups=JSON.parse(JSON.stringify(Q)));const i=this.boundingSphere;return i!==null&&(A.data.boundingSphere={center:i.center.toArray(),radius:i.radius}),A}clone(){return new this.constructor().copy(this)}copy(A){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const I={};this.name=A.name;const g=A.index;g!==null&&this.setIndex(g.clone(I));const B=A.attributes;for(const s in B){const o=B[s];this.setAttribute(s,o.clone(I))}const t=A.morphAttributes;for(const s in t){const o=[],e=t[s];for(let a=0,n=e.length;a<n;a++)o.push(e[a].clone(I));this.morphAttributes[s]=o}this.morphTargetsRelative=A.morphTargetsRelative;const Q=A.groups;for(let s=0,o=Q.length;s<o;s++){const e=Q[s];this.addGroup(e.start,e.count,e.materialIndex)}const i=A.boundingBox;i!==null&&(this.boundingBox=i.clone());const C=A.boundingSphere;return C!==null&&(this.boundingSphere=C.clone()),this.drawRange.start=A.drawRange.start,this.drawRange.count=A.drawRange.count,this.userData=A.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const SQ=new LA,PI=new CC,cB=new hQ,NQ=new f,DB=new f,lB=new f,yB=new f,lt=new f,dB=new f,pQ=new f,wB=new f;class MQ extends WA{constructor(A=new hB,I=new cC){super(),this.isMesh=!0,this.type="Mesh",this.geometry=A,this.material=I,this.updateMorphTargets()}copy(A,I){return super.copy(A,I),A.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=A.morphTargetInfluences.slice()),A.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},A.morphTargetDictionary)),this.material=Array.isArray(A.material)?A.material.slice():A.material,this.geometry=A.geometry,this}updateMorphTargets(){const I=this.geometry.morphAttributes,g=Object.keys(I);if(g.length>0){const B=I[g[0]];if(B!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let t=0,Q=B.length;t<Q;t++){const i=B[t].name||String(t);this.morphTargetInfluences.push(0),this.morphTargetDictionary[i]=t}}}}getVertexPosition(A,I){const g=this.geometry,B=g.attributes.position,t=g.morphAttributes.position,Q=g.morphTargetsRelative;I.fromBufferAttribute(B,A);const i=this.morphTargetInfluences;if(t&&i){dB.set(0,0,0);for(let C=0,s=t.length;C<s;C++){const o=i[C],e=t[C];o!==0&&(lt.fromBufferAttribute(e,A),Q?dB.addScaledVector(lt,o):dB.addScaledVector(lt.sub(I),o))}I.add(dB)}return I}raycast(A,I){const g=this.geometry,B=this.material,t=this.matrixWorld;B!==void 0&&(g.boundingSphere===null&&g.computeBoundingSphere(),cB.copy(g.boundingSphere),cB.applyMatrix4(t),PI.copy(A.ray).recast(A.near),!(cB.containsPoint(PI.origin)===!1&&(PI.intersectSphere(cB,NQ)===null||PI.origin.distanceToSquared(NQ)>(A.far-A.near)**2))&&(SQ.copy(t).invert(),PI.copy(A.ray).applyMatrix4(SQ),!(g.boundingBox!==null&&PI.intersectsBox(g.boundingBox)===!1)&&this._computeIntersections(A,I,PI)))}_computeIntersections(A,I,g){let B;const t=this.geometry,Q=this.material,i=t.index,C=t.attributes.position,s=t.attributes.uv,o=t.attributes.uv1,e=t.attributes.normal,a=t.groups,n=t.drawRange;if(i!==null)if(Array.isArray(Q))for(let r=0,D=a.length;r<D;r++){const l=a[r],y=Q[l.materialIndex],w=Math.max(l.start,n.start),u=Math.min(i.count,Math.min(l.start+l.count,n.start+n.count));for(let G=w,M=u;G<M;G+=3){const x=i.getX(G),k=i.getX(G+1),S=i.getX(G+2);B=uB(this,y,A,g,s,o,e,x,k,S),B&&(B.faceIndex=Math.floor(G/3),B.face.materialIndex=l.materialIndex,I.push(B))}}else{const r=Math.max(0,n.start),D=Math.min(i.count,n.start+n.count);for(let l=r,y=D;l<y;l+=3){const w=i.getX(l),u=i.getX(l+1),G=i.getX(l+2);B=uB(this,Q,A,g,s,o,e,w,u,G),B&&(B.faceIndex=Math.floor(l/3),I.push(B))}}else if(C!==void 0)if(Array.isArray(Q))for(let r=0,D=a.length;r<D;r++){const l=a[r],y=Q[l.materialIndex],w=Math.max(l.start,n.start),u=Math.min(C.count,Math.min(l.start+l.count,n.start+n.count));for(let G=w,M=u;G<M;G+=3){const x=G,k=G+1,S=G+2;B=uB(this,y,A,g,s,o,e,x,k,S),B&&(B.faceIndex=Math.floor(G/3),B.face.materialIndex=l.materialIndex,I.push(B))}}else{const r=Math.max(0,n.start),D=Math.min(C.count,n.start+n.count);for(let l=r,y=D;l<y;l+=3){const w=l,u=l+1,G=l+2;B=uB(this,Q,A,g,s,o,e,w,u,G),B&&(B.faceIndex=Math.floor(l/3),I.push(B))}}}}function dC(E,A,I,g,B,t,Q,i){let C;if(A.side===vi?C=g.intersectTriangle(Q,t,B,!0,i):C=g.intersectTriangle(B,t,Q,A.side===jB,i),C===null)return null;wB.copy(i),wB.applyMatrix4(E.matrixWorld);const s=I.ray.origin.distanceTo(wB);return s<I.near||s>I.far?null:{distance:s,point:wB.clone(),object:E}}function uB(E,A,I,g,B,t,Q,i,C,s){E.getVertexPosition(i,DB),E.getVertexPosition(C,lB),E.getVertexPosition(s,yB);const o=dC(E,A,I,g,DB,lB,yB,pQ);if(o){const e=new f;eI.getBarycoord(pQ,DB,lB,yB,e),B&&(o.uv=eI.getInterpolatedAttribute(B,i,C,s,e,new zA)),t&&(o.uv1=eI.getInterpolatedAttribute(t,i,C,s,e,new zA)),Q&&(o.normal=eI.getInterpolatedAttribute(Q,i,C,s,e,new f),o.normal.dot(g.direction)>0&&o.normal.multiplyScalar(-1));const a={a:i,b:C,c:s,normal:new f,materialIndex:0};eI.getNormal(DB,lB,yB,a.normal),o.face=a,o.barycoord=e}return o}function wC(E){const A={};for(const I in E){A[I]={};for(const g in E[I]){const B=E[I][g];B&&(B.isColor||B.isMatrix3||B.isMatrix4||B.isVector2||B.isVector3||B.isVector4||B.isTexture||B.isQuaternion)?B.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),A[I][g]=null):A[I][g]=B.clone():Array.isArray(B)?A[I][g]=B.slice():A[I][g]=B}}return A}function uC(E){const A=[];for(let I=0;I<E.length;I++)A.push(E[I].clone());return A}var fC=`void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}`,GC=`void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}`;class FC extends FQ{constructor(A){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=fC,this.fragmentShader=GC,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,A!==void 0&&this.setValues(A)}copy(A){return super.copy(A),this.fragmentShader=A.fragmentShader,this.vertexShader=A.vertexShader,this.uniforms=wC(A.uniforms),this.uniformsGroups=uC(A.uniformsGroups),this.defines=Object.assign({},A.defines),this.wireframe=A.wireframe,this.wireframeLinewidth=A.wireframeLinewidth,this.fog=A.fog,this.lights=A.lights,this.clipping=A.clipping,this.extensions=Object.assign({},A.extensions),this.glslVersion=A.glslVersion,this}toJSON(A){const I=super.toJSON(A);I.glslVersion=this.glslVersion,I.uniforms={};for(const B in this.uniforms){const Q=this.uniforms[B].value;Q&&Q.isTexture?I.uniforms[B]={type:"t",value:Q.toJSON(A).uuid}:Q&&Q.isColor?I.uniforms[B]={type:"c",value:Q.getHex()}:Q&&Q.isVector2?I.uniforms[B]={type:"v2",value:Q.toArray()}:Q&&Q.isVector3?I.uniforms[B]={type:"v3",value:Q.toArray()}:Q&&Q.isVector4?I.uniforms[B]={type:"v4",value:Q.toArray()}:Q&&Q.isMatrix3?I.uniforms[B]={type:"m3",value:Q.toArray()}:Q&&Q.isMatrix4?I.uniforms[B]={type:"m4",value:Q.toArray()}:I.uniforms[B]={value:Q}}Object.keys(this.defines).length>0&&(I.defines=this.defines),I.vertexShader=this.vertexShader,I.fragmentShader=this.fragmentShader,I.lights=this.lights,I.clipping=this.clipping;const g={};for(const B in this.extensions)this.extensions[B]===!0&&(g[B]=!0);return Object.keys(g).length>0&&(I.extensions=g),I}}class kQ extends WA{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new LA,this.projectionMatrix=new LA,this.projectionMatrixInverse=new LA,this.coordinateSystem=Lg}copy(A,I){return super.copy(A,I),this.matrixWorldInverse.copy(A.matrixWorldInverse),this.projectionMatrix.copy(A.projectionMatrix),this.projectionMatrixInverse.copy(A.projectionMatrixInverse),this.coordinateSystem=A.coordinateSystem,this}getWorldDirection(A){return super.getWorldDirection(A).negate()}updateMatrixWorld(A){super.updateMatrixWorld(A),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(A,I){super.updateWorldMatrix(A,I),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class RQ extends WA{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new VI,this.environmentIntensity=1,this.environmentRotation=new VI,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(A,I){return super.copy(A,I),A.background!==null&&(this.background=A.background.clone()),A.environment!==null&&(this.environment=A.environment.clone()),A.fog!==null&&(this.fog=A.fog.clone()),this.backgroundBlurriness=A.backgroundBlurriness,this.backgroundIntensity=A.backgroundIntensity,this.backgroundRotation.copy(A.backgroundRotation),this.environmentIntensity=A.environmentIntensity,this.environmentRotation.copy(A.environmentRotation),A.overrideMaterial!==null&&(this.overrideMaterial=A.overrideMaterial.clone()),this.matrixAutoUpdate=A.matrixAutoUpdate,this}toJSON(A){const I=super.toJSON(A);return this.fog!==null&&(I.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(I.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(I.object.backgroundIntensity=this.backgroundIntensity),I.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(I.object.environmentIntensity=this.environmentIntensity),I.object.environmentRotation=this.environmentRotation.toArray(),I}}class SC extends cI{constructor(A=null,I=1,g=1,B,t,Q,i,C,s=mI,o=mI,e,a){super(null,Q,i,C,s,o,B,t,e,a),this.isDataTexture=!0,this.image={data:A,width:I,height:g},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class fB extends hB{constructor(A=1,I=1,g=1,B=1){super(),this.type="PlaneGeometry",this.parameters={width:A,height:I,widthSegments:g,heightSegments:B};const t=A/2,Q=I/2,i=Math.floor(g),C=Math.floor(B),s=i+1,o=C+1,e=A/i,a=I/C,n=[],r=[],D=[],l=[];for(let y=0;y<o;y++){const w=y*a-Q;for(let u=0;u<s;u++){const G=u*e-t;r.push(G,-w,0),D.push(0,0,1),l.push(u/i),l.push(1-y/C)}}for(let y=0;y<C;y++)for(let w=0;w<i;w++){const u=w+s*y,G=w+s*(y+1),M=w+1+s*(y+1),x=w+1+s*y;n.push(u,G,x),n.push(G,M,x)}this.setIndex(n),this.setAttribute("position",new rB(r,3)),this.setAttribute("normal",new rB(D,3)),this.setAttribute("uv",new rB(l,2))}copy(A){return super.copy(A),this.parameters=Object.assign({},A.parameters),this}static fromJSON(A){return new fB(A.width,A.height,A.widthSegments,A.heightSegments)}}class yt extends FC{constructor(A){super(A),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}const mQ={enabled:!1,files:{},add:function(E,A){this.enabled!==!1&&(this.files[E]=A)},get:function(E){if(this.enabled!==!1)return this.files[E]},remove:function(E){delete this.files[E]},clear:function(){this.files={}}};class NC{constructor(A,I,g){const B=this;let t=!1,Q=0,i=0,C;const s=[];this.onStart=void 0,this.onLoad=A,this.onProgress=I,this.onError=g,this.itemStart=function(o){i++,t===!1&&B.onStart!==void 0&&B.onStart(o,Q,i),t=!0},this.itemEnd=function(o){Q++,B.onProgress!==void 0&&B.onProgress(o,Q,i),Q===i&&(t=!1,B.onLoad!==void 0&&B.onLoad())},this.itemError=function(o){B.onError!==void 0&&B.onError(o)},this.resolveURL=function(o){return C?C(o):o},this.setURLModifier=function(o){return C=o,this},this.addHandler=function(o,e){return s.push(o,e),this},this.removeHandler=function(o){const e=s.indexOf(o);return e!==-1&&s.splice(e,2),this},this.getHandler=function(o){for(let e=0,a=s.length;e<a;e+=2){const n=s[e],r=s[e+1];if(n.global&&(n.lastIndex=0),n.test(o))return r}return null}}}const pC=new NC;class dt{constructor(A){this.manager=A!==void 0?A:pC,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(A,I){const g=this;return new Promise(function(B,t){g.load(A,B,I,t)})}parse(){}setCrossOrigin(A){return this.crossOrigin=A,this}setWithCredentials(A){return this.withCredentials=A,this}setPath(A){return this.path=A,this}setResourcePath(A){return this.resourcePath=A,this}setRequestHeader(A){return this.requestHeader=A,this}}dt.DEFAULT_MATERIAL_NAME="__DEFAULT";const GI={};class MC extends Error{constructor(A,I){super(A),this.response=I}}class kC extends dt{constructor(A){super(A)}load(A,I,g,B){A===void 0&&(A=""),this.path!==void 0&&(A=this.path+A),A=this.manager.resolveURL(A);const t=mQ.get(A);if(t!==void 0)return this.manager.itemStart(A),setTimeout(()=>{I&&I(t),this.manager.itemEnd(A)},0),t;if(GI[A]!==void 0){GI[A].push({onLoad:I,onProgress:g,onError:B});return}GI[A]=[],GI[A].push({onLoad:I,onProgress:g,onError:B});const Q=new Request(A,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),i=this.mimeType,C=this.responseType;fetch(Q).then(s=>{if(s.status===200||s.status===0){if(s.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||s.body===void 0||s.body.getReader===void 0)return s;const o=GI[A],e=s.body.getReader(),a=s.headers.get("X-File-Size")||s.headers.get("Content-Length"),n=a?parseInt(a):0,r=n!==0;let D=0;const l=new ReadableStream({start(y){w();function w(){e.read().then(({done:u,value:G})=>{if(u)y.close();else{D+=G.byteLength;const M=new ProgressEvent("progress",{lengthComputable:r,loaded:D,total:n});for(let x=0,k=o.length;x<k;x++){const S=o[x];S.onProgress&&S.onProgress(M)}y.enqueue(G),w()}},u=>{y.error(u)})}}});return new Response(l)}else throw new MC(`fetch for "${s.url}" responded with ${s.status}: ${s.statusText}`,s)}).then(s=>{switch(C){case"arraybuffer":return s.arrayBuffer();case"blob":return s.blob();case"document":return s.text().then(o=>new DOMParser().parseFromString(o,i));case"json":return s.json();default:if(i===void 0)return s.text();{const e=/charset="?([^;"\\s]*)"?/i.exec(i),a=e&&e[1]?e[1].toLowerCase():void 0,n=new TextDecoder(a);return s.arrayBuffer().then(r=>n.decode(r))}}}).then(s=>{mQ.add(A,s);const o=GI[A];delete GI[A];for(let e=0,a=o.length;e<a;e++){const n=o[e];n.onLoad&&n.onLoad(s)}}).catch(s=>{const o=GI[A];if(o===void 0)throw this.manager.itemError(A),s;delete GI[A];for(let e=0,a=o.length;e<a;e++){const n=o[e];n.onError&&n.onError(s)}this.manager.itemError(A)}).finally(()=>{this.manager.itemEnd(A)}),this.manager.itemStart(A)}setResponseType(A){return this.responseType=A,this}setMimeType(A){return this.mimeType=A,this}}class wt{constructor(A,I,g,B){wt.prototype.isMatrix2=!0,this.elements=[1,0,0,1],A!==void 0&&this.set(A,I,g,B)}identity(){return this.set(1,0,0,1),this}fromArray(A,I=0){for(let g=0;g<4;g++)this.elements[g]=A[g+I];return this}set(A,I,g,B){const t=this.elements;return t[0]=A,t[2]=I,t[1]=g,t[3]=B,this}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Ot}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Ot);const oI=-9,FI=(9-oI)/254,ut=Math.exp(oI),RC=11,mC=11,tA=1<<RC,bI=1<<mC,xQ=1,xC=!0;function Dg(E){return E==="int"||E==="ivec2"||E==="ivec3"||E==="ivec4"}function lg(E){return E==="uint"||E==="uvec2"||E==="uvec3"||E==="uvec4"}function UC(E){return E==="float"||E==="vec2"||E==="vec3"||E==="vec4"}function YC(E){return E==="mat2"||E==="mat2x2"||E==="mat2x3"||E==="mat2x4"||E==="mat3"||E==="mat3x2"||E==="mat3x3"||E==="mat3x4"||E==="mat4"||E==="mat4x2"||E==="mat4x3"||E==="mat4x4"}function GB(E){return UC(E)||YC(E)}function yg(E){return E==="mat2"||E==="mat2x2"}function dg(E){return E==="mat3"||E==="mat3x3"}function wg(E){return E==="mat4"||E==="mat4x4"}function yA(E){return Math.trunc(E).toString()}function dA(E){return`${Math.max(0,Math.trunc(E)).toString()}u`}function gA(E){return E===Number.POSITIVE_INFINITY?"INFINITY":E===Number.NEGATIVE_INFINITY?"-INFINITY":Number.isInteger(E)?E.toFixed(1):E.toString()}function jI(E){return E instanceof _I?E.type:E.dynoOut().type}class _I{constructor(A){this.__isDynoValue=!0,this.type=A}}class jA extends _I{constructor(A,I){super(A.outTypes[I]),this.dyno=A,this.key=I}}class FB extends _I{constructor(A,I){super(A),this.literal=I}getLiteral(){return this.literal}}class JC extends FB{constructor(A,I){super(A,""),this.value=I}getLiteral(){const{type:A,value:I}=this;switch(A){case"bool":return I?"true":"false";case"uint":return dA(I);case"int":return yA(I);case"float":return gA(I);case"bvec2":{const g=I;return`bvec2(${g[0]}, ${g[1]})`}case"uvec2":{if(I instanceof zA)return`uvec2(${dA(I.x)}, ${dA(I.y)})`;const g=I;return`uvec2(${dA(g[0])}, ${dA(g[1])})`}case"ivec2":{if(I instanceof zA)return`ivec2(${yA(I.x)}, ${yA(I.y)})`;const g=I;return`ivec2(${yA(g[0])}, ${yA(g[1])})`}case"vec2":{if(I instanceof zA)return`vec2(${gA(I.x)}, ${gA(I.y)})`;const g=I;return`vec2(${gA(g[0])}, ${gA(g[1])})`}case"bvec3":{const g=I;return`bvec3(${g[0]}, ${g[1]}, ${g[2]})`}case"uvec3":{if(I instanceof f)return`uvec3(${dA(I.x)}, ${dA(I.y)}, ${dA(I.z)})`;const g=I;return`uvec3(${dA(g[0])}, ${dA(g[1])}, ${dA(g[2])})`}case"ivec3":{if(I instanceof f)return`ivec3(${yA(I.x)}, ${yA(I.y)}, ${yA(I.z)})`;const g=I;return`ivec3(${yA(g[0])}, ${yA(g[1])}, ${yA(g[2])})`}case"vec3":{if(I instanceof f)return`vec3(${gA(I.x)}, ${gA(I.y)}, ${gA(I.z)})`;const g=I;return`vec3(${gA(g[0])}, ${gA(g[1])}, ${gA(g[2])})`}case"bvec4":{const g=I;return`bvec4(${g[0]}, ${g[1]}, ${g[2]}, ${g[3]})`}case"uvec4":{if(I instanceof qA)return`uvec4(${dA(I.x)}, ${dA(I.y)}, ${dA(I.z)}, ${dA(I.w)})`;const g=I;return`uvec4(${dA(g[0])}, ${dA(g[1])}, ${dA(g[2])}, ${dA(g[3])})`}case"ivec4":{if(I instanceof qA)return`ivec4(${yA(I.x)}, ${yA(I.y)}, ${yA(I.z)}, ${yA(I.w)})`;const g=I;return`ivec4(${yA(g[0])}, ${yA(g[1])}, ${yA(g[2])}, ${yA(g[3])})`}case"vec4":{if(I instanceof qA)return`vec4(${gA(I.x)}, ${gA(I.y)}, ${gA(I.z)}, ${gA(I.w)})`;if(I instanceof uA)return`vec4(${gA(I.x)}, ${gA(I.y)}, ${gA(I.z)}, ${gA(I.w)})`;const g=I;return`vec4(${gA(g[0])}, ${gA(g[1])}, ${gA(g[2])}, ${gA(g[3])})`}case"mat2":case"mat2x2":{const g=I,B=g instanceof wt?g.elements:I,t=new Array(4).fill(0).map((Q,i)=>gA(B[i]));return`${A}(${t.join(", ")})`}case"mat2x3":{const g=I,B=new Array(6).fill(0).map((t,Q)=>gA(g[Q]));return`${A}(${B.join(", ")})`}case"mat2x4":{const g=I,B=new Array(8).fill(0).map((t,Q)=>gA(g[Q]));return`${A}(${B.join(", ")})`}case"mat3":case"mat3x3":{const g=I,B=g instanceof hI?g.elements:I,t=new Array(9).fill(0).map((Q,i)=>gA(B[i]));return`${A}(${t.join(", ")})`}case"mat3x2":{const g=I,B=new Array(6).fill(0).map((t,Q)=>gA(g[Q]));return`${A}(${B.join(", ")})`}case"mat3x4":{const g=I,B=new Array(12).fill(0).map((t,Q)=>gA(g[Q]));return`${A}(${B.join(", ")})`}case"mat4":case"mat4x4":{const g=I,B=g instanceof LA?g.elements:I,t=new Array(16).fill(0).map((Q,i)=>gA(B[i]));return`${A}(${t.join(", ")})`}case"mat4x2":{const g=I,B=new Array(8).fill(0).map((t,Q)=>gA(g[Q]));return`${A}(${B.join(", ")})`}case"mat4x3":{const g=I,B=new Array(12).fill(0).map((t,Q)=>gA(g[Q]));return`${A}(${B.join(", ")})`}default:throw new Error(`Type not implemented: ${String(A)}`)}}}function LC(E,A){return new JC(E,A)}const UQ="    ";class HC{constructor({indent:A}={}){this.globals=new Set,this.statements=[],this.uniforms={},this.declares=new Set,this.updaters=[],this.sequence=0,this.indent=UQ,this.indent=A??UQ}nextSequence(){return this.sequence++}}class bA{constructor({inTypes:A,outTypes:I,inputs:g,update:B,globals:t,statements:Q,generate:i}){this.inTypes=A??{},this.outTypes=I??{},this.inputs=g??{},this.update=B,this.globals=t,this.statements=Q,this.generate=i??(({inputs:C,outputs:s,compile:o})=>{var e,a;return{globals:(e=this.globals)==null?void 0:e.call(this,{inputs:C,outputs:s,compile:o}),statements:(a=this.statements)==null?void 0:a.call(this,{inputs:C,outputs:s,compile:o})}})}get outputs(){const A={};for(const I in this.outTypes)A[I]=new jA(this,I);return A}apply(A){return Object.assign(this.inputs,A),this.outputs}compile({inputs:A,outputs:I,compile:g}){const B=[`// ${this.constructor.name}(${Object.values(A).join(", ")}) => (${Object.values(I).join(", ")})`],t=[];for(const s in I){const o=I[s];o&&!g.declares.has(o)&&(g.declares.add(o),t.push(s))}const{globals:Q,statements:i,uniforms:C}=this.generate({inputs:A,outputs:I,compile:g});for(const s of Q??[])g.globals.add(s);for(const s in C)g.uniforms[s]=C[s];this.update&&g.updaters.push(this.update);for(const s of t){const o=I[s];o&&(g.uniforms[o]||B.push(`${YQ(o,this.outTypes[s])};`))}return i!=null&&i.length&&(B.push("{"),B.push(...i.map(s=>g.indent+s)),B.push("}")),B}}class bC extends bA{constructor({inTypes:A,outTypes:I,inputs:g,update:B,globals:t,construct:Q}){super({inTypes:A,outTypes:I,inputs:g,update:B,globals:t,generate:i=>this.generateBlock(i)}),this.construct=Q}generateBlock({inputs:A,outputs:I,compile:g}){var r,D;const B={},t={};for(const l in A)A[l]!=null&&(B[l]=new FB(this.inTypes[l],A[l]));for(const l in I)I[l]!=null&&(t[l]=new _I(this.outTypes[l]));const Q={roots:[]},i=this.construct(B,t,Q);for(const l of((r=this.globals)==null?void 0:r.call(this,{inputs:A,outputs:I,compile:g}))??[])g.globals.add(l);const C=[],s=new Map;function o(l,y,w){let u=s.get(l);if(!u){u={sequence:g.nextSequence(),outNames:new Map,newOuts:new Set},s.set(l,u);for(const G in l.inputs){let M=l.inputs[G];for(;M;){if(M instanceof _I){M instanceof jA&&o(M.dyno,M.key);break}M=M.dynoOut()}}C.push(l)}y&&(w||u.newOuts.add(y),u.outNames.set(y,w??`${y}_${u.sequence}`))}for(const l of Q.roots)o(l);for(const l in t){let y=(i==null?void 0:i[l])??t[l];for(;y;){if(y instanceof _I){y instanceof jA&&o(y.dyno,y.key,I[l]);break}y=y.dynoOut()}t[l]=y}const e=[];for(const l of C){const y={},w={};for(const M in l.inputs){let x=l.inputs[M];for(;x;){if(x instanceof _I){if(x instanceof FB)y[M]=x.getLiteral();else if(x instanceof jA){const k=(D=s.get(x.dyno))==null?void 0:D.outNames.get(x.key);if(!k)throw new Error(`Source not found for ${x.dyno.constructor.name}.${x.key}`);y[M]=k}break}x=x.dynoOut()}}const u=s.get(l)??{outNames:new Map};for(const[M,x]of u.outNames.entries())w[M]=x;const G=l.compile({inputs:y,outputs:w,compile:g});e.push(G)}const a=[];for(const l in I)t[l]instanceof FB&&a.push(`${I[l]} = ${t[l].getLiteral()};`);return a.length>0&&e.push(a),{statements:e.flatMap((l,y)=>y===0?l:["",...l])}}}function SB(E,A,I,{update:g,globals:B}={}){return new bC({inTypes:E,outTypes:A,construct:I,update:g,globals:B})}function ft({inTypes:E,outTypes:A,inputs:I,update:g,globals:B,statements:t,generate:Q}){return new bA({inTypes:E,outTypes:A,inputs:I,update:g,globals:B,statements:t,generate:Q})}function YQ(E,A,I){const g=typeof A=="string"?A:A.type;if(!g)throw new Error(`Invalid DynoType: ${String(A)}`);return`${g} ${E}${I!=null?`[${I}]`:""}`}function SI(E){var t;let A=!1;const I=E.split(`\n`).map(Q=>{const i=Q.trimEnd();return A?i:i.length>0?(A=!0,i):null}).filter(Q=>Q!=null);for(;I.length>0&&I[I.length-1].length===0;)I.pop();if(I.length===0)return[];const g=(t=I[0].match(/^\\s*/))==null?void 0:t[0];if(!g)return I;const B=new RegExp(`^${g}`);return I.map(Q=>Q.replace(B,""))}function aI(E){return SI(E).join(`\n`)}class KC extends bA{constructor({a:A,outKey:I,outTypeFunc:g}){const B={a:jI(A)},t=g(jI(A)),Q={[I]:t};super({inTypes:B,outTypes:Q,inputs:{a:A}}),this.outKey=I}dynoOut(){return new jA(this,this.outKey)}}class NB extends bA{constructor({a:A,b:I,outKey:g,outTypeFunc:B}){const t={a:jI(A),b:jI(I)},Q=B(jI(A),jI(I)),i={[g]:Q};super({inTypes:t,outTypes:i,inputs:{a:A,b:I}}),this.outKey=g}dynoOut(){return new jA(this,this.outKey)}}const Gt=new Float32Array(1),JQ=new Uint32Array(Gt.buffer);function ug(E){Gt[0]=E;const A=JQ[0],I=A>>31&1,g=A>>23&255,B=A&8388607,t=I<<15;if(g===255)return B!==0?t|32767:t|31744;const Q=g-127+15;if(Q>=31)return t|31744;if(Q<=0){if(Q<-10)return t;const C=(B|8388608)>>1-Q+13;return t|C}const i=B>>13;return t|Q<<10|i}function aA(E){const A=E>>15&1,I=E>>10&31,g=E&1023;let B;if(I===0)if(g===0)B=A<<31;else{let t=g,Q=-14;for(;(t&1024)===0;)t<<=1,Q--;t&=1023;const i=Q+127,C=t<<13;B=A<<31|i<<23|C}else if(I===31)g===0?B=A<<31|2139095040:B=A<<31|2143289344;else{const t=I-15+127,Q=g<<13;B=A<<31|t<<23|Q}return JQ[0]=B,Gt[0]}function gI(E){return Math.max(0,Math.min(255,Math.round(E*255)))}function LQ(E){const A=[],I=new Set;function g(B){B&&typeof B=="object"&&!I.has(B)&&(I.add(B),B instanceof ArrayBuffer?A.push(B):ArrayBuffer.isView(B)?A.push(B.buffer):Array.isArray(B)?B.forEach(g):Object.values(B).forEach(g))}return g(E),A}function Wg(E,A,I,g,B,t,Q,i,C,s,o,e,a,n,r,D){const l=gI(n),y=gI(r),w=gI(D),u=gI(a),G=TQ(new uA(C,s,o,e)),M=G&255,x=G>>>8&255,k=G>>>16&255,S=t===0?0:Math.min(255,Math.max(0,Math.round((Math.log(t)-oI)/FI)+1)),N=Q===0?0:Math.min(255,Math.max(0,Math.round((Math.log(Q)-oI)/FI)+1)),H=i===0?0:Math.min(255,Math.max(0,Math.round((Math.log(i)-oI)/FI)+1)),U=ug(I),m=ug(g),J=ug(B),K=A*4;E[K]=l|y<<8|w<<16|u<<24,E[K+1]=U|m<<16,E[K+2]=J|M<<16|x<<24,E[K+3]=S|N<<8|H<<16|k<<24}function HQ(E,A,I,g,B){const t=ug(I),Q=ug(g),i=ug(B),C=A*4;E[C+1]=t|Q<<16,E[C+2]=i|E[C+2]&4294901760}function bQ(E,A,I,g,B){const t=I===0?0:Math.min(255,Math.max(0,Math.round((Math.log(I)-oI)/FI)+1)),Q=g===0?0:Math.min(255,Math.max(0,Math.round((Math.log(g)-oI)/FI)+1)),i=B===0?0:Math.min(255,Math.max(0,Math.round((Math.log(B)-oI)/FI)+1)),C=A*4;E[C+3]=t|Q<<8|i<<16|E[C+3]&4278190080}function KQ(E,A,I,g,B,t){const Q=TQ(new uA(I,g,B,t)),i=Q&255,C=Q>>>8&255,s=Q>>>16&255,o=A*4;E[o+2]=E[o+2]&65535|i<<16|C<<24,E[o+3]=E[o+3]&16777215|s<<24}function qC(E,A,I,g,B,t){const Q=gI(I),i=gI(g),C=gI(B),s=gI(t),o=A*4;E[o]=Q|i<<8|C<<16|s<<24}function TC(E,A,I,g,B){const t=gI(I),Q=gI(g),i=gI(B),C=A*4;E[C]=t|Q<<8|i<<16|E[C]&4278190080}function ZC(E,A,I){const g=gI(I),B=A*4;E[B]=E[B]&16777215|g<<24}const zC=new f,WC=new f,vC=new uA,OC=new XI,VC={center:zC,scales:WC,quaternion:vC,color:OC,opacity:0};function qQ(E,A){const I=VC,g=A*4,B=E[g],t=E[g+1],Q=E[g+2],i=E[g+3];I.color.set((B&255)/255,(B>>>8&255)/255,(B>>>16&255)/255),I.opacity=(B>>>24&255)/255,I.center.set(aA(t&65535),aA(t>>>16&65535),aA(Q&65535));const C=i&255;I.scales.x=C===0?0:Math.exp(oI+(C-1)*FI);const s=i>>>8&255;I.scales.y=s===0?0:Math.exp(oI+(s-1)*FI);const o=i>>>16&255;I.scales.z=o===0?0:Math.exp(oI+(o-1)*FI);const e=Q>>>16&65535|i>>>8&16711680;return PC(e,I.quaternion),I}function _A(E){const A=tA,I=Math.max(xQ,Math.min(bI,Math.ceil(E/A))),g=Math.ceil(E/(A*I)),B=A*I*g;return{width:A,height:I,depth:g,maxSplats:B}}function pB(E){const A=tA,I=Math.max(xQ,Math.min(bI,Math.ceil(E/A))),g=Math.ceil(E/(A*I));return A*I*g}const XC=aI(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);function TQ(E){const A=E.clone().normalize();A.w<0&&A.set(-A.x,-A.y,-A.z,-A.w);const I=2*Math.acos(A.w),g=Math.sqrt(A.x*A.x+A.y*A.y+A.z*A.z),B=g<1e-6?new f(1,0,0):new f(A.x,A.y,A.z).divideScalar(g),t=Math.abs(B.x)+Math.abs(B.y)+Math.abs(B.z);let Q=B.x/t,i=B.y/t;if(B.z<0){const n=Q;Q=(1-Math.abs(i))*(Q>=0?1:-1),i=(1-Math.abs(n))*(i>=0?1:-1)}const C=Q*.5+.5,s=i*.5+.5,o=Math.round(C*255),e=Math.round(s*255);return Math.round(I*(255/Math.PI))<<16|e<<8|o}function PC(E,A){const I=E&255,g=E>>>8&255,B=E>>>16&255,t=I/255,Q=g/255;let i=(t-.5)*2,C=(Q-.5)*2;const s=1-(Math.abs(i)+Math.abs(C)),o=Math.max(-s,0);i+=i>=0?-o:o,C+=C>=0?-o:o;const e=new f(i,C,s).normalize(),n=B/255*Math.PI*.5,r=Math.sin(n),D=Math.cos(n);return A.set(e.x*r,e.y*r,e.z*r,D),A}function MB(E,A,I,g){const B=Math.max(-127,Math.min(127,E*127)),t=Math.max(-127,Math.min(127,A*127)),Q=Math.max(-127,Math.min(127,I*127)),i=Math.max(-127,Math.min(127,g*127));return B&255|(t&255)<<8|(Q&255)<<16|(i&255)<<24}function kB(E,A,I){const g=A*2;for(let B=0;B<9;++B){const t=Math.max(-63,Math.min(63,I[B]*63))&127,Q=B*7,i=Q+7,C=Math.floor(Q/32),s=Q-C*32,o=t<<s&4294967295;if(E[g+C]|=o,i>C*32+32){const e=t>>>32-s&4294967295;E[g+C+1]|=e}}}function RB(E,A,I){E[A*4+0]=MB(I[0],I[1],I[2],I[3]),E[A*4+1]=MB(I[4],I[5],I[6],I[7]),E[A*4+2]=MB(I[8],I[9],I[10],I[11]),E[A*4+3]=MB(I[12],I[13],I[14],0)}function mB(E,A,I){const g=A*4;for(let B=0;B<21;++B){const t=Math.max(-31,Math.min(31,I[B]*31))&63,Q=B*6,i=Q+6,C=Math.floor(Q/32),s=Q-C*32,o=t<<s&4294967295;if(E[g+C]|=o,i>C*32+32){const e=t>>>32-s&4294967295;E[g+C+1]|=e}}}function jC(E,A){const I=[];let g=0,B=null;const t=new vt((C,s)=>{if(I.push(C),g+=C.length,s||g>=A){const o=new Uint8Array(g);let e=0;for(const a of I)o.set(a,e),e+=a.length;B=o.slice(0,A)}}),Q=1024;let i=0;for(;B==null&&i<E.length;){const C=E.slice(i,i+Q);t.push(C,!1),i+=Q}if(B==null&&(t.push(new Uint8Array,!0),B==null))throw new Error("Failed to decompress partial gzip");return B}class _C{constructor({fileBytes:A,chunkBytes:I=64*1024}){this.fileBytes=A,this.chunkBytes=I,this.offset=0,this.chunks=[],this.totalBytes=0,this.gunzip=new vt((g,B)=>{this.chunks.push(g),this.totalBytes+=g.length})}read(A){for(;this.totalBytes<A&&this.offset<this.fileBytes.length;){const t=Math.min(this.offset+this.chunkBytes,this.fileBytes.length);this.gunzip.push(this.fileBytes.subarray(this.offset,t),!1),this.offset=t}if(this.totalBytes<A&&this.offset>=this.fileBytes.length&&this.gunzip.push(new Uint8Array(0),!0),this.totalBytes<A)throw new Error(`Unexpected EOF: needed ${A}, got ${this.totalBytes}`);const I=new Uint8Array(this.totalBytes);let g=0;for(const t of this.chunks)I.set(t,g),g+=t.length;const B=I.subarray(0,A);return this.chunks=[I.subarray(A)],this.totalBytes-=A,B}}function ZQ(E,A,I){const g=Math.floor(E.length/32);if(g*32!==E.length)throw new Error("Invalid .splat file size");A(g);const B=new Float32Array(E.buffer);for(let t=0;t<g;++t){const Q=t*32,i=t*8,C=B[i+0],s=B[i+1],o=B[i+2],e=B[i+3],a=B[i+4],n=B[i+5],r=E[Q+24]/255,D=E[Q+25]/255,l=E[Q+26]/255,y=E[Q+27]/255,w=(E[Q+28]-128)/128,u=(E[Q+29]-128)/128,G=(E[Q+30]-128)/128,M=(E[Q+31]-128)/128;I(t,C,s,o,e,a,n,u,G,M,w,y,r,D,l)}}function $C(E){let A=0,I=0,g=new Uint32Array(0);return ZQ(E,B=>{A=B,I=pB(A),g=new Uint32Array(I*4)},(B,t,Q,i,C,s,o,e,a,n,r,D,l,y,w)=>{Wg(g,B,t,Q,i,C,s,o,e,a,n,r,D,l,y,w)}),{packedArray:g,numSplats:A}}const xB={0:{bytesPerCenter:12,bytesPerScale:12,bytesPerRotation:16,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:4,scaleOffsetBytes:12,rotationOffsetBytes:24,colorOffsetBytes:40,sphericalHarmonicsOffsetBytes:44,scaleRange:1},1:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:2,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767},2:{bytesPerCenter:6,bytesPerScale:6,bytesPerRotation:8,bytesPerColor:4,bytesPerSphericalHarmonicsComponent:1,scaleOffsetBytes:6,rotationOffsetBytes:12,colorOffsetBytes:20,sphericalHarmonicsOffsetBytes:24,scaleRange:32767}},zQ={0:0,1:9,2:24,3:45};function AE(E,A,I,g){var D;let Q=0;const i=new DataView(E.buffer,Q,4096);Q+=4096;const C=i.getUint8(0),s=i.getUint8(1);if(C!==0||s<1)throw new Error(`Unsupported .ksplat version: ${C}.${s}`);const o=i.getUint32(4,!0);i.getUint32(16,!0);const e=i.getUint16(20,!0);if(e<0||e>2)throw new Error(`Invalid .ksplat compression level: ${e}`);const a=i.getFloat32(36,!0)||-1.5,n=i.getFloat32(40,!0)||1.5;let r=4096+o*1024;for(let l=0;l<o;++l){let y=function(hA,P){if(e===0)return X.getFloat32(hA+O+P*4,!0);if(e===1)return aA(X.getUint16(hA+O+P*2,!0));const sA=X.getUint8(hA+O+P)/255;return a+sA*(n-a)};const w=new DataView(E.buffer,Q,1024);Q+=1024;const u=w.getUint32(0,!0),G=w.getUint32(4,!0),M=w.getUint32(8,!0),x=w.getUint32(12,!0),k=w.getFloat32(16,!0),S=w.getUint16(20,!0),N=(w.getUint32(24,!0)||((D=xB[e])==null?void 0:D.scaleRange))??1,H=w.getUint32(32,!0),U=H*M,m=w.getUint32(36,!0),J=m*4,K=S*x+J,z=w.getUint16(40,!0),T=zQ[z],{bytesPerCenter:W,bytesPerScale:BA,bytesPerRotation:AA,bytesPerColor:CA,bytesPerSphericalHarmonicsComponent:QA,scaleOffsetBytes:EA,rotationOffsetBytes:IA,colorOffsetBytes:_,sphericalHarmonicsOffsetBytes:O}=xB[e],v=W+BA+AA+CA+T*QA,Z=v*G,RA=Z+K,SA=[0,3,6,1,4,7,2,5,8],NA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],mA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],xA=z>=1?new Float32Array(3*3):void 0,nA=z>=2?new Float32Array(5*3):void 0,OA=z>=3?new Float32Array(7*3):void 0,KA=k/2/N,TA=r+J,VA=r+K,X=new DataView(E.buffer,VA,Z),rA=new Float32Array(E.buffer,TA,x*3),V=new Uint32Array(E.buffer,r,m);let nI=H,TI=U;for(let hA=0;hA<u;++hA){const P=hA*v;let sA;if(hA<U)sA=Math.floor(hA/M);else{const lA=V[nI-H];hA>=TI+lA&&(nI+=1,TI+=lA),sA=nI}const q=e===0?X.getFloat32(P+0,!0):(X.getUint16(P+0,!0)-N)*KA+rA[3*sA+0],pA=e===0?X.getFloat32(P+4,!0):(X.getUint16(P+2,!0)-N)*KA+rA[3*sA+1],$A=e===0?X.getFloat32(P+8,!0):(X.getUint16(P+4,!0)-N)*KA+rA[3*sA+2],DI=e===0?X.getFloat32(P+EA+0,!0):aA(X.getUint16(P+EA+0,!0)),$I=e===0?X.getFloat32(P+EA+4,!0):aA(X.getUint16(P+EA+2,!0)),jg=e===0?X.getFloat32(P+EA+8,!0):aA(X.getUint16(P+EA+4,!0)),_g=e===0?X.getFloat32(P+IA+0,!0):aA(X.getUint16(P+IA+0,!0)),$g=e===0?X.getFloat32(P+IA+4,!0):aA(X.getUint16(P+IA+2,!0)),Ag=e===0?X.getFloat32(P+IA+8,!0):aA(X.getUint16(P+IA+4,!0)),pg=e===0?X.getFloat32(P+IA+12,!0):aA(X.getUint16(P+IA+6,!0)),UA=X.getUint8(P+_+0)/255,Mg=X.getUint8(P+_+1)/255,kg=X.getUint8(P+_+2)/255,AB=X.getUint8(P+_+3)/255;if(I(hA,q,pA,$A,DI,$I,jg,$g,Ag,pg,_g,AB,UA,Mg,kg),z>=1&&xA){for(const[lA,MI]of SA.entries())xA[lA]=y(P,MI);if(nA)for(const[lA,MI]of NA.entries())nA[lA]=y(P,MI);if(OA)for(const[lA,MI]of mA.entries())OA[lA]=y(P,MI);g==null||g(hA,xA,nA,OA)}}r+=RA}}function IE(E){var y;let g=0;const B=new DataView(E.buffer,g,4096);g+=4096;const t=B.getUint8(0),Q=B.getUint8(1);if(t!==0||Q<1)throw new Error(`Unsupported .ksplat version: ${t}.${Q}`);const i=B.getUint32(4,!0),C=B.getUint32(16,!0),s=B.getUint16(20,!0);if(s<0||s>2)throw new Error(`Invalid .ksplat compression level: ${s}`);const o=B.getFloat32(36,!0)||-1.5,e=B.getFloat32(40,!0)||1.5,a=C,n=pB(a),r=new Uint32Array(n*4),D={};let l=4096+i*1024;for(let w=0;w<i;++w){let u=function(sA,q){if(s===0)return V.getFloat32(sA+Z+q*4,!0);if(s===1)return aA(V.getUint16(sA+Z+q*2,!0));const pA=V.getUint8(sA+Z+q)/255;return o+pA*(e-o)};const G=new DataView(E.buffer,g,1024);g+=1024;const M=G.getUint32(0,!0),x=G.getUint32(4,!0),k=G.getUint32(8,!0),S=G.getUint32(12,!0),N=G.getFloat32(16,!0),H=G.getUint16(20,!0),U=(G.getUint32(24,!0)||((y=xB[s])==null?void 0:y.scaleRange))??1,m=G.getUint32(32,!0),J=m*k,K=G.getUint32(36,!0),z=K*4,T=H*S+z,W=G.getUint16(40,!0),BA=zQ[W],{bytesPerCenter:AA,bytesPerScale:CA,bytesPerRotation:QA,bytesPerColor:EA,bytesPerSphericalHarmonicsComponent:IA,scaleOffsetBytes:_,rotationOffsetBytes:O,colorOffsetBytes:v,sphericalHarmonicsOffsetBytes:Z}=xB[s],RA=AA+CA+QA+EA+BA*IA,SA=RA*x,NA=SA+T,mA=[0,3,6,1,4,7,2,5,8],xA=[9,14,19,10,15,20,11,16,21,12,17,22,13,18,23],nA=[24,31,38,25,32,39,26,33,40,27,34,41,28,35,42,29,36,43,30,37,44],OA=W>=1?new Float32Array(3*3):void 0,KA=W>=2?new Float32Array(5*3):void 0,TA=W>=3?new Float32Array(7*3):void 0,VA=N/2/U,X=l+z,rA=l+T,V=new DataView(E.buffer,rA,SA),nI=new Float32Array(E.buffer,X,S*3),TI=new Uint32Array(E.buffer,l,K);let hA=m,P=J;for(let sA=0;sA<M;++sA){const q=sA*RA;let pA;if(sA<J)pA=Math.floor(sA/k);else{const BI=TI[hA-m];sA>=P+BI&&(hA+=1,P+=BI),pA=hA}const $A=s===0?V.getFloat32(q+0,!0):(V.getUint16(q+0,!0)-U)*VA+nI[3*pA+0],DI=s===0?V.getFloat32(q+4,!0):(V.getUint16(q+2,!0)-U)*VA+nI[3*pA+1],$I=s===0?V.getFloat32(q+8,!0):(V.getUint16(q+4,!0)-U)*VA+nI[3*pA+2],jg=s===0?V.getFloat32(q+_+0,!0):aA(V.getUint16(q+_+0,!0)),_g=s===0?V.getFloat32(q+_+4,!0):aA(V.getUint16(q+_+2,!0)),$g=s===0?V.getFloat32(q+_+8,!0):aA(V.getUint16(q+_+4,!0)),Ag=s===0?V.getFloat32(q+O+0,!0):aA(V.getUint16(q+O+0,!0)),pg=s===0?V.getFloat32(q+O+4,!0):aA(V.getUint16(q+O+2,!0)),UA=s===0?V.getFloat32(q+O+8,!0):aA(V.getUint16(q+O+4,!0)),Mg=s===0?V.getFloat32(q+O+12,!0):aA(V.getUint16(q+O+6,!0)),kg=V.getUint8(q+v+0)/255,AB=V.getUint8(q+v+1)/255,lA=V.getUint8(q+v+2)/255,MI=V.getUint8(q+v+3)/255;if(Wg(r,sA,$A,DI,$I,jg,_g,$g,pg,UA,Mg,Ag,MI,kg,AB,lA),W>=1){if(OA){D.sh1||(D.sh1=new Uint32Array(a*2));for(const[BI,YA]of mA.entries())OA[BI]=u(q,YA);kB(D.sh1,sA,OA)}if(KA){D.sh2||(D.sh2=new Uint32Array(a*4));for(const[BI,YA]of xA.entries())KA[BI]=u(q,YA);RB(D.sh2,sA,KA)}if(TA){D.sh3||(D.sh3=new Uint32Array(a*4));for(const[BI,YA]of nA.entries())TA[BI]=u(q,YA);mB(D.sh3,sA,TA)}}}l+=NA}return{packedArray:r,numSplats:a,extra:D}}function gE(E,A,I={}){let g;return A&&(g=(B,t)=>{const Q=new WebAssembly.Instance(A,B);return t(Q),Q.exports}),E({noInitialRun:!0,instantiateWasm:g,...I})}var BE=(()=>{var E=self.location.href;return function(I={}){var I=typeof I<"u"?I:{},g,B;I.ready=new Promise(function(h,c){g=h,B=c});const Q=globalThis.ServiceWorkerGlobalScope!==void 0&&typeof self<"u"&&globalThis.caches&&globalThis.caches.default!==void 0,i=typeof process=="object"&&process.release&&process.release.name==="node";(Q||i)&&(globalThis.ImageData||(globalThis.ImageData=class{constructor(c,d,F){this.data=c,this.width=d,this.height=F}}),self.location.href===void 0&&(self.location.href="https://localhost"),typeof self<"u"&&self.location===void 0&&(self.location={href:""}));var C=Object.assign({},I),s=typeof window=="object",o=typeof importScripts=="function";typeof process=="object"&&typeof process.versions=="object"&&process.versions.node;var e="";function a(h){return I.locateFile?I.locateFile(h,e):e+h}var n;(s||o)&&(o?e=self.location.href:typeof document<"u"&&document.currentScript&&(e=document.currentScript.src),E&&(e=E),e.indexOf("blob:")!==0?e=e.substr(0,e.replace(/[?#].*/,"").lastIndexOf("/")+1):e="",o&&(n=h=>{var c=new XMLHttpRequest;return c.open("GET",h,!1),c.responseType="arraybuffer",c.send(null),new Uint8Array(c.response)})),I.print||console.log.bind(console);var r=I.printErr||console.warn.bind(console);Object.assign(I,C),C=null,I.arguments&&I.arguments,I.thisProgram&&I.thisProgram,I.quit&&I.quit;var D;I.wasmBinary&&(D=I.wasmBinary),I.noExitRuntime,typeof WebAssembly!="object"&&NA("no native wasm support detected");var l,y=!1;function w(h,c,d){for(var F=c+d,p="";!(c>=F);){var R=h[c++];if(!R)return p;if(!(R&128)){p+=String.fromCharCode(R);continue}var L=h[c++]&63;if((R&224)==192){p+=String.fromCharCode((R&31)<<6|L);continue}var Y=h[c++]&63;if((R&240)==224?R=(R&15)<<12|L<<6|Y:R=(R&7)<<18|L<<12|Y<<6|h[c++]&63,R<65536)p+=String.fromCharCode(R);else{var b=R-65536;p+=String.fromCharCode(55296|b>>10,56320|b&1023)}}return p}function u(h,c){return h?w(S,h,c):""}function G(h,c,d,F){if(!(F>0))return 0;for(var p=d,R=d+F-1,L=0;L<h.length;++L){var Y=h.charCodeAt(L);if(Y>=55296&&Y<=57343){var b=h.charCodeAt(++L);Y=65536+((Y&1023)<<10)|b&1023}if(Y<=127){if(d>=R)break;c[d++]=Y}else if(Y<=2047){if(d+1>=R)break;c[d++]=192|Y>>6,c[d++]=128|Y&63}else if(Y<=65535){if(d+2>=R)break;c[d++]=224|Y>>12,c[d++]=128|Y>>6&63,c[d++]=128|Y&63}else{if(d+3>=R)break;c[d++]=240|Y>>18,c[d++]=128|Y>>12&63,c[d++]=128|Y>>6&63,c[d++]=128|Y&63}}return c[d]=0,d-p}function M(h,c,d){return G(h,S,c,d)}function x(h){for(var c=0,d=0;d<h.length;++d){var F=h.charCodeAt(d);F<=127?c++:F<=2047?c+=2:F>=55296&&F<=57343?(c+=4,++d):c+=3}return c}var k,S,N,H,U,m,J,K;function z(){var h=l.buffer;I.HEAP8=k=new Int8Array(h),I.HEAP16=N=new Int16Array(h),I.HEAP32=U=new Int32Array(h),I.HEAPU8=S=new Uint8Array(h),I.HEAPU16=H=new Uint16Array(h),I.HEAPU32=m=new Uint32Array(h),I.HEAPF32=J=new Float32Array(h),I.HEAPF64=K=new Float64Array(h)}var T,W=[],BA=[],AA=[];function CA(){if(I.preRun)for(typeof I.preRun=="function"&&(I.preRun=[I.preRun]);I.preRun.length;)IA(I.preRun.shift());rA(W)}function QA(){rA(BA)}function EA(){if(I.postRun)for(typeof I.postRun=="function"&&(I.postRun=[I.postRun]);I.postRun.length;)O(I.postRun.shift());rA(AA)}function IA(h){W.unshift(h)}function _(h){BA.unshift(h)}function O(h){AA.unshift(h)}var v=0,Z=null;function RA(h){v++,I.monitorRunDependencies&&I.monitorRunDependencies(v)}function SA(h){if(v--,I.monitorRunDependencies&&I.monitorRunDependencies(v),v==0&&Z){var c=Z;Z=null,c()}}function NA(h){I.onAbort&&I.onAbort(h),h="Aborted("+h+")",r(h),y=!0,h+=". Build with -sASSERTIONS for more info.";var c=new WebAssembly.RuntimeError(h);throw B(c),c}var mA="data:application/octet-stream;base64,";function xA(h){return h.startsWith(mA)}var nA;I.locateFile?(nA="webp_dec.wasm",xA(nA)||(nA=a(nA))):nA=new URL("data:application/wasm;base64,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AiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAvyAgICfwF+AkAgAkUNACAAIAE6AAAgACACaiIDQQFrIAE6AAAgAkEDSQ0AIAAgAToAAiAAIAE6AAEgA0EDayABOgAAIANBAmsgAToAACACQQdJDQAgACABOgADIANBBGsgAToAACACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkEEayABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBCGsgATYCACACQQxrIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQRBrIAE2AgAgAkEUayABNgIAIAJBGGsgATYCACACQRxrIAE2AgAgBCADQQRxQRhyIgRrIgJBIEkNACABrUKBgICAEH4hBSADIARqIQEDQCABIAU3AxggASAFNwMQIAEgBTcDCCABIAU3AwAgAUEgaiEBIAJBIGsiAkEfSw0ACwsgAAuXKQELfyMAQRBrIgskAAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQaDbACgCACIGQRAgAEELakF4cSAAQQtJGyIFQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiAkEDdCIBQcjbAGoiACABQdDbAGooAgAiASgCCCIERgRAQaDbACAGQX4gAndxNgIADAELIAQgADYCDCAAIAQ2AggLIAFBCGohACABIAJBA3QiAkEDcjYCBCABIAJqIgEgASgC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A39BBCECAn8gACABckEDcUUEQEEAIAAoAgAgASgCAEYNARoLAkADQCAALQAAIgMgAS0AACIERw0BIAFBAWohASAAQQFqIQAgAkEBayICDQALQQAPCyADIARrCwt0AQF/IAJFBEAgACgCBCABKAIERg8LIAAgAUYEQEEBDwsgASgCBCICLQAAIQECQCAAKAIEIgMtAAAiAEUNACAAIAFHDQADQCACLQABIQEgAy0AASIARQ0BIAJBAWohAiADQQFqIQMgACABRg0ACwsgACABRgv/AwERfyABQQNsIQ5BACABayEPIAFBfWwhEEEAIAFBAnRrIRFBACABQQF0IhJrIRMgBEEBdEEBciEUA0AgAyEEAkAgACATaiIKLQAAIgggACABaiIMLQAAIgtrIhVB78kAai0AACAAIA9qIg0tAAAiAyAALQAAIglrQe/JAGotAABBAnRqIBRKDQAgACARai0AACAAIBBqLQAAIgdrQe/JAGotAAAgBUoNACAHIAhrQe/JAGotAAAgBUoNACAIIANrQe/JAGotAAAiFiAFSg0AIAAgDmotAAAgACASai0AACIHa0HvyQBqLQAAIAVKDQAgByALa0HvyQBqLQAAIAVKDQAgCyAJa0HvyQBqLQAAIhcgBUoNACAJIANrQQNsIQcCfyAGIBZOIAYgF05xRQRAIA0gAyAHIBVB/DdqLAAAaiIDQQNqQQN1QfDAAGosAABqQe/DAGotAAA6AAAgACEMIAkgA0EEakEDdUHwwABqLAAAawwBCyAKIAggB0EEakEDdUHwwABqLAAAIghBAWpBAXUiCmpB78MAai0AADoAACANIAdBA2pBA3VB8MAAaiwAACADakHvwwBqLQAAOgAAIAAgCSAIa0HvwwBqLQAAOgAAIAsgCmsLIQMgDCADQe/DAGotAAA6AAALIARBAWshAyAAIAJqIQAgBEEBSw0ACwv0AQEHfwJAIAFBAEwNACAAQUBrIQYDQCAGKAIAIAAoAjhIBEAgACgCGEEATA0CCyAAKAIEBEAgACAAKQJMQiCJNwJMCyAAIAJBhOEAQYDhACAAKAIAGygCABEDAAJAIAAoAgQNACAAKAI0IAAoAghsQQBMDQAgACgCTCEHIAAoAlAhCEEAIQUDQCAHIAVBAnQiCWoiCiAKKAIAIAggCWooAgBqNgIAIAVBAWoiBSAAKAI0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akG0AWogBSANIAogBhAnIANBAUYNAQNAIAAgAkEBayIDQRRsakG0AWogBSANIAYgBhAnIAJBAUshBCADIQIgBA0ACwwBCyAGIApGDQAgBiAKIAggCWxBAnQQFBoLIA8gEGohAwJAIA5BAEwNAEEAIQlBACECIA5BBE8EQCAOQXxxIQ8DQCACIANqIAYgAkECdGooAgBBCHY6AAAgAyACQQFyIgRqIAYgBEECdGooAgBBCHY6AAAgAyACQQJyIgRqIAYgBEECdGooAgBBCHY6AAAgAyACQQNyIgRqIAYgBEECdGooAgBBCHY6AAAgAkEEaiICIA9HDQALCyAOQQNxIgRFDQADQCACIANqIAYgAkECdGooAgBBCHY6AAAgAkEBaiECIAlBAWoiCSAERw0ACwsgCygCDCIEBEAgCygCjAEhAiAIQQFxBH8gAiADIAMgByAEQQJ0QbDgAGooAgARAQAgBUEBaiEFIAMiAiAHagUgAwshBCAIQQFHBEADQCACIAQgBCAHIAsoAgxBAnRBsOAAaigCABEBACAEIAQgB2oiAiACIAcgCygCDEECdEGw4ABqKAIAEQEAIAIgB2ohBCACIQMgBUECaiIFIA1HDQALCyALIAM2AowBCyAKIAAoAmQiCSAIbEECdGohCiANIQUgDCAIayIMQQBKDQALCyAAIAE2AmwgACABNgJ0C+IBAQR/IAAEfyAALQAABUEACyEAAkAgA0EATA0AIANBA3EhBQJAIANBBEkEQEEAIQMMAQsgA0F8cSEHQQAhAwNAIAIgA2ogASADai0AACAAaiIAOgAAIAIgA0EBciIEaiABIARqLQAAIABqIgA6AAAgAiADQQJyIgRqIAEgBGotAAAgAGoiADoAACACIANBA3IiBGogASAEai0AACAAaiIAOgAAIANBBGoiAyAHRw0ACwsgBUUNAANAIAIgA2ogASADai0AACAAaiIAOgAAIANBAWohAyAGQQFqIgYgBUcNAAsLC88CAQR/AkAgAARAIANBAEwNASADQQFHBEAgA0EBcSEFIANBfnEhBwNAIAIgBGogASAEai0AACAAIARqLQAAajoAACACIARBAXIiA2ogASADai0AACAAIANqLQAAajoAACAEQQJqIgQgB0cNAAsgBUUNAgsgAiAEaiABIARqLQAAIAAgBGotAABqOgAADwsgA0EA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AigCGCACKAIcajYCGCACIAIoAkQgAigCSGo2AkQgAiACKAJAQQFqNgJAIAEoAhwiAigCGEEATARAQYjhACEDAkACQCACKAIEDQBBjOEAIQMgAigCFA0AIAIoAjQgAigCCGxBAEwNASACKAJMIQRBACEDA0AgAigCRCADaiAEIANBAnQiCGooAgA6AAAgAigCTCIEIAhqQQA2AgAgA0EBaiIDIAIoAjQgAigCCGxIDQALDAELIAIgAygCABEAAAsgAiACKAIYIAIoAhxqNgIYIAIgAigCRCACKAJIajYCRCACIAIoAkBBAWo2AkALIAEoAiAiAigCGEEATARAQYjhACEDAkACQCACKAIEDQBBjOEAIQMgAigCFA0AIAIoAjQgAigCCGxBAEwNASACKAJMIQRBACEDA0AgAigCRCADaiAEIANBAnQiCGooAgA6AAAgAigCTCIEIAhqQQA2AgAgA0EBaiIDIAIoAjQgAigCCGxIDQALDAELIAIgAygCABEAAAsgAiACKAIYIAIoAhxqNgIYIAIgAigCRCACKAJIajYCRCACIAIoAkBBAWo2AkAgASgCICECCyABKAIYIgMoAkQgASgCHCgCRCACKAJEIAwgAygCNCAOEQIAIAZBAWohBiAMIAsoAhRqIQwgASgCGCICQUBrKAIAIAIoAjhIDQALCyAGIAlqIQkgByAKSA0ACyAJC+kCAQl/IAEoAgAiBCgCHCIGIAQoAiwiAyABKAIQIghsaiEFAkAgACgCaCIHBEAgACgCECICQQBMDQEgBCgCICEJIAEoAiQhAyAAKAIAIQYgBCgCECEKQQAhAANAIAcgAyACIAcgBhAbIgsgBmxqIQcgAxAkIABqIQAgAiALayICQQBKDQALIABBAEwNASAKIAggCWxqIAQoAiAgBSAEKAIsIAEoAiQoAjQgAEEBEDFBAA8LIAZFDQAgAkEATA0AIAAoAmAhASACQQhPBEAgAkF4cSEEQQAhAANAIAVB/wEgARAVIANqQf8BIAEQFSADakH/ASABEBUgA2pB/wEgARAVIANqQf8BIAEQFSADakH/ASABEBUgA2pB/wEgARAVIANqQf8BIAEQFSADaiEFIABBCGoiACAERw0ACwsgAkEHcSICRQ0AQQAhAANAIAVB/wEgARAVIANqIQUgAEEBaiIAIAJHDQALC0EAC7MCAQd/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6OcAKAIAIgAEQEHo5wAgACgCCDYCACAAKAIEIAAoAgARAAAgABASDAELC0Hh5wBBADoAAAsGAEGAggQLJAEBf0HE4gAoAgAiAARAA0AgACgCABEKACAAKAIEIgANAAsLC4UBAQN/AkAgACgCBCICIgBBA3EEQANAIAAtAABFDQIgAEEBaiIAQQNxDQALCwNAIAAiAUEEaiEAIAEoAgAiA0F/cyADQYGChAhrcUGAgYKEeHFFDQALA0AgASIAQQFqIQEgAC0AAA0ACwsgACACa0EBaiIAEBYiAQR/IAEgAiAAEBQFQQALC9MBAQF+IAAgAC0A3wEgAEEZay0AACAALQC/ASAAQRprLQAAIAAtAJ8BIABBG2stAAAgAC0AfyAAQRxrLQAAIAAtAF8gAEEday0AACAALQA/IABBHmstAAAgAC0AHyAAQR9rLQAAIABBIGstAAAgAEEBay0AAGpqampqampqampqampqakEIakEEdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAAC9cIARJ/IABB78MAIABBIWstAABrIgIgAEEBay0AAGoiASAAQSBrIgstAAAiA2otAAA6AAAgACABIABBH2siDC0AACIEai0AADoAASAAIAEgAEEeayINLQAAIgVqLQAAOgACIAAgASAAQR1rIg4tAAAiBmotAAA6AAMgACABIABBHGsiDy0AACIHai0AADoABCAAIAEgAEEbayIQLQAAIghqLQAAOgAFIAAgASAAQRprIhEtAAAiCWotAAA6AAYgACABIABBGWsiEi0AACIKai0AADoAByAAIAogAiAALQAfaiIBai0AADoAJyAAIAEgCWotAAA6ACYgACABIAhqLQAAOgAlIAAgASAHai0AADoAJCAAIAEgBmotAAA6ACMgACABIAVqLQAAOgAiIAAgASAEai0AADoAISAAIAEgA2otAAA6ACAgACAKIAIgAC0AP2oiAWotAAA6AEcgACABIAlqLQAAOgBGIAAgASAIai0AADoARSAAIAEgB2otAAA6AEQgACABIAZqLQAAOgBDIAAgASAFai0AADoAQiAAIAEgBGotAAA6AEEgACABIANqLQAAOgBAIAAgAiAALQBfaiIBIAstAAAiA2otAAA6AGAgACABIAwtAAAiBGotAAA6AGEgACABIA0tAAAiBWotAAA6AGIgACABIA4tAAAiBmotAAA6AGMgACABIA8tAAAiB2otAAA6AGQgACABIBAtAAAiCGotAAA6AGUgACABIBEtAAAiCWotAAA6AGYgACABIBItAAAiCmotAAA6AGcgACAKIAIgAC0Af2oiAWotAAA6AIcBIAAgASAJai0AADoAhgEgACABIAhqLQAAOgCFASAAIAEgB2otAAA6AIQBIAAgASAGai0AADoAgwEgACABIAVqLQAAOgCCASAAIAEgBGotAAA6AIEBIAAgASADai0AADoAgAEgACAKIAIgAC0AnwFqIgFqLQAAOgCnASAAIAEgCWotAAA6AKYBIAAgASAIai0AADoApQEgACABIAdqLQAAOgCkASAAIAEgBmotAAA6AKMBIAAgASAFai0AADoAogEgACABIARqLQAAOgChASAAIAEgA2otAAA6AKABIAAgAiAALQC/AWoiASALLQAAIgtqLQAAOgDAASAAIAEgDC0AACIDai0AADoAwQEgACABIA0tAAAiDGotAAA6AMIBIAAgASAOLQAAIgRqLQAAOgDDASAAIAEgDy0AACINai0AADoAxAEgACABIBAtAAAiBWotAAA6AMUBIAAgASARLQAAIg5qLQAAOgDGASAAIAEgEi0AACIGai0AADoAxwEgACAGIAIgAC0A3wFqIgJqLQAAOgDnASAAIAIgDmotAAA6AOYBIAAgAiAFai0AADoA5QEgACACIA1qLQAAOgDkASAAIAIgBGotAAA6AOMBIAAgAiAMai0AADoA4gEgACACIANqLQAAOgDhASAAIAIgC2otAAA6AOABC0gBAX4gACAAQSBrKQAAIgE3AOABIAAgATcAwAEgACABNwCgASAAIAE3AIABIAAgATcAYCAAIAE3AEAgACABNwAgIAAgATcAAAu0AQAgACAAMQAfQoGChIiQoMCAAX43ACAgACAAMQA/QoGChIiQoMCAAX43AEAgACAAMQBfQoGChIiQoMCAAX43AGAgACAAMQB/QoGChIiQoMCAAX43AIABIAAgADEAnwFCgYKEiJCgwIABfjcAoAEgACAAMQC/AUKBgoSIkKDAgAF+NwDAASAAIAAxAN8BQoGChIiQoMCAAX43AOABIAAgAEEBazEAAEKBgoSIkKDAgAF+NwAAC4sBAQF+IAAgAC0A3wEgAC0AvwEgAC0AnwEgAC0AfyAALQBfIAAtAD8gAEEBay0AACAALQAfampqampqakEEakEDdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAAC50BAQF+IAAgAEEZay0AACAAQRprLQAAIABBG2stAAAgAEEcay0AACAAQR1rLQAAIABBHmstAAAgAEEgay0AACAAQR9rLQAAampqampqakEEakEDdq1C/wGDQoGChIiQoMCAAX4iATcA4AEgACABNwDAASAAIAE3AKABIAAgATcAgAEgACABNwBgIAAgATcAQCAAIAE3ACAgACABNwAACwcAIAARDwALhgEAIABCgIGChIiQoMCAfzcA4AEgAEKAgYKEiJCgwIB/NwDAASAAQoCBgoSIkKDAgH83AKABIABCgIGChIiQoMCAfzcAgAEgAEKAgYKEiJCgwIB/NwBgIABCgIGChIiQoMCAfzcAQCAAQoCBgoSIkKDAgH83ACAgAEKAgYKEiJCgwIB/NwAAC48EAQF+IAAgAEERay0AACAALQDfAyAAQRJrLQAAIAAtAL8DIABBE2stAAAgAC0AnwMgAEEUay0AACAALQD/AiAAQRVrLQAAIAAtAN8CIABBFmstAAAgAC0AvwIgAEEXay0AACAALQCfAiAAQRhrLQAAIAAtAP8BIABBGWstAAAgAC0A3wEgAEEaay0AACAALQC/ASAAQRtrLQAAIAAtAJ8BIABBHGstAAAgAC0AfyAAQR1rLQAAIAAtAF8gAEEeay0AACAALQA/IABBH2stAAAgAC0AHyAAQQFrLQAAIABBIGstAABqampqampqampqampqampqampqampqampqampqampqQRBqQQV2rUL/AYNCgYKEiJCgwIABfiIBNwAIIAAgATcAACAAIAE3ACAgACABNwAoIAAgATcAQCAAIAE3AEggACABNwBgIAAgATcAaCAAIAE3AIABIAAgATcAiAEgACABNwCgASAAIAE3AKgBIAAgATcAwAEgACABNwDIASAAIAE3AOgBIAAgATcA4AEgACABNwCIAiAAIAE3AIACIAAgATcAqAIgACABNwCgAiAAIAE3AMgCIAAgATcAwAIgACABNwDoAiAAIAE3AOACIAAgATcAiAMgACABNwCAAyAAIAE3AKgDIAAgATcAoAMgACABNwDIAyAAIAE3AMADIAAgATcA6AMgACABNwDgAwukAwETfyAAQRFrIQMgAEESayEEIABBE2shBSAAQRRrIQYgAEEVayEHIABBFmshCCAAQRdrIQkgAEEYayEKIABBGWshCyAAQRprIQwgAEEbayENIABBHGshDiAAQR1rIQ8gAEEeayEQIABBH2shESAAQSBrIRJB78MAIABBIWstAABrIRMDQCAAIBMgAEEBay0AAGoiASASLQAAai0AADoAACAAIAEgES0AAGotAAA6AAEgACABIBAtAABqLQAAOgACIAAgASAPLQAAai0AADoAAyAAIAEgDi0AAGotAAA6AAQgACABIA0tAABqLQAAOgAFIAAgASAMLQAAai0AADoABiAAIAEgCy0AAGotAAA6AAcgACABIAotAABqLQAAOgAIIAAgASAJLQAAai0AADoACSAAIAEgCC0AAGotAAA6AAogACABIActAABqLQAAOgALIAAgASAGLQAAai0AADoADCAAIAEgBS0AAGotAAA6AA0gACABIAQtAABqLQAAOgAOIAAgASADLQAAai0AADoADyAAQSBqIQAgAkEBaiICQRBHDQALC5cCAgJ+AX8gACAAQSBrIgMpAAAiATcAACAAIAE3ACAgACABNwBAIAAgATcAYCAAIAE3AIABIAAgATcAoAEgACABNwDAASAAIAE3AOABIAAgAykACCIBNwAIIAAgATcAKCAAIAE3AEggACABNwBoIAAgATcAiAEgACABNwCoASAAIAE3AMgBIAAgATcA6AEgACADKQAIIgE3AIgCIAAgAykAACICNwCAAiAAIAE3AKgCIAAgAjcAoAIgACABNwDIAiAAIAI3AMACIAAgATcA6AIgACACNwDgAiAAIAI3AIADIAAgATcAiAMgACABNwCoAyAAIAI3AKADIAAgAjcAwAMgACABNwDIAyAAIAE3AOgDIAAgAjcA4AMLigQBAX4gACAAMQAfQoGChIiQoMCAAX4iATcAICAAIAE3ACggACAAMQA/QoGChIiQoMCAAX4iATcAQCAAIAE3AEggACAAMQBfQoGChIiQoMCAAX4iATcAYCAAIAE3AGggACAAMQB/QoGChIiQoMCAAX4iATcAgAEgACABNwCIASAAIAAxAJ8BQoGChIiQoMCAAX4iATcAqAEgACABNwCgASAAIABBAWsxAABCgYKEiJCgwIABfiIBNwAAIAAgATcACCAAIAAxAL8BQoGChIiQoMCAAX4iATcAyAEgACABNwDAASAAIAAxAN8BQoGChIiQoMCAAX4iATcA6AEgACABNwDgASAAIAAxAP8BQoGChIiQoMCAAX4iATcAiAIgACABNwCAAiAAIAAxAJ8CQoGChIiQoMCAAX4iATcAqAIgACABNwCgAiAAIAAxAL8CQoGChIiQoMCAAX4iATcAyAIgACABNwDAAiAAIAAxAN8CQoGChIiQoMCAAX4iATcA6AIgACABNwDgAiAAIAAxAP8CQoGChIiQoMCAAX4iATcAiAMgACABNwCAAyAAIAAxAJ8DQoGChIiQoMCAAX4iATcAqAMgACABNwCgAyAAIAAxAL8DQoGChIiQoMCAAX4iATcAyAMgACABNwDAAyAAIAAxAN8DQoGChIiQoMCAAX4iATcA6AMgACABNwDgAwv/AgEBfiAAIAAtAN8DIAAtAL8DIAAtAJ8DIAAtAP8CIAAtAN8CIAAtAL8CIAAtAJ8CIAAtAP8BIAAtAN8BIAAtAL8BIAAtAJ8BIAAtAH8gAC0AXyAALQA/IABBAWstAAAgAC0AH2pqampqampqampqampqakEIakEEdq1C/wGDQoGChIiQoMCAAX4iATcAACAAIAE3AAggACABNwAoIAAgATcAICAAIAE3AEggACABNwBAIAAgATcAaCAAIAE3AGAgACABNwCIASAAIAE3AIABIAAgATcAqAEgACABNwCgASAAIAE3AMgBIAAgATcAwAEgACABNwDoASAAIAE3AOABIAAgATcAiAIgACABNwCAAiAAIAE3AKgCIAAgATcAoAIgACABNwDIAiAAIAE3AMACIAAgATcA6AIgACABNwDgAiAAIAE3AIgDIAAgATcAgAMgACABNwCoAyAAIAE3AKADIAAgATcAyAMgACABNwDAAyAAIAE3AOgDIAAgATcA4AMLoQMBAX4gACAAQRFrLQAAIABBEmstAAAgAEETay0AACAAQRRrLQAAIABBFWstAAAgAEEWay0AACAAQRdrLQAAIABBGGstAAAgAEEZay0AACAAQRprLQAAIABBG2stAAAgAEEcay0A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IAIgAigC/BE2AqQBAkAgA0ECRgRAIAIoAoASIQMgAiACKAKwATYCgBIgAiADNgKwAQwBCyACICwQKwsgAQRAIAIoAtQRIQEgAiACKAKsATYC1BEgAiABNgKsAQsgAigChAEiAQRAIAIoAogBIAIoAowBIAERBQAhASACIAIoApABIAFFcjYCkAELIAIgAigCmAFBAWoiAUEAIAEgAigCnAFHGzYCmAEMAgsgAiABNgKoASACIAIoAvwRNgKkASACICwQKyACIAlBJGoQLw0BC0EAIQMgAigCAA0FIAJBgxE2AgggAkIGNwIADAULIAIgAigC/BFBAWoiGTYC/BEgGSACKAK0AkgNAAsLIAIoApQBQQBKBEBBACEDIAIoApABDQMLQQEhAwwCC0EAIQMgAigCAA0BIAJBthE2AgggAkIHNwIADAELQQAhAyACKAIADQAgAkG0EDYCCCACQgE3AgALQQEhASACKAKUAUEASgRAIAIoApABRSEBCyAJKAJYIgQEQCAJQSRqIAQRAAALIAEgA3ENAgsgAkEANgKAASACKAK4EhASIAJCADcCuBIgAigCqBIiAQRAIAEoAhQiAwRAIAMQHSADEBILIAEQEgsgAkEANgKoEiACKALwERASIAJCADcCDCACQgA3AvARIAJCADcCFCACQgA3AhwgAkEANgIkIAJBADYCBAsgAigCACEBDAELQQAhASACQQA2AgQLIAJBADYCgAEgAigCuBIQEiACQgA3ArgSIAIoAqgSIgMEQCADKAIUIgQEQCAEEB0gBBASCyADEBILIAJBADYCqBIgAigC8BEQEgsgAhASIAEEQCAMKAJgIgNFDQEgAygCDEEATARAIAMoAlAQEgsgA0EANgJQDAELQQAhASAMKAJ0IgNFDQAgAygCMEUNACAMKAJgIgNFBEBBAiEBDAELIAMoAghBAWshBiADKAIQIQgCQCADKAIAQQpNBEAgAyAIIAYgA0EUaiIEKAIAIgNsajYCEAwBCyADQQAgAygCICIEazYCICADQQAgAygCJCIKazYCJCADQQAgAygCKCIFazYCKCADIAggBCAGbGo2AhAgAyADKAIUIAogBkEBdSIEbGo2AhQgAyADKAIYIAQgBWxqNgIYIAMoAhwiCEUNASADIAggA0EsaiIEKAIAIgMgBmxqNgIcCyAEQQAgA2s2AgALIAlBsAFqJAAgAQ0AIAwoAhgiAUUNAAJAQaDfAC0AAA0AQaDfAEEBOgAAQZDfAEGACBAENgIAQQYQJkGU3wBB/QoQBDYCAEEHECZBoN8ALQAADQBBoN8AQQE6AABBkN8AQYAIEAQ2AgBBBhAmQZTfAEH9ChAENgIAQQcQJgsgDCABNgIMIAwgKiArbEECdDYCCEGQ3wAoAgBBAUG8EiAMQQhqIgQQByIDEAggDCArNgIYIAwgKjYCECAMIAM2AgggAEGU3wAoAgBBA0HAEiAEEAc2AgAgAxADIAEQEgwBCyAAQQI2AgALIAxBwAFqJAALvwIBB38gACAAQR9rLQAAIgVBAWoiASAAQR5rLQAAIgJqQQF2IgM6AEAgACABIABBIGstAAAiBmpBAXY6AAAgACACIABBHWstAAAiAWpBAWpBAXYiBDoAQSAAIAM6AAEgACABIABBHGstAAAiA2pBAWpBAXYiBzoAQiAAIAQ6AAIgACAHOgADIAAgBSABQQJqIgRqIAJBAXRqQQJ2Igc6AGAgACAGIAJBAmoiAmogBUEBdGpBAnY6ACAgACADIAIgAUEBdGpqQQJ2IgU6AGEgACAHOgAhIABBGWstAAAhBiAAQRprLQAAIQIgACAAQRtrLQAAIgEgBCADQQF0ampBAnYiBDoAYiAAIAU6ACIgACAGIAEgAkEBdGpqQQJqQQJ2OgBjIAAgAiADIAFBAXRqakECakECdjoAQyAAIAQ6ACMLsAIBCX8gACAALQAfIgMgAC0APyIEakEBakEBdiICOgBiIAAgBCAALQBfIgdqQQFqQQF2OgBgIAAgAjoAQCAAIABBAWstAAAiBkEBaiIBIABBIWstAAAiAmpBAXYiBToAIiAAIAEgA2pBAXYiAToAQiAAIAU6AAAgACABOgAgIAAgAEEgay0AACIBIAZBAmoiBSACQQF0ampBAnYiCDoAIyAAIABBHmstAAAgASAAQR9rLQAAIglBAXRqakECakECdjoAAyAAIAkgAiABQQF0ampBAmpBAnY6AAIgACACIANBAmoiASAGQQF0ampBAnYiAjoAQyAAIAg6AAEgACAEIAVqIANBAXRqQQJ2IgM6AGMgACACOgAhIAAgASAHaiAEQQF0akECdjoAYSAAIAM6AEEL2QEBBn8gACAALQBfIgE6AGMgACABOgBiIAAgAToAYSAAIAE6AGAgACAALQAfIgRBAWoiAyAALQA/IgJqQQF2IgU6ACAgACADIABBAWstAAAiBmpBAXY6AAAgACABIAJqQQFqQQF2IgM6AEAgACAFOgACIAAgAzoAIiAAIAEgBGogAkEBdGpBAmpBAnYiAzoAISAAIAYgAkECaiICaiAEQQF0akECdjoAASAAIAEgAmogAUEBdGpBAnYiAjoAQSAAIAM6AAMgACACOgAjIAAgAToAQyAAIAE6AEILbgEBfyAAIAAtAF8gAEEday0AACAALQA/IABBHmstAAAgAC0AHyAAQR9rLQAAIABBIGstAAAgAEEBay0AAGpqampqampBBGpBA3ZB/wFxQYGChAhsIgE2AGAgACABNgBAIAAgATYAICAAIAE2AAALpAIBBn8gAEHvwwAgAEEhay0AAGsiAiAAQQFrLQAAaiIBIABBIGstAAAiA2otAAA6AAAgACABIABBH2stAAAiBGotAAA6AAEgACABIABBHmstAAAiBWotAAA6AAIgACABIABBHWstAAAiBmotAAA6AAMgACAGIAIgAC0AH2oiAWotAAA6ACMgACABIAVqLQAAOgAiIAAgASAEai0AADoAISAAIAEgA2otAAA6ACAgACAGIAIgAC0AP2oiAWotAAA6AEMgACABIAVqLQAAOgBCIAAgASAEai0AADoAQSAAIAEgA2otAAA6AEAgACAGIAIgAC0AX2oiAmotAAA6AGMgACACIAVqLQAAOgBiIAAgAiAEai0AADoAYSAAIAIgA2otAAA6AGAL4gEBBn8gACAAQRxrLQAAIABBHmstAAAiAkECaiIDIABBHWstAAAiAUEBdGpqQQJ2IgQ6AGMgACABIABBH2stAAAiBUECaiIGIAJBAXRqakECdiICOgBiIAAgAyAAQSBrLQAAIgFqIAVBAXRqQQJ2IgM6AGEgACAGIABBIWstAABqIAFBAXRqQQJ2IgE6AGAgACAEOgBDIAAgAjoAQiAAIAM6AEEgACABOgBAIAAgBDoAIyAAIAI6ACIgACADOgAhIAAgAToAICAAIAQ6AAMgACACOgACIAAgAzoAASAAIAE6AAALpgIBBX8gACAALQBfIAAtAB8iAUECaiIDIAAtAD8iAkEBdGpqQQJ2OgBgIAAgAiAAQQFrLQAAIgRBAmoiBSABQQF0ampBAnYiAToAYSAAIAE6AEAgACAAQSFrLQAAIgIgAyAEQQF0ampBAnYiAToAYiAAIAE6AEEgACABOgAgIAAgBSAAQSBrLQAAIgNqIAJBAXRqQQJ2IgE6AGMgACABOgBCIAAgAToAISAAIAE6AAAgAEEday0AACEFIABBHmstAAAhASAAIAIgAEEfay0AACIEaiADQQF0akECakECdiICOgBDIAAgAjoAIiAAIAI6AAEgACABIANqIARBAXRqQQJqQQJ2IgI6ACMgACACOgACIAAgBCAFaiABQQF0akECakECdjoAAwujAgEFfyAAIABBHWstAAAiAkECaiIFIABBH2stAAAiA2ogAEEeay0AACIBQQF0akECdiIEOgAgIAAgAUECaiIBIABBIGstAABqIANBAXRqQQJ2OgAAIAAgAEEcay0AACIDIAEgAkEBdGpqQQJ2IgE6AEAgACAEOgABIAAgAToAISAAIABBG2stAAAiBCAFIANBAXRqakECdiICOgBgIAAgAToAAiAAIAI6AEEgACACOgAiIAAgAjoAAyAAIABBGmstAAAiAiADIARBAXRqakECakECdiIDOgBhIAAgAEEZay0AACIBIAQgAkEBdGpqQQJqQQJ2IgQ6AGIgACADOgAjIAAgAzoAQiAAIAEgAmogAUEBdGpBAmpBAnY6AGMgACAEOgBDCy8AIAAgARAhIABBIGogAUEEahAhIABBQGsgAUGAAWoQISAAQeAAaiABQYQBahAhC08BAX8gAC8BACICBEAgAiABECALIAAvASAiAgRAIAIgAUEEahAgCyAALwFAIgIEQCACIAFBgAFqECALIAAvAWAiAARAIAAgAUGEAWoQIAsLqQIBBH8jAEEQayICJAAgASgCACIEQfD///8HSQRAAkACQCAEQQtPBEAgBEEPckEBaiIFEDghAyACIAVBgICAgHhyNgIIIAIgAzYCACACIAQ2AgQgAyAEaiEFDAELIAIgBDoACyACIARqIQUgAiEDIARFDQELIAMgAUEEaiAEEBQaCyAFQQA6AAAgAkEMaiACIAARAwAgAigCDBAIIAIoAgwiABADIAIsAAtBAEgEQCACKAIAEBILIAJBEGokACAADwtB2AAQFkHQAGoiA0Hk2gA2AgAgA0GQ2QA2AgBBGRA4IgFBADYCCCABQoyAgIDAATcCACABQQxqIgBBlwopAAA3AAUgAUGSCikAADcADCADIAA2AgQgA0HA2QA2AgAgA0Hg2QBBPBANAAvkEgETfwJAIAEgACgCbCIDayICQQBMDQAgACgCCCIIKAIAIQsgACgCECAAKAJkIgUgA2xBAnRqIQYgACgCFCEJAkAgACgCsAEiBEEASgRAIAAgBEEBayICQRRsakG0AWogAyABIAYgCRAnIARBAUYNAQNAIAAgAkEBayIGQRRsakG0AWogAyABIAkgCRAnIAJBAUshBCAGIQIgBA0ACwwBCyAGIAlGDQAgCSAGIAIgBWxBAnQQFBoLIAgoAlgiBiABIAEgBkobIgYgCCgCVCICIAAoAmwiAyACIANKIgUbIgRMDQAgCCAGIARrIgY2AhAgCCAEIAJrNgIIIAggCCgCUCAIKAJMIgprIgQ2AgwgCSALQQJ0IhAgAiADa2xBACAFG2ogCkECdGohCyAAKAIMIgIoAgAiEUEKTQRAIAIoAhAgAigCFCINIAAoAnRsaiEKAkAgCCgCXARAIAZBAEwEQEEAIQgMAgtBACEJQQAhCANAIAsgCSAQbGoiAyAQIAAoAowCIgIoAiwgAigCICIEIAIoAhhqQQFrIARtIgQgBiAJayICIAIgBEobEEEgACgCjAIgAiADIBAQGyAJaiEJQQAhBQJAIAAoAowCIgNBQGsiDigCACADKAI4Tg0AIAogCCANbGohEyADKAI0IQwgAygCRCESA0AgAygCGEEASg0BQYjhACECAkACQCADKAIEDQBBjOEAIQIgAygCFA0AIAMoAjQgAygCCGxBAEwNASADKAJMIQdBACECA0AgAygCRCACaiAHIAJBAnQiBGooAgA6AAAgAygCTCIHIARqQQA2AgAgAkEBaiICIAMoAjQgAygCCGxIDQALDAELIAMgAigCABEAAAsgAyADKAIYIAMoAhxqNgIYIAMgAygCRCADKAJIajYCRCAOIA4oAgBBAWo2AgBBACECIAxBAEoEQANAIBIgAkECdGoiFCgCACIEQf///3dNBEBBACEHIBQgBEGAgIAITwR/IARBgICAeHFBgICAeCAEQRh2biIHIARB/wFxbEGAgIAEakEYdnIgByAEQQh2Qf8BcWxBgICABGpBEHZBgP4DcXIgByAEQRB2Qf8BcWxBgICABGpBCHZBgID8B3FyBUEACzYCAAsgAkEBaiICIAxHDQALCyASIAwg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b2wAZW1zY3JpcHRlbjo6dmFsAGJhZCBwYXJ0aXRpb24gbGVuZ3RoAHVuc2lnbmVkIGxvbmcAc3RkOjp3c3RyaW5nAGJhc2ljX3N0cmluZwBzdGQ6OnN0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBkb3VibGUAZGVjb2RlAEJhZCBjb2RlIHdvcmQAdm9pZABGcmFtZSBzZXR1cCBmYWlsZWQASW1hZ2VEYXRhAFZQOFgAV0VCUABWUDhMAE9LAEFMUEgAUklGRgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxkb3VibGU+AEluY29ycmVjdCBrZXlmcmFtZSBwYXJhbWV0ZXJzLgBUcnVuY2F0ZWQgaGVhZGVyLgBubyBtZW1vcnkgZHVyaW5nIGZyYW1lIGluaXRpYWxpemF0aW9uLgBOb3QgYSBrZXkgZnJhbWUuAEZyYW1lIG5vdCBkaXNwbGF5YWJsZS4AT3V0cHV0IGFib3J0ZWQuAFByZW1hdHVyZSBlbmQtb2YtZmlsZSBlbmNvdW50ZXJlZC4AUHJlbWF0dXJlIGVuZC1vZi1wYXJ0aXRpb24wIGVuY291bnRlcmVkLgBDb3VsZCBub3QgZGVjb2RlIGFscGhhIGRhdGEuAG51bGwgVlA4SW8gcGFzc2VkIHRvIFZQOEdldEhlYWRlcnMoKQBWUDggAAAAwCgAAHwnAABpaWkA6CsAAGlpAAA4KQAAwCgAAOgrAADoKwAAAAAAAP///////////////////////////////////////////7D2////////////3/H8///////////5/f3////////////0/P//////////6v7+///////////9///////////////2/v//////////7/3+///////////+//7////////////4/v//////////+//+///////////////////////////9/v//////////+/7+///////////+//7////////////+/f/+////////+v/+//7////////+/////////////////////////////////////////////////////////9n/////////////4fzx/f///v/////q+vH6/f/9/v/////+////////////3/7+///////////u/f7+///////////4/v//////////+f7////////////////////////////9////////////9/7////////////////////////////9/v///////////P/////////////////////////////+/v///////////f/////////////////////////////+/f//////////+v/////////////+/////////////////////////////////////////////////////////7r7+v//////////6vv0/v/////////7+/P9/v/+///////9/v//////////7P3+///////////7/f3+/v/////////+/v///////////v7+///////////////////////////+/////////////v7////////////+/////////////////////////////v////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////j/////////////+v78/v/////////4/vn9///////////9/f//////////9v39///////////8/vv+/v/////////+/P//////////+P79///////////9//7+///////////7/v//////////9fv+///////////9/f7////////////7/f///////////P3+/////////////v/////////////8////////////+f/+//////////////7//////////////f//////////+v///////////////////////////////////////////v///////////////////////////4CAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgP2I/v/k24CAgICAvYHy/+PV/9uAgIBqfuP81tH//4CAgAFi+P/s4v//gICAtYXu/t3q/5qAgIBOhsr3xrT/24CAgAG5+f/z/4CAgICAuJb3/+zggICAgIBNbtj/7OaAgICAgAFl+//x/4CAgICAqovx/OzR//+AgIAldMTz5P///4CAgAHM/v/1/4CAgICAz6D6/+6AgICAgIBmZ+f/06uAgICAgAGY/P/w/4CAgICAsYfz/+rhgICAgIBQgdP/wuCAgICAgAEB/4CAgICAgICA9gH/gICAgICAgID/gICAgICAgICAgMYj7d/Bu6KgkZs+gy3G3ayw3J383QFEL5LQlafdov/fgAGV8f/d4P//gICAuI3q/d7c/8eAgIBRY7XysL75yv//gAGB6P3WxfLE//+AY3nS+snG/8qAgIAXW6Pyqrv30v//gAHI9v/q/4CAgICAbbLx/+f1//+AgIAsgsn9zcD//4CAgAGE7/vb0f+lgICAXojh+9q+//+AgIAWZK71uqH/x4CAgAG2+f/o64CAgICAfI/x/+PqgICAgIAjTbX7wdP/zYCAgAGd9//s5///gICAeY3r/+Hj//+AgIAtY7z7w9n/4ICAgAEB+//V/4CAgICAywH4//+AgICAgICJAbH/4P+AgICAgP0J+PvP0P/AgICArw3g88G5+cb//4BJEavdobPsp//qgAFf9/3Ut///gICA71r0+tPR//+AgICbTcP4vMP//4CAgAEY7/va2//NgICAyTPb/8S6gICAgIBFLr7vydr/5ICAgAG/+///gICAgICA36X5/9X/gICAgICNfPj//4CAgICAgAEQ+P//gICAgICAviTm/+z/gICAgICVAf+AgICAgICAgAHi/4CAgICAgICA98D/gICAgICAgIDwgP+AgICAgICAgAGG/P//gICAgICA1T76//+AgICAgIA3Xf+AgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMoY1eu6v9yg8K//fia26Km45K7/u4A9Lorbl7Lwqv/YgAFw5vrHv/ef//+Apm3k/NPX/66AgIAnTaLorLT1sv//gAE03PbGx/nc//+AfEq/87fB+t3//4AYR4Lbmqrztv//gAG24fnb8P/ggICAlZbi/NjN/6uAgIAcbKryt8L+3///gAFR5vzMy//AgICAe2bR97zE/+mAgIAUX5nzpK3/y4CAgAHe+P/Y1YCAgICAqK/2/OvN//+AgIAvdNf/09T//4CAgAF57P3U1v//gICAjVTV/MnK/9uAgIAqUKDworn/zYCAgAEB/4CAgICAgICA9AH/gICAgICAgIDuAf+AgICAgICAgOd4MFlzcXiYcJizQH6qdi5GX69Fj1BVUkibZzg6CqvavRENmHIaEaMswxUKrXkYUMMaPixAVZBHCiar1ZAiGqouNxOIoCHORz8UCHJy0AwJ4lEoC2C2VB0QJIa3WYliZWqllEi7ZIKdbyBLUEJmp2NKPijqgCk1CbLxjRoIa0orGpJJpjEXnUEmaaAzNB9zgGhPDBvZ/1cRB1dERyxyMw+6Fy8pDm62txURwkItGWbFvRcSFlhYk5YqLi3EzStht3VVJiOzPSc1yFcaFSvoqzgiM2hyZh1dTSccVas6pVpiQCIWdM4XIiumSWs2IBozAVErH0QZahZAqyThciITFWaEvBBMfD4STl9VOTIwM8FlI5/Xb1kubzyUH6zb5BUSb3BxTVWz/yZ4cigqAcT10QoZbVgrHYym1SUrmj0/HptDLUQB0WRQCCuaATMaR45OThD/gCLFqykoBWbTtwQB3TMyEajRwBcZUoofJKsbpiYs5UNXOqlScxo7sz87WrQ7pl1JmigoFXSP0SInry8PELci3zEtty4RIbcGYg8gtzkuFhiAATYRJUEgSXMcgBeAzSgDCXMzwBIG31clCXM7TUAVL2g3LNoJNjWC4kBaRs0oKRcaOTY5cLgFKSam1R4iGoWYdAoghicTNd0aciBJ/x8JQeoCDwF2SUsgDDPA/6ArM1gfI0NmVTe6VTgVF287zS0lwDcmRnxJZgEiYn1iKlhoVXWvUl9UNVmAZHFlLUtPey8zgFGrATkRBUdmOTUpMSYhDXk5SRoBVSkKQ4pNblovcnMVAgpm/6YXBmUdEApVgGXEGjkSCmZm1SIUK3UUDySjgEQBGmY9RyUiNR/zwEU8RyZJdxzeJUQtgCIBLwv1qz4RE0aSVTc+RiUrJZpko1WgAT8JXIgcQCDJVUsPCQlA/7h3EFYGHAVA/xn4ATgIEYSJ/zd0gDoPFFKHORp5KKQyH4mahRkj2jNnLIODex8GnlYoQIeU4C23gBYaEYPwmg4B0S0QFVtA3gcBxTgVJ5s8ihdm1VMMDTbA/0QvHFUaVVWAgCCSqxILBz+QqwQE9iMbCpKuqwwagL5QI2O0UH42LVV+L1ewMykUIGVLgIt2knSAVTgpD7DsVSUJPkceEXd2/xESimUmPIo3RisajpIkEx6r/2EbFIotPT7bAVG8QCApFHWXjhQVo3ATDD3DgDAEGABBoSoLEQH/Av4DBAb9Bfz7+gf5CPj3AEHAKgu1BQQFBgcICQoKCwwNDg8QERESExQUFRUWFhcXGBkZGhscHR4fICEiIyQlJSYnKCkqKywtLi4vMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUZHSElKS0xMTU5PUFFSU1RVVldYWVtdX2BiZGVmaGpsbnBydHZ6fH6AgoSGiIqMj5GUl5qdBAAFAAYABwAIAAkACgALAAwADQAOAA8AEAARABIAEwAUABUAFgAXABgAGQAaABsAHAAdAB4AHwAgACEAIgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA8AD4AQABCAEQARgBIAEoATABOAFAAUgBUAFYAWABaAFwAXgBgAGIAZABmAGgAagBsAG4AcAByAHQAdwB6AH0AgACDAIYAiQCMAI8AkgCVAJgAmwCeAKEApACnAKoArQCxALUAuQC9AMEAxQDJAM0A0QDVANkA3QDhAOUA6gDvAPUA+QD+AAMBCAENARIBFwEcAQgHBgQEAgICAQEBAQACCAAAAAQACAAMAIAAhACIAIwAAAEEAQgBDAGAAYQBiAGMAQABBAgFAgMGCQwNCgcLDg8QFwAAFBcAABkXAAAfFwAArZSMALCbjIcAtJ2NhoIA/v7z5sSxmYyFgoEAAAAAAACKC4wLjguSC5oLqgvKCwoMjAyMDYwPjBMAAAAAAAAAABESAAECAwQFEAYHCAkKCwwNDg8CAwcDAwsAAAAAAAAAGAcXGSgGJykWGiYqOAU3ORUbNjolK0gER0kUHDU7RkokLFhFSzQ8A1dZEx1WWiMtRExVWzM9aAJnaRIeZmoiLlRcQ01lazI+eAF3eVNdER9kbEJOdnohL3V7MT9jbVJeAHR8QU8QIGJuMHN9UV9Acn5hb1Bxf2BwAwQDBAQCAgQEBAIBAQBBgDAL4BGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5Ojs8PT4/QEFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f39/f38AAAAAAAAAAPDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDx8vP09fb3+Pn6+/z9/v8AAQIDBAUGBwgJCgsMDQ4PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PDw8PAEHwwwAL4wgBAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAP/+/fz7+vn49/b19PPy8fDv7u3s6+rp6Ofm5eTj4uHg397d3Nva2djX1tXU09LR0M/OzczLysnIx8bFxMPCwcC/vr28u7q5uLe2tbSzsrGwr66trKuqqainpqWko6KhoJ+enZybmpmYl5aVlJOSkZCPjo2Mi4qJiIeGhYSDgoGAf359fHt6eXh3dnV0c3JxcG9ubWxramloZ2ZlZGNiYWBfXl1cW1pZWFdWVVRTUlFQT05NTEtKSUhHRkVEQ0JBQD8+PTw7Ojk4NzY1NDMyMTAvLi0sKyopKCcmJSQjIiEgHx4dHBsaGRgXFhUUExIREA8ODQwLCgkIBwYFBAMCAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gIGCg4SFhoeIiYqLjI2Oj5CRkpOUlZaXmJmam5ydnp+goaKjpKWmp6ipqqusra6vsLGys7S1tre4ubq7vL2+v8DBwsPExcbHyMnKy8zNzs/Q0dLT1NXW19jZ2tvc3d7f4OHi4+Tl5ufo6err7O3u7/Dx8vP09fb3+Pn6+/z9/v8AAAAAAAEAAAADAAAABwAAAA8AAAAfAAAAPwAAAH8AAAD/AAAA/wEAAP8DAAD/BwAA/w8AAP8fAAD/PwAA/38AAP//AAD//wEA//8DAP//BwD//w8A//8fAP//PwD//38A////AEHgzAALjQ4wUuENhhizA8usX3dqYogcVVw4aCi4sxT4/oVKS7jdSZfz/GSJAlVcAAApStrBfg2rt0BZfVeSVHLKGU5pjNM4Ze4BDF91oTJS9jdUMiy7WrFXqg/nM/Vz2u5faOLMY3WDDplu7acwR8bZwE88FWtJ+gMUTwz7GlQyC5lzHMvXJgY3zG/Yd7ssKi92dd3MJWRhVLMkFYd9CqgUBCJnvx4UgxW0VuMC5XNvscpEQk0mKPuuunPt61AK+7ZqHQvUOg1oO9s1gx4IK5Vrznfw5YFRvDuFeJSUnwA87eUnTlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJhaXRzSWNFRU5TXzlhbGxvY2F0b3JJY0VFRUUAAPQsAAA8JwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAPQsAACEJwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAPQsAADMJwAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAAD0LAAAFCgAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAA9CwAAGAoAABOMTBlbXNjcmlwdGVuM3ZhbEUAAPQsAACsKAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAAD0LAAAyCgAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAA9CwAAPAoAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAPQsAAAYKQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAD0LAAAQCkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAA9CwAAGgpAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAAPQsAACQKQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAD0LAAAuCkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAA9CwAAOApAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAAPQsAAAIKgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAD0LAAAMCoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAA9CwAAFgqAABOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAAA0LQAAgCoAACQtAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAAA0LQAAsCoAAKQqAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAAA0LQAA4CoAAKQqAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQA0LQAAECsAAAQrAAAAAAAAhCsAAGMAAABkAAAAZQAAAGYAAABnAAAATjEwX19jeHhhYml2MTIzX19mdW5kYW1lbnRhbF90eXBlX2luZm9FADQtAABcKwAApCoAAHYAAABIKwAAkCsAAGIAAABIKwAAnCsAAGMAAABIKwAAqCsAAGgAAABIKwAAtCsAAGEAAABIKwAAwCsAAHMAAABIKwAAzCsAAHQAAABIKwAA2CsAAGkAAABIKwAA5CsAAGoAAABIKwAA8CsAAGwAAABIKwAA/CsAAG0AAABIKwAACCwAAHgAAABIKwAAFCwAAHkAAABIKwAAICwAAGYAAABIKwAALCwAAGQAAABIKwAAOCwAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAAA0LQAARCwAANQqAABTdDlleGNlcHRpb24AAAAAAAAAAKwsAAA8AAAAaAAAAGkAAABTdDExbG9naWNfZXJyb3IANC0AAJwsAABULQAAAAAAAOAsAAA8AAAAagAAAGkAAABTdDEybGVuZ3RoX2Vycm9yAAAAADQtAADMLAAArCwAAAAAAADUKgAAYwAAAGsAAABlAAAAZgAAAGwAAABtAAAAbgAAAG8AAABTdDl0eXBlX2luZm8AAAAA9CwAABQtAAAAAAAAbCwAAGMAAABwAAAAZQAAAGYAAABsAAAAcQAAAHIAAABzAAAA9CwAAHgsAAAAAAAAVC0AAHQAAAB1AAAAdgBB8NoACyrwMwEAdC0AAHgtAAB8LQAAgC0AAIQtAACILQAAjC0AAJAtAACULQAAmC0=",self.location.href).href;function OA(h){try{if(h==nA&&D)return new Uint8Array(D);if(n)return n(h);throw"both async and sync fetching of the wasm failed"}catch(c){NA(c)}}function KA(h){return!D&&(s||o)&&typeof fetch=="function"?fetch(h,{credentials:"same-origin"}).then(function(c){if(!c.ok)throw"failed to load wasm binary file at \'"+h+"\'";return c.arrayBuffer()}).catch(function(){return OA(h)}):Promise.resolve().then(function(){return OA(h)})}function TA(h,c,d){return KA(h).then(function(F){return WebAssembly.instantiate(F,c)}).then(function(F){return F}).then(d,function(F){r("failed to asynchronously prepare wasm: "+F),NA(F)})}function VA(h,c,d,F){return!h&&typeof WebAssembly.instantiateStreaming=="function"&&!xA(c)&&typeof fetch=="function"?fetch(c,{credentials:"same-origin"}).then(function(p){var R=WebAssembly.instantiateStreaming(p,d);return R.then(F,function(L){return r("wasm streaming compile failed: "+L),r("falling back to ArrayBuffer instantiation"),TA(c,d,F)})}):TA(c,d,F)}function X(){var h={a:Be};function c(F,p){var R=F.exports;return I.asm=R,l=I.asm.s,z(),T=I.asm.y,_(I.asm.t),SA(),R}RA();function d(F){c(F.instance)}if(I.instantiateWasm)try{return I.instantiateWasm(h,c)}catch(F){r("Module.instantiateWasm callback failed with error: "+F),B(F)}return VA(D,nA,h,d).catch(B),{}}function rA(h){for(;h.length>0;)h.shift()(I)}function V(h){this.excPtr=h,this.ptr=h-24,this.set_type=function(c){m[this.ptr+4>>2]=c},this.get_type=function(){return m[this.ptr+4>>2]},this.set_destructor=function(c){m[this.ptr+8>>2]=c},this.get_destructor=function(){return m[this.ptr+8>>2]},this.set_refcount=function(c){U[this.ptr>>2]=c},this.set_caught=function(c){c=c?1:0,k[this.ptr+12>>0]=c},this.get_caught=function(){return k[this.ptr+12>>0]!=0},this.set_rethrown=function(c){c=c?1:0,k[this.ptr+13>>0]=c},this.get_rethrown=function(){return k[this.ptr+13>>0]!=0},this.init=function(c,d){this.set_adjusted_ptr(0),this.set_type(c),this.set_destructor(d),this.set_refcount(0),this.set_caught(!1),this.set_rethrown(!1)},this.add_ref=function(){var c=U[this.ptr>>2];U[this.ptr>>2]=c+1},this.release_ref=function(){var c=U[this.ptr>>2];return U[this.ptr>>2]=c-1,c===1},this.set_adjusted_ptr=function(c){m[this.ptr+16>>2]=c},this.get_adjusted_ptr=function(){return m[this.ptr+16>>2]},this.get_exception_ptr=function(){var c=Gi(this.get_type());if(c)return m[this.excPtr>>2];var d=this.get_adjusted_ptr();return d!==0?d:this.excPtr}}function nI(h,c,d){var F=new V(h);throw F.init(c,d),h}function TI(h,c,d,F,p){}function hA(h){switch(h){case 1:return 0;case 2:return 1;case 4:return 2;case 8:return 3;default:throw new TypeError("Unknown type size: "+h)}}function P(){for(var h=new Array(256),c=0;c<256;++c)h[c]=String.fromCharCode(c);sA=h}var sA=void 0;function q(h){for(var c="",d=h;S[d];)c+=sA[S[d++]];return c}var pA={},$A={},DI={},$I=48,jg=57;function _g(h){if(h===void 0)return"_unknown";h=h.replace(/[^a-zA-Z0-9_]/g,"$");var c=h.charCodeAt(0);return c>=$I&&c<=jg?"_"+h:h}function $g(h,c){return h=_g(h),{[h]:function(){return c.apply(this,arguments)}}[h]}function Ag(h,c){var d=$g(c,function(F){this.name=c,this.message=F;var p=new Error(F).stack;p!==void 0&&(this.stack=this.toString()+`\n`+p.replace(/^Error(:[^\\n]*)?\\n/,""))});return d.prototype=Object.create(h.prototype),d.prototype.constructor=d,d.prototype.toString=function(){return this.message===void 0?this.name:this.name+": "+this.message},d}var pg=void 0;function UA(h){throw new pg(h)}var Mg=void 0;function kg(h){throw new Mg(h)}function AB(h,c,d){h.forEach(function(Y){DI[Y]=c});function F(Y){var b=d(Y);b.length!==h.length&&kg("Mismatched type converter count");for(var j=0;j<h.length;++j)lA(h[j],b[j])}var p=new Array(c.length),R=[],L=0;c.forEach((Y,b)=>{$A.hasOwnProperty(Y)?p[b]=$A[Y]:(R.push(Y),pA.hasOwnProperty(Y)||(pA[Y]=[]),pA[Y].push(()=>{p[b]=$A[Y],++L,L===R.length&&F(p)}))}),R.length===0&&F(p)}function lA(h,c,d={}){if(!("argPackAdvance"in c))throw new TypeError("registerType registeredInstance requires argPackAdvance");var F=c.name;if(h||UA(\'type "\'+F+\'" must have a positive integer typeid pointer\'),$A.hasOwnProperty(h)){if(d.ignoreDuplicateRegistrations)return;UA("Cannot register type \'"+F+"\' twice")}if($A[h]=c,delete DI[h],pA.hasOwnProperty(h)){var p=pA[h];delete pA[h],p.forEach(R=>R())}}function MI(h,c,d,F,p){var R=hA(d);c=q(c),lA(h,{name:c,fromWireType:function(L){return!!L},toWireType:function(L,Y){return Y?F:p},argPackAdvance:8,readValueFromPointer:function(L){var Y;if(d===1)Y=k;else if(d===2)Y=N;else if(d===4)Y=U;else throw new TypeError("Unknown boolean type size: "+c);return this.fromWireType(Y[L>>R])},destructorFunction:null})}var BI=[],YA=[{},{value:void 0},{value:null},{value:!0},{value:!1}];function Di(h){h>4&&--YA[h].refcount===0&&(YA[h]=void 0,BI.push(h))}function hs(){for(var h=0,c=5;c<YA.length;++c)YA[c]!==void 0&&++h;return h}function cs(){for(var h=5;h<YA.length;++h)if(YA[h]!==void 0)return YA[h];return null}function Ds(){I.count_emval_handles=hs,I.get_first_emval=cs}var Rg={toValue:h=>(h||UA("Cannot use deleted val. handle = "+h),YA[h].value),toHandle:h=>{switch(h){case void 0:return 1;case null:return 2;case!0:return 3;case!1:return 4;default:{var c=BI.length?BI.pop():YA.length;return YA[c]={refcount:1,value:h},c}}}};function Jt(h){return this.fromWireType(U[h>>2])}function ls(h,c){c=q(c),lA(h,{name:c,fromWireType:function(d){var F=Rg.toValue(d);return Di(d),F},toWireType:function(d,F){return Rg.toHandle(F)},argPackAdvance:8,readValueFromPointer:Jt,destructorFunction:null})}function ys(h,c){switch(c){case 2:return function(d){return this.fromWireType(J[d>>2])};case 3:return function(d){return this.fromWireType(K[d>>3])};default:throw new TypeError("Unknown float type: "+h)}}function ds(h,c,d){var F=hA(d);c=q(c),lA(h,{name:c,fromWireType:function(p){return p},toWireType:function(p,R){return R},argPackAdvance:8,readValueFromPointer:ys(c,F),destructorFunction:null})}function ws(h){for(;h.length;){var c=h.pop(),d=h.pop();d(c)}}function us(h,c,d,F,p,R){var L=c.length;L<2&&UA("argTypes array size mismatch! Must at least get return value and \'this\' types!"),c[1];for(var Y=!1,b=1;b<c.length;++b)if(c[b]!==null&&c[b].destructorFunction===void 0){Y=!0;break}var j=c[0].name!=="void",wA=L-2,oA=new Array(wA),MA=[],ZI=[];return function(){arguments.length!==wA&&UA("function "+h+" called with "+arguments.length+" arguments, expected "+wA+" args!"),ZI.length=0;var IB;MA.length=1,MA[0]=p;for(var zI=0;zI<wA;++zI)oA[zI]=c[zI+2].toWireType(ZI,arguments[zI]),MA.push(oA[zI]);var WB=F.apply(null,MA);function te(Qe){if(Y)ws(ZI);else for(var mg=2;mg<c.length;mg++){var ie=mg===1?IB:oA[mg-2];c[mg].destructorFunction!==null&&c[mg].destructorFunction(ie)}if(j)return c[0].fromWireType(Qe)}return te(WB)}}function fs(h,c,d){if(h[c].overloadTable===void 0){var F=h[c];h[c]=function(){return h[c].overloadTable.hasOwnProperty(arguments.length)||UA("Function \'"+d+"\' called with an invalid number of arguments ("+arguments.length+") - expects one of ("+h[c].overloadTable+")!"),h[c].overloadTable[arguments.length].apply(this,arguments)},h[c].overloadTable=[],h[c].overloadTable[F.argCount]=F}}function Gs(h,c,d){I.hasOwnProperty(h)?((d===void 0||I[h].overloadTable!==void 0&&I[h].overloadTable[d]!==void 0)&&UA("Cannot register public name \'"+h+"\' twice"),fs(I,h,h),I.hasOwnProperty(d)&&UA("Cannot register multiple overloads of a function with the same number of arguments ("+d+")!"),I[h].overloadTable[d]=c):(I[h]=c,d!==void 0&&(I[h].numArguments=d))}function Fs(h,c){for(var d=[],F=0;F<h;F++)d.push(m[c+F*4>>2]);return d}function Ss(h,c,d){I.hasOwnProperty(h)||kg("Replacing nonexistant public symbol"),I[h].overloadTable!==void 0&&d!==void 0?I[h].overloadTable[d]=c:(I[h]=c,I[h].argCount=d)}function Ns(h,c,d){var F=I["dynCall_"+h];return d&&d.length?F.apply(null,[c].concat(d)):F.call(null,c)}var ZB=[];function li(h){var c=ZB[h];return c||(h>=ZB.length&&(ZB.length=h+1),ZB[h]=c=T.get(h)),c}function ps(h,c,d){if(h.includes("j"))return Ns(h,c,d);var F=li(c).apply(null,d);return F}function Ms(h,c){var d=[];return function(){return d.length=0,Object.assign(d,arguments),ps(h,c,d)}}function ks(h,c){h=q(h);function d(){return h.includes("j")?Ms(h,c):li(c)}var F=d();return typeof F!="function"&&UA("unknown function pointer with signature "+h+": "+c),F}var yi=void 0;function di(h){var c=fi(h),d=q(c);return kI(c),d}function Rs(h,c){var d=[],F={};function p(R){if(!F[R]&&!$A[R]){if(DI[R]){DI[R].forEach(p);return}d.push(R),F[R]=!0}}throw c.forEach(p),new yi(h+": "+d.map(di).join([", "]))}function ms(h,c,d,F,p,R,L){var Y=Fs(c,d);h=q(h),p=ks(F,p),Gs(h,function(){Rs("Cannot call "+h+" due to unbound types",Y)},c-1),AB([],Y,function(b){var j=[b[0],null].concat(b.slice(1));return Ss(h,us(h,j,null,p,R),c-1),[]})}function xs(h,c,d){switch(c){case 0:return d?function(p){return k[p]}:function(p){return S[p]};case 1:return d?function(p){return N[p>>1]}:function(p){return H[p>>1]};case 2:return d?function(p){return U[p>>2]}:function(p){return m[p>>2]};default:throw new TypeError("Unknown integer type: "+h)}}function Us(h,c,d,F,p){c=q(c);var R=hA(d),L=oA=>oA;if(F===0){var Y=32-8*d;L=oA=>oA<<Y>>>Y}var b=c.includes("unsigned"),j=(oA,MA)=>{},wA;b?wA=function(oA,MA){return j(MA,this.name),MA>>>0}:wA=function(oA,MA){return j(MA,this.name),MA},lA(h,{name:c,fromWireType:L,toWireType:wA,argPackAdvance:8,readValueFromPointer:xs(c,R,F!==0),destructorFunction:null})}function Ys(h,c,d){var F=[Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],p=F[c];function R(L){L=L>>2;var Y=m,b=Y[L],j=Y[L+1];return new p(Y.buffer,j,b)}d=q(d),lA(h,{name:d,fromWireType:R,argPackAdvance:8,readValueFromPointer:R},{ignoreDuplicateRegistrations:!0})}function Js(h,c){c=q(c);var d=c==="std::string";lA(h,{name:c,fromWireType:function(F){var p=m[F>>2],R=F+4,L;if(d)for(var Y=R,b=0;b<=p;++b){var j=R+b;if(b==p||S[j]==0){var wA=j-Y,oA=u(Y,wA);L===void 0?L=oA:(L+="\\0",L+=oA),Y=j+1}}else{for(var MA=new Array(p),b=0;b<p;++b)MA[b]=String.fromCharCode(S[R+b]);L=MA.join("")}return kI(F),L},toWireType:function(F,p){p instanceof ArrayBuffer&&(p=new Uint8Array(p));var R,L=typeof p=="string";L||p instanceof Uint8Array||p instanceof Uint8ClampedArray||p instanceof Int8Array||UA("Cannot pass non-string to std::string"),d&&L?R=x(p):R=p.length;var Y=Lt(4+R+1),b=Y+4;if(m[Y>>2]=R,d&&L)M(p,b,R+1);else if(L)for(var j=0;j<R;++j){var wA=p.charCodeAt(j);wA>255&&(kI(b),UA("String has UTF-16 code units that do not fit in 8 bits")),S[b+j]=wA}else for(var j=0;j<R;++j)S[b+j]=p[j];return F!==null&&F.push(kI,Y),Y},argPackAdvance:8,readValueFromPointer:Jt,destructorFunction:function(F){kI(F)}})}function Ls(h,c){for(var d="",F=0;!(F>=c/2);++F){var p=N[h+F*2>>1];if(p==0)break;d+=String.fromCharCode(p)}return d}function Hs(h,c,d){if(d===void 0&&(d=2147483647),d<2)return 0;d-=2;for(var F=c,p=d<h.length*2?d/2:h.length,R=0;R<p;++R){var L=h.charCodeAt(R);N[c>>1]=L,c+=2}return N[c>>1]=0,c-F}function bs(h){return h.length*2}function Ks(h,c){for(var d=0,F="";!(d>=c/4);){var p=U[h+d*4>>2];if(p==0)break;if(++d,p>=65536){var R=p-65536;F+=String.fromCharCode(55296|R>>10,56320|R&1023)}else F+=String.fromCharCode(p)}return F}function qs(h,c,d){if(d===void 0&&(d=2147483647),d<4)return 0;for(var F=c,p=F+d-4,R=0;R<h.length;++R){var L=h.charCodeAt(R);if(L>=55296&&L<=57343){var Y=h.charCodeAt(++R);L=65536+((L&1023)<<10)|Y&1023}if(U[c>>2]=L,c+=4,c+4>p)break}return U[c>>2]=0,c-F}function Ts(h){for(var c=0,d=0;d<h.length;++d){var F=h.charCodeAt(d);F>=55296&&F<=57343&&++d,c+=4}return c}function Zs(h,c,d){d=q(d);var F,p,R,L,Y;c===2?(F=Ls,p=Hs,L=bs,R=()=>H,Y=1):c===4&&(F=Ks,p=qs,L=Ts,R=()=>m,Y=2),lA(h,{name:d,fromWireType:function(b){for(var j=m[b>>2],wA=R(),oA,MA=b+4,ZI=0;ZI<=j;++ZI){var IB=b+4+ZI*c;if(ZI==j||wA[IB>>Y]==0){var zI=IB-MA,WB=F(MA,zI);oA===void 0?oA=WB:(oA+="\\0",oA+=WB),MA=IB+c}}return kI(b),oA},toWireType:function(b,j){typeof j!="string"&&UA("Cannot pass non-string to C++ string type "+d);var wA=L(j),oA=Lt(4+wA+c);return m[oA>>2]=wA>>Y,p(j,oA+4,wA+c),b!==null&&b.push(kI,oA),oA},argPackAdvance:8,readValueFromPointer:Jt,destructorFunction:function(b){kI(b)}})}function zs(h,c){c=q(c),lA(h,{isVoid:!0,name:c,argPackAdvance:0,fromWireType:function(){},toWireType:function(d,F){}})}var Ws={};function vs(h){var c=Ws[h];return c===void 0?q(h):c}function wi(){if(typeof globalThis=="object")return globalThis;function h(c){c.$$$embind_global$$$=c;var d=typeof $$$embind_global$$$=="object"&&c.$$$embind_global$$$==c;return d||delete c.$$$embind_global$$$,d}if(typeof $$$embind_global$$$=="object"||(typeof global=="object"&&h(global)?$$$embind_global$$$=global:typeof self=="object"&&h(self)&&($$$embind_global$$$=self),typeof $$$embind_global$$$=="object"))return $$$embind_global$$$;throw Error("unable to get global object.")}function Os(h){return h===0?Rg.toHandle(wi()):(h=vs(h),Rg.toHandle(wi()[h]))}function Vs(h){h>4&&(YA[h].refcount+=1)}function Xs(h,c){var d=$A[h];return d===void 0&&UA(c+" has unknown type "+di(h)),d}function Ps(h){var c=new Array(h+1);return function(d,F,p){c[0]=d;for(var R=0;R<h;++R){var L=Xs(m[F+R*4>>2],"parameter "+R);c[R+1]=L.readValueFromPointer(p),p+=L.argPackAdvance}var Y=new(d.bind.apply(d,c));return Rg.toHandle(Y)}}var ui={};function js(h,c,d,F){h=Rg.toValue(h);var p=ui[c];return p||(p=Ps(c),ui[c]=p),p(h,d,F)}function _s(){NA("")}function $s(h,c,d){S.copyWithin(h,c,c+d)}function Ae(){return 2147483648}function Ie(h){var c=l.buffer;try{return l.grow(h-c.byteLength+65535>>>16),z(),1}catch{}}function ge(h){var c=S.length;h=h>>>0;var d=Ae();if(h>d)return!1;let F=(b,j)=>b+(j-b%j)%j;for(var p=1;p<=4;p*=2){var R=c*(1+.2/p);R=Math.min(R,h+100663296);var L=Math.min(d,F(Math.max(h,R),65536)),Y=Ie(L);if(Y)return!0}return!1}P(),pg=I.BindingError=Ag(Error,"BindingError"),Mg=I.InternalError=Ag(Error,"InternalError"),Ds(),yi=I.UnboundTypeError=Ag(Error,"UnboundTypeError");var Be={n:nI,o:TI,l:MI,r:ls,k:ds,c:ms,b:Us,a:Ys,g:Js,f:Zs,m:zs,d:Di,e:Os,i:Vs,h:js,j:_s,q:$s,p:ge};X();var Lt=function(){return(Lt=I.asm.u).apply(null,arguments)},kI=function(){return(kI=I.asm.v).apply(null,arguments)},fi=I.___getTypeName=function(){return(fi=I.___getTypeName=I.asm.w).apply(null,arguments)};I.__embind_initialize_bindings=function(){return(I.__embind_initialize_bindings=I.asm.x).apply(null,arguments)};var Gi=function(){return(Gi=I.asm.z).apply(null,arguments)},zB;Z=function h(){zB||Fi(),zB||(Z=h)};function Fi(){if(v>0||(CA(),v>0))return;function h(){zB||(zB=!0,I.calledRun=!0,!y&&(QA(),g(I),I.onRuntimeInitialized&&I.onRuntimeInitialized(),EA()))}I.setStatus?(I.setStatus("Running..."),setTimeout(function(){setTimeout(function(){I.setStatus("")},1),h()},1)):h()}if(I.preInit)for(typeof I.preInit=="function"&&(I.preInit=[I.preInit]);I.preInit.length>0;)I.preInit.pop()();return Fi(),I.ready}})();let Ft;async function tE(E,A){let I=E,g=A;arguments.length===1&&!(E instanceof WebAssembly.Module)&&(I=void 0,g=E),Ft=gE(BE,I,g)}async function QE(E){Ft||tE();const I=(await Ft).decode(E);if(!I)throw new Error("Decoding error");return I}async function iE(E,A){const I=JSON.parse(new TextDecoder().decode(E));if(I.quats.encoding!=="quaternion_packed")throw new Error("Unsupported quaternion encoding");const g=I.means.shape[0],B=pB(g),t=new Uint32Array(B*4),Q={},i=await Promise.all([vg(A[I.means.files[0]]),vg(A[I.means.files[1]])]);for(let n=0;n<g;++n){const r=n*4,D=(i[0][r+0]+(i[1][r+0]<<8))/65535,l=(i[0][r+1]+(i[1][r+1]<<8))/65535,y=(i[0][r+2]+(i[1][r+2]<<8))/65535;let w=I.means.mins[0]+(I.means.maxs[0]-I.means.mins[0])*D,u=I.means.mins[1]+(I.means.maxs[1]-I.means.mins[1])*l,G=I.means.mins[2]+(I.means.maxs[2]-I.means.mins[2])*y;w=Math.sign(w)*(Math.exp(Math.abs(w))-1),u=Math.sign(u)*(Math.exp(Math.abs(u))-1),G=Math.sign(G)*(Math.exp(Math.abs(G))-1),HQ(t,n,w,u,G)}const C=await vg(A[I.scales.files[0]]);for(let n=0;n<g;++n){const r=n*4,D=C[r+0]/255,l=C[r+1]/255,y=C[r+2]/255,w=I.scales.mins[0]+(I.scales.maxs[0]-I.scales.mins[0])*D,u=I.scales.mins[1]+(I.scales.maxs[1]-I.scales.mins[1])*l,G=I.scales.mins[2]+(I.scales.maxs[2]-I.scales.mins[2])*y;bQ(t,n,Math.exp(w),Math.exp(u),Math.exp(G))}const s=await vg(A[I.quats.files[0]]),o=Math.sqrt(2);for(let n=0;n<g;++n){const r=n*4,D=(s[r+0]/255-.5)*o,l=(s[r+1]/255-.5)*o,y=(s[r+2]/255-.5)*o,w=Math.sqrt(Math.max(0,1-D*D-l*l-y*y)),u=s[r+3]-252,G=u===0?D:u===1?w:l,M=u<=1?l:u===2?w:y,x=u<=2?y:w;KQ(t,n,G,M,x,u===0?w:D)}const e=await vg(A[I.sh0.files[0]]),a=.28209479177387814;for(let n=0;n<g;++n){const r=n*4,D=e[r+0]/255,l=e[r+1]/255,y=e[r+2]/255,w=e[r+3]/255,u=I.sh0.mins[0]+(I.sh0.maxs[0]-I.sh0.mins[0])*D,G=I.sh0.mins[1]+(I.sh0.maxs[1]-I.sh0.mins[1])*l,M=I.sh0.mins[2]+(I.sh0.maxs[2]-I.sh0.mins[2])*y,x=I.sh0.mins[3]+(I.sh0.maxs[3]-I.sh0.mins[3])*w,k=a*u+.5,S=a*G+.5,N=a*M+.5,H=1/(1+Math.exp(-x));qC(t,n,k,S,N,H)}if(I.shN){Q.sh1=new Uint32Array(g*2),Q.sh2=new Uint32Array(g*4),Q.sh3=new Uint32Array(g*4);const n=new Float32Array(9),r=new Float32Array(15),D=new Float32Array(21),[l,y]=await Promise.all([St(A[I.shN.files[0]]),St(A[I.shN.files[1]])]);for(let w=0;w<g;++w){const u=w*4,G=y.rgba[u+0]+(y.rgba[u+1]<<8),M=(G&63)*15,k=(G>>>6)*l.width+M;for(let S=0;S<3;++S){for(let N=0;N<3;++N)n[N*3+S]=I.shN.mins+(I.shN.maxs-I.shN.mins)*l.rgba[(k+N)*4+S]/255;for(let N=0;N<5;++N)r[N*3+S]=I.shN.mins+(I.shN.maxs-I.shN.mins)*l.rgba[(k+3+N)*4+S]/255;for(let N=0;N<7;++N)D[N*3+S]=I.shN.mins+(I.shN.maxs-I.shN.mins)*l.rgba[(k+8+N)*4+S]/255}kB(Q.sh1,w,n),RB(Q.sh2,w,r),mB(Q.sh3,w,D)}}return{packedArray:t,numSplats:g,extra:Q}}async function St(E){const{data:A,width:I,height:g}=await QE(E);return{rgba:A,width:I,height:g}}async function vg(E){const{rgba:A}=await St(E);return A}const Ng=class Ng{constructor({fileBytes:A}){this.header="",this.littleEndian=!0,this.elements={},this.comments=[],this.data=null,this.numSplats=0,this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A}async parseHeader(){const I=new ReadableStream({start:Q=>{Q.enqueue(this.fileBytes.slice(0,65536)),Q.close()}}).pipeThrough(new TextDecoderStream).getReader();this.header="";const g=`end_header\n`;for(;;){const{value:Q,done:i}=await I.read();if(i)throw new Error("Failed to read header");this.header+=Q;const C=this.header.indexOf(g);if(C>=0){this.header=this.header.slice(0,C+g.length);break}}const B=new TextEncoder().encode(this.header).length;this.data=new DataView(this.fileBytes.buffer,B),this.elements={};let t=null;this.comments=[],this.header.trim().split(`\n`).forEach((Q,i)=>{const C=Q.trim();if(i===0){if(C!=="ply")throw new Error("Invalid PLY header");return}if(C.length===0)return;const s=C.split(" ");switch(s[0]){case"format":if(s[1]==="binary_little_endian")this.littleEndian=!0;else if(s[1]==="binary_big_endian")this.littleEndian=!1;else throw new Error(`Unsupported PLY format: ${s[1]}`);if(s[2]!=="1.0")throw new Error(`Unsupported PLY version: ${s[2]}`);break;case"end_header":break;case"comment":this.comments.push(C.slice(8));break;case"element":{const o=s[1];t={name:o,count:Number.parseInt(s[2]),properties:{}},this.elements[o]=t;break}case"property":if(t==null)throw new Error("Property must be inside an element");s[1]==="list"?t.properties[s[4]]={isList:!0,type:s[3],countType:s[2]}:t.properties[s[2]]={isList:!1,type:s[1]};break}}),this.elements.vertex&&(this.numSplats=this.elements.vertex.count)}parseData(A){let I=0;const g=this.data;if(g==null)throw new Error("No data to parse");for(const B in this.elements){const t=this.elements[B],{count:Q,properties:i}=t,C={},s=[];for(const[e,a]of Object.entries(i))a.isList?(C[e]=[],s.push(()=>{const n=C[e];n.length=YB[a.countType](g,I,this.littleEndian),I+=fg[a.countType];for(let r=0;r<n.length;r++)n[r]=YB[a.type](g,I,this.littleEndian),I+=fg[a.type]})):(C[e]=0,s.push(()=>{C[e]=YB[a.type](g,I,this.littleEndian),I+=fg[a.type]}));const o=A(t)??(()=>{});for(let e=0;e<Q;e++){for(const a of s)a();o(e,C)}}}parseSplats(A,I){if(this.elements.vertex==null)throw new Error("No vertex element found");let g=!1;const B=[];let t=0,Q=[],i=[],C=[],s,o,e;function a(){const y=EE[t];Q=new Array(3).fill(null).flatMap((w,u)=>[0,1,2].map((G,M)=>`f_rest_${u+M*y/3}`)),i=new Array(5).fill(null).flatMap((w,u)=>[0,1,2].map((G,M)=>`f_rest_${3+u+M*y/3}`)),C=new Array(7).fill(null).flatMap((w,u)=>[0,1,2].map((G,M)=>`f_rest_${8+u+M*y/3}`)),s=t>=1?new Float32Array(3*3):void 0,o=t>=2?new Float32Array(5*3):void 0,e=t>=3?new Float32Array(7*3):void 0}function n(y,w){if(!s)throw new Error("Missing sh1");for(const[u,G]of Q.entries())s[u]=w[G]*8/255-4;if(o)for(const[u,G]of i.entries())o[u]=w[G]*8/255-4;if(e)for(const[u,G]of C.entries())e[u]=w[G]*8/255-4;I==null||I(y,s,o,e)}function r(y){const{min_x:w,min_y:u,min_z:G,max_x:M,max_y:x,max_z:k,min_scale_x:S,min_scale_y:N,min_scale_z:H,max_scale_x:U,max_scale_y:m,max_scale_z:J}=y.properties;if(!w||!u||!G||!M||!x||!k||!S||!N||!H||!U||!m||!J)throw new Error("Missing PLY chunk properties");return g=!0,(K,z)=>{const{min_x:T,min_y:W,min_z:BA,max_x:AA,max_y:CA,max_z:QA,min_scale_x:EA,min_scale_y:IA,min_scale_z:_,max_scale_x:O,max_scale_y:v,max_scale_z:Z,min_r:RA,min_g:SA,min_b:NA,max_r:mA,max_g:xA,max_b:nA}=z;B.push({min_x:T,min_y:W,min_z:BA,max_x:AA,max_y:CA,max_z:QA,min_scale_x:EA,min_scale_y:IA,min_scale_z:_,max_scale_x:O,max_scale_y:v,max_scale_z:Z,min_r:RA,min_g:SA,min_b:NA,max_r:mA,max_g:xA,max_b:nA})}}function D(y){if(I&&y.name==="sh")return t=vQ(y.properties),a(),n;if(y.name!=="vertex")return null;const{packed_position:w,packed_rotation:u,packed_scale:G,packed_color:M}=y.properties;if(!w||!u||!G||!M)throw new Error("Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color");const x=Math.sqrt(2);return(k,S)=>{const N=B[k>>>8];if(N==null)throw new Error("Missing PLY chunk");const{min_x:H,min_y:U,min_z:m,max_x:J,max_y:K,max_z:z,min_scale_x:T,min_scale_y:W,min_scale_z:BA,max_scale_x:AA,max_scale_y:CA,max_scale_z:QA,min_r:EA,min_g:IA,min_b:_,max_r:O,max_g:v,max_b:Z}=N,{packed_position:RA,packed_rotation:SA,packed_scale:NA,packed_color:mA}=S,xA=(RA>>>21&2047)/2047*(J-H)+H,nA=(RA>>>11&1023)/1023*(K-U)+U,OA=(RA&2047)/2047*(z-m)+m,KA=((SA>>>20&1023)/1023-.5)*x,TA=((SA>>>10&1023)/1023-.5)*x,VA=((SA&1023)/1023-.5)*x,X=Math.sqrt(Math.max(0,1-KA*KA-TA*TA-VA*VA)),rA=SA>>>30,V=rA===0?KA:rA===1?X:TA,nI=rA<=1?TA:rA===2?X:VA,TI=rA<=2?VA:X,hA=rA===0?X:KA,P=Math.exp((NA>>>21&2047)/2047*(AA-T)+T),sA=Math.exp((NA>>>11&1023)/1023*(CA-W)+W),q=Math.exp((NA&2047)/2047*(QA-BA)+BA),pA=(mA>>>24&255)/255*((O??1)-(EA??0))+(EA??0),$A=(mA>>>16&255)/255*((v??1)-(IA??0))+(IA??0),DI=(mA>>>8&255)/255*((Z??1)-(_??0))+(_??0),$I=(mA&255)/255;A(k,xA,nA,OA,P,sA,q,V,nI,TI,hA,$I,pA,$A,DI)}}const l=y=>{if(y.name==="chunk")return r(y);if(g)return D(y);if(y.name!=="vertex")return null;const{x:w,y:u,z:G,scale_0:M,scale_1:x,scale_2:k,rot_0:S,rot_1:N,rot_2:H,rot_3:U,opacity:m,f_dc_0:J,f_dc_1:K,f_dc_2:z,red:T,green:W,blue:BA,alpha:AA}=y.properties;if(!w||!u||!G)throw new Error("Missing PLY properties: x, y, z");const CA=M&&x&&k,QA=S&&N&&H&&U,EA=AA!=null?JB[AA.type]:1,IA=T!=null?JB[T.type]:1,_=W!=null?JB[W.type]:1,O=BA!=null?JB[BA.type]:1;return t=vQ(y.properties),a(),(v,Z)=>{const RA=CA?Math.exp(Z.scale_0):Ng.defaultPointScale,SA=CA?Math.exp(Z.scale_1):Ng.defaultPointScale,NA=CA?Math.exp(Z.scale_2):Ng.defaultPointScale,mA=QA?Z.rot_1:0,xA=QA?Z.rot_2:0,nA=QA?Z.rot_3:0,OA=QA?Z.rot_0:1,KA=m!=null?1/(1+Math.exp(-Z.opacity)):AA!=null?Z.alpha/EA:1,TA=J!=null?Z.f_dc_0*UB+.5:T!=null?Z.red/IA:1,VA=K!=null?Z.f_dc_1*UB+.5:W!=null?Z.green/_:1,X=z!=null?Z.f_dc_2*UB+.5:BA!=null?Z.blue/O:1;if(A(v,Z.x,Z.y,Z.z,RA,SA,NA,mA,xA,nA,OA,KA,TA,VA,X),I&&s){if(s)for(const[rA,V]of Q.entries())s[rA]=Z[V];if(o)for(const[rA,V]of i.entries())o[rA]=Z[V];if(e)for(const[rA,V]of C.entries())e[rA]=Z[V];I(v,s,o,e)}}};this.parseData(l)}injectRgba(A){let I=0;const g=this.data;if(g==null)throw new Error("No parsed data");if(A.length!==this.numSplats*4)throw new Error("Invalid RGBA array length");for(const B in this.elements){const t=this.elements[B],{count:Q,properties:i}=t,C=[];let s=0;const o=B==="vertex";if(o){for(const e of["opacity","f_dc_0","f_dc_1","f_dc_2"])if(!i[e]||i[e].type!=="float")throw new Error(`Can\'t injectRgba due to property: ${e}`)}for(const[e,a]of Object.entries(i))if(a.isList)C.push(()=>{const n=YB[a.countType](g,I,this.littleEndian);I+=fg[a.countType],I+=n*fg[a.type]});else{if(o)if(e==="f_dc_0"||e==="f_dc_1"||e==="f_dc_2"){const n=Number.parseInt(e.slice(5));C.push(()=>{const r=(A[s+n]/255-.5)/UB;WQ[a.type](g,I,this.littleEndian,r)})}else e==="opacity"&&C.push(()=>{const n=Math.max(-100,Math.min(100,-Math.log(1/(A[s+3]/255)-1)));WQ[a.type](g,I,this.littleEndian,n)});C.push(()=>{I+=fg[a.type]})}for(let e=0;e<Q;e++){for(const a of C)a();o&&(s+=4)}}}};Ng.defaultPointScale=.001;let Og=Ng;const UB=.28209479177387814,YB={char:(E,A,I)=>E.getInt8(A),uchar:(E,A,I)=>E.getUint8(A),short:(E,A,I)=>E.getInt16(A,I),ushort:(E,A,I)=>E.getUint16(A,I),int:(E,A,I)=>E.getInt32(A,I),uint:(E,A,I)=>E.getUint32(A,I),float:(E,A,I)=>E.getFloat32(A,I),double:(E,A,I)=>E.getFloat64(A,I)},WQ={char:(E,A,I,g)=>{E.setInt8(A,g)},uchar:(E,A,I,g)=>{E.setUint8(A,g)},short:(E,A,I,g)=>{E.setInt16(A,g,I)},ushort:(E,A,I,g)=>{E.setUint16(A,g,I)},int:(E,A,I,g)=>{E.setInt32(A,g,I)},uint:(E,A,I,g)=>{E.setUint32(A,g,I)},float:(E,A,I,g)=>{E.setFloat32(A,g,I)},double:(E,A,I,g)=>{E.setFloat64(A,g,I)}},fg={char:1,uchar:1,short:2,ushort:2,int:4,uint:4,float:4,double:8},JB={char:127,uchar:255,short:32767,ushort:65535,int:2147483647,uint:4294967295,float:1,double:1},CE={0:0,9:1,24:2,45:3},EE={0:0,1:9,2:24,3:45};function vQ(E){let A=0;for(;E[`f_rest_${A}`];)A+=1;const I=CE[A];if(I==null)throw new Error(`Unsupported number of SH coefficients: ${A}`);return I}const vA={type:"Gsplat"},Nt={type:"PackedSplats"},sE=(E,A)=>new aE({packedSplats:E,index:A}),eE=(E,A,I,g)=>new nE({packedSplats:E,index:A,base:I,count:g}),LB=E=>new rE({gsplat:E}),pt=({gsplat:E,flags:A,index:I,center:g,scales:B,quaternion:t,rgba:Q,rgb:i,opacity:C,x:s,y:o,z:e,r:a,g:n,b:r})=>new hE({gsplat:E,flags:A,index:I,center:g,scales:B,quaternion:t,rgba:Q,rgb:i,opacity:C,x:s,y:o,z:e,r:a,g:n,b:r}),oE=(E,{scale:A,rotate:I,translate:g,recolor:B})=>new cE({gsplat:E,scale:A,rotate:I,translate:g,recolor:B}),NI=aI(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`),Mt=aI(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n`),OQ=aI(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);class aE extends bA{constructor({packedSplats:A,index:I}){super({inTypes:{packedSplats:Nt,index:"int"},outTypes:{gsplat:vA},inputs:{packedSplats:A,index:I},globals:()=>[NI,Mt,OQ],statements:({inputs:g,outputs:B})=>{const{gsplat:t}=B;if(!t)return[];const{packedSplats:Q,index:i}=g;let C;return Q&&i?C=SI(`\n            if (readPackedSplat(${Q}.texture, ${Q}.numSplats, ${i}, ${t})) {\n              bool zeroSize = all(equal(${t}.scales, vec3(0.0, 0.0, 0.0)));\n              ${t}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${t}.flags = 0u;\n            }\n          `):C=[`${t}.flags = 0u;`],C.push(`${t}.index = ${i??"0"};`),C}})}dynoOut(){return new jA(this,"gsplat")}}class nE extends bA{constructor({packedSplats:A,index:I,base:g,count:B}){super({inTypes:{packedSplats:Nt,index:"int",base:"int",count:"int"},outTypes:{gsplat:vA},inputs:{packedSplats:A,index:I,base:g,count:B},globals:()=>[NI,Mt,OQ],statements:({inputs:t,outputs:Q})=>{const{gsplat:i}=Q;if(!i)return[];const{packedSplats:C,index:s,base:o,count:e}=t;let a;return C&&s&&o&&e?a=SI(`\n            ${i}.flags = 0u;\n            if ((${s} >= ${o}) && (${s} < (${o} + ${e}))) {\n              if (readPackedSplat(${C}.texture, ${C}.numSplats, ${s}, ${i})) {\n                bool zeroSize = all(equal(${i}.scales, vec3(0.0, 0.0, 0.0)));\n                ${i}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `):a=[`${i}.flags = 0u;`],a.push(`${i}.index = ${s??"0"};`),a}})}dynoOut(){return new jA(this,"gsplat")}}class rE extends bA{constructor({gsplat:A}){super({inTypes:{gsplat:vA},outTypes:{flags:"uint",active:"bool",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},inputs:{gsplat:A},globals:()=>[NI],statements:({inputs:I,outputs:g})=>{const{gsplat:B}=I,{flags:t,active:Q,index:i,center:C,scales:s,quaternion:o,rgba:e,rgb:a,opacity:n,x:r,y:D,z:l,r:y,g:w,b:u}=g;return[t?`${t} = ${B?`${B}.flags`:"0u"};`:null,Q?`${Q} = isGsplatActive(${B?`${B}.flags`:"0u"});`:null,i?`${i} = ${B?`${B}.index`:"0"};`:null,C?`${C} = ${B?`${B}.center`:"vec3(0.0, 0.0, 0.0)"};`:null,s?`${s} = ${B?`${B}.scales`:"vec3(0.0, 0.0, 0.0)"};`:null,o?`${o} = ${B?`${B}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)"};`:null,e?`${e} = ${B?`${B}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)"};`:null,a?`${a} = ${B?`${B}.rgba.rgb`:"vec3(0.0, 0.0, 0.0)"};`:null,n?`${n} = ${B?`${B}.rgba.a`:"0.0"};`:null,r?`${r} = ${B?`${B}.center.x`:"0.0"};`:null,D?`${D} = ${B?`${B}.center.y`:"0.0"};`:null,l?`${l} = ${B?`${B}.center.z`:"0.0"};`:null,y?`${y} = ${B?`${B}.rgba.r`:"0.0"};`:null,w?`${w} = ${B?`${B}.rgba.g`:"0.0"};`:null,u?`${u} = ${B?`${B}.rgba.b`:"0.0"};`:null].filter(Boolean)}})}}class hE extends bA{constructor({gsplat:A,flags:I,index:g,center:B,scales:t,quaternion:Q,rgba:i,rgb:C,opacity:s,x:o,y:e,z:a,r:n,g:r,b:D}){super({inTypes:{gsplat:vA,flags:"uint",index:"int",center:"vec3",scales:"vec3",quaternion:"vec4",rgba:"vec4",rgb:"vec3",opacity:"float",x:"float",y:"float",z:"float",r:"float",g:"float",b:"float"},outTypes:{gsplat:vA},inputs:{gsplat:A,flags:I,index:g,center:B,scales:t,quaternion:Q,rgba:i,rgb:C,opacity:s,x:o,y:e,z:a,r:n,g:r,b:D},globals:()=>[NI],statements:({inputs:l,outputs:y})=>{const{gsplat:w}=y;if(!w)return[];const{gsplat:u,flags:G,index:M,center:x,scales:k,quaternion:S,rgba:N,rgb:H,opacity:U,x:m,y:J,z:K,r:z,g:T,b:W}=l;return[`${w}.flags = ${G??(u?`${u}.flags`:"0u")};`,`${w}.index = ${M??(u?`${u}.index`:"0")};`,`${w}.center = ${x??(u?`${u}.center`:"vec3(0.0, 0.0, 0.0)")};`,`${w}.scales = ${k??(u?`${u}.scales`:"vec3(0.0, 0.0, 0.0)")};`,`${w}.quaternion = ${S??(u?`${u}.quaternion`:"vec4(0.0, 0.0, 0.0, 1.0)")};`,`${w}.rgba = ${N??(u?`${u}.rgba`:"vec4(0.0, 0.0, 0.0, 0.0)")};`,H?`${w}.rgba.rgb = ${H};`:null,U?`${w}.rgba.a = ${U};`:null,m?`${w}.center.x = ${m};`:null,J?`${w}.center.y = ${J};`:null,K?`${w}.center.z = ${K};`:null,z?`${w}.rgba.r = ${z};`:null,T?`${w}.rgba.g = ${T};`:null,W?`${w}.rgba.b = ${W};`:null].filter(Boolean)}})}dynoOut(){return new jA(this,"gsplat")}}aI(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);class cE extends bA{constructor({gsplat:A,scale:I,rotate:g,translate:B,recolor:t}){super({inTypes:{gsplat:vA,scale:"float",rotate:"vec4",translate:"vec3",recolor:"vec4"},outTypes:{gsplat:vA},inputs:{gsplat:A,scale:I,rotate:g,translate:B,recolor:t},globals:()=>[NI],statements:({inputs:Q,outputs:i,compile:C})=>{const{gsplat:s}=i;if(!s||!Q.gsplat)return[];const{scale:o,rotate:e,translate:a,recolor:n}=Q,r=C.indent;return[`${s} = ${Q.gsplat};`,`if (isGsplatActive(${s}.flags)) {`,o?`${r}${s}.center *= ${o};`:null,e?`${r}${s}.center = quatVec(${e}, ${s}.center);`:null,a?`${r}${s}.center += ${a};`:null,o?`${r}${s}.scales *= ${o};`:null,e?`${r}${s}.quaternion = quatQuat(${e}, ${s}.quaternion);`:null,n?`${r}${s}.rgba *= ${n};`:null,"}"].filter(Boolean)}})}dynoOut(){return new jA(this,"gsplat")}}const DE=E=>new lE({gsplat:E});class lE extends bA{constructor({gsplat:A}){super({inTypes:{gsplat:vA},inputs:{gsplat:A},globals:()=>[NI],statements:({inputs:I,outputs:g})=>{const{output:B}=g;if(!B)return[];const{gsplat:t}=I;return t?SI(`\n            if (isGsplatActive(${t}.flags)) {\n              ${B} = packSplat(${t}.center, ${t}.scales, ${t}.quaternion, ${t}.rgba);\n            } else {\n              ${B} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `):[`${B} = uvec4(0u, 0u, 0u, 0u);`]}})}dynoOut(){return new jA(this,"output")}}class yE extends bA{constructor({rgba8:A}){super({inTypes:{rgba8:"vec4"},inputs:{rgba8:A},statements:({inputs:I,outputs:g})=>[`target = ${I.rgba8??"vec4(0.0, 0.0, 0.0, 0.0)"};`]})}dynoOut(){return new jA(this,"rgba8")}}class pI extends bA{constructor({key:A,type:I,count:g,value:B,update:t,globals:Q}){A=A??"value",super({outTypes:{[A]:I},update:()=>{if(t){const i=t(this.value);i!==void 0&&(this.value=i)}this.uniform.value=this.value},generate:({inputs:i,outputs:C})=>{const s=(Q==null?void 0:Q({inputs:i,outputs:C}))??[],o={},e=C[A];return e&&(s.push(`uniform ${YQ(e,I,g)};`),o[e]=this.uniform),{globals:s,uniforms:o}}}),this.type=I,this.count=g,this.value=B,this.uniform={value:B},this.outKey=A}dynoOut(){return new jA(this,this.outKey)}}class kt extends pI{constructor({key:A,value:I,update:g}){super({key:A,type:"int",value:I,update:g})}}class HB extends pI{constructor({key:A,value:I,update:g}){super({key:A,type:"float",value:I,update:g})}}class dE extends pI{constructor({key:A,value:I,update:g}){super({key:A,type:"vec3",value:I,update:g})}}class VQ extends pI{constructor({key:A,value:I,update:g}){super({key:A,type:"vec4",value:I,update:g})}}class Rt extends pI{constructor({key:A,value:I,update:g}){super({key:A,type:"usampler2DArray",value:I,update:g})}}class XQ{constructor({graph:A,inputs:I,outputs:g,template:B}){this.graph=A,this.template=B,this.inputs=I??{},this.outputs=g??{};const t=new HC({indent:this.template.indent});for(const i in this.outputs)this.outputs[i]&&t.declares.add(this.outputs[i]);const Q=A.compile({inputs:this.inputs,outputs:this.outputs,compile:t});this.shader=B.generate({globals:t.globals,statements:Q}),this.uniforms=t.uniforms,this.updaters=t.updaters}prepareMaterial(){return wE(this)}update(){for(const A of this.updaters)A()}}class PQ{constructor(A){const I=A.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m),g=A.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);if(!I||!g)throw new Error("Template must contain {{ GLOBALS }} and {{ STATEMENTS }}");this.before=A.substring(0,I.index),this.between=A.substring(I.index+I[0].length,g.index),this.after=A.substring(g.index+g[0].length),this.indent=g[1]}generate({globals:A,statements:I}){return this.before+Array.from(A).join(`\n\n`)+this.between+I.map(g=>this.indent+g).join(`\n`)+this.after}}const jQ=new Map;function wE(E){let A=jQ.get(E);return A||(A=new yt({glslVersion:ji,vertexShader:XC,fragmentShader:E.shader,uniforms:E.uniforms}),jQ.set(E,A),A)}function _Q(E,A,I="add"){const g=()=>{throw new Error(`Invalid ${I} types: ${E}, ${A}`)};if(E===A)return E;if(E==="int"){if(Dg(A))return A;g()}if(A==="int"){if(Dg(E))return E;g()}if(E==="uint"){if(lg(A))return A;g()}if(A==="uint"){if(lg(E))return E;g()}if(E==="float"){if(GB(A))return A;g()}if(A==="float"){if(GB(E))return E;g()}throw new Error(`Invalid ${I} types: ${E}, ${A}`)}function uE(E,A){return _Q(E,A,"sub")}function fE(E,A){const I=()=>{throw new Error(`Invalid mul types: ${E}, ${A}`)},g=B=>B;if(E==="int"){if(Dg(A))return g(A);I()}if(A==="int"){if(Dg(E))return g(E);I()}if(E==="uint"){if(lg(A))return g(A);I()}if(A==="uint"){if(lg(E))return g(E);I()}if(E==="float"){if(GB(A))return g(A);I()}if(A==="float"){if(GB(E))return g(E);I()}if(Dg(E)||lg(E)||Dg(A)||lg(A)){if(E===A)return g(E);I()}if(E==="vec2"){if(A==="vec2"||yg(A))return g("vec2");if(A==="mat3x2")return g("vec3");if(A==="mat4x2")return g("vec4");I()}if(E==="vec3"){if(A==="mat2x3")return g("vec2");if(A==="vec3"||dg(A))return g("vec3");if(A==="mat4x3")return g("vec4");I()}if(E==="vec4"){if(A==="mat2x4")return g("vec2");if(A==="mat3x4")return g("vec3");if(A==="vec4"||wg(A))return g("vec4");I()}if(A==="vec2"){if(yg(E))return g("vec2");if(E==="mat2x3")return g("vec3");if(E==="mat2x4")return g("vec4");I()}if(A==="vec3"){if(E==="mat3x2")return g("vec2");if(dg(E))return g("vec3");if(E==="mat3x4")return g("vec4");I()}if(A==="vec4"){if(E==="mat4x2")return g("vec2");if(E==="mat4x3")return g("vec3");if(wg(E))return g("vec4");I()}if(yg(E)){if(yg(A))return g("mat2");if(A==="mat3x2")return g("mat3x2");if(A==="mat4x2")return g("mat4x2");I()}if(E==="mat2x3"){if(yg(A))return g("mat2x3");if(A==="mat3x2")return g("mat3");if(A==="mat4x2")return g("mat4x3");I()}if(E==="mat2x4"){if(yg(A))return g("mat2x4");if(A==="mat3x2")return g("mat3x4");if(A==="mat4x2")return g("mat4");I()}if(E==="mat3x2"){if(A==="mat2x3")return g("mat2");if(dg(A))return g("mat3x2");if(A==="mat4x3")return g("mat4x2");I()}if(dg(E)){if(A==="mat2x3")return g("mat2x3");if(dg(A))return g("mat3");if(A==="mat4x3")return g("mat4x3");I()}if(E==="mat3x4"){if(A==="mat2x3")return g("mat2x4");if(dg(A))return g("mat3x4");if(A==="mat4x3")return g("mat4");I()}if(E==="mat4x2"){if(A==="mat2x4")return g("mat2");if(A==="mat3x4")return g("mat3x2");if(wg(A))return g("mat4x2");I()}if(E==="mat4x3"){if(A==="mat2x4")return g("mat2x3");if(A==="mat3x4")return g("mat3");if(wg(A))return g("mat4x3");I()}if(wg(E)){if(A==="mat2x4")return g("mat2x4");if(A==="mat3x4")return g("mat3x4");if(wg(A))return g("mat4");I()}throw new Error(`Invalid mul types: ${E}, ${A}`)}const bB=(E,A)=>new SE({a:E,b:A}),GE=(E,A)=>new NE({a:E,b:A}),FE=(E,A)=>new pE({a:E,b:A});class SE extends NB{constructor({a:A,b:I}){super({a:A,b:I,outKey:"sum",outTypeFunc:_Q}),this.statements=({inputs:g,outputs:B})=>[`${B.sum} = ${g.a} + ${g.b};`]}}class NE extends NB{constructor({a:A,b:I}){super({a:A,b:I,outKey:"difference",outTypeFunc:uE}),this.statements=({inputs:g,outputs:B})=>[`${B.difference} = ${g.a} - ${g.b};`]}}class pE extends NB{constructor({a:A,b:I}){super({a:A,b:I,outKey:"product",outTypeFunc:fE}),this.statements=({inputs:g,outputs:B})=>[`${B.product} = ${g.a} * ${g.b};`]}}const ME=E=>new RE({a:E}),kE=(E,A)=>new xE({a:E,b:A});class RE extends KC{constructor({a:A}){super({a:A,outTypeFunc:I=>I,outKey:"normalize"}),this.statements=({inputs:I,outputs:g})=>[`${g.normalize} = normalize(${I.a});`]}}function mE(E){if(E==="float")return"vec2";if(E==="vec2")return"vec3";if(E==="vec3")return"vec4";throw new Error("Invalid type")}class xE extends NB{constructor({a:A,b:I}){const g=jI(A),B=mE(g);super({a:A,b:I,outKey:"extend",outTypeFunc:()=>B}),this.statements=({inputs:t,outputs:Q})=>[`${Q.extend} = ${B}(${t.a}, ${t.b});`]}}const UE=(E,{scale:A,scales:I,rotate:g,translate:B})=>new JE({position:E,scale:A,scales:I,rotate:g,translate:B}).outputs.position,YE=(E,{scale:A,scales:I,rotate:g})=>new LE({dir:E,scale:A,scales:I,rotate:g}).outputs.dir;class JE extends bA{constructor({position:A,scale:I,scales:g,rotate:B,translate:t}){super({inTypes:{position:"vec3",scale:"float",scales:"vec3",rotate:"vec4",translate:"vec3"},outTypes:{position:"vec3"},inputs:{position:A,scale:I,scales:g,rotate:B,translate:t},statements:({inputs:Q,outputs:i})=>{const{position:C}=i;if(!C)return[];const{scale:s,scales:o,rotate:e,translate:a}=Q;return[`${C} = ${Q.position??"vec3(0.0, 0.0, 0.0)"};`,s?`${C} *= ${s};`:null,o?`${C} *= ${o};`:null,e?`${C} = quatVec(${e}, ${C});`:null,a?`${C} += ${a};`:null].filter(Boolean)}})}}class LE extends bA{constructor({dir:A,scale:I,scales:g,rotate:B}){super({inTypes:{dir:"vec3",scale:"float",scales:"vec3",rotate:"vec4"},outTypes:{dir:"vec3"},inputs:{dir:A,scale:I,scales:g,rotate:B},statements:({inputs:t,outputs:Q})=>{const{dir:i}=Q;if(!i)return[];const{scale:C,scales:s,rotate:o}=t;return[`${i} = ${t.dir??"vec3(0.0, 0.0, 0.0)"};`,C?`${i} *= ${C};`:null,s?`${i} *= ${s};`:null,o?`${i} = quatVec(${o}, ${i});`:null].filter(Boolean)}})}}var HE=`precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}`;const iA=class iA{constructor(A={}){this.maxSplats=0,this.numSplats=0,this.packedArray=null,this.isInitialized=!1,this.target=null,this.source=null,this.needsUpdate=!0,this.extra={},this.dyno=new $Q({packedSplats:this}),this.initialized=Promise.resolve(this),this.reinitialize(A)}reinitialize(A){this.isInitialized=!1,A.url||A.fileBytes||A.construct?this.initialized=this.asyncInitialize(A).then(()=>(this.isInitialized=!0,this)):(this.initialize(A),this.isInitialized=!0,this.initialized=Promise.resolve(this))}initialize(A){A.packedArray?(this.packedArray=A.packedArray,this.maxSplats=Math.floor(this.packedArray.length/4),this.maxSplats=Math.floor(this.maxSplats/tA)*tA,this.numSplats=Math.min(this.maxSplats,A.numSplats??Number.POSITIVE_INFINITY)):(this.maxSplats=A.maxSplats??0,this.numSplats=0),this.extra=A.extra??{}}async asyncInitialize(A){const{url:I,fileBytes:g,construct:B}=A;if(I){const t=new Bs;t.packedSplats=this,await t.loadAsync(I)}else if(g){const t=await oi({input:g,fileType:A.fileType,pathOrUrl:A.fileName??I});this.initialize(t)}if(B){const t=B(this);t instanceof Promise&&await t}}dispose(){this.target&&(this.target.dispose(),this.target=null),this.source&&(this.source.dispose(),this.source=null)}ensureSplats(A){const I=A<=this.maxSplats?this.maxSplats:Math.max(A,2*this.maxSplats),g=this.packedArray?this.packedArray.length/4:0;if(!this.packedArray||I>g){this.maxSplats=_A(I).maxSplats;const B=new Uint32Array(this.maxSplats*4);this.packedArray&&B.set(this.packedArray),this.packedArray=B}return this.packedArray}ensureSplatsSh(A,I){let g,B;if(A===0)return this.ensureSplats(I);if(A===1)g=2,B="sh1";else if(A===2)g=4,B="sh2";else if(A===3)g=4,B="sh3";else throw new Error(`Invalid level: ${A}`);let t=this.extra[B]?this.extra[B].length/g:0;const Q=I<=t?t:Math.max(I,2*t);if(!this.extra[B]||Q>t){t=_A(Q).maxSplats;const i=new Uint32Array(t*g);this.extra[B]&&i.set(this.extra[B]),this.extra[B]=i}return this.extra[B]}getSplat(A){if(!this.packedArray||A>=this.numSplats)throw new Error("Invalid index");return qQ(this.packedArray,A)}setSplat(A,I,g,B,t,Q){const i=this.ensureSplats(A+1);Wg(i,A,I.x,I.y,I.z,g.x,g.y,g.z,B.x,B.y,B.z,B.w,t,Q.r,Q.g,Q.b),this.numSplats=Math.max(this.numSplats,A+1)}pushSplat(A,I,g,B,t){const Q=this.ensureSplats(this.numSplats+1);Wg(Q,this.numSplats,A.x,A.y,A.z,I.x,I.y,I.z,g.x,g.y,g.z,g.w,B,t.r,t.g,t.b),++this.numSplats}forEachSplat(A){if(!(!this.packedArray||!this.numSplats))for(let I=0;I<this.numSplats;++I){const g=qQ(this.packedArray,I);A(I,g.center,g.scales,g.quaternion,g.opacity,g.color)}}ensureGenerate(A){if(this.target&&(A??1)<=this.maxSplats)return!1;this.dispose();const I=_A(A??1),{width:g,height:B,depth:t}=I;return this.maxSplats=I.maxSplats,this.target=new nQ(g,B,t,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:mI,minFilter:mI}),this.target.texture.format=gg,this.target.texture.type=WI,this.target.texture.internalFormat="RGBA32UI",this.target.scissorTest=!0,!0}generateMapping(A){let I=0;const g=A.map(B=>{const t=I,Q=Math.ceil(B/tA)*tA;return I+=Q,{base:t,count:B}});return{maxSplats:I,mapping:g}}getTexture(){return this.target?this.target.texture:this.source||this.packedArray?this.maybeUpdateSource():iA.getEmpty()}maybeUpdateSource(){if(!this.packedArray)throw new Error("No packed splats");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:I,depth:g}=this.source.image;this.maxSplats!==A*I*g&&(this.source.dispose(),this.source=null)}if(this.source)this.packedArray.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.packedArray.buffer));else{const{width:A,height:I,depth:g}=_A(this.maxSplats);this.source=new xI(this.packedArray,A,I,g),this.source.format=gg,this.source.type=WI,this.source.internalFormat="RGBA32UI",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}static getEmpty(){if(!iA.emptySource){const{width:A,height:I,depth:g,maxSplats:B}=_A(1),t=new Uint32Array(B*4);iA.emptySource=new xI(t,A,I,g),iA.emptySource.format=gg,iA.emptySource.type=WI,iA.emptySource.internalFormat="RGBA32UI",iA.emptySource.needsUpdate=!0}return iA.emptySource}prepareProgramMaterial(A){let I=iA.generatorProgram.get(A);if(!I){const B=SB({index:"int"},{output:"uvec4"},({index:t})=>{A.inputs.index=t;const Q=A.outputs.gsplat;return{output:DE(Q)}});iA.programTemplate||(iA.programTemplate=new PQ(HE)),I=new XQ({graph:B,inputs:{index:"index"},outputs:{output:"target"},template:iA.programTemplate}),Object.assign(I.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),iA.generatorProgram.set(A,I)}const g=I.prepareMaterial();return iA.mesh.material=g,{program:I,material:g}}saveRenderState(A){return{xrEnabled:A.xr.enabled,autoClear:A.autoClear}}resetRenderState(A,I){A.setRenderTarget(null),A.xr.enabled=I.xrEnabled,A.autoClear=I.autoClear}generate({generator:A,base:I,count:g,renderer:B}){if(!this.target)throw new Error("Target must be initialized with ensureSplats");if(I+g>this.maxSplats)throw new Error("Base + count exceeds maxSplats");const{program:t,material:Q}=this.prepareProgramMaterial(A);t.update();const i=this.saveRenderState(B),C=Math.ceil((I+g)/tA)*tA,s=tA*bI;for(Q.uniforms.targetBase.value=I,Q.uniforms.targetCount.value=g;I<C;){const o=Math.floor(I/s);Q.uniforms.targetLayer.value=o;const e=o*s,a=Math.floor((I-e)/tA),n=Math.min(bI,Math.ceil((C-e)/tA));this.target.scissor.set(0,a,tA,n-a),B.setRenderTarget(this.target,o),B.xr.enabled=!1,B.autoClear=!1,B.render(iA.scene,iA.camera),I+=tA*(n-a)}return this.resetRenderState(B,i),{nextBase:C}}};iA.emptySource=null,iA.programTemplate=null,iA.generatorProgram=new Map,iA.geometry=new fB(2,2),iA.mesh=new MQ(iA.geometry,new yt({visible:!1})),iA.scene=new RQ().add(iA.mesh),iA.camera=new kQ;let Gg=iA;class $Q extends pI{constructor({packedSplats:A}={}){super({key:"packedSplats",type:Nt,globals:()=>[Mt],value:{texture:Gg.getEmpty(),numSplats:0},update:I=>{var g,B;return I.texture=((g=this.packedSplats)==null?void 0:g.getTexture())??Gg.getEmpty(),I.numSplats=((B=this.packedSplats)==null?void 0:B.numSplats)??0,I}}),this.packedSplats=A}}var bE=`precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}`;const GA=class GA{constructor({renderer:A}={}){this.renderer=A,this.capacity=0,this.count=0}dispose(){this.target&&(this.target.dispose(),this.target=void 0)}ensureBuffer(A,I){const B=Math.ceil(Math.max(1,A)/tA)*tA*4;if(I.byteLength>=B)return I;const t=new ArrayBuffer(B);if(I instanceof ArrayBuffer)return t;const Q=I.constructor;return new Q(t)}ensureCapacity(A){const{width:I,height:g,depth:B,maxSplats:t}=_A(A);(!this.target||t>this.capacity)&&(this.dispose(),this.capacity=t,this.target=new nQ(I,g,B,{depthBuffer:!1,stencilBuffer:!1,generateMipmaps:!1,magFilter:mI,minFilter:mI}),this.target.texture.format=tB,this.target.texture.type=BB,this.target.texture.internalFormat="RGBA8",this.target.scissorTest=!0)}prepareProgramMaterial(A){let I=GA.readbackProgram.get(A);if(!I){const B=SB({index:"int"},{rgba8:"vec4"},({index:t})=>(A.inputs.index=t,{rgba8:new yE({rgba8:A.outputs.rgba8})}));GA.programTemplate||(GA.programTemplate=new PQ(bE)),I=new XQ({graph:B,inputs:{index:"index"},outputs:{rgba8:"target"},template:GA.programTemplate}),Object.assign(I.uniforms,{targetLayer:{value:0},targetBase:{value:0},targetCount:{value:0}}),GA.readbackProgram.set(A,I)}const g=I.prepareMaterial();return GA.mesh.material=g,{program:I,material:g}}saveRenderState(A){return{xrEnabled:A.xr.enabled,autoClear:A.autoClear}}resetRenderState(A,I){A.setRenderTarget(null),A.xr.enabled=I.xrEnabled,A.autoClear=I.autoClear}process({count:A,material:I}){const g=this.renderer;if(!g)throw new Error("No renderer");if(!this.target)throw new Error("No target");const B=tA*bI;I.uniforms.targetBase.value=0,I.uniforms.targetCount.value=A;let t=0;for(;t<A;){const Q=Math.floor(t/B),i=Q*B,C=Math.min(bI,Math.ceil((A-i)/tA));I.uniforms.targetLayer.value=Q,this.target.scissor.set(0,0,tA,C),g.setRenderTarget(this.target,Q),g.xr.enabled=!1,g.autoClear=!1,g.render(GA.scene,GA.camera),t+=tA*C}this.count=A}async read({readback:A}){const I=this.renderer;if(!I)throw new Error("No renderer");if(!this.target)throw new Error("No target");const g=Math.ceil(this.count/tA)*tA;if(A.byteLength<g*4)throw new Error(`Readback buffer too small: ${A.byteLength} < ${g*4}`);const B=new Uint8Array(A instanceof ArrayBuffer?A:A.buffer),t=tA*bI;let Q=0;const i=[];for(;Q<this.count;){const C=Math.floor(Q/t),s=C*t,o=Math.min(bI,Math.ceil((this.count-s)/tA));I.setRenderTarget(this.target,C);const e=tA*o*4,a=B.subarray(s*4,s*4+e),n=I==null?void 0:I.readRenderTargetPixelsAsync(this.target,0,0,tA,o,a);i.push(n),Q+=tA*o}return Promise.all(i).then(()=>A)}render({reader:A,count:I,renderer:g}){if(this.renderer=g||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(I);const{program:B,material:t}=this.prepareProgramMaterial(A);B.update();const Q=this.saveRenderState(this.renderer);this.process({count:I,material:t}),this.resetRenderState(this.renderer,Q)}async readback({readback:A}){if(!this.renderer)throw new Error("No renderer");const I=this.saveRenderState(this.renderer),g=this.read({readback:A});return this.resetRenderState(this.renderer,I),g}async renderReadback({reader:A,count:I,renderer:g,readback:B}){if(this.renderer=g||this.renderer,!this.renderer)throw new Error("No renderer");this.ensureCapacity(I);const{program:t,material:Q}=this.prepareProgramMaterial(A);t.update();const i=this.saveRenderState(this.renderer);this.process({count:I,material:Q});const C=this.read({readback:B});return this.resetRenderState(this.renderer,i),C}getTexture(){var A;return(A=this.target)==null?void 0:A.texture}};GA.programTemplate=null,GA.readbackProgram=new Map,GA.geometry=new fB(2,2),GA.mesh=new MQ(GA.geometry,new yt({visible:!1})),GA.scene=new RQ().add(GA.mesh),GA.camera=new kQ;let mt=GA;const FA=class FA{constructor(A={}){this.capacity=0,this.count=0,this.array=null,this.readback=null,this.source=null,this.needsUpdate=!0,this.dyno=new pI({key:"rgbaArray",type:Ii,globals:()=>[gi],value:{texture:FA.getEmpty(),count:0},update:I=>{var g;return I.texture=((g=this.readback)==null?void 0:g.getTexture())??this.source??FA.getEmpty(),I.count=this.count,I}}),A.array?(this.array=A.array,this.capacity=Math.floor(this.array.length/4),this.capacity=Math.floor(this.capacity/tA)*tA,this.count=Math.min(this.capacity,A.count??Number.POSITIVE_INFINITY)):(this.capacity=A.capacity??0,this.count=0)}dispose(){this.readback&&(this.readback.dispose(),this.readback=null),this.source&&(this.source.dispose(),this.source=null)}ensureCapacity(A){var I;if(!this.array||A>(((I=this.array)==null?void 0:I.length)??0)/4){this.capacity=_A(A).maxSplats;const g=new Uint8Array(this.capacity*4);this.array&&g.set(this.array),this.array=g}return this.array}getTexture(){var I;let A=(I=this.readback)==null?void 0:I.getTexture();return(this.source||this.array)&&(A=this.maybeUpdateSource()),A??FA.getEmpty()}maybeUpdateSource(){if(!this.array)throw new Error("No array");if(this.needsUpdate||!this.source){if(this.needsUpdate=!1,this.source){const{width:A,height:I,depth:g}=this.source.image;this.capacity!==A*I*g&&(this.source.dispose(),this.source=null)}if(this.source)this.array.buffer!==this.source.image.data.buffer&&(this.source.image.data=new Uint8Array(this.array.buffer));else{const{width:A,height:I,depth:g}=_A(this.capacity);this.source=new xI(this.array,A,I,g),this.source.format=tB,this.source.type=BB,this.source.internalFormat="RGBA8",this.source.needsUpdate=!0}this.source.needsUpdate=!0}return this.source}render({reader:A,count:I,renderer:g}){this.readback||(this.readback=new mt({renderer:g})),this.readback.render({reader:A,count:I,renderer:g}),this.capacity=this.readback.capacity,this.count=this.readback.count}fromPackedSplats({packedSplats:A,base:I,count:g,renderer:B}){const{dynoSplats:t,dynoBase:Q,dynoCount:i,reader:C}=FA.makeDynos();return t.packedSplats=A,Q.value=I,i.value=g,this.render({reader:C,count:g,renderer:B}),this}async read(){if(!this.readback)throw new Error("No readback");return(!this.array||this.array.length<this.count*4)&&(this.array=new Uint8Array(this.capacity*4)),(await this.readback.readback({readback:this.array})).subarray(0,this.count*4)}static getEmpty(){if(!FA.emptySource){const A=new Uint8Array(4);FA.emptySource=new xI(A,1,1,1),FA.emptySource.format=tB,FA.emptySource.type=BB,FA.emptySource.internalFormat="RGBA8",FA.emptySource.needsUpdate=!0}return FA.emptySource}static makeDynos(){if(!FA.dynos){const A=new $Q,I=new kt({value:0}),g=new kt({value:0}),B=SB({index:"int"},{rgba8:"vec4"},({index:t})=>{if(!t)throw new Error("index is undefined");t=bB(t,I);const Q=eE(A,t,I,g);return{rgba8:LB(Q).outputs.rgba}});FA.dynos={dynoSplats:A,dynoBase:I,dynoCount:g,reader:B}}return FA.dynos}};FA.emptySource=null,FA.dynos=null;let Ai=FA;const Ii={type:"RgbaArray"},gi=aI(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);function KE(E,A){return new bA({inTypes:{rgba:Ii,index:"int"},outTypes:{rgba:"vec4"},inputs:{rgba:E,index:A},globals:()=>[gi],statements:({inputs:g,outputs:B})=>SI(`\n        if ((index >= 0) && (index < ${g.rgba}.count)) {\n          ${B.rgba} = texelFetch(${g.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${B.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)}).outputs.rgba}function qE(E){switch(E){case"all":return 0;case"plane":return 1;case"sphere":return 2;case"box":return 3;case"ellipsoid":return 4;case"cylinder":return 5;case"capsule":return 6;case"infinite_cone":return 7;default:throw new Error(`Unknown SDF type: ${E}`)}}function TE(E){switch(E){case"multiply":return 0;case"set_rgb":return 1;case"add_rgba":return 2;default:throw new Error(`Unknown blend mode: ${E}`)}}class ZE extends WA{constructor(A={}){super();const{type:I,invert:g,opacity:B,color:t,displace:Q,radius:i}=A;this.type=I??"sphere",this.invert=g??!1,this.opacity=B??1,this.color=t??new XI(1,1,1),this.displace=Q??new f(0,0,0),this.radius=i??0}}const TB=class TB extends WA{constructor(A={}){const{name:I,rgbaBlendMode:g="multiply",sdfSmooth:B=0,softEdge:t=0,invert:Q=!1,sdfs:i=null}=A;super(),this.rgbaBlendMode=g,this.sdfSmooth=B,this.softEdge=t,this.invert=Q,this.sdfs=i,this.ordering=TB.nextOrdering++,this.name=I??`Edit ${this.ordering}`}addSdf(A){this.sdfs==null&&(this.sdfs=[]),this.sdfs.includes(A)||this.sdfs.push(A)}removeSdf(A){this.sdfs!=null&&(this.sdfs=this.sdfs.filter(I=>I!==A))}};TB.nextOrdering=1;let xt=TB;class zE{constructor({maxSdfs:A,maxEdits:I}){this.maxSdfs=Math.max(16,A??0),this.numSdfs=0,this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs),this.dynoSdfArray=new pI({key:"sdfArray",type:Bi,globals:()=>[ti],value:{numSdfs:0,sdfTexture:this.sdfTexture},update:g=>(g.numSdfs=this.numSdfs,g.sdfTexture=this.sdfTexture,g)}),this.maxEdits=Math.max(16,I??0),this.numEdits=0,this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoNumEdits=new kt({value:0}),this.dynoEdits=this.newEdits(this.editData,this.maxEdits)}newSdfTexture(A,I){const g=new SC(A,8,I,gg,WI);return g.internalFormat="RGBA32UI",g.needsUpdate=!0,g}newEdits(A,I){return new pI({key:"edits",type:"uvec4",count:I,globals:()=>[Qi],value:A})}ensureCapacity({maxSdfs:A,maxEdits:I}){let g=!1;return A>this.sdfTexture.image.height&&(this.sdfTexture.dispose(),this.maxSdfs=Math.max(this.maxSdfs*2,A),this.sdfData=new Uint32Array(this.maxSdfs*8*4),this.sdfFloatData=new Float32Array(this.sdfData.buffer),this.sdfTexture=this.newSdfTexture(this.sdfData,this.maxSdfs)),I>(this.dynoEdits.count??0)&&(this.maxEdits=Math.max(this.maxEdits*2,I),this.editData=new Uint32Array(this.maxEdits*4),this.editFloatData=new Float32Array(this.editData.buffer),this.dynoEdits=this.newEdits(this.editData,this.maxEdits),g=!0),g}updateEditData(A,I){const g=this.editData[A]!==I;return this.editData[A]=I,g}updateEditFloatData(A,I){Fg[0]=I;const g=this.editFloatData[A]!==Fg[0];return g&&(this.editFloatData[A]=Fg[0]),g}encodeEdit(A,{sdfFirst:I,sdfCount:g,invert:B,rgbaBlendMode:t,softEdge:Q,sdfSmooth:i}){const C=A*4;let s=!1;return s=this.updateEditData(C+0,t|(B?256:0))||s,s=this.updateEditData(C+1,I|g<<16)||s,s=this.updateEditFloatData(C+2,Q)||s,s=this.updateEditFloatData(C+3,i)||s,s}updateSdfData(A,I){const g=this.sdfData[A]!==I;return this.sdfData[A]=I,g}updateSdfFloatData(A,I){Fg[0]=I;const g=this.sdfFloatData[A]!==Fg[0];return g&&(this.sdfFloatData[A]=Fg[0]),g}encodeSdf(A,{sdfType:I,invert:g,center:B,quaternion:t,scale:Q,sizes:i},C){const s=A*32,o=I|(g?256:0);let e=!1;e=this.updateSdfFloatData(s+0,(B==null?void 0:B.x)??0)||e,e=this.updateSdfFloatData(s+1,(B==null?void 0:B.y)??0)||e,e=this.updateSdfFloatData(s+2,(B==null?void 0:B.z)??0)||e,e=this.updateSdfData(s+3,o)||e,e=this.updateSdfFloatData(s+4,(t==null?void 0:t.x)??0)||e,e=this.updateSdfFloatData(s+5,(t==null?void 0:t.y)??0)||e,e=this.updateSdfFloatData(s+6,(t==null?void 0:t.z)??0)||e,e=this.updateSdfFloatData(s+7,(t==null?void 0:t.w)??0)||e,e=this.updateSdfFloatData(s+8,(Q==null?void 0:Q.x)??0)||e,e=this.updateSdfFloatData(s+9,(Q==null?void 0:Q.y)??0)||e,e=this.updateSdfFloatData(s+10,(Q==null?void 0:Q.z)??0)||e,e=this.updateSdfData(s+11,0)||e,e=this.updateSdfFloatData(s+12,(i==null?void 0:i.x)??0)||e,e=this.updateSdfFloatData(s+13,(i==null?void 0:i.y)??0)||e,e=this.updateSdfFloatData(s+14,(i==null?void 0:i.z)??0)||e,e=this.updateSdfFloatData(s+15,(i==null?void 0:i.w)??0)||e;const a=Math.min(4,C.length);for(let n=0;n<a;++n){const r=s+16+n*4;e=this.updateSdfFloatData(r+0,C[n].x)||e,e=this.updateSdfFloatData(r+1,C[n].y)||e,e=this.updateSdfFloatData(r+2,C[n].z)||e,e=this.updateSdfFloatData(r+3,C[n].w)||e}return e}update(A){const I=A.reduce((e,{sdfs:a})=>e+a.length,0),g=this.ensureCapacity({maxEdits:A.length,maxSdfs:I}),B=[new qA,new qA],t=new f,Q=new uA,i=new f,C=new qA;let s=0,o=g;A.length!==this.dynoNumEdits.value&&(this.dynoNumEdits.value=A.length,this.numEdits=A.length,o=!0);for(const[e,{edit:a,sdfs:n}]of A.entries()){o=this.encodeEdit(e,{sdfFirst:s,sdfCount:n.length,invert:a.invert,rgbaBlendMode:TE(a.rgbaBlendMode),softEdge:a.softEdge,sdfSmooth:a.sdfSmooth})||o;let r=!1;for(const D of n)C.set(D.scale.x,D.scale.y,D.scale.z,D.radius),D.scale.setScalar(1),D.updateMatrixWorld(),D.matrixWorld.clone().invert().decompose(t,Q,i),D.scale.set(C.x,C.y,C.z),D.updateMatrixWorld(),B[0].set(D.color.r,D.color.g,D.color.b,D.opacity),B[1].set(D.displace.x,D.displace.y,D.displace.z,1),r=this.encodeSdf(s,{sdfType:qE(D.type),invert:D.invert,center:t,quaternion:Q,scale:i,sizes:C},B)||r,s+=1;this.numSdfs=s,r&&(this.sdfTexture.needsUpdate=!0),o||(o=r)}return{updated:o,dynoUpdated:g}}modify(A){return WE(A,this.dynoSdfArray,this.dynoNumEdits,this.dynoEdits)}}const Bi={type:"SdfArray"},ti=aI(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`),Qi=aI(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);function WE(E,A,I,g){return new bA({inTypes:{gsplat:vA,sdfArray:Bi,numEdits:"int",rgbaDisplaceEdits:"uvec4"},outTypes:{gsplat:vA},globals:()=>[ti,Qi],inputs:{gsplat:E,sdfArray:A,numEdits:I,rgbaDisplaceEdits:g},statements:({inputs:t,outputs:Q})=>{const{sdfArray:i,numEdits:C,rgbaDisplaceEdits:s}=t,{gsplat:o}=Q;return SI(`\n        ${o} = ${t.gsplat};\n        if (isGsplatActive(${o}.flags)) {\n          for (int editIndex = 0; editIndex < ${C}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${s}[editIndex], ${i}.sdfTexture, ${i}.numSdfs,\n              ${o}.center, ${o}.rgba\n            );\n          }\n        }\n      `)}}).outputs.gsplat}const Fg=new Float32Array(1);class KB{constructor(){this.scale=new HB({value:Number.NEGATIVE_INFINITY}),this.rotate=new VQ({value:new uA(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)}),this.translate=new dE({value:new f(Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY,Number.POSITIVE_INFINITY)})}apply(A){return UE(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}applyDir(A){return YE(A,{rotate:this.rotate})}applyGsplat(A){return oE(A,{scale:this.scale,rotate:this.rotate,translate:this.translate})}updateFromMatrix(A){const I=new f,g=new uA,B=new f;A.decompose(B,g,I);const t=(I.x+I.y+I.z)/3;let Q=!1;return t!==this.scale.value&&(this.scale.value=t,Q=!0),B.equals(this.translate.value)||(this.translate.value.copy(B),Q=!0),g.equals(this.rotate.value)||(this.rotate.value.copy(g),Q=!0),Q}update(A){return A.updateMatrixWorld(),this.updateFromMatrix(A.matrixWorld)}}class vE extends WA{constructor({numSplats:A,generator:I,construct:g,update:B}){if(super(),this.numSplats=A??0,this.generator=I,this.frameUpdate=B,this.version=0,g){const t=g(this);Object.assign(this,t)}}updateVersion(){this.version+=1}set needsUpdate(A){A&&this.updateVersion()}}const qI=class qI extends vE{constructor(A={}){const I=new KB,g=new KB,B=new KB,t=new KB,Q=new VQ({value:new qA(Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY,Number.NEGATIVE_INFINITY)}),i=new HB({value:0}),C=new HB({value:0}),s={transform:I,viewToWorld:g,worldToView:B,viewToObject:t,recolor:Q,time:i,deltaTime:C};if(super({update:({time:o,deltaTime:e,viewToWorld:a,globalEdits:n})=>this.update({time:o,deltaTime:e,viewToWorld:a,globalEdits:n})}),this.isInitialized=!1,this.recolor=new XI(1,1,1),this.opacity=1,this.enableViewToObject=!1,this.enableViewToWorld=!1,this.enableWorldToView=!1,this.skinning=null,this.edits=null,this.rgbaDisplaceEdits=null,this.splatRgba=null,this.maxSh=3,this.packedSplats=A.packedSplats??new Gg,this.numSplats=this.packedSplats.numSplats,this.editable=A.editable??!0,this.onFrame=A.onFrame,this.context=s,this.objectModifier=A.objectModifier,this.worldModifier=A.worldModifier,this.updateGenerator(),A.url||A.fileBytes||A.constructSplats||A.packedSplats&&!A.packedSplats.isInitialized)this.initialized=this.asyncInitialize(A).then(async()=>{if(this.updateGenerator(),this.isInitialized=!0,A.onLoad){const o=A.onLoad(this);o instanceof Promise&&await o}return this});else if(this.isInitialized=!0,this.initialized=Promise.resolve(this),A.onLoad){const o=A.onLoad(this);o instanceof Promise&&(this.initialized=o.then(()=>this))}}async asyncInitialize(A){const{url:I,fileBytes:g,fileType:B,fileName:t,maxSplats:Q,constructSplats:i}=A;if(I||g||i){const C={url:I,fileBytes:g,fileType:B,fileName:t,maxSplats:Q,construct:i};this.packedSplats.reinitialize(C)}this.packedSplats&&(await this.packedSplats.initialized,this.numSplats=this.packedSplats.numSplats,this.updateGenerator())}static async staticInitialize(){await vB(),qI.isStaticInitialized=!0}pushSplat(A,I,g,B,t){this.packedSplats.pushSplat(A,I,g,B,t)}forEachSplat(A){this.packedSplats.forEachSplat(A)}dispose(){this.packedSplats.dispose()}constructGenerator(A){const{transform:I,viewToObject:g,recolor:B}=A,t=SB({index:"int"},{gsplat:vA},({index:Q})=>{if(!Q)throw new Error("index is undefined");let i=sE(this.packedSplats.dyno,Q);if(this.maxSh>=1){const{sh1Texture:s,sh2Texture:o,sh3Texture:e}=this.ensureShTextures();if(s){const a=g.translate,{center:n}=LB(i).outputs,r=ME(GE(n,a));let D=PE(i,s,r);this.maxSh>=2&&o&&(D=bB(D,jE(i,o,r))),this.maxSh>=3&&e&&(D=bB(D,_E(i,e,r)));let{rgba:l}=LB(i).outputs;l=bB(l,kE(D,LC("float",0))),i=pt({gsplat:i,rgba:l})}}if(this.splatRgba){const s=KE(this.splatRgba.dyno,Q);i=pt({gsplat:i,rgba:s})}this.skinning&&(i=this.skinning.modify(i)),this.objectModifier&&(i=this.objectModifier.apply({gsplat:i}).gsplat),i=I.applyGsplat(i);const C=FE(B,LB(i).outputs.rgba);return i=pt({gsplat:i,rgba:C}),this.rgbaDisplaceEdits&&(i=this.rgbaDisplaceEdits.modify(i)),this.worldModifier&&(i=this.worldModifier.apply({gsplat:i}).gsplat),{gsplat:i}});this.generator=t}updateGenerator(){this.constructGenerator(this.context)}update({time:A,viewToWorld:I,deltaTime:g,globalEdits:B}){var l;this.numSplats=this.packedSplats.numSplats,this.context.time.value=A,this.context.deltaTime.value=g,qI.dynoTime.value=A;const{transform:t,viewToObject:Q,recolor:i}=this.context;let C=t.update(this);this.context.viewToWorld.updateFromMatrix(I)&&this.enableViewToWorld&&(C=!0);const s=I.clone().invert();this.context.worldToView.updateFromMatrix(s)&&this.enableWorldToView&&(C=!0);const a=new LA().compose(t.translate.value,t.rotate.value,new f().setScalar(t.scale.value)).invert().multiply(I);Q.updateFromMatrix(a)&&(this.enableViewToObject||this.packedSplats.extra.sh1)&&(C=!0);const n=new qA(this.recolor.r,this.recolor.g,this.recolor.b,this.opacity);n.equals(i.value)||(i.value.copy(n),C=!0);const r=this.editable?(this.edits??[]).concat(B):[];this.editable&&!this.edits&&this.traverseVisible(y=>{y instanceof xt&&r.push(y)}),r.sort((y,w)=>y.ordering-w.ordering);const D=r.map(y=>{if(y.sdfs!=null)return{edit:y,sdfs:y.sdfs};const w=[];return y.traverseVisible(u=>{u instanceof ZE&&w.push(u)}),{edit:y,sdfs:w}});if(D.length>0&&!this.rgbaDisplaceEdits){const y=D.length,w=D.reduce((u,G)=>u+G.sdfs.length,0);this.rgbaDisplaceEdits=new zE({maxEdits:y,maxSdfs:w}),this.updateGenerator()}if(this.rgbaDisplaceEdits){const y=this.rgbaDisplaceEdits.update(D);C||(C=y.updated),y.dynoUpdated&&this.updateGenerator()}C&&this.updateVersion(),(l=this.onFrame)==null||l.call(this,{mesh:this,time:A,deltaTime:g})}raycast(A,I){if(!this.packedSplats.packedArray||!this.packedSplats.numSplats)return;const{near:g,far:B,ray:t}=A,Q=this.matrixWorld.clone().invert(),i=new hI().setFromMatrix4(Q),C=t.origin.clone().applyMatrix4(Q),s=t.direction.clone().applyMatrix3(i),o=new f;Q.decompose(new f,new uA,o),(o.x*o.y*o.z)**(1/3);const a=Mi(C.x,C.y,C.z,s.x,s.y,s.z,g,B,this.packedSplats.numSplats,this.packedSplats.packedArray,!0);for(const n of a){const r=t.direction.clone().multiplyScalar(n).add(t.origin);I.push({distance:n,point:r,object:this})}}ensureShTextures(){if(!this.packedSplats.extra.sh1)return{};let A=this.packedSplats.extra.sh1Texture;if(!A){let B=this.packedSplats.extra.sh1;const{width:t,height:Q,depth:i,maxSplats:C}=_A(B.length/2);if(B.length<C*2){const o=new Uint32Array(C*2);o.set(B),this.packedSplats.extra.sh1=o,B=o}const s=new xI(B,t,Q,i);s.format=Pi,s.type=WI,s.internalFormat="RG32UI",s.needsUpdate=!0,A=new Rt({value:s,key:"sh1"}),this.packedSplats.extra.sh1Texture=A}if(!this.packedSplats.extra.sh2)return{sh1Texture:A};let I=this.packedSplats.extra.sh2Texture;if(!I){let B=this.packedSplats.extra.sh2;const{width:t,height:Q,depth:i,maxSplats:C}=_A(B.length/4);if(B.length<C*4){const o=new Uint32Array(C*4);o.set(B),this.packedSplats.extra.sh2=o,B=o}const s=new xI(B,t,Q,i);s.format=gg,s.type=WI,s.internalFormat="RGBA32UI",s.needsUpdate=!0,I=new Rt({value:s,key:"sh2"}),this.packedSplats.extra.sh2Texture=I}if(!this.packedSplats.extra.sh3)return{sh1Texture:A,sh2Texture:I};let g=this.packedSplats.extra.sh3Texture;if(!g){let B=this.packedSplats.extra.sh3;const{width:t,height:Q,depth:i,maxSplats:C}=_A(B.length/4);if(B.length<C*4){const o=new Uint32Array(C*4);o.set(B),this.packedSplats.extra.sh3=o,B=o}const s=new xI(B,t,Q,i);s.format=gg,s.type=WI,s.internalFormat="RGBA32UI",s.needsUpdate=!0,g=new Rt({value:s,key:"sh3"}),this.packedSplats.extra.sh3Texture=g}return{sh1Texture:A,sh2Texture:I,sh3Texture:g}}};qI.staticInitialized=qI.staticInitialize(),qI.isStaticInitialized=!1,qI.dynoTime=new HB({value:0});let Ut=qI;const OE=aI(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`),VE=aI(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (-1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (-1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`),XE=aI(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);function PE(E,A,I){return ft({inTypes:{gsplat:vA,sh1:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:E,sh1:A,viewDir:I},globals:()=>[NI,OE],statements:({inputs:g,outputs:B})=>SI(`\n        if (isGsplatActive(${g.gsplat}.flags)) {\n          ${B.rgb} = evaluateSH1(${g.gsplat}, ${g.sh1}, ${g.viewDir});\n        } else {\n          ${B.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}function jE(E,A,I){return ft({inTypes:{gsplat:vA,sh2:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:E,sh2:A,viewDir:I},globals:()=>[NI,VE],statements:({inputs:g,outputs:B})=>SI(`\n        if (isGsplatActive(${g.gsplat}.flags)) {\n          ${B.rgb} = evaluateSH2(${g.gsplat}, ${g.sh2}, ${g.viewDir});\n        } else {\n          ${B.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}function _E(E,A,I){return ft({inTypes:{gsplat:vA,sh3:"usampler2DArray",viewDir:"vec3"},outTypes:{rgb:"vec3"},inputs:{gsplat:E,sh3:A,viewDir:I},globals:()=>[NI,XE],statements:({inputs:g,outputs:B})=>SI(`\n        if (isGsplatActive(${g.gsplat}.flags)) {\n          ${B.rgb} = evaluateSH3(${g.gsplat}, ${g.sh3}, ${g.viewDir});\n        } else {\n          ${B.rgb} = vec3(0.0);\n        }\n      `)}).outputs.rgb}function $E(E){return new Worker(self.location.href,{name:E==null?void 0:E.name})}class As{constructor(){this.messages={},this.messageIdNext=0,this.worker=new $E,this.worker.onmessage=A=>this.onMessage(A)}makeMessageId(){return++this.messageIdNext}makeMessagePromiseId(){const A=this.makeMessageId(),I=new Promise((g,B)=>{this.messages[A]={resolve:g,reject:B}});return{id:A,promise:I}}onMessage(A){const{id:I,result:g,error:B}=A.data,t=this.messages[I];t&&(delete this.messages[I],B?t.reject(B):t.resolve(g))}async call(A,I){const{id:g,promise:B}=this.makeMessagePromiseId();return this.worker.postMessage({name:A,args:I,id:g},{transfer:LQ(I)}),B}}let ii=4,qB=0;const Ci=[],Ei=[];async function Is(){const E=Ci.shift();if(E)return E;if(qB<ii){const A=new As;return qB+=1,A}return new Promise(A=>{Ei.push(A)})}function gs(E){if(qB>ii){qB-=1;return}const A=Ei.shift();if(A){A(E);return}Ci.push(E)}async function Vg(E){const A=await Is();try{return await E(A)}finally{gs(A)}}class Bs extends dt{constructor(A){super(A),this.fileLoader=new kC(A)}load(A,I,g,B){this.fileLoader.setResponseType("arraybuffer"),this.fileLoader.setCrossOrigin(this.crossOrigin),this.fileLoader.setWithCredentials(this.withCredentials),this.fileLoader.setPath(this.path),this.fileLoader.setResourcePath(this.resourcePath),this.fileLoader.setRequestHeader(this.requestHeader),this.fileLoader.load(A,async t=>{if(I){const Q=t,i={},C=[];let s=this.fileType;try{const o=Qs(Q);if(this.fileType==="pcsogs"&&o===void 0)throw new Error("Invalid PC SOGS file");if(o!==void 0){s="pcsogs";for(const a of["means","scales","quats","sh0","shN"]){const n=o[a];if(n){const r=n.files;for(const D of r){const l=new URL(D,A).toString();this.manager.itemStart(l);const y=this.loadExtra(l).then(w=>{i[D]=w}).catch(w=>{throw this.manager.itemError(l),w}).finally(()=>{this.manager.itemEnd(l)});C.push(y)}}}}await Promise.all(C);const e=await oi({input:Q,extraFiles:i,fileType:s,pathOrUrl:A});this.packedSplats?(this.packedSplats.initialize(e),I(this.packedSplats)):I(new Gg(e))}catch(o){B==null||B(o)}}},g,B)}async loadAsync(A,I){return new Promise((g,B)=>{this.load(A,t=>{g(t)},I,B)})}async loadExtra(A){return new Promise((I,g)=>{this.fileLoader.load(A,B=>I(B),void 0,B=>g(B))})}parse(A){return new Ut({packedSplats:A})}}var Xg=(E=>(E.PLY="ply",E.SPZ="spz",E.SPLAT="splat",E.KSPLAT="ksplat",E.PCSOGS="pcsogs",E))(Xg||{});function si(E){const A=new DataView(E.buffer);if((A.getUint32(0,!0)&16777215)===7957616)return"ply";if((A.getUint32(0,!0)&16777215)===559903){const I=jC(E,4);return new DataView(I.buffer).getUint32(0,!0)===1347635022?"spz":void 0}}function ts(E){const A=E.split(/[?#]/,1)[0],I=Math.max(A.lastIndexOf("/"),A.lastIndexOf("\\\\")),g=A.slice(I+1),B=g.lastIndexOf(".");return B<=0||B===g.length-1?"":g.slice(B+1).toLowerCase()}function ei(E){const A=ts(E);if(A==="ply")return"ply";if(A==="spz")return"spz";if(A==="splat")return"splat";if(A==="ksplat")return"ksplat"}function Qs(E){try{let A;if(typeof E=="string")A=E;else{const g=E instanceof ArrayBuffer?new Uint8Array(E):E;if(g.length>65536)return;A=new TextDecoder().decode(g)}const I=JSON.parse(A);if(!I||typeof I!="object"||Array.isArray(I))return;for(const g of["means","scales","quats","sh0"])if(!I[g]||typeof I[g]!="object"||Array.isArray(I[g])||!I[g].shape||!I[g].files||g!=="quats"&&(!I[g].mins||!I[g].maxs))return;return I}catch{return}}async function oi({input:E,extraFiles:A,fileType:I,pathOrUrl:g}){const B=E instanceof ArrayBuffer?new Uint8Array(E):E;let t=I;switch(I||(t=si(B),!t&&g&&(t=ei(g))),t){case"ply":{const Q=new Og({fileBytes:B});await Q.parseHeader();const i=Q.numSplats,C=_A(i).maxSplats,s={fileBytes:B,packedArray:new Uint32Array(C*4)};return await Vg(async o=>{const{packedArray:e,numSplats:a,extra:n}=await o.call("unpackPly",s);return{packedArray:e,numSplats:a,extra:n}})}case"spz":return await Vg(async Q=>{const{packedArray:i,numSplats:C,extra:s}=await Q.call("decodeSpz",{fileBytes:B});return{packedArray:i,numSplats:C,extra:s}});case"splat":return await Vg(async Q=>{const{packedArray:i,numSplats:C}=await Q.call("decodeAntiSplat",{fileBytes:B});return{packedArray:i,numSplats:C}});case"ksplat":return await Vg(async Q=>{const{packedArray:i,numSplats:C,extra:s}=await Q.call("decodeKsplat",{fileBytes:B});return{packedArray:i,numSplats:C,extra:s}});case"pcsogs":return await Vg(async Q=>{const{packedArray:i,numSplats:C,extra:s}=await Q.call("decodePcSogs",{fileBytes:B,extraFiles:A});return{packedArray:i,numSplats:C,extra:s}});default:throw new Error(`Unknown splat file type: ${t}`)}}class is{constructor({maxSplats:A=1}={}){this.numSplats=0,this.maxSplats=_A(A).maxSplats,this.centers=new Float32Array(this.maxSplats*3),this.scales=new Float32Array(this.maxSplats*3),this.quaternions=new Float32Array(this.maxSplats*4),this.opacities=new Float32Array(this.maxSplats),this.colors=new Float32Array(this.maxSplats*3)}pushSplat(){const A=this.numSplats;return this.ensureIndex(A),this.numSplats+=1,A}unpushSplat(A){if(A===this.numSplats-1)this.numSplats-=1;else throw new Error("Cannot unpush splat from non-last position")}ensureCapacity(A){if(A>this.maxSplats){const I=Math.max(A,this.maxSplats*2),g=new Float32Array(I*3),B=new Float32Array(I*3),t=new Float32Array(I*4),Q=new Float32Array(I),i=new Float32Array(I*3);if(g.set(this.centers),B.set(this.scales),t.set(this.quaternions),Q.set(this.opacities),i.set(this.colors),this.centers=g,this.scales=B,this.quaternions=t,this.opacities=Q,this.colors=i,this.sh1){const C=new Float32Array(I*9);C.set(this.sh1),this.sh1=C}if(this.sh2){const C=new Float32Array(I*15);C.set(this.sh2),this.sh2=C}if(this.sh3){const C=new Float32Array(I*21);C.set(this.sh3),this.sh3=C}this.maxSplats=I}}ensureIndex(A){this.ensureCapacity(A+1)}setCenter(A,I,g,B){this.centers[A*3]=I,this.centers[A*3+1]=g,this.centers[A*3+2]=B}setScale(A,I,g,B){this.scales[A*3]=I,this.scales[A*3+1]=g,this.scales[A*3+2]=B}setQuaternion(A,I,g,B,t){this.quaternions[A*4]=I,this.quaternions[A*4+1]=g,this.quaternions[A*4+2]=B,this.quaternions[A*4+3]=t}setOpacity(A,I){this.opacities[A]=I}setColor(A,I,g,B){this.colors[A*3]=I,this.colors[A*3+1]=g,this.colors[A*3+2]=B}setSh1(A,I){this.sh1||(this.sh1=new Float32Array(this.maxSplats*9));for(let g=0;g<9;++g)this.sh1[A*9+g]=I[g]}setSh2(A,I){this.sh2||(this.sh2=new Float32Array(this.maxSplats*15));for(let g=0;g<15;++g)this.sh2[A*15+g]=I[g]}setSh3(A,I){this.sh3||(this.sh3=new Float32Array(this.maxSplats*21));for(let g=0;g<21;++g)this.sh3[A*21+g]=I[g]}}class ai{constructor({fileBytes:A}){this.fileBytes=A instanceof ArrayBuffer?new Uint8Array(A):A,this.reader=new _C({fileBytes:this.fileBytes});const I=new DataView(this.reader.read(16).buffer);if(I.getUint32(0,!0)!==1347635022)throw new Error("Invalid SPZ file");if(this.version=I.getUint32(4,!0),this.version<1||this.version>2)throw new Error(`Unsupported SPZ version: ${this.version}`);this.numSplats=I.getUint32(8,!0),this.shDegree=I.getUint8(12),this.fractionalBits=I.getUint8(13),this.flags=I.getUint8(14),this.flagAntiAlias=(this.flags&1)!==0,this.reserved=I.getUint8(15),this.parsed=!1}parseSplats(A,I,g,B,t,Q){if(this.parsed)throw new Error("SPZ file already parsed");if(this.parsed=!0,this.version===1){const i=this.reader.read(this.numSplats*3*2),C=new Uint16Array(i.buffer);for(let s=0;s<this.numSplats;s++){const o=s*3,e=aA(C[o]),a=aA(C[o+1]),n=aA(C[o+2]);A==null||A(s,e,a,n)}}else if(this.version===2){const i=1<<this.fractionalBits,C=this.reader.read(this.numSplats*3*3);for(let s=0;s<this.numSplats;s++){const o=s*9,e=((C[o+2]<<24|C[o+1]<<16|C[o]<<8)>>8)/i,a=((C[o+5]<<24|C[o+4]<<16|C[o+3]<<8)>>8)/i,n=((C[o+8]<<24|C[o+7]<<16|C[o+6]<<8)>>8)/i;A==null||A(s,e,a,n)}}else throw new Error("Unreachable");{const i=this.reader.read(this.numSplats);for(let C=0;C<this.numSplats;C++)I==null||I(C,i[C]/255)}{const i=this.reader.read(this.numSplats*3),C=ri/.15;for(let s=0;s<this.numSplats;s++){const o=s*3,e=(i[o]/255-.5)*C+.5,a=(i[o+1]/255-.5)*C+.5,n=(i[o+2]/255-.5)*C+.5;g==null||g(s,e,a,n)}}{const i=this.reader.read(this.numSplats*3);for(let C=0;C<this.numSplats;C++){const s=C*3,o=Math.exp(i[s]/16-10),e=Math.exp(i[s+1]/16-10),a=Math.exp(i[s+2]/16-10);B==null||B(C,o,e,a)}}{const i=this.reader.read(this.numSplats*3);for(let C=0;C<this.numSplats;C++){const s=C*3,o=i[s]/127.5-1,e=i[s+1]/127.5-1,a=i[s+2]/127.5-1,n=Math.sqrt(Math.max(0,1-o*o-e*e-a*a));t==null||t(C,o,e,a,n)}}if(Q&&this.shDegree>=1){const i=new Float32Array(9),C=this.shDegree>=2?new Float32Array(5*3):void 0,s=this.shDegree>=3?new Float32Array(7*3):void 0,o=this.reader.read(this.numSplats*ni[this.shDegree]*3);let e=0;for(let a=0;a<this.numSplats;a++){for(let n=0;n<9;++n)i[n]=(o[e+n]-128)/128;if(e+=9,C){for(let n=0;n<15;++n)C[n]=(o[e+n]-128)/128;e+=15}if(s){for(let n=0;n<21;++n)s[n]=(o[e+n]-128)/128;e+=21}Q==null||Q(a,i,C,s)}}}}const ni={1:3,2:8,3:15},ri=.28209479177387814,Cs=1347635022,Es=2,ss=1;class KI{constructor({numSplats:A,shDegree:I,fractionalBits:g=12,flagAntiAlias:B=!0}){this.clippedCount=0;const t=19+(I>=1?9:0)+(I>=2?15:0)+(I>=3?21:0),Q=16+A*t;this.buffer=new ArrayBuffer(Q),this.view=new DataView(this.buffer),this.view.setUint32(0,Cs,!0),this.view.setUint32(4,Es,!0),this.view.setUint32(8,A,!0),this.view.setUint8(12,I),this.view.setUint8(13,g),this.view.setUint8(14,B?ss:0),this.view.setUint8(15,0),this.numSplats=A,this.shDegree=I,this.fractionalBits=g,this.fraction=1<<g,this.flagAntiAlias=B}setCenter(A,I,g,B){const t=Math.round(I*this.fraction),Q=Math.max(-8388607,Math.min(8388607,t)),i=Math.round(g*this.fraction),C=Math.max(-8388607,Math.min(8388607,i)),s=Math.round(B*this.fraction),o=Math.max(-8388607,Math.min(8388607,s));(t!==Q||i!==C||s!==o)&&(this.clippedCount+=1);const n=16+A*9;this.view.setUint8(n,Q&255),this.view.setUint8(n+1,Q>>8&255),this.view.setUint8(n+2,Q>>16&255),this.view.setUint8(n+3,C&255),this.view.setUint8(n+4,C>>8&255),this.view.setUint8(n+5,C>>16&255),this.view.setUint8(n+6,o&255),this.view.setUint8(n+7,o>>8&255),this.view.setUint8(n+8,o>>16&255)}setAlpha(A,I){const g=16+this.numSplats*9+A;this.view.setUint8(g,Math.max(0,Math.min(255,Math.round(I*255))))}static scaleRgb(A){const I=((A-.5)/(ri/.15)+.5)*255;return Math.max(0,Math.min(255,Math.round(I)))}setRgb(A,I,g,B){const t=16+this.numSplats*10+A*3;this.view.setUint8(t,KI.scaleRgb(I)),this.view.setUint8(t+1,KI.scaleRgb(g)),this.view.setUint8(t+2,KI.scaleRgb(B))}setScale(A,I,g,B){const t=16+this.numSplats*13+A*3;this.view.setUint8(t,Math.max(0,Math.min(255,Math.round((Math.log(I)+10)*16)))),this.view.setUint8(t+1,Math.max(0,Math.min(255,Math.round((Math.log(g)+10)*16)))),this.view.setUint8(t+2,Math.max(0,Math.min(255,Math.round((Math.log(B)+10)*16))))}setQuat(A,I,g,B,t){const Q=16+this.numSplats*16+A*3,i=t<0;this.view.setUint8(Q,Math.max(0,Math.min(255,Math.round(((i?-I:I)+1)*127.5)))),this.view.setUint8(Q+1,Math.max(0,Math.min(255,Math.round(((i?-g:g)+1)*127.5)))),this.view.setUint8(Q+2,Math.max(0,Math.min(255,Math.round(((i?-B:B)+1)*127.5))))}static quantizeSh(A,I){const g=Math.round(A*128)+128,B=1<<8-I,t=Math.floor((g+B/2)/B)*B;return Math.max(0,Math.min(255,t))}setSh(A,I,g,B){const t=ni[this.shDegree]||0,Q=16+this.numSplats*19+A*t*3;for(let i=0;i<9;++i)this.view.setUint8(Q+i,KI.quantizeSh(I[i],5));if(g){const i=Q+9;for(let C=0;C<15;++C)this.view.setUint8(i+C,KI.quantizeSh(g[C],4));if(B){const C=i+15;for(let s=0;s<21;++s)this.view.setUint8(C+s,KI.quantizeSh(B[s],4))}}}async finalize(){const A=new Uint8Array(this.buffer),g=new ReadableStream({async start(Q){Q.enqueue(A),Q.close()}}).pipeThrough(new CompressionStream("gzip")),t=await new Response(g).arrayBuffer();return console.log("Compressed",A.length,"bytes to",t.byteLength,"bytes"),new Uint8Array(t)}}async function es(E){var o,e,a;const A=new is,{inputs:I,clipXyz:g,maxSh:B,fractionalBits:t=12,opacityThreshold:Q}=E;for(const n of I){let r=function(S){return S.multiplyScalar(u),S.applyQuaternion(G),S.add(M),S},D=function(S){return S.multiplyScalar(u),S},l=function(S){return S.premultiply(G),S},y=function(S){return!x||x.containsPoint(S)},w=function(S){return Q!==void 0?S>=Q:!0};const u=((o=n.transform)==null?void 0:o.scale)??1,G=new uA().fromArray(((e=n.transform)==null?void 0:e.quaternion)??[0,0,0,1]),M=new f().fromArray(((a=n.transform)==null?void 0:a.translate)??[0,0,0]),x=g?new ig(new f().fromArray(g.min),new f().fromArray(g.max)):void 0;let k=n.fileType;switch(k||(k=si(n.fileBytes),!k&&n.pathOrUrl&&(k=ei(n.pathOrUrl))),k){case Xg.PLY:{const S=new Og({fileBytes:n.fileBytes});await S.parseHeader();let N=null;S.parseSplats((H,U,m,J,K,z,T,W,BA,AA,CA,QA,EA,IA,_)=>{const O=r(new f(U,m,J));if(y(O)&&w(QA)){N=A.pushSplat(),A.setCenter(N,O.x,O.y,O.z);const v=D(new f(K,z,T));A.setScale(N,v.x,v.y,v.z);const Z=l(new uA(W,BA,AA,CA));A.setQuaternion(N,Z.x,Z.y,Z.z,Z.w),A.setOpacity(N,QA),A.setColor(N,EA,IA,_)}else N=null},(H,U,m,J)=>{U&&N!==null&&A.setSh1(N,U),m&&N!==null&&A.setSh2(N,m),J&&N!==null&&A.setSh3(N,J)});break}case Xg.SPZ:{const S=new ai({fileBytes:n.fileBytes}),N=new Int32Array(S.numSplats);N.fill(-1);const H=new Float32Array(S.numSplats*3),U=new f;S.parseSplats((m,J,K,z)=>{const T=r(new f(J,K,z));H[m*3]=T.x,H[m*3+1]=T.y,H[m*3+2]=T.z},(m,J)=>{U.fromArray(H,m*3),y(U)&&w(J)&&(N[m]=A.pushSplat(),A.setCenter(N[m],U.x,U.y,U.z),A.setOpacity(N[m],J))},(m,J,K,z)=>{N[m]>=0&&A.setColor(N[m],J,K,z)},(m,J,K,z)=>{if(N[m]>=0){const T=D(new f(J,K,z));A.setScale(N[m],T.x,T.y,T.z)}},(m,J,K,z,T)=>{if(N[m]>=0){const W=l(new uA(J,K,z,T));A.setQuaternion(N[m],W.x,W.y,W.z,W.w)}},(m,J,K,z)=>{N[m]>=0&&(A.setSh1(N[m],J),K&&A.setSh2(N[m],K),z&&A.setSh3(N[m],z))});break}case Xg.SPLAT:ZQ(n.fileBytes,S=>{},(S,N,H,U,m,J,K,z,T,W,BA,AA,CA,QA,EA)=>{const IA=r(new f(N,H,U));if(y(IA)&&w(AA)){const _=A.pushSplat();A.setCenter(_,IA.x,IA.y,IA.z);const O=D(new f(m,J,K));A.setScale(_,O.x,O.y,O.z);const v=l(new uA(z,T,W,BA));A.setQuaternion(_,v.x,v.y,v.z,v.w),A.setOpacity(_,AA),A.setColor(_,CA,QA,EA)}});break;case Xg.KSPLAT:{let S=null;AE(n.fileBytes,N=>{},(N,H,U,m,J,K,z,T,W,BA,AA,CA,QA,EA,IA)=>{const _=r(new f(H,U,m));if(y(_)&&w(CA)){S=A.pushSplat(),A.setCenter(S,_.x,_.y,_.z);const O=D(new f(J,K,z));A.setScale(S,O.x,O.y,O.z);const v=l(new uA(T,W,BA,AA));A.setQuaternion(S,v.x,v.y,v.z,v.w),A.setOpacity(S,CA),A.setColor(S,QA,EA,IA)}else S=null},(N,H,U,m)=>{S!==null&&(A.setSh1(S,H),U&&A.setSh2(S,U),m&&A.setSh3(S,m))});break}default:throw new Error(`transcodeSpz not implemented for ${k}`)}}const i=Math.min(B??3,A.sh3?3:A.sh2?2:A.sh1?1:0),C=new KI({numSplats:A.numSplats,shDegree:i,fractionalBits:t,flagAntiAlias:!0});for(let n=0;n<A.numSplats;++n){const r=n*3,D=n*4;C.setCenter(n,A.centers[r],A.centers[r+1],A.centers[r+2]),C.setScale(n,A.scales[r],A.scales[r+1],A.scales[r+2]),C.setQuat(n,A.quaternions[D],A.quaternions[D+1],A.quaternions[D+2],A.quaternions[D+3]),C.setAlpha(n,A.opacities[n]),C.setRgb(n,A.colors[r],A.colors[r+1],A.colors[r+2]),A.sh1&&i>=1&&C.setSh(n,A.sh1.slice(n*9,(n+1)*9),i>=2&&A.sh2?A.sh2.slice(n*15,(n+1)*15):void 0,i>=3&&A.sh3?A.sh3.slice(n*21,(n+1)*21):void 0)}return{fileBytes:await C.finalize(),clippedCount:C.clippedCount}}async function hi(E){const{name:A,args:I,id:g}=E.data;let B,t;try{switch(A){case"unpackPly":{const{packedArray:Q,fileBytes:i}=I,C=await os({packedArray:Q,fileBytes:i});B={id:g,numSplats:C.numSplats,packedArray:C.packedArray,extra:C.extra};break}case"decodeSpz":{const{fileBytes:Q}=I,i=as(Q);B={id:g,numSplats:i.numSplats,packedArray:i.packedArray,extra:i.extra};break}case"decodeAntiSplat":{const{fileBytes:Q}=I,i=$C(Q);B={id:g,numSplats:i.numSplats,packedArray:i.packedArray};break}case"decodeKsplat":{const{fileBytes:Q}=I,i=IE(Q);B={id:g,numSplats:i.numSplats,packedArray:i.packedArray,extra:i.extra};break}case"decodePcSogs":{const{fileBytes:Q,extraFiles:i}=I,C=await iE(Q,i);B={id:g,numSplats:C.numSplats,packedArray:C.packedArray,extra:C.extra};break}case"sortSplats":{const{maxSplats:Q,totalSplats:i,readback:C,ordering:s}=I;B={id:g,readback:C,...ns({totalSplats:i,readback:C,ordering:s})};break}case"sortDoubleSplats":{const{numSplats:Q,readback:i,ordering:C}=I;B={id:g,readback:i,ordering:C},xC&&(B={id:g,readback:i,ordering:C,activeSplats:pi(Q,i,C)});break}case"transcodeSpz":{const Q=I,i=await es(Q);B={id:g,fileBytes:i,input:Q};break}default:throw new Error(`Unknown name: ${A}`)}}catch(Q){t=Q}self.postMessage({id:g,result:B,error:t},{transfer:LQ(B)})}async function os({packedArray:E,fileBytes:A}){const I=new Og({fileBytes:A});await I.parseHeader();const g=I.numSplats,B={},t=Math.exp(-20);return I.parseSplats((Q,i,C,s,o,e,a,n,r,D,l,y,w,u,G)=>{Wg(E,Q,i,C,s,o<t?0:Math.max(ut,o),e<t?0:Math.max(ut,e),a<t?0:Math.max(ut,a),n,r,D,l,y,w,u,G)},(Q,i,C,s)=>{i&&(B.sh1||(B.sh1=new Uint32Array(g*2)),kB(B.sh1,Q,i)),C&&(B.sh2||(B.sh2=new Uint32Array(g*4)),RB(B.sh2,Q,C)),s&&(B.sh3||(B.sh3=new Uint32Array(g*4)),mB(B.sh3,Q,s))}),{packedArray:E,numSplats:g,extra:B}}function as(E){const A=new ai({fileBytes:E}),I=A.numSplats,g=pB(I),B=new Uint32Array(g*4),t={};return A.parseSplats((Q,i,C,s)=>{HQ(B,Q,i,C,s)},(Q,i)=>{ZC(B,Q,i)},(Q,i,C,s)=>{TC(B,Q,i,C,s)},(Q,i,C,s)=>{bQ(B,Q,i,C,s)},(Q,i,C,s,o)=>{KQ(B,Q,i,C,s,o)},(Q,i,C,s)=>{i&&(t.sh1||(t.sh1=new Uint32Array(I*2)),kB(t.sh1,Q,i)),C&&(t.sh2||(t.sh2=new Uint32Array(I*4)),RB(t.sh2,Q,C)),s&&(t.sh3||(t.sh3=new Uint32Array(I*4)),mB(t.sh3,Q,s))}),{packedArray:B,numSplats:I,extra:t}}const Sg=31744,Pg=Sg+1;let DA=null;function ns({totalSplats:E,readback:A,ordering:I}){DA||(DA=new Uint32Array(Pg)),DA.fill(0);const g=A.map(C=>new Uint32Array(C.buffer)),B=g[0].length,t=Math.ceil(E/B);let Q=0;for(let C=0;C<t;++C){const s=g[C],o=Math.min(s.length,E-Q);for(let e=0;e<o;++e){const a=s[e]&32767;a<Sg&&(DA[a]+=1)}Q+=o}let i=0;for(let C=0;C<Pg;++C){const s=i+DA[C];DA[C]=i,i=s}Q=0;for(let C=0;C<t;++C){const s=g[C],o=Math.min(s.length,E-Q);for(let e=0;e<o;++e){const a=s[e]&32767;a<Sg&&(I[DA[a]]=Q+e,DA[a]+=1)}Q+=o}if(DA[Pg-1]!==i)throw new Error(`Expected ${i} active splats but got ${DA[Pg-1]}`);return{activeSplats:i,ordering:I}}function Ee({numSplats:E,readback:A,ordering:I}){DA||(DA=new Uint32Array(Pg)),DA.fill(0);for(let B=0;B<E;++B){const t=A[B];t<Sg&&(DA[t]+=1)}let g=0;for(let B=Sg-1;B>=0;--B){const t=g+DA[B];DA[B]=g,g=t}for(let B=0;B<E;++B){const t=A[B];t<Sg&&(I[DA[t]]=B,DA[t]+=1)}if(DA[0]!==g)throw new Error(`Expected ${g} active splats but got ${DA[0]}`);return{activeSplats:g,ordering:I}}const Yt=[];function ci(E){Yt.push(E)}async function rs(){self.addEventListener("message",ci),await vB(),self.removeEventListener("message",ci),self.addEventListener("message",hi);for(const E of Yt)hi(E);Yt.length=0}rs().catch(console.error)})();\n//# sourceMappingURL=worker-DwLc-3SK.js.map\n', gg = typeof self < "u" && self.Blob && new Blob([FQ], { type: "text/javascript;charset=utf-8" });
function Wn(t) {
  let A;
  try {
    if (A = gg && (self.URL || self.webkitURL).createObjectURL(gg), !A) throw "";
    const I = new Worker(A, {
      name: t == null ? void 0 : t.name
    });
    return I.addEventListener("error", () => {
      (self.URL || self.webkitURL).revokeObjectURL(A);
    }), I;
  } catch {
    return new Worker(
      "data:text/javascript;charset=utf-8," + encodeURIComponent(FQ),
      {
        name: t == null ? void 0 : t.name
      }
    );
  } finally {
    A && (self.URL || self.webkitURL).revokeObjectURL(A);
  }
}
class On {
  constructor() {
    this.messages = {}, this.messageIdNext = 0, this.worker = new Wn(), this.worker.onmessage = (A) => this.onMessage(A);
  }
  makeMessageId() {
    return ++this.messageIdNext;
  }
  makeMessagePromiseId() {
    const A = this.makeMessageId(), I = new Promise((g, B) => {
      this.messages[A] = { resolve: g, reject: B };
    });
    return { id: A, promise: I };
  }
  onMessage(A) {
    const { id: I, result: g, error: B } = A.data, i = this.messages[I];
    i && (delete this.messages[I], B ? i.reject(B) : i.resolve(g));
  }
  // Invoke an RPC on the worker with the given name and arguments.
  // The normal usage of a worker is to run one activity at a time,
  // but this function allows for concurrent calls, tagging each request
  // with a unique message Id and awaiting a response to that same Id.
  // The method will automatically transfer any ArrayBuffers in the
  // arguments to the worker. If you'd like to transfer a copy of a
  // buffer then you must clone it before passing to this function.
  async call(A, I) {
    const { id: g, promise: B } = this.makeMessagePromiseId();
    return this.worker.postMessage(
      { name: A, args: I, id: g },
      { transfer: wB(I) }
    ), B;
  }
}
let GQ = 4, sI = 0;
const SQ = [], NQ = [];
async function Vn() {
  const t = SQ.shift();
  if (t)
    return t;
  if (sI < GQ) {
    const A = new On();
    return sI += 1, A;
  }
  return new Promise((A) => {
    NQ.push(A);
  });
}
function Pn(t) {
  if (sI > GQ) {
    sI -= 1;
    return;
  }
  const A = NQ.shift();
  if (A) {
    A(t);
    return;
  }
  SQ.push(t);
}
async function ut(t) {
  const A = await Vn();
  try {
    return await t(A);
  } finally {
    Pn(A);
  }
}
class Xn extends _Q {
  constructor(A) {
    super(A), this.fileLoader = new $Q(A);
  }
  load(A, I, g, B) {
    this.fileLoader.setResponseType("arraybuffer"), this.fileLoader.setCrossOrigin(this.crossOrigin), this.fileLoader.setWithCredentials(this.withCredentials), this.fileLoader.setPath(this.path), this.fileLoader.setResourcePath(this.resourcePath), this.fileLoader.setRequestHeader(this.requestHeader), this.fileLoader.load(
      A,
      async (i) => {
        if (I) {
          const e = i, Q = {}, s = [];
          let E = this.fileType;
          try {
            const a = kQ(e);
            if (this.fileType === "pcsogs" && a === void 0)
              throw new Error("Invalid PC SOGS file");
            if (a !== void 0) {
              E = "pcsogs";
              for (const o of ["means", "scales", "quats", "sh0", "shN"]) {
                const r = a[o];
                if (r) {
                  const h = r.files;
                  for (const c of h) {
                    const l = new URL(c, A).toString();
                    this.manager.itemStart(l);
                    const u = this.loadExtra(l).then((D) => {
                      Q[c] = D;
                    }).catch((D) => {
                      throw this.manager.itemError(l), D;
                    }).finally(() => {
                      this.manager.itemEnd(l);
                    });
                    s.push(u);
                  }
                }
              }
            }
            await Promise.all(s);
            const C = await xQ({
              input: e,
              extraFiles: Q,
              fileType: E,
              pathOrUrl: A
            });
            this.packedSplats ? (this.packedSplats.initialize(C), I(this.packedSplats)) : I(new KA(C));
          } catch (a) {
            B == null || B(a);
          }
        }
      },
      g,
      B
    );
  }
  async loadAsync(A, I) {
    return new Promise((g, B) => {
      this.load(
        A,
        (i) => {
          g(i);
        },
        I,
        B
      );
    });
  }
  async loadExtra(A) {
    return new Promise((I, g) => {
      this.fileLoader.load(
        A,
        (B) => I(B),
        void 0,
        (B) => g(B)
      );
    });
  }
  parse(A) {
    return new OA({ packedSplats: A });
  }
}
var Rt = /* @__PURE__ */ ((t) => (t.PLY = "ply", t.SPZ = "spz", t.SPLAT = "splat", t.KSPLAT = "ksplat", t.PCSOGS = "pcsogs", t))(Rt || {});
function mQ(t) {
  const A = new DataView(t.buffer);
  if ((A.getUint32(0, !0) & 16777215) === 7957616)
    return "ply";
  if ((A.getUint32(0, !0) & 16777215) === 559903) {
    const I = MB(t, 4);
    return new DataView(I.buffer).getUint32(0, !0) === 1347635022 ? "spz" : void 0;
  }
}
function jn(t) {
  const A = t.split(/[?#]/, 1)[0], I = Math.max(
    A.lastIndexOf("/"),
    A.lastIndexOf("\\")
  ), g = A.slice(I + 1), B = g.lastIndexOf(".");
  return B <= 0 || B === g.length - 1 ? "" : g.slice(B + 1).toLowerCase();
}
function MQ(t) {
  const A = jn(t);
  if (A === "ply")
    return "ply";
  if (A === "spz")
    return "spz";
  if (A === "splat")
    return "splat";
  if (A === "ksplat")
    return "ksplat";
}
function $o(t) {
  return kQ(t) !== void 0;
}
function kQ(t) {
  try {
    let A;
    if (typeof t == "string")
      A = t;
    else {
      const g = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
      if (g.length > 65536)
        return;
      A = new TextDecoder().decode(g);
    }
    const I = JSON.parse(A);
    if (!I || typeof I != "object" || Array.isArray(I))
      return;
    for (const g of ["means", "scales", "quats", "sh0"])
      if (!I[g] || typeof I[g] != "object" || Array.isArray(I[g]) || !I[g].shape || !I[g].files || g !== "quats" && (!I[g].mins || !I[g].maxs))
        return;
    return I;
  } catch {
    return;
  }
}
async function xQ({
  input: t,
  extraFiles: A,
  fileType: I,
  pathOrUrl: g
}) {
  const B = t instanceof ArrayBuffer ? new Uint8Array(t) : t;
  let i = I;
  switch (I || (i = mQ(B), !i && g && (i = MQ(g))), i) {
    case "ply": {
      const e = new QI({ fileBytes: B });
      await e.parseHeader();
      const Q = e.numSplats, s = fA(Q).maxSplats, E = { fileBytes: B, packedArray: new Uint32Array(s * 4) };
      return await ut(async (a) => {
        const { packedArray: C, numSplats: o, extra: r } = await a.call(
          "unpackPly",
          E
        );
        return { packedArray: C, numSplats: o, extra: r };
      });
    }
    case "spz":
      return await ut(async (e) => {
        const { packedArray: Q, numSplats: s, extra: E } = await e.call(
          "decodeSpz",
          {
            fileBytes: B
          }
        );
        return { packedArray: Q, numSplats: s, extra: E };
      });
    case "splat":
      return await ut(async (e) => {
        const { packedArray: Q, numSplats: s } = await e.call(
          "decodeAntiSplat",
          {
            fileBytes: B
          }
        );
        return { packedArray: Q, numSplats: s };
      });
    case "ksplat":
      return await ut(async (e) => {
        const { packedArray: Q, numSplats: s, extra: E } = await e.call(
          "decodeKsplat",
          { fileBytes: B }
        );
        return { packedArray: Q, numSplats: s, extra: E };
      });
    case "pcsogs":
      return await ut(async (e) => {
        const { packedArray: Q, numSplats: s, extra: E } = await e.call(
          "decodePcSogs",
          { fileBytes: B, extraFiles: A }
        );
        return { packedArray: Q, numSplats: s, extra: E };
      });
    default:
      throw new Error(`Unknown splat file type: ${i}`);
  }
}
class _n {
  constructor({ maxSplats: A = 1 } = {}) {
    this.numSplats = 0, this.maxSplats = fA(A).maxSplats, this.centers = new Float32Array(this.maxSplats * 3), this.scales = new Float32Array(this.maxSplats * 3), this.quaternions = new Float32Array(this.maxSplats * 4), this.opacities = new Float32Array(this.maxSplats), this.colors = new Float32Array(this.maxSplats * 3);
  }
  pushSplat() {
    const A = this.numSplats;
    return this.ensureIndex(A), this.numSplats += 1, A;
  }
  unpushSplat(A) {
    if (A === this.numSplats - 1)
      this.numSplats -= 1;
    else
      throw new Error("Cannot unpush splat from non-last position");
  }
  ensureCapacity(A) {
    if (A > this.maxSplats) {
      const I = Math.max(A, this.maxSplats * 2), g = new Float32Array(I * 3), B = new Float32Array(I * 3), i = new Float32Array(I * 4), e = new Float32Array(I), Q = new Float32Array(I * 3);
      if (g.set(this.centers), B.set(this.scales), i.set(this.quaternions), e.set(this.opacities), Q.set(this.colors), this.centers = g, this.scales = B, this.quaternions = i, this.opacities = e, this.colors = Q, this.sh1) {
        const s = new Float32Array(I * 9);
        s.set(this.sh1), this.sh1 = s;
      }
      if (this.sh2) {
        const s = new Float32Array(I * 15);
        s.set(this.sh2), this.sh2 = s;
      }
      if (this.sh3) {
        const s = new Float32Array(I * 21);
        s.set(this.sh3), this.sh3 = s;
      }
      this.maxSplats = I;
    }
  }
  ensureIndex(A) {
    this.ensureCapacity(A + 1);
  }
  setCenter(A, I, g, B) {
    this.centers[A * 3] = I, this.centers[A * 3 + 1] = g, this.centers[A * 3 + 2] = B;
  }
  setScale(A, I, g, B) {
    this.scales[A * 3] = I, this.scales[A * 3 + 1] = g, this.scales[A * 3 + 2] = B;
  }
  setQuaternion(A, I, g, B, i) {
    this.quaternions[A * 4] = I, this.quaternions[A * 4 + 1] = g, this.quaternions[A * 4 + 2] = B, this.quaternions[A * 4 + 3] = i;
  }
  setOpacity(A, I) {
    this.opacities[A] = I;
  }
  setColor(A, I, g, B) {
    this.colors[A * 3] = I, this.colors[A * 3 + 1] = g, this.colors[A * 3 + 2] = B;
  }
  setSh1(A, I) {
    this.sh1 || (this.sh1 = new Float32Array(this.maxSplats * 9));
    for (let g = 0; g < 9; ++g)
      this.sh1[A * 9 + g] = I[g];
  }
  setSh2(A, I) {
    this.sh2 || (this.sh2 = new Float32Array(this.maxSplats * 15));
    for (let g = 0; g < 15; ++g)
      this.sh2[A * 15 + g] = I[g];
  }
  setSh3(A, I) {
    this.sh3 || (this.sh3 = new Float32Array(this.maxSplats * 21));
    for (let g = 0; g < 21; ++g)
      this.sh3[A * 21 + g] = I[g];
  }
}
var $n = `precision highp float;
precision highp int;
precision highp sampler2D;
precision highp usampler2D;
precision highp isampler2D;
precision highp sampler2DArray;
precision highp usampler2DArray;
precision highp isampler2DArray;
precision highp sampler3D;
precision highp usampler3D;
precision highp isampler3D;

#include <splatDefines>

uniform uint targetLayer;
uniform int targetBase;
uniform int targetCount;

out uvec4 target;

{{ GLOBALS }}

void produceSplat(int index) {
    {{ STATEMENTS }}
}

void main() {
    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);
    int index = targetIndex - targetBase;

    if ((index >= 0) && (index < targetCount)) {
        produceSplat(index);
    } else {
        target = uvec4(0u, 0u, 0u, 0u);
    }
}`;
const IA = class IA {
  constructor(A = {}) {
    this.maxSplats = 0, this.numSplats = 0, this.packedArray = null, this.isInitialized = !1, this.target = null, this.source = null, this.needsUpdate = !0, this.extra = {}, this.dyno = new PI({ packedSplats: this }), this.initialized = Promise.resolve(this), this.reinitialize(A);
  }
  reinitialize(A) {
    this.isInitialized = !1, A.url || A.fileBytes || A.construct ? this.initialized = this.asyncInitialize(A).then(() => (this.isInitialized = !0, this)) : (this.initialize(A), this.isInitialized = !0, this.initialized = Promise.resolve(this));
  }
  initialize(A) {
    A.packedArray ? (this.packedArray = A.packedArray, this.maxSplats = Math.floor(this.packedArray.length / 4), this.maxSplats = Math.floor(this.maxSplats / j) * j, this.numSplats = Math.min(
      this.maxSplats,
      A.numSplats ?? Number.POSITIVE_INFINITY
    )) : (this.maxSplats = A.maxSplats ?? 0, this.numSplats = 0), this.extra = A.extra ?? {};
  }
  async asyncInitialize(A) {
    const { url: I, fileBytes: g, construct: B } = A;
    if (I) {
      const i = new Xn();
      i.packedSplats = this, await i.loadAsync(I);
    } else if (g) {
      const i = await xQ({
        input: g,
        fileType: A.fileType,
        pathOrUrl: A.fileName ?? I
      });
      this.initialize(i);
    }
    if (B) {
      const i = B(this);
      i instanceof Promise && await i;
    }
  }
  // Call this when you are finished with the PackedSplats and want to free
  // any buffers it holds.
  dispose() {
    this.target && (this.target.dispose(), this.target = null), this.source && (this.source.dispose(), this.source = null);
  }
  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,
  // resize exponentially and copy over the original data.
  //
  // Typically you don't need to call this, because calling this.setSplat(index, ...)
  // and this.pushSplat(...) will automatically call ensureSplats() so we have
  // enough splats.
  ensureSplats(A) {
    const I = A <= this.maxSplats ? this.maxSplats : (
      // Grow exponentially to avoid frequent reallocations
      Math.max(A, 2 * this.maxSplats)
    ), g = this.packedArray ? this.packedArray.length / 4 : 0;
    if (!this.packedArray || I > g) {
      this.maxSplats = fA(I).maxSplats;
      const B = new Uint32Array(this.maxSplats * 4);
      this.packedArray && B.set(this.packedArray), this.packedArray = B;
    }
    return this.packedArray;
  }
  // Ensure the extra array for the given level is large enough to hold numSplats
  ensureSplatsSh(A, I) {
    let g, B;
    if (A === 0)
      return this.ensureSplats(I);
    if (A === 1)
      g = 2, B = "sh1";
    else if (A === 2)
      g = 4, B = "sh2";
    else if (A === 3)
      g = 4, B = "sh3";
    else
      throw new Error(`Invalid level: ${A}`);
    let i = this.extra[B] ? this.extra[B].length / g : 0;
    const e = I <= i ? i : Math.max(I, 2 * i);
    if (!this.extra[B] || e > i) {
      i = fA(e).maxSplats;
      const Q = new Uint32Array(i * g);
      this.extra[B] && Q.set(this.extra[B]), this.extra[B] = Q;
    }
    return this.extra[B];
  }
  // Unpack the 16-byte Gsplat data at index into the Three.js components
  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,
  // opacity: number 0..1, color: THREE.Color 0..1.
  getSplat(A) {
    if (!this.packedArray || A >= this.numSplats)
      throw new Error("Invalid index");
    return MI(this.packedArray, A);
  }
  // Set all PackedSplat components at index with the provided Gsplat attributes
  // (can be the same objects returned by getSplat). Ensures there is capacity
  // for at least index+1 Gsplats.
  setSplat(A, I, g, B, i, e) {
    const Q = this.ensureSplats(A + 1);
    mI(
      Q,
      A,
      I.x,
      I.y,
      I.z,
      g.x,
      g.y,
      g.z,
      B.x,
      B.y,
      B.z,
      B.w,
      i,
      e.r,
      e.g,
      e.b
    ), this.numSplats = Math.max(this.numSplats, A + 1);
  }
  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on
  // construction where you just want to iterate and create a collection of Gsplats.
  pushSplat(A, I, g, B, i) {
    const e = this.ensureSplats(this.numSplats + 1);
    mI(
      e,
      this.numSplats,
      A.x,
      A.y,
      A.z,
      I.x,
      I.y,
      I.z,
      g.x,
      g.y,
      g.z,
      g.w,
      B,
      i.r,
      i.g,
      i.b
    ), ++this.numSplats;
  }
  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat
  // and invoke the callback function with the Gsplat attributes.
  forEachSplat(A) {
    if (!(!this.packedArray || !this.numSplats))
      for (let I = 0; I < this.numSplats; ++I) {
        const g = MI(this.packedArray, I);
        A(
          I,
          g.center,
          g.scales,
          g.quaternion,
          g.opacity,
          g.color
        );
      }
  }
  // Ensures our PackedSplats.target render target has enough space to generate
  // maxSplats total Gsplats, and reallocate if not large enough.
  ensureGenerate(A) {
    if (this.target && (A ?? 1) <= this.maxSplats)
      return !1;
    this.dispose();
    const I = fA(A ?? 1), { width: g, height: B, depth: i } = I;
    return this.maxSplats = I.maxSplats, this.target = new n.WebGLArrayRenderTarget(g, B, i, {
      depthBuffer: !1,
      stencilBuffer: !1,
      generateMipmaps: !1,
      magFilter: n.NearestFilter,
      minFilter: n.NearestFilter
    }), this.target.texture.format = n.RGBAIntegerFormat, this.target.texture.type = n.UnsignedIntType, this.target.texture.internalFormat = "RGBA32UI", this.target.scissorTest = !0, !0;
  }
  // Given an array of splatCounts (.numSplats for each
  // SplatGenerator/SplatMesh in the scene), compute a
  // "mapping layout" in the composite array of generated outputs.
  generateMapping(A) {
    let I = 0;
    const g = A.map((B) => {
      const i = I, e = Math.ceil(B / j) * j;
      return I += e, { base: i, count: B };
    });
    return { maxSplats: I, mapping: g };
  }
  // Returns a THREE.DataArrayTexture representing the PackedSplats content as
  // a Uint32x4 data array texture (2048 x 2048 x depth in size)
  getTexture() {
    return this.target ? this.target.texture : this.source || this.packedArray ? this.maybeUpdateSource() : IA.getEmpty();
  }
  // Check if source texture needs to be created/updated
  maybeUpdateSource() {
    if (!this.packedArray)
      throw new Error("No packed splats");
    if (this.needsUpdate || !this.source) {
      if (this.needsUpdate = !1, this.source) {
        const { width: A, height: I, depth: g } = this.source.image;
        this.maxSplats !== A * I * g && (this.source.dispose(), this.source = null);
      }
      if (this.source)
        this.packedArray.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.packedArray.buffer));
      else {
        const { width: A, height: I, depth: g } = fA(this.maxSplats);
        this.source = new n.DataArrayTexture(
          this.packedArray,
          A,
          I,
          g
        ), this.source.format = n.RGBAIntegerFormat, this.source.type = n.UnsignedIntType, this.source.internalFormat = "RGBA32UI", this.source.needsUpdate = !0;
      }
      this.source.needsUpdate = !0;
    }
    return this.source;
  }
  // Can be used where you need an uninitialized THREE.DataArrayTexture like
  // a uniform you will update with the result of this.getTexture() later.
  static getEmpty() {
    if (!IA.emptySource) {
      const { width: A, height: I, depth: g, maxSplats: B } = fA(1), i = new Uint32Array(B * 4);
      IA.emptySource = new n.DataArrayTexture(
        i,
        A,
        I,
        g
      ), IA.emptySource.format = n.RGBAIntegerFormat, IA.emptySource.type = n.UnsignedIntType, IA.emptySource.internalFormat = "RGBA32UI", IA.emptySource.needsUpdate = !0;
    }
    return IA.emptySource;
  }
  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,
  // generating it if necessary and caching the result.
  prepareProgramMaterial(A) {
    let I = IA.generatorProgram.get(A);
    if (!I) {
      const B = MA(
        { index: "int" },
        { output: "uvec4" },
        ({ index: i }) => {
          A.inputs.index = i;
          const e = A.outputs.gsplat;
          return { output: Ng(e) };
        }
      );
      IA.programTemplate || (IA.programTemplate = new zI(
        $n
      )), I = new ZI({
        graph: B,
        inputs: { index: "index" },
        outputs: { output: "target" },
        template: IA.programTemplate
      }), Object.assign(I.uniforms, {
        targetLayer: { value: 0 },
        targetBase: { value: 0 },
        targetCount: { value: 0 }
      }), IA.generatorProgram.set(A, I);
    }
    const g = I.prepareMaterial();
    return IA.mesh.material = g, { program: I, material: g };
  }
  saveRenderState(A) {
    return {
      xrEnabled: A.xr.enabled,
      autoClear: A.autoClear
    };
  }
  resetRenderState(A, I) {
    A.setRenderTarget(null), A.xr.enabled = I.xrEnabled, A.autoClear = I.autoClear;
  }
  // Executes a dyno program specified by generator which is any DynoBlock that
  // maps { index: "int" } to { gsplat: Gsplat }. This is called in
  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for
  // SplatGenerator instances whose version is newer than what was generated
  // for it last time.
  generate({
    generator: A,
    base: I,
    count: g,
    renderer: B
  }) {
    if (!this.target)
      throw new Error("Target must be initialized with ensureSplats");
    if (I + g > this.maxSplats)
      throw new Error("Base + count exceeds maxSplats");
    const { program: i, material: e } = this.prepareProgramMaterial(A);
    i.update();
    const Q = this.saveRenderState(B), s = Math.ceil((I + g) / j) * j, E = j * It;
    for (e.uniforms.targetBase.value = I, e.uniforms.targetCount.value = g; I < s; ) {
      const a = Math.floor(I / E);
      e.uniforms.targetLayer.value = a;
      const C = a * E, o = Math.floor((I - C) / j), r = Math.min(
        It,
        Math.ceil((s - C) / j)
      );
      this.target.scissor.set(
        0,
        o,
        j,
        r - o
      ), B.setRenderTarget(this.target, a), B.xr.enabled = !1, B.autoClear = !1, B.render(IA.scene, IA.camera), I += j * (r - o);
    }
    return this.resetRenderState(B, Q), { nextBase: s };
  }
};
IA.emptySource = null, IA.programTemplate = null, IA.generatorProgram = /* @__PURE__ */ new Map(), IA.geometry = new n.PlaneGeometry(2, 2), IA.mesh = new n.Mesh(
  IA.geometry,
  new n.RawShaderMaterial({ visible: !1 })
), IA.scene = new n.Scene().add(IA.mesh), IA.camera = new n.Camera();
let KA = IA;
class PI extends x {
  constructor({ packedSplats: A } = {}) {
    super({
      key: "packedSplats",
      type: qt,
      globals: () => [nI],
      value: {
        texture: KA.getEmpty(),
        numSplats: 0
      },
      update: (I) => {
        var g, B;
        return I.texture = ((g = this.packedSplats) == null ? void 0 : g.getTexture()) ?? KA.getEmpty(), I.numSplats = ((B = this.packedSplats) == null ? void 0 : B.numSplats) ?? 0, I;
      }
    }), this.packedSplats = A;
  }
}
class YI extends n.InstancedBufferGeometry {
  constructor(A, I) {
    super(), this.ordering = A, this.setAttribute("position", new n.BufferAttribute(Ao, 3)), this.setIndex(new n.BufferAttribute(to, 1)), this._maxInstanceCount = A.length, this.instanceCount = I, this.attribute = new n.InstancedBufferAttribute(A, 1, !1, 1), this.attribute.setUsage(n.DynamicDrawUsage), this.setAttribute("splatIndex", this.attribute);
  }
  update(A, I) {
    this.ordering = A, this.attribute.array = A, this.instanceCount = I, this.attribute.addUpdateRange(0, I), this.attribute.needsUpdate = !0;
  }
}
const Ao = new Float32Array([
  -1,
  -1,
  0,
  1,
  -1,
  0,
  1,
  1,
  0,
  -1,
  1,
  0
]), to = new Uint16Array([0, 1, 2, 0, 2, 3]), tt = class tt {
  constructor(A) {
    if (this.lastTime = null, this.encodeLinear = !1, this.superXY = 1, this.display = null, this.sorting = null, this.pending = null, this.sortingCheck = !1, this.readback = new Uint16Array(0), this.spark = A.spark, this.camera = A.camera, this.viewToWorld = A.viewToWorld ?? new n.Matrix4(), A.target) {
      const { width: I, height: g, doubleBuffer: B } = A.target, i = Math.max(1, Math.min(4, A.target.superXY ?? 1));
      if (this.superXY = i, I * i > 8192 || g * i > 8192)
        throw new Error("Target size too large");
      this.target = new n.WebGLRenderTarget(
        I * i,
        g * i,
        {
          format: n.RGBAFormat,
          type: n.UnsignedByteType,
          colorSpace: n.SRGBColorSpace
        }
      ), B && (this.back = new n.WebGLRenderTarget(
        I * i,
        g * i,
        {
          format: n.RGBAFormat,
          type: n.UnsignedByteType,
          colorSpace: n.SRGBColorSpace
        }
      )), this.encodeLinear = !0;
    }
    this.onTextureUpdated = A.onTextureUpdated, this.sortRadial = A.sortRadial ?? !0, this.sortDistance = A.sortDistance, this.sortCoorient = A.sortCoorient, this.depthBias = A.depthBias, this.sort360 = A.sort360, this.orderingFreelist = new dB({
      allocate: (I) => new Uint32Array(I),
      valid: (I, g) => I.length === g
    }), this.autoUpdate = !1, this.setAutoUpdate(A.autoUpdate ?? !1);
  }
  // Call this when you are done with the SparkViewpoint and want to
  // free up its resources (GPU targets, pixel buffers, etc.)
  dispose() {
    var A;
    this.setAutoUpdate(!1), this.target && (this.target.dispose(), this.target = void 0), this.back && (this.back.dispose(), this.back = void 0), this.display && (this.spark.releaseAccumulator(this.display.accumulator), this.display.geometry.dispose(), this.display = null), (A = this.pending) != null && A.accumulator && (this.spark.releaseAccumulator(this.pending.accumulator), this.pending = null);
  }
  // Use this function to change whether this viewpoint will auto-update
  // its sort order whenever the attached SparkRenderer updates the Gsplats.
  // Turn this on or off depending on whether you expect to do renders from
  // this viewpoint most frames.
  setAutoUpdate(A) {
    !this.autoUpdate && A ? this.spark.autoViewpoints.push(this) : this.autoUpdate && !A && (this.spark.autoViewpoints = this.spark.autoViewpoints.filter(
      (I) => I !== this
    )), this.autoUpdate = A;
  }
  // See below async prepareRenderPixels() for explanation of parameters.
  // Awaiting this method updates the Gsplats in the scene and performs a sort of the
  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()
  // call in the same tick.
  async prepare({
    scene: A,
    camera: I,
    viewToWorld: g,
    update: B,
    forceOrigin: i
  }) {
    var Q;
    for (g ? this.viewToWorld = g : (this.camera = I ?? this.camera, this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone())); B ?? !0; ) {
      const s = i ? this.viewToWorld : void 0;
      if (this.spark.updateInternal({ scene: A, originToWorld: s }))
        break;
      await new Promise((a) => setTimeout(a, 10));
    }
    const e = this.spark.active;
    e !== ((Q = this.display) == null ? void 0 : Q.accumulator) && (this.spark.active.refCount += 1), await this.sortUpdate({ accumulator: e, viewToWorld: this.viewToWorld });
  }
  // Render out the viewpoint to the view target RGBA buffer.
  // Swaps buffers if doubleBuffer: true was set.
  // Calls onTextureUpdated(texture) with the resulting texture.
  renderTarget({
    scene: A,
    camera: I
  }) {
    var B;
    const g = this.back ?? this.target;
    if (!g)
      throw new Error("Must initialize SparkViewpoint with target");
    if (I = I ?? this.camera, !I)
      throw new Error("Must provide camera");
    if (I instanceof n.PerspectiveCamera) {
      const i = new n.PerspectiveCamera().copy(I, !1);
      i.aspect = g.width / g.height, i.updateProjectionMatrix(), I = i;
    }
    this.viewToWorld = I.matrixWorld.clone();
    try {
      this.spark.renderer.setRenderTarget(g), this.spark.prepareViewpoint(this), this.spark.renderer.render(A, I);
    } finally {
      this.spark.prepareViewpoint(this.spark.defaultView), this.spark.renderer.setRenderTarget(null);
    }
    g !== this.target && ([this.target, this.back] = [this.back, this.target]), (B = this.onTextureUpdated) == null || B.call(this, g.texture);
  }
  // Read back the previously rendered target image as a Uint8Array of packed
  // RGBA values (in that order). If superXY was set greater than 1 then
  // downsampling is performed in the target pixel array with simple averaging
  // to derive the returned pixel values. Subsequent calls to this.readTarget()
  // will reuse the same buffers to minimize memory allocations.
  async readTarget() {
    if (!this.target)
      throw new Error("Must initialize SparkViewpoint with target");
    const { width: A, height: I } = this.target, g = A * I * 4;
    (!this.superPixels || this.superPixels.length < g) && (this.superPixels = new Uint8Array(g)), await this.spark.renderer.readRenderTargetPixelsAsync(
      this.target,
      0,
      0,
      A,
      I,
      this.superPixels
    );
    const { superXY: B } = this;
    if (B === 1)
      return this.superPixels;
    const i = A / B, e = I / B, Q = i * e * 4;
    (!this.pixels || this.pixels.length < Q) && (this.pixels = new Uint8Array(Q));
    const { superPixels: s, pixels: E } = this, a = B * B;
    for (let C = 0; C < e; C++) {
      const o = C * i;
      for (let r = 0; r < i; r++) {
        const h = r * B;
        let c = 0, l = 0, u = 0, D = 0;
        for (let d = 0; d < B; d++) {
          const w = (C * B + d) * this.target.width;
          for (let F = 0; F < B; F++) {
            const m = (w + h + F) * 4;
            c += s[m], l += s[m + 1], u += s[m + 2], D += s[m + 3];
          }
        }
        const y = (o + r) * 4;
        E[y] = c / a, E[y + 1] = l / a, E[y + 2] = u / a, E[y + 3] = D / a;
      }
    }
    return E;
  }
  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene
  // and any camera/viewToWorld viewpoint overrides. By default update is true,
  // which triggers its SparkRenderer to check and potentially update the Gsplats.
  // Setting update to false disables this and sorts the Gsplats as they are.
  // Setting forceOrigin (default: false) to true forces the view update to
  // recalculate the splats with this view origin, potentially altering any
  // view-dependent effects. If you expect view-dependent effects to play a role
  // in the rendering quality, enable this.
  //
  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),
  // this.renderTarget(...), and finally returns the result this.readTarget(),
  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially
  // downsampled if the superXY parameter was used). These steps can also be called
  // manually, for example if you need to alter the scene before and after
  // this.renderTarget(...) to hide UI elements from being rendered.
  async prepareRenderPixels({
    scene: A,
    camera: I,
    viewToWorld: g,
    update: B,
    forceOrigin: i
  }) {
    return await this.prepare({ scene: A, camera: I, viewToWorld: g, update: B, forceOrigin: i }), this.renderTarget({ scene: A, camera: I }), this.readTarget();
  }
  // This is called automatically by SparkRenderer, there is no need to call it!
  // The method cannot be private because then SparkRenderer would
  // not be able to call it.
  autoPoll({ accumulator: A }) {
    var i, e, Q, s;
    this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone());
    let I = !1, g = !1;
    if (!this.display)
      I = !0;
    else if (A) {
      I = !0;
      const { mappingVersion: E } = this.display.accumulator;
      A.mappingVersion === E && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A, g = !0);
    }
    const B = ((i = this.sorting) == null ? void 0 : i.viewToWorld) ?? ((e = this.display) == null ? void 0 : e.viewToWorld);
    B && !BI({
      matrix1: this.viewToWorld,
      matrix2: B,
      // By default update sort each 1 cm
      maxDistance: this.sortDistance ?? 0.01,
      // By default for radial sort, update for intermittent movement so that
      // we bring back splats culled by being behind the camera.
      // For depth sort, small rotations can change sort order a lot, so
      // update sort for even small rotations.
      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999
    }) && (I = !0), I && (A && (A.refCount += 1), A && ((Q = this.pending) != null && Q.accumulator) && this.pending.accumulator !== ((s = this.display) == null ? void 0 : s.accumulator) && this.spark.releaseAccumulator(this.pending.accumulator), this.pending = { accumulator: A, viewToWorld: this.viewToWorld, displayed: g }, this.driveSort());
  }
  async driveSort() {
    var A;
    for (; ; ) {
      if (this.sorting || !this.pending)
        return;
      const { viewToWorld: I, displayed: g } = this.pending;
      let B = this.pending.accumulator ?? ((A = this.display) == null ? void 0 : A.accumulator);
      if (B || (B = this.spark.active, B.refCount += 1), this.pending = null, !B)
        throw new Error("No accumulator to sort");
      this.sorting = { viewToWorld: I }, await this.sortUpdate({ accumulator: B, viewToWorld: I, displayed: g }), this.sorting = null;
    }
  }
  async sortUpdate({
    accumulator: A,
    viewToWorld: I,
    displayed: g = !1
  }) {
    if (this.sortingCheck)
      throw new Error("Only one sort at a time");
    this.sortingCheck = !0, A = A ?? this.spark.active;
    const { numSplats: B, maxSplats: i } = A.splats;
    let e = 0, Q = this.orderingFreelist.alloc(i);
    if (B > 0) {
      const {
        reader: s,
        doubleSortReader: E,
        dynoSortRadial: a,
        dynoOrigin: C,
        dynoDirection: o,
        dynoDepthBias: r,
        dynoSort360: h,
        dynoSplats: c
      } = tt.makeSorter(), l = Math.ceil(i / 2);
      this.readback = s.ensureBuffer(l, this.readback);
      const u = A.toWorld.clone().invert(), D = I.clone().premultiply(u);
      a.value = this.sort360 ? !0 : this.sortRadial, C.value.set(0, 0, 0).applyMatrix4(D), o.value.set(0, 0, -1).applyMatrix4(D).sub(C.value).normalize(), r.value = this.depthBias ?? 1, h.value = this.sort360 ?? !1, c.packedSplats = A.splats, await s.renderReadback({
        renderer: this.spark.renderer,
        reader: E,
        count: Math.ceil(B / 2),
        readback: this.readback
      });
      const y = await ut(async (d) => d.call("sortDoubleSplats", {
        numSplats: B,
        readback: this.readback,
        ordering: Q
      }));
      this.readback = y.readback, Q = y.ordering, e = y.activeSplats;
    }
    this.updateDisplay({
      accumulator: A,
      viewToWorld: I,
      ordering: Q,
      activeSplats: e,
      displayed: g
    }), this.sortingCheck = !1;
  }
  updateDisplay({
    accumulator: A,
    viewToWorld: I,
    ordering: g,
    activeSplats: B,
    displayed: i = !1
  }) {
    if (!this.display)
      this.display = {
        accumulator: A,
        viewToWorld: I,
        geometry: new YI(g, B)
      };
    else {
      !i && A !== this.display.accumulator && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A), this.display.viewToWorld = I;
      const e = this.display.geometry.ordering;
      e.length === g.length ? this.display.geometry.update(g, B) : (this.display.geometry.dispose(), this.display.geometry = new YI(g, B)), this.orderingFreelist.free(e);
    }
    this.spark.viewpoint === this && this.spark.prepareViewpoint(this);
  }
  static makeSorter() {
    if (!tt.dynos) {
      const A = new gI({ value: !0 }), I = new ft({ value: new n.Vector3() }), g = new ft({ value: new n.Vector3() }), B = new Et({ value: 1 }), i = new gI({ value: !1 }), e = new PI(), Q = new iI(), s = MA(
        { index: "int" },
        { rgba8: "vec4" },
        ({ index: E }) => {
          if (!E)
            throw new Error("No index");
          const a = {
            sortRadial: A,
            sortOrigin: I,
            sortDirection: g,
            sortDepthBias: B,
            sort360: i
          }, C = nA(E, q("int", 2)), o = Jt(e, C), r = Bg({ gsplat: o, ...a }), h = Jt(
            e,
            pA(C, q("int", 1))
          ), c = Bg({ gsplat: h, ...a }), l = TA({
            vectorType: "vec2",
            x: r,
            y: c
          });
          return { rgba8: Yi(Ui(l)) };
        }
      );
      tt.dynos = {
        dynoSortRadial: A,
        dynoOrigin: I,
        dynoDirection: g,
        dynoDepthBias: B,
        dynoSort360: i,
        dynoSplats: e,
        reader: Q,
        doubleSortReader: s
      };
    }
    return tt.dynos;
  }
};
tt.EMPTY_TEXTURE = new n.Texture(), tt.dynos = null;
let CI = tt;
const Io = oA(`
  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {
    if (!isGsplatActive(gsplat.flags)) {
      return INFINITY;
    }

    vec3 center = gsplat.center - sortOrigin;
    float biasedDepth = dot(center, sortDirection) + sortDepthBias;
    if (!sort360 && (biasedDepth <= 0.0)) {
      return INFINITY;
    }

    return sortRadial ? length(center) : biasedDepth;
  }
`);
function Bg({
  gsplat: t,
  sortRadial: A,
  sortOrigin: I,
  sortDirection: g,
  sortDepthBias: B,
  sort360: i
}) {
  return Kt({
    inTypes: {
      gsplat: _,
      sortRadial: "bool",
      sortOrigin: "vec3",
      sortDirection: "vec3",
      sortDepthBias: "float",
      sort360: "bool"
    },
    outTypes: { metric: "float" },
    globals: () => [NA, Io],
    inputs: {
      gsplat: t,
      sortRadial: A,
      sortOrigin: I,
      sortDirection: g,
      sortDepthBias: B,
      sort360: i
    },
    statements: ({ inputs: e, outputs: Q }) => {
      const {
        gsplat: s,
        sortRadial: E,
        sortOrigin: a,
        sortDirection: C,
        sortDepthBias: o,
        sort360: r
      } = e;
      return UA(`
        ${Q.metric} = computeSort(${s}, ${E}, ${a}, ${C}, ${o}, ${r});
      `);
    }
  }).outputs.metric;
}
class FI {
  constructor() {
    this.splats = new KA(), this.toWorld = new n.Matrix4(), this.mapping = [], this.refCount = 0, this.splatsVersion = -1, this.mappingVersion = -1;
  }
  ensureGenerate(A) {
    this.splats.ensureGenerate(A) && (this.mapping = []);
  }
  // Generate all Gsplats from an array of generators
  generateSplats({
    renderer: A,
    modifier: I,
    generators: g,
    forceUpdate: B,
    originToWorld: i
  }) {
    const e = this.mapping.reduce((E, a) => (E.set(a.node, a), E), /* @__PURE__ */ new Map());
    let Q = 0, s = 0;
    for (const { node: E, generator: a, version: C, base: o, count: r } of g) {
      const h = e.get(E);
      if ((B || a !== (h == null ? void 0 : h.generator) || C !== (h == null ? void 0 : h.version) || o !== (h == null ? void 0 : h.base) || r !== (h == null ? void 0 : h.count)) && a && r > 0) {
        const c = I.apply(a);
        try {
          this.splats.generate({
            generator: c,
            base: o,
            count: r,
            renderer: A
          });
        } catch (l) {
          E.generator = void 0, E.generatorError = l;
        }
        Q += 1;
      }
      s = Math.max(s, o + r);
    }
    return this.splats.numSplats = s, this.toWorld = i, this.mapping = g, Q !== 0;
  }
  // Check if this accumulator has exactly the same generator mapping as
  // the previous one. If so, we can reuse the Gsplat sort order.
  hasCorrespondence(A) {
    return this.mapping.length !== A.mapping.length ? !1 : this.mapping.every(({ node: I, base: g, count: B }, i) => {
      const {
        node: e,
        base: Q,
        count: s
      } = A.mapping[i];
      return I === e && g === Q && B === s;
    });
  }
}
var go = `const float LN_SCALE_MIN = -9.0;
const float LN_SCALE_MAX = 9.0;
const float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; 

const uint SPLAT_TEX_WIDTH_BITS = 11u;
const uint SPLAT_TEX_HEIGHT_BITS = 11u;
const uint SPLAT_TEX_DEPTH_BITS = 11u;
const uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;

const uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;
const uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;
const uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;

const uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;
const uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;
const uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;

const uint F16_INF = 0x7c00u;
const float PI = 3.1415926535897932384626433832795;

const float INFINITY = 1.0 / 0.0;
const float NEG_INFINITY = -INFINITY;

const float MAX_PIXEL_RADIUS = 512.0;
const float MIN_ALPHA = 0.5 * (1.0 / 255.0); 
const float MAX_STDDEV = sqrt(8.0);

float sqr(float x) {
    return x * x;
}

float pow4(float x) {
    float x2 = x * x;
    return x2 * x2;
}

float pow8(float x) {
    float x4 = pow4(x);
    return x4 * x4;
}

vec3 srgbToLinear(vec3 rgb) {
    return pow(rgb, vec3(2.2));
}

vec3 linearToSrgb(vec3 rgb) {
    return pow(rgb, vec3(1.0 / 2.2));
}

uint encodeQuatOctXy88R8(vec4 q) {
    
    if (q.w < 0.0) {
        q = -q;
    }
    
    float theta = 2.0 * acos(q.w);
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    
    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;
    
    
    
    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);
    vec2 p = vec2(axis.x, axis.y) / sum;
    
    if (axis.z < 0.0) {
        float oldPx = p.x;
        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);
        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);
    }
    
    float u_f = p.x * 0.5 + 0.5;
    float v_f = p.y * 0.5 + 0.5;
    
    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));
    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));
    
    
    
    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));
    
    
    return (angleInt << 16u) | (quantV << 8u) | quantU;
}

vec4 decodeQuatOctXy88R8(uint encoded) {
    
    uint quantU = encoded & uint(0xFFu);               
    uint quantV = (encoded >> 8u) & uint(0xFFu);         
    uint angleInt = encoded >> 16u;                      

    
    float u_f = float(quantU) / 255.0;
    float v_f = float(quantV) / 255.0;
    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);

    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));
    float t = max(-axis.z, 0.0);
    axis.x += (axis.x >= 0.0) ? -t : t;
    axis.y += (axis.y >= 0.0) ? -t : t;
    axis = normalize(axis);
    
    
    float theta = (float(angleInt) / 255.0) * 3.14159265359;
    float halfTheta = theta * 0.5;
    float s = sin(halfTheta);
    float w = cos(halfTheta);
    
    return vec4(axis * s, w);
}

    

    

    

    

    

    

    

    

    

    

uvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {
    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));

    uint uQuat = encodeQuatOctXy88R8(quaternion);
    
    
    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);

    
    uvec3 uScales = uvec3(
        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,
        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u
    );

    
    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);
    uint word1 = packHalf2x16(center.xy);
    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);
    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);
    return uvec4(word0, word1, word2, word3);
}

void unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {
    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;

    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);
    rgba = vec4(uRgba) / 255.0;

    center = vec4(
        unpackHalf2x16(word1),
        unpackHalf2x16(word2 & 0xffffu)
    ).xyz;

    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);
    scales = vec3(
        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),
        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),
        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)
    );

    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);
    quaternion = decodeQuatOctXy88R8(uQuat);
    
    
}

vec3 quatVec(vec4 q, vec3 v) {
    
    vec3 t = 2.0 * cross(q.xyz, v);
    return v + q.w * t + cross(q.xyz, t);
}

vec4 quatQuat(vec4 q1, vec4 q2) {
    return vec4(
        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,
        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z
    );
}

mat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {
    
    return mat3(
        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),
        s.x * (2.0 * (q.x * q.y + q.w * q.z)),
        s.x * (2.0 * (q.x * q.z - q.w * q.y)),
        s.y * (2.0 * (q.x * q.y - q.w * q.z)),
        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),
        s.y * (2.0 * (q.y * q.z + q.w * q.x)),
        s.z * (2.0 * (q.x * q.z + q.w * q.y)),
        s.z * (2.0 * (q.y * q.z - q.w * q.x)),
        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))
    );
}

vec4 slerp(vec4 q1, vec4 q2, float t) {
    
    float cosHalfTheta = dot(q1, q2);

    
    if (abs(cosHalfTheta) >= 0.999) {
        return q1;
    }
    
    
    
    if (cosHalfTheta < 0.0) {
        q2 = -q2;
        cosHalfTheta = -cosHalfTheta;
    }

    
    float halfTheta = acos(cosHalfTheta);
    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);

    
    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;
    float ratioB = sin(t * halfTheta) / sinHalfTheta;

    
    return q1 * ratioA + q2 * ratioB;
}

ivec3 splatTexCoord(int index) {
    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;
    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;
    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;
    return ivec3(x, y, z);
}`, Bo = `precision highp float;
precision highp int;

#include <splatDefines>

uniform float near;
uniform float far;
uniform bool encodeLinear;
uniform float maxStdDev;
uniform bool disableFalloff;
uniform float falloff;

uniform bool splatTexEnable;
uniform sampler3D splatTexture;
uniform mat2 splatTexMul;
uniform vec2 splatTexAdd;
uniform float splatTexNear;
uniform float splatTexFar;
uniform float splatTexMid;

out vec4 fragColor;

in vec4 vRgba;
in vec2 vSplatUv;
in vec3 vNdc;

void main() {
    vec4 rgba = vRgba;

    float z = dot(vSplatUv, vSplatUv);
    if (!splatTexEnable) {
        if (z > (maxStdDev * maxStdDev)) {
            discard;
        }
    } else {
        vec2 uv = splatTexMul * vSplatUv + splatTexAdd;
        float ndcZ = vNdc.z;
        float depth = (2.0 * near * far) / (far + near - ndcZ * (far - near));
        float clampedFar = max(splatTexFar, splatTexNear);
        float clampedDepth = clamp(depth, splatTexNear, clampedFar);
        float logDepth = log2(clampedDepth + 1.0);
        float logNear = log2(splatTexNear + 1.0);
        float logFar = log2(clampedFar + 1.0);

        float texZ;
        if (splatTexMid > 0.0) {
            float clampedMid = clamp(splatTexMid, splatTexNear, clampedFar);
            float logMid = log2(clampedMid + 1.0);
            texZ = (clampedDepth <= clampedMid) ?
                (0.5 * ((logDepth - logNear) / (logMid - logNear))) :
                (0.5 * ((logDepth - logMid) / (logFar - logMid)) + 0.5);
        } else {
            texZ = (logDepth - logNear) / (logFar - logNear);
        }

        vec4 modulate = texture(splatTexture, vec3(uv, 1.0 - texZ));
        rgba *= modulate;
    }

    rgba.a *= mix(1.0, exp(-0.5 * z), falloff);

    if (rgba.a < MIN_ALPHA) {
        discard;
    }
    if (encodeLinear) {
        rgba.rgb = srgbToLinear(rgba.rgb);
    }
    fragColor = rgba;
}`, io = `precision highp float;
precision highp int;
precision highp usampler2DArray;

#include <splatDefines>

attribute uint splatIndex;

out vec4 vRgba;
out vec2 vSplatUv;
out vec3 vNdc;

uniform vec2 renderSize;
uniform uint numSplats;
uniform vec4 renderToViewQuat;
uniform vec3 renderToViewPos;
uniform float maxStdDev;
uniform float time;
uniform float deltaTime;
uniform bool debugFlag;
uniform bool enable2DGS;
uniform float blurAmount;
uniform float preBlurAmount;
uniform float focalDistance;
uniform float apertureAngle;
uniform float clipXY;
uniform float renderScale;

uniform usampler2DArray packedSplats;

void main() {
    
    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);

    if (uint(gl_InstanceID) >= numSplats) {
        return;
    }
    if (splatIndex == 0xffffffffu) {
        
        return;
    }

    ivec3 texCoord = ivec3(
        splatIndex & SPLAT_TEX_WIDTH_MASK,
        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,
        splatIndex >> SPLAT_TEX_LAYER_BITS
    );
    uvec4 packed = texelFetch(packedSplats, texCoord, 0);

    vec3 center, scales;
    vec4 quaternion, rgba;
    unpackSplat(packed, center, scales, quaternion, rgba);

    if (rgba.a < MIN_ALPHA) {
        return;
    }
    bvec3 zeroScales = equal(scales, vec3(0.0));
    if (all(zeroScales)) {
        return;
    }

    
    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;

    
    if (viewCenter.z >= 0.0) {
        return;
    }

    
    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);

    
    if (abs(clipCenter.z) >= clipCenter.w) {
        return;
    }

    
    float clip = clipXY * clipCenter.w;
    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {
        return;
    }

    
    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);

    if (enable2DGS && any(zeroScales)) {
        vRgba = rgba;
        vSplatUv = position.xy * maxStdDev;

        vec3 offset;
        if (zeroScales.z) {
            offset = vec3(vSplatUv.xy * scales.xy, 0.0);
        } else if (zeroScales.y) {
            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);
        } else {
            offset = vec3(0.0, vSplatUv.xy * scales.yz);
        }

        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);
        gl_Position = projectionMatrix * vec4(viewPos, 1.0);
        vNdc = gl_Position.xyz / gl_Position.w;
        return;
    }

    
    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;

    
    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);
    mat3 cov3D = RS * transpose(RS);

    
    vec2 scaledRenderSize = renderSize * renderScale;
    vec2 focal = 0.5 * scaledRenderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);
    float invZ = 1.0 / viewCenter.z;
    vec2 J1 = focal * invZ;
    vec2 J2 = -(J1 * viewCenter.xy) * invZ;
    mat3 J = mat3(
        J1.x, 0.0, J2.x,
        0.0, J1.y, J2.y,
        0.0, 0.0, 0.0
    );

    
    
    
    
    
    
    
    mat3 cov2D = transpose(J) * cov3D * J;
    float a = cov2D[0][0];
    float d = cov2D[1][1];
    float b = cov2D[0][1];

    
    a += preBlurAmount;
    d += preBlurAmount;

    float fullBlurAmount = blurAmount;
    if ((focalDistance > 0.0) && (apertureAngle > 0.0)) {
        float focusRadius = MAX_PIXEL_RADIUS;
        if (viewCenter.z < 0.0) {
            float focusBlur = abs((-viewCenter.z - focalDistance) / viewCenter.z);
            float apertureRadius = focal.x * tan(0.5 * apertureAngle);
            focusRadius = focusBlur * apertureRadius;
        }
        fullBlurAmount = clamp(sqr(focusRadius), blurAmount, sqr(MAX_PIXEL_RADIUS));
    }

    
    float detOrig = a * d - b * b;
    a += fullBlurAmount;
    d += fullBlurAmount;
    float det = a * d - b * b;

    
    float blurAdjust = sqrt(max(0.0, detOrig / det));
    rgba.a *= blurAdjust;
    if (rgba.a < MIN_ALPHA) {
        return;
    }

    
    float eigenAvg = 0.5 * (a + d);
    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));
    float eigen1 = eigenAvg + eigenDelta;
    float eigen2 = eigenAvg - eigenDelta;

    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));
    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);

    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));
    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));

    
    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;
    vec2 ndcOffset = (2.0 / scaledRenderSize) * pixelOffset;
    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);

    vRgba = rgba;
    vSplatUv = position.xy * maxStdDev;
    vNdc = ndc;
    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);
}`;
let GI = null;
function eo() {
  return GI || (n.ShaderChunk.splatDefines = go, GI = {
    splatVertex: io,
    splatFragment: Bo
  }), GI;
}
const ig = 5;
let LI = !1, JI = !1, RQ;
function Qo(t) {
  let A = !1;
  return t instanceof OA ? !0 : (t.traverse((I) => {
    A = A || I instanceof OA;
  }), A);
}
const UQ = n.Scene.prototype.add;
n.Scene.prototype.add = function(t) {
  return LI = LI || Qo(t), JI = JI || t instanceof EI, UQ.call(this, t), this;
};
const so = n.Scene.prototype.onBeforeRender;
n.Scene.prototype.onBeforeRender = function(t) {
  if (LI) {
    if (!JI) {
      const A = RQ || new EI({ renderer: t });
      this.add(A);
    }
    n.Scene.prototype.onBeforeRender = so, n.Scene.prototype.add = UQ;
  }
};
const QA = class QA extends n.Mesh {
  constructor(A) {
    const I = QA.makeUniforms(), g = eo(), B = new n.ShaderMaterial({
      glslVersion: n.GLSL3,
      vertexShader: g.splatVertex,
      fragmentShader: g.splatFragment,
      uniforms: I,
      transparent: !0,
      blending: n.NormalBlending,
      depthTest: !0,
      depthWrite: !1,
      side: n.DoubleSide
    });
    super(eg, B), this.renderScale = 1, this.splatTexture = null, this.autoViewpoints = [], this.rotateToAccumulator = new vt({ value: new n.Quaternion() }), this.translateToAccumulator = new ft({ value: new n.Vector3() }), this.lastFrame = -1, this.lastUpdateTime = null, this.defaultCameras = [], this.pendingUpdate = null, this.envViewpoint = null, this.frustumCulled = !1, this.renderer = A.renderer, this.material = B, this.uniforms = I;
    const i = MA(
      { gsplat: _ },
      { gsplat: _ },
      ({ gsplat: e }) => {
        if (!e)
          throw new Error("gsplat not defined");
        return e = KI(e, {
          rotate: this.rotateToAccumulator,
          translate: this.translateToAccumulator
        }), { gsplat: e };
      }
    );
    this.modifier = new Jn(i), this.autoUpdate = A.autoUpdate ?? !0, this.preUpdate = A.preUpdate ?? !1, this.originDistance = A.originDistance ?? 1, this.maxStdDev = A.maxStdDev ?? Math.sqrt(8), this.enable2DGS = A.enable2DGS ?? !1, this.preBlurAmount = A.preBlurAmount ?? 0, this.blurAmount = A.blurAmount ?? 0.3, this.focalDistance = A.focalDistance ?? 0, this.apertureAngle = A.apertureAngle ?? 0, this.falloff = A.falloff ?? 1, this.clipXY = A.clipXY ?? 1.4, this.active = new FI(), this.accumulatorCount = 1, this.freeAccumulators = [];
    for (let e = 0; e < 1; ++e)
      this.freeAccumulators.push(new FI()), this.accumulatorCount += 1;
    this.defaultView = new CI({
      ...A.view,
      autoUpdate: !0,
      spark: this
    }), this.viewpoint = this.defaultView, this.prepareViewpoint(this.viewpoint), this.clock = A.clock ? pB(A.clock) : new n.Clock(), RQ = this;
  }
  static makeUniforms() {
    return {
      // Size of render viewport in pixels
      renderSize: { value: new n.Vector2() },
      // Near and far plane distances
      near: { value: 0.1 },
      far: { value: 1e3 },
      // Total number of Gsplats in packedSplats to render
      numSplats: { value: 0 },
      // SplatAccumulator to view transformation quaternion
      renderToViewQuat: { value: new n.Quaternion() },
      // SplatAccumulator to view transformation translation
      renderToViewPos: { value: new n.Vector3() },
      // Maximum distance (in stddevs) from Gsplat center to render
      maxStdDev: { value: 1 },
      // Enable interpreting 0-thickness Gsplats as 2DGS
      enable2DGS: { value: !1 },
      // Add to projected 2D splat covariance diagonal (thickens and brightens)
      preBlurAmount: { value: 0 },
      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)
      blurAmount: { value: 0.3 },
      // Depth-of-field distance to focal plane
      focalDistance: { value: 0 },
      // Full-width angle of aperture opening (in radians)
      apertureAngle: { value: 0 },
      // Modulate Gaussian kernal falloff. 0 means "no falloff, flat shading",
      // 1 is normal e^-x^2 falloff.
      falloff: { value: 1 },
      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds
      clipXY: { value: 1.4 },
      // Debug renderSize scale factor
      renderScale: { value: 1 },
      // Enable splat texture rendering
      splatTexEnable: { value: !1 },
      // Splat texture to render
      splatTexture: { type: "t", value: QA.EMPTY_SPLAT_TEXTURE },
      // Splat texture UV transform (multiply)
      splatTexMul: { value: new n.Matrix2() },
      // Splat texture UV transform (add)
      splatTexAdd: { value: new n.Vector2() },
      // Splat texture near plane distance
      splatTexNear: { value: 0.1 },
      // Splat texture far plane distance
      splatTexFar: { value: 1e3 },
      // Splat texture mid plane distance, or 0.0 to disable
      splatTexMid: { value: 0 },
      // Gsplat collection to render
      packedSplats: { type: "t", value: KA.getEmpty() },
      // Time in seconds for time-based effects
      time: { value: 0 },
      // Delta time in seconds since last frame
      deltaTime: { value: 0 },
      // Whether to encode Gsplat with linear RGB (for environment mapping)
      encodeLinear: { value: !1 },
      // Debug flag that alternates each frame
      debugFlag: { value: !1 }
    };
  }
  canAllocAccumulator() {
    return this.freeAccumulators.length > 0 || this.accumulatorCount < ig;
  }
  maybeAllocAccumulator() {
    let A = this.freeAccumulators.pop();
    if (A === void 0) {
      if (this.accumulatorCount >= ig)
        return null;
      A = new FI(), this.accumulatorCount += 1;
    }
    return A.refCount = 1, A;
  }
  releaseAccumulator(A) {
    A.refCount -= 1, A.refCount === 0 && this.freeAccumulators.push(A);
  }
  newViewpoint(A) {
    return new CI({ ...A, spark: this });
  }
  onBeforeRender(A, I, g) {
    var r, h;
    const B = this.time ?? this.clock.getElapsedTime(), i = B - (this.viewpoint.lastTime ?? B);
    this.viewpoint.lastTime = B;
    const e = A.info.render.frame, Q = e !== this.lastFrame;
    this.lastFrame = e;
    const s = this.viewpoint;
    if (s === this.defaultView) {
      if (Q)
        if (!A.xr.isPresenting)
          this.defaultView.viewToWorld = g.matrixWorld.clone(), this.defaultCameras = [this.defaultView.viewToWorld];
        else {
          const c = A.xr.getCamera().cameras;
          this.defaultCameras = c.map((l) => l.matrixWorld), this.defaultView.viewToWorld = Co(this.defaultCameras) ?? new n.Matrix4();
        }
      this.autoUpdate && this.update({ scene: I, viewToWorld: this.defaultView.viewToWorld });
    }
    if (Q && (this.uniforms.time.value = B, this.uniforms.deltaTime.value = i, this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1), s.target)
      this.uniforms.renderSize.value.set(
        s.target.width,
        s.target.height
      );
    else {
      const c = A.getDrawingBufferSize(
        this.uniforms.renderSize.value
      );
      if (c.x === 1 && c.y === 1) {
        const l = (r = A.xr.getSession()) == null ? void 0 : r.renderState.baseLayer;
        l && (c.x = l.framebufferWidth, c.y = l.framebufferHeight);
      }
    }
    const E = g;
    if (this.uniforms.near.value = E.near, this.uniforms.far.value = E.far, this.uniforms.encodeLinear.value = s.encodeLinear, this.uniforms.maxStdDev.value = this.maxStdDev, this.uniforms.enable2DGS.value = this.enable2DGS, this.uniforms.preBlurAmount.value = this.preBlurAmount, this.uniforms.blurAmount.value = this.blurAmount, this.uniforms.focalDistance.value = this.focalDistance, this.uniforms.apertureAngle.value = this.apertureAngle, this.uniforms.falloff.value = this.falloff, this.uniforms.clipXY.value = this.clipXY, this.uniforms.renderScale.value = this.renderScale, this.splatTexture) {
      const { enable: c, texture: l, multiply: u, add: D, near: y, far: d, mid: w } = this.splatTexture;
      c && l ? (this.uniforms.splatTexEnable.value = !0, this.uniforms.splatTexture.value = l, u ? this.uniforms.splatTexMul.value.fromArray(u.elements) : this.uniforms.splatTexMul.value.set(
        0.5 / this.maxStdDev,
        0,
        0,
        0.5 / this.maxStdDev
      ), this.uniforms.splatTexAdd.value.set((D == null ? void 0 : D.x) ?? 0.5, (D == null ? void 0 : D.y) ?? 0.5), this.uniforms.splatTexNear.value = y ?? this.uniforms.near.value, this.uniforms.splatTexFar.value = d ?? this.uniforms.far.value, this.uniforms.splatTexMid.value = w ?? 0) : (this.uniforms.splatTexEnable.value = !1, this.uniforms.splatTexture.value = QA.EMPTY_SPLAT_TEXTURE);
    } else
      this.uniforms.splatTexEnable.value = !1, this.uniforms.splatTexture.value = QA.EMPTY_SPLAT_TEXTURE;
    const a = ((h = s.display) == null ? void 0 : h.accumulator.toWorld) ?? new n.Matrix4(), C = g.matrixWorld.clone().invert();
    a.clone().premultiply(C).decompose(
      this.uniforms.renderToViewPos.value,
      this.uniforms.renderToViewQuat.value,
      new n.Vector3()
    );
  }
  // Update the uniforms for the given viewpoint.
  // Note that the client expects to be able to call render() at any point
  // to update the canvas, so we must switch the viewpoint back to
  // defaultView when we're finished.
  prepareViewpoint(A) {
    if (this.viewpoint = A ?? this.viewpoint, this.viewpoint.display) {
      const { accumulator: I, geometry: g } = this.viewpoint.display;
      this.uniforms.numSplats.value = I.splats.numSplats, this.uniforms.packedSplats.value = I.splats.getTexture(), this.geometry = g;
    } else
      this.uniforms.numSplats.value = 0, this.uniforms.packedSplats.value = KA.getEmpty(), this.geometry = eg;
  }
  // If spark.autoUpdate is false then you must manually call
  // spark.update({ scene }) to have the scene Gsplats be re-generated.
  update({
    scene: A,
    viewToWorld: I
  }) {
    const g = this.matrixWorld.clone();
    this.preUpdate ? this.updateInternal({ scene: A, originToWorld: g, viewToWorld: I }) : (this.pendingUpdate = {
      scene: A,
      originToWorld: g
    }, setTimeout(() => {
      if (this.pendingUpdate) {
        const { scene: B, originToWorld: i } = this.pendingUpdate;
        this.pendingUpdate = null, this.updateInternal({ scene: B, originToWorld: i, viewToWorld: I });
      }
    }, 1));
  }
  updateInternal({
    scene: A,
    originToWorld: I,
    viewToWorld: g
  }) {
    var o;
    if (!this.canAllocAccumulator())
      return !1;
    I || (I = this.active.toWorld), g = g ?? I.clone();
    const B = this.time ?? this.clock.getElapsedTime(), i = B - (this.lastUpdateTime ?? B);
    this.lastUpdateTime = B;
    const e = this.active.mapping.reduce((r, h) => (r.set(h.node, h), r), /* @__PURE__ */ new Map()), { generators: Q, globalEdits: s } = this.compileScene(A);
    for (const r of Q)
      (o = r.frameUpdate) == null || o.call(r, {
        object: r,
        time: B,
        deltaTime: i,
        viewToWorld: g,
        globalEdits: s
      });
    for (const r of Q) {
      const h = e.get(r), c = r.generator ? r.numSplats : 0;
      (r.generator !== (h == null ? void 0 : h.generator) || c !== (h == null ? void 0 : h.count)) && r.updateVersion();
    }
    const a = !BI({
      matrix1: I,
      matrix2: this.active.toWorld,
      maxDistance: this.originDistance
    }) || Q.length !== e.size || Q.some((r) => {
      var h;
      return r.version !== ((h = e.get(r)) == null ? void 0 : h.version);
    });
    let C = null;
    if (a) {
      if (C = this.maybeAllocAccumulator(), !C)
        throw new Error("Unreachable");
      const r = !BI({
        matrix1: I,
        matrix2: this.active.toWorld,
        maxDistance: 1e-5,
        minCoorient: 0.99999
      }), c = Q.map((w, F) => {
        const m = e.get(w);
        return m ? (
          // Sort by version deltas then by previous ordering in the mapping,
          // attempting to keep unchanging generators near the front
          // to improve our chances of avoiding a re-generation.
          [w.version - m.version, m.base, w]
        ) : [Number.POSITIVE_INFINITY, w.version, w];
      }).sort((w, F) => w[0] !== F[0] ? w[0] - F[0] : w[1] - F[1]).map(([w, F, m]) => m), l = c.map((w) => w.numSplats), { maxSplats: u, mapping: D } = C.splats.generateMapping(l), y = c.map((w, F) => {
        const { base: m, count: f } = D[F];
        return {
          node: w,
          generator: w.generator,
          version: w.version,
          base: m,
          count: f
        };
      });
      I.clone().invert().decompose(
        this.translateToAccumulator.value,
        this.rotateToAccumulator.value,
        new n.Vector3()
      ), C.ensureGenerate(u), C.generateSplats({
        renderer: this.renderer,
        modifier: this.modifier,
        generators: y,
        forceUpdate: r,
        originToWorld: I
      }), C.splatsVersion = this.active.splatsVersion + 1;
      const d = C.hasCorrespondence(this.active);
      C.mappingVersion = this.active.mappingVersion + (d ? 0 : 1), this.releaseAccumulator(this.active), this.active = C, this.prepareViewpoint();
    }
    return setTimeout(() => {
      for (const r of this.autoViewpoints)
        r.autoPoll({ accumulator: C ?? void 0 });
    }, 1), !0;
  }
  compileScene(A) {
    const I = [];
    A.traverse((B) => {
      B instanceof cI && I.push(B);
    });
    const g = /* @__PURE__ */ new Set();
    return A.traverseVisible((B) => {
      if (B instanceof eI) {
        let i = B.parent;
        for (; i != null && !(i instanceof OA); )
          i = i.parent;
        i == null && g.add(B);
      }
    }), { generators: I, globalEdits: Array.from(g) };
  }
  // Renders out the scene to an environment map that can be used for
  // Image-based lighting or similar applications. First optionally updates Gsplats,
  // sorts them with respect to the provided worldCenter, renders 6 cube faces,
  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture
  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.
  async renderEnvMap({
    renderer: A,
    scene: I,
    worldCenter: g,
    size: B = 256,
    near: i = 0.1,
    far: e = 1e3,
    hideObjects: Q = [],
    update: s = !1
  }) {
    var r, h;
    if (this.envViewpoint || (this.envViewpoint = this.newViewpoint({ sort360: !0 })), !QA.cubeRender || QA.cubeRender.target.width !== B || QA.cubeRender.near !== i || QA.cubeRender.far !== e) {
      QA.cubeRender && QA.cubeRender.target.dispose();
      const c = new n.WebGLCubeRenderTarget(B, {
        format: n.RGBAFormat,
        generateMipmaps: !0,
        minFilter: n.LinearMipMapLinearFilter
      }), l = new n.CubeCamera(i, e, c);
      QA.cubeRender = { target: c, camera: l, near: i, far: e };
    }
    QA.pmrem || (QA.pmrem = new n.PMREMGenerator(A ?? this.renderer));
    const E = new n.Matrix4().setPosition(g);
    await ((r = this.envViewpoint) == null ? void 0 : r.prepare({ scene: I, viewToWorld: E, update: s }));
    const { target: a, camera: C } = QA.cubeRender;
    C.position.copy(g);
    const o = /* @__PURE__ */ new Map();
    for (const c of Q)
      o.set(c, c.visible), c.visible = !1;
    this.prepareViewpoint(this.envViewpoint), C.update(A ?? this.renderer, I), this.prepareViewpoint(this.defaultView);
    for (const [c, l] of o.entries())
      c.visible = l;
    return (h = QA.pmrem) == null ? void 0 : h.fromCubemap(a.texture).texture;
  }
  // Utility function to recursively set the envMap property for any
  // THREE.MeshStandardMaterial within the subtree of root.
  recurseSetEnvMap(A, I) {
    A.traverse((g) => {
      if (g instanceof n.Mesh)
        if (Array.isArray(g.material))
          for (const B of g.material)
            B instanceof n.MeshStandardMaterial && (B.envMap = I);
        else
          g.material instanceof n.MeshStandardMaterial && (g.material.envMap = I);
    });
  }
  // Utility function that helps extract the Gsplat RGBA values from a
  // SplatGenerator, including the result of any real-time RGBA SDF edits applied
  // to a SplatMesh. This effectively "bakes" any computed RGBA values, which can
  // now be used as a pipeline input via SplatMesh.splatRgba to inject these
  // baked values into the Gsplat data.
  getRgba({
    generator: A,
    rgba: I
  }) {
    const g = this.active.mapping.find(({ node: B }) => B === A);
    if (!g)
      throw new Error("Generator not found");
    return I = I ?? new UI(), I.fromPackedSplats({
      packedSplats: this.active.splats,
      base: g.base,
      count: g.count,
      renderer: this.renderer
    }), I;
  }
  // Utility function that builds on getRgba({ generator }) and additionally
  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA
  // in that byte order.
  async readRgba({
    generator: A,
    rgba: I
  }) {
    return I = this.getRgba({ generator: A, rgba: I }), I.read();
  }
};
QA.cubeRender = null, QA.pmrem = null, QA.EMPTY_SPLAT_TEXTURE = new n.Data3DTexture();
let EI = QA;
const eg = new YI(new Uint32Array(1), 0);
MA(
  { packedSplats: qt, index: "int" },
  { gsplat: _ },
  ({ packedSplats: t, index: A }) => {
    if (!t || !A)
      throw new Error("Invalid input");
    return { gsplat: Jt(t, A) };
  }
);
function Co(t) {
  if (t.length === 0)
    return null;
  const A = new n.Vector3(), I = new n.Quaternion(), g = new n.Vector3(), B = [], i = [];
  for (const e of t)
    e.decompose(A, I, g), B.push(A), i.push(I);
  return new n.Matrix4().compose(
    FB(B),
    GB(i),
    new n.Vector3(1, 1, 1)
  );
}
function Eo(t, A, I) {
  const g = Math.floor(t.length / 32);
  if (g * 32 !== t.length)
    throw new Error("Invalid .splat file size");
  const B = new Float32Array(t.buffer);
  for (let i = 0; i < g; ++i) {
    const e = i * 32, Q = i * 8, s = B[Q + 0], E = B[Q + 1], a = B[Q + 2], C = B[Q + 3], o = B[Q + 4], r = B[Q + 5], h = t[e + 24] / 255, c = t[e + 25] / 255, l = t[e + 26] / 255, u = t[e + 27] / 255, D = (t[e + 28] - 128) / 128, y = (t[e + 29] - 128) / 128, d = (t[e + 30] - 128) / 128, w = (t[e + 31] - 128) / 128;
    I(
      i,
      s,
      E,
      a,
      C,
      o,
      r,
      y,
      d,
      w,
      D,
      u,
      h,
      c,
      l
    );
  }
}
const Qg = {
  0: {
    bytesPerCenter: 12,
    bytesPerScale: 12,
    bytesPerRotation: 16,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 4,
    scaleOffsetBytes: 12,
    rotationOffsetBytes: 24,
    colorOffsetBytes: 40,
    sphericalHarmonicsOffsetBytes: 44,
    scaleRange: 1
  },
  1: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 2,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  },
  2: {
    bytesPerCenter: 6,
    bytesPerScale: 6,
    bytesPerRotation: 8,
    bytesPerColor: 4,
    bytesPerSphericalHarmonicsComponent: 1,
    scaleOffsetBytes: 6,
    rotationOffsetBytes: 12,
    colorOffsetBytes: 20,
    sphericalHarmonicsOffsetBytes: 24,
    scaleRange: 32767
  }
}, ao = {
  0: 0,
  1: 9,
  2: 24,
  3: 45
};
function no(t, A, I, g) {
  var c;
  let e = 0;
  const Q = new DataView(t.buffer, e, 4096);
  e += 4096;
  const s = Q.getUint8(0), E = Q.getUint8(1);
  if (s !== 0 || E < 1)
    throw new Error(
      `Unsupported .ksplat version: ${s}.${E}`
    );
  const a = Q.getUint32(4, !0);
  Q.getUint32(16, !0);
  const C = Q.getUint16(20, !0);
  if (C < 0 || C > 2)
    throw new Error(`Invalid .ksplat compression level: ${C}`);
  const o = Q.getFloat32(36, !0) || -1.5, r = Q.getFloat32(40, !0) || 1.5;
  let h = 4096 + a * 1024;
  for (let l = 0; l < a; ++l) {
    let u = function(SA, T) {
      if (C === 0)
        return H.getFloat32(
          SA + O + T * 4,
          !0
        );
      if (C === 1)
        return dA(
          H.getUint16(
            SA + O + T * 2,
            !0
          )
        );
      const ZA = H.getUint8(SA + O + T) / 255;
      return o + ZA * (r - o);
    };
    const D = new DataView(t.buffer, e, 1024);
    e += 1024;
    const y = D.getUint32(0, !0), d = D.getUint32(4, !0), w = D.getUint32(8, !0), F = D.getUint32(12, !0), m = D.getFloat32(16, !0), f = D.getUint16(20, !0), p = (D.getUint32(24, !0) || ((c = Qg[C]) == null ? void 0 : c.scaleRange)) ?? 1, R = D.getUint32(32, !0), S = R * w, G = D.getUint32(36, !0), Y = G * 4, M = f * F + Y, k = D.getUint16(40, !0), U = ao[k], {
      bytesPerCenter: J,
      bytesPerScale: AA,
      bytesPerRotation: Z,
      bytesPerColor: gA,
      bytesPerSphericalHarmonicsComponent: tA,
      scaleOffsetBytes: V,
      rotationOffsetBytes: b,
      colorOffsetBytes: P,
      sphericalHarmonicsOffsetBytes: O
    } = Qg[C], X = J + AA + Z + gA + U * tA, L = X * d, DA = L + M, CA = [0, 3, 6, 1, 4, 7, 2, 5, 8], yA = [
      9,
      14,
      19,
      10,
      15,
      20,
      11,
      16,
      21,
      12,
      17,
      22,
      13,
      18,
      23
    ], wA = [
      24,
      31,
      38,
      25,
      32,
      39,
      26,
      33,
      40,
      27,
      34,
      41,
      28,
      35,
      42,
      29,
      36,
      43,
      30,
      37,
      44
    ], FA = k >= 1 ? new Float32Array(3 * 3) : void 0, rA = k >= 2 ? new Float32Array(5 * 3) : void 0, YA = k >= 3 ? new Float32Array(7 * 3) : void 0, GA = m / 2 / p, VA = h + Y, PA = h + M, H = new DataView(
      t.buffer,
      PA,
      L
    ), uA = new Float32Array(
      t.buffer,
      VA,
      F * 3
    ), vA = new Uint32Array(
      t.buffer,
      h,
      G
    );
    let mt = R, Wt = S;
    for (let SA = 0; SA < y; ++SA) {
      const T = SA * X;
      let ZA;
      if (SA < S)
        ZA = Math.floor(SA / w);
      else {
        const XA = vA[mt - R];
        SA >= Wt + XA && (mt += 1, Wt += XA), ZA = mt;
      }
      const hI = C === 0 ? H.getFloat32(T + 0, !0) : (H.getUint16(T + 0, !0) - p) * GA + uA[3 * ZA + 0], lI = C === 0 ? H.getFloat32(T + 4, !0) : (H.getUint16(T + 2, !0) - p) * GA + uA[3 * ZA + 1], uI = C === 0 ? H.getFloat32(T + 8, !0) : (H.getUint16(T + 4, !0) - p) * GA + uA[3 * ZA + 2], DI = C === 0 ? H.getFloat32(T + V + 0, !0) : dA(H.getUint16(T + V + 0, !0)), yI = C === 0 ? H.getFloat32(T + V + 4, !0) : dA(H.getUint16(T + V + 2, !0)), vQ = C === 0 ? H.getFloat32(T + V + 8, !0) : dA(H.getUint16(T + V + 4, !0)), ZQ = C === 0 ? H.getFloat32(T + b + 0, !0) : dA(
        H.getUint16(T + b + 0, !0)
      ), zQ = C === 0 ? H.getFloat32(T + b + 4, !0) : dA(
        H.getUint16(T + b + 2, !0)
      ), WQ = C === 0 ? H.getFloat32(T + b + 8, !0) : dA(
        H.getUint16(T + b + 4, !0)
      ), OQ = C === 0 ? H.getFloat32(T + b + 12, !0) : dA(
        H.getUint16(T + b + 6, !0)
      ), VQ = H.getUint8(T + P + 0) / 255, PQ = H.getUint8(T + P + 1) / 255, XQ = H.getUint8(T + P + 2) / 255, jQ = H.getUint8(T + P + 3) / 255;
      if (I(
        SA,
        hI,
        lI,
        uI,
        DI,
        yI,
        vQ,
        zQ,
        WQ,
        OQ,
        ZQ,
        jQ,
        VQ,
        PQ,
        XQ
      ), k >= 1 && FA) {
        for (const [XA, Mt] of CA.entries())
          FA[XA] = u(T, Mt);
        if (rA)
          for (const [XA, Mt] of yA.entries())
            rA[XA] = u(T, Mt);
        if (YA)
          for (const [XA, Mt] of wA.entries())
            YA[XA] = u(T, Mt);
        g == null || g(SA, FA, rA, YA);
      }
    }
    h += DA;
  }
}
class oo {
  constructor({ fileBytes: A }) {
    this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A, this.reader = new kB({ fileBytes: this.fileBytes });
    const I = new DataView(this.reader.read(16).buffer);
    if (I.getUint32(0, !0) !== 1347635022)
      throw new Error("Invalid SPZ file");
    if (this.version = I.getUint32(4, !0), this.version < 1 || this.version > 2)
      throw new Error(`Unsupported SPZ version: ${this.version}`);
    this.numSplats = I.getUint32(8, !0), this.shDegree = I.getUint8(12), this.fractionalBits = I.getUint8(13), this.flags = I.getUint8(14), this.flagAntiAlias = (this.flags & 1) !== 0, this.reserved = I.getUint8(15), this.parsed = !1;
  }
  parseSplats(A, I, g, B, i, e) {
    if (this.parsed)
      throw new Error("SPZ file already parsed");
    if (this.parsed = !0, this.version === 1) {
      const Q = this.reader.read(this.numSplats * 3 * 2), s = new Uint16Array(Q.buffer);
      for (let E = 0; E < this.numSplats; E++) {
        const a = E * 3, C = dA(s[a]), o = dA(s[a + 1]), r = dA(s[a + 2]);
        A == null || A(E, C, o, r);
      }
    } else if (this.version === 2) {
      const Q = 1 << this.fractionalBits, s = this.reader.read(this.numSplats * 3 * 3);
      for (let E = 0; E < this.numSplats; E++) {
        const a = E * 9, C = ((s[a + 2] << 24 | s[a + 1] << 16 | s[a] << 8) >> 8) / Q, o = ((s[a + 5] << 24 | s[a + 4] << 16 | s[a + 3] << 8) >> 8) / Q, r = ((s[a + 8] << 24 | s[a + 7] << 16 | s[a + 6] << 8) >> 8) / Q;
        A == null || A(E, C, o, r);
      }
    } else
      throw new Error("Unreachable");
    {
      const Q = this.reader.read(this.numSplats);
      for (let s = 0; s < this.numSplats; s++)
        I == null || I(s, Q[s] / 255);
    }
    {
      const Q = this.reader.read(this.numSplats * 3), s = LQ / 0.15;
      for (let E = 0; E < this.numSplats; E++) {
        const a = E * 3, C = (Q[a] / 255 - 0.5) * s + 0.5, o = (Q[a + 1] / 255 - 0.5) * s + 0.5, r = (Q[a + 2] / 255 - 0.5) * s + 0.5;
        g == null || g(E, C, o, r);
      }
    }
    {
      const Q = this.reader.read(this.numSplats * 3);
      for (let s = 0; s < this.numSplats; s++) {
        const E = s * 3, a = Math.exp(Q[E] / 16 - 10), C = Math.exp(Q[E + 1] / 16 - 10), o = Math.exp(Q[E + 2] / 16 - 10);
        B == null || B(s, a, C, o);
      }
    }
    {
      const Q = this.reader.read(this.numSplats * 3);
      for (let s = 0; s < this.numSplats; s++) {
        const E = s * 3, a = Q[E] / 127.5 - 1, C = Q[E + 1] / 127.5 - 1, o = Q[E + 2] / 127.5 - 1, r = Math.sqrt(
          Math.max(0, 1 - a * a - C * C - o * o)
        );
        i == null || i(s, a, C, o, r);
      }
    }
    if (e && this.shDegree >= 1) {
      const Q = new Float32Array(9), s = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0, E = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0, a = this.reader.read(
        this.numSplats * YQ[this.shDegree] * 3
      );
      let C = 0;
      for (let o = 0; o < this.numSplats; o++) {
        for (let r = 0; r < 9; ++r)
          Q[r] = (a[C + r] - 128) / 128;
        if (C += 9, s) {
          for (let r = 0; r < 15; ++r)
            s[r] = (a[C + r] - 128) / 128;
          C += 15;
        }
        if (E) {
          for (let r = 0; r < 21; ++r)
            E[r] = (a[C + r] - 128) / 128;
          C += 21;
        }
        e == null || e(o, Q, s, E);
      }
    }
  }
}
const YQ = { 1: 3, 2: 8, 3: 15 }, LQ = 0.28209479177387814, ro = 1347635022, co = 2, ho = 1;
class $A {
  constructor({
    numSplats: A,
    shDegree: I,
    fractionalBits: g = 12,
    flagAntiAlias: B = !0
  }) {
    this.clippedCount = 0;
    const i = 19 + (I >= 1 ? 9 : 0) + (I >= 2 ? 15 : 0) + (I >= 3 ? 21 : 0), e = 16 + A * i;
    this.buffer = new ArrayBuffer(e), this.view = new DataView(this.buffer), this.view.setUint32(0, ro, !0), this.view.setUint32(4, co, !0), this.view.setUint32(8, A, !0), this.view.setUint8(12, I), this.view.setUint8(13, g), this.view.setUint8(14, B ? ho : 0), this.view.setUint8(15, 0), this.numSplats = A, this.shDegree = I, this.fractionalBits = g, this.fraction = 1 << g, this.flagAntiAlias = B;
  }
  setCenter(A, I, g, B) {
    const i = Math.round(I * this.fraction), e = Math.max(-8388607, Math.min(8388607, i)), Q = Math.round(g * this.fraction), s = Math.max(-8388607, Math.min(8388607, Q)), E = Math.round(B * this.fraction), a = Math.max(-8388607, Math.min(8388607, E));
    (i !== e || Q !== s || E !== a) && (this.clippedCount += 1);
    const r = 16 + A * 9;
    this.view.setUint8(r, e & 255), this.view.setUint8(r + 1, e >> 8 & 255), this.view.setUint8(r + 2, e >> 16 & 255), this.view.setUint8(r + 3, s & 255), this.view.setUint8(r + 4, s >> 8 & 255), this.view.setUint8(r + 5, s >> 16 & 255), this.view.setUint8(r + 6, a & 255), this.view.setUint8(r + 7, a >> 8 & 255), this.view.setUint8(r + 8, a >> 16 & 255);
  }
  setAlpha(A, I) {
    const g = 16 + this.numSplats * 9 + A;
    this.view.setUint8(
      g,
      Math.max(0, Math.min(255, Math.round(I * 255)))
    );
  }
  static scaleRgb(A) {
    const I = ((A - 0.5) / (LQ / 0.15) + 0.5) * 255;
    return Math.max(0, Math.min(255, Math.round(I)));
  }
  setRgb(A, I, g, B) {
    const i = 16 + this.numSplats * 10 + A * 3;
    this.view.setUint8(i, $A.scaleRgb(I)), this.view.setUint8(i + 1, $A.scaleRgb(g)), this.view.setUint8(i + 2, $A.scaleRgb(B));
  }
  setScale(A, I, g, B) {
    const i = 16 + this.numSplats * 13 + A * 3;
    this.view.setUint8(
      i,
      Math.max(0, Math.min(255, Math.round((Math.log(I) + 10) * 16)))
    ), this.view.setUint8(
      i + 1,
      Math.max(0, Math.min(255, Math.round((Math.log(g) + 10) * 16)))
    ), this.view.setUint8(
      i + 2,
      Math.max(0, Math.min(255, Math.round((Math.log(B) + 10) * 16)))
    );
  }
  setQuat(A, I, g, B, i) {
    const e = 16 + this.numSplats * 16 + A * 3, Q = i < 0;
    this.view.setUint8(
      e,
      Math.max(
        0,
        Math.min(255, Math.round(((Q ? -I : I) + 1) * 127.5))
      )
    ), this.view.setUint8(
      e + 1,
      Math.max(
        0,
        Math.min(255, Math.round(((Q ? -g : g) + 1) * 127.5))
      )
    ), this.view.setUint8(
      e + 2,
      Math.max(
        0,
        Math.min(255, Math.round(((Q ? -B : B) + 1) * 127.5))
      )
    );
  }
  static quantizeSh(A, I) {
    const g = Math.round(A * 128) + 128, B = 1 << 8 - I, i = Math.floor((g + B / 2) / B) * B;
    return Math.max(0, Math.min(255, i));
  }
  setSh(A, I, g, B) {
    const i = YQ[this.shDegree] || 0, e = 16 + this.numSplats * 19 + A * i * 3;
    for (let Q = 0; Q < 9; ++Q)
      this.view.setUint8(e + Q, $A.quantizeSh(I[Q], 5));
    if (g) {
      const Q = e + 9;
      for (let s = 0; s < 15; ++s)
        this.view.setUint8(Q + s, $A.quantizeSh(g[s], 4));
      if (B) {
        const s = Q + 15;
        for (let E = 0; E < 21; ++E)
          this.view.setUint8(s + E, $A.quantizeSh(B[E], 4));
      }
    }
  }
  async finalize() {
    const A = new Uint8Array(this.buffer), g = new ReadableStream({
      async start(e) {
        e.enqueue(A), e.close();
      }
    }).pipeThrough(new CompressionStream("gzip")), i = await new Response(g).arrayBuffer();
    return console.log(
      "Compressed",
      A.length,
      "bytes to",
      i.byteLength,
      "bytes"
    ), new Uint8Array(i);
  }
}
async function Ar(t) {
  var a, C, o;
  const A = new _n(), {
    inputs: I,
    clipXyz: g,
    maxSh: B,
    fractionalBits: i = 12,
    opacityThreshold: e
  } = t;
  for (const r of I) {
    let h = function(f) {
      return f.multiplyScalar(y), f.applyQuaternion(d), f.add(w), f;
    }, c = function(f) {
      return f.multiplyScalar(y), f;
    }, l = function(f) {
      return f.premultiply(d), f;
    }, u = function(f) {
      return !F || F.containsPoint(f);
    }, D = function(f) {
      return e !== void 0 ? f >= e : !0;
    };
    const y = ((a = r.transform) == null ? void 0 : a.scale) ?? 1, d = new n.Quaternion().fromArray(
      ((C = r.transform) == null ? void 0 : C.quaternion) ?? [0, 0, 0, 1]
    ), w = new n.Vector3().fromArray(
      ((o = r.transform) == null ? void 0 : o.translate) ?? [0, 0, 0]
    ), F = g ? new n.Box3(
      new n.Vector3().fromArray(g.min),
      new n.Vector3().fromArray(g.max)
    ) : void 0;
    let m = r.fileType;
    switch (m || (m = mQ(r.fileBytes), !m && r.pathOrUrl && (m = MQ(r.pathOrUrl))), m) {
      case Rt.PLY: {
        const f = new QI({ fileBytes: r.fileBytes });
        await f.parseHeader();
        let p = null;
        f.parseSplats(
          (R, S, G, Y, M, k, U, J, AA, Z, gA, tA, V, b, P) => {
            const O = h(new n.Vector3(S, G, Y));
            if (u(O) && D(tA)) {
              p = A.pushSplat(), A.setCenter(p, O.x, O.y, O.z);
              const X = c(
                new n.Vector3(M, k, U)
              );
              A.setScale(p, X.x, X.y, X.z);
              const L = l(
                new n.Quaternion(J, AA, Z, gA)
              );
              A.setQuaternion(
                p,
                L.x,
                L.y,
                L.z,
                L.w
              ), A.setOpacity(p, tA), A.setColor(p, V, b, P);
            } else
              p = null;
          },
          (R, S, G, Y) => {
            S && p !== null && A.setSh1(p, S), G && p !== null && A.setSh2(p, G), Y && p !== null && A.setSh3(p, Y);
          }
        );
        break;
      }
      case Rt.SPZ: {
        const f = new oo({ fileBytes: r.fileBytes }), p = new Int32Array(f.numSplats);
        p.fill(-1);
        const R = new Float32Array(f.numSplats * 3), S = new n.Vector3();
        f.parseSplats(
          (G, Y, M, k) => {
            const U = h(new n.Vector3(Y, M, k));
            R[G * 3] = U.x, R[G * 3 + 1] = U.y, R[G * 3 + 2] = U.z;
          },
          (G, Y) => {
            S.fromArray(R, G * 3), u(S) && D(Y) && (p[G] = A.pushSplat(), A.setCenter(p[G], S.x, S.y, S.z), A.setOpacity(p[G], Y));
          },
          (G, Y, M, k) => {
            p[G] >= 0 && A.setColor(p[G], Y, M, k);
          },
          (G, Y, M, k) => {
            if (p[G] >= 0) {
              const U = c(
                new n.Vector3(Y, M, k)
              );
              A.setScale(p[G], U.x, U.y, U.z);
            }
          },
          (G, Y, M, k, U) => {
            if (p[G] >= 0) {
              const J = l(
                new n.Quaternion(Y, M, k, U)
              );
              A.setQuaternion(
                p[G],
                J.x,
                J.y,
                J.z,
                J.w
              );
            }
          },
          (G, Y, M, k) => {
            p[G] >= 0 && (A.setSh1(p[G], Y), M && A.setSh2(p[G], M), k && A.setSh3(p[G], k));
          }
        );
        break;
      }
      case Rt.SPLAT:
        Eo(
          r.fileBytes,
          (f) => {
          },
          (f, p, R, S, G, Y, M, k, U, J, AA, Z, gA, tA, V) => {
            const b = h(new n.Vector3(p, R, S));
            if (u(b) && D(Z)) {
              const P = A.pushSplat();
              A.setCenter(P, b.x, b.y, b.z);
              const O = c(
                new n.Vector3(G, Y, M)
              );
              A.setScale(P, O.x, O.y, O.z);
              const X = l(
                new n.Quaternion(k, U, J, AA)
              );
              A.setQuaternion(
                P,
                X.x,
                X.y,
                X.z,
                X.w
              ), A.setOpacity(P, Z), A.setColor(P, gA, tA, V);
            }
          }
        );
        break;
      case Rt.KSPLAT: {
        let f = null;
        no(
          r.fileBytes,
          (p) => {
          },
          (p, R, S, G, Y, M, k, U, J, AA, Z, gA, tA, V, b) => {
            const P = h(new n.Vector3(R, S, G));
            if (u(P) && D(gA)) {
              f = A.pushSplat(), A.setCenter(f, P.x, P.y, P.z);
              const O = c(
                new n.Vector3(Y, M, k)
              );
              A.setScale(f, O.x, O.y, O.z);
              const X = l(
                new n.Quaternion(U, J, AA, Z)
              );
              A.setQuaternion(
                f,
                X.x,
                X.y,
                X.z,
                X.w
              ), A.setOpacity(f, gA), A.setColor(f, tA, V, b);
            } else
              f = null;
          },
          (p, R, S, G) => {
            f !== null && (A.setSh1(f, R), S && A.setSh2(f, S), G && A.setSh3(f, G));
          }
        );
        break;
      }
      default:
        throw new Error(`transcodeSpz not implemented for ${m}`);
    }
  }
  const Q = Math.min(
    B ?? 3,
    A.sh3 ? 3 : A.sh2 ? 2 : A.sh1 ? 1 : 0
  ), s = new $A({
    numSplats: A.numSplats,
    shDegree: Q,
    fractionalBits: i,
    flagAntiAlias: !0
  });
  for (let r = 0; r < A.numSplats; ++r) {
    const h = r * 3, c = r * 4;
    s.setCenter(
      r,
      A.centers[h],
      A.centers[h + 1],
      A.centers[h + 2]
    ), s.setScale(
      r,
      A.scales[h],
      A.scales[h + 1],
      A.scales[h + 2]
    ), s.setQuat(
      r,
      A.quaternions[c],
      A.quaternions[c + 1],
      A.quaternions[c + 2],
      A.quaternions[c + 3]
    ), s.setAlpha(r, A.opacities[r]), s.setRgb(
      r,
      A.colors[h],
      A.colors[h + 1],
      A.colors[h + 2]
    ), A.sh1 && Q >= 1 && s.setSh(
      r,
      A.sh1.slice(r * 9, (r + 1) * 9),
      Q >= 2 && A.sh2 ? A.sh2.slice(r * 15, (r + 1) * 15) : void 0,
      Q >= 3 && A.sh3 ? A.sh3.slice(r * 21, (r + 1) * 21) : void 0
    );
  }
  return { fileBytes: await s.finalize(), clippedCount: s.clippedCount };
}
class tr {
  constructor(A) {
    this.mesh = A.mesh, this.numSplats = A.numSplats ?? this.mesh.numSplats;
    const { width: I, height: g, depth: B, maxSplats: i } = fA(this.numSplats);
    this.skinData = new Uint16Array(i * 4), this.skinTexture = new n.DataArrayTexture(
      this.skinData,
      I,
      g,
      B
    ), this.skinTexture.format = n.RGBAIntegerFormat, this.skinTexture.type = n.UnsignedShortType, this.skinTexture.internalFormat = "RGBA16UI", this.skinTexture.needsUpdate = !0, this.numBones = A.numBones ?? 256, this.boneData = new Float32Array(this.numBones * 16), this.boneTexture = new n.DataTexture(
      this.boneData,
      4,
      this.numBones,
      n.RGBAFormat,
      n.FloatType
    ), this.boneTexture.internalFormat = "RGBA32F", this.boneTexture.needsUpdate = !0, this.uniform = new x({
      key: "skinning",
      type: JQ,
      globals: () => [HQ],
      value: {
        numSplats: this.numSplats,
        numBones: this.numBones,
        skinTexture: this.skinTexture,
        boneTexture: this.boneTexture
      }
    });
  }
  // Apply the skeletal animation to a Gsplat in a dyno program.
  modify(A) {
    return uo(A, this.uniform);
  }
  // Set the "rest" pose for a bone with position and quaternion orientation.
  setRestQuatPos(A, I, g) {
    const B = A * 16;
    this.boneData[B + 0] = I.x, this.boneData[B + 1] = I.y, this.boneData[B + 2] = I.z, this.boneData[B + 3] = I.w, this.boneData[B + 4] = g.x, this.boneData[B + 5] = g.y, this.boneData[B + 6] = g.z, this.boneData[B + 7] = 0, this.boneData[B + 8] = 0, this.boneData[B + 9] = 0, this.boneData[B + 10] = 0, this.boneData[B + 11] = 1, this.boneData[B + 12] = 0, this.boneData[B + 13] = 0, this.boneData[B + 14] = 0, this.boneData[B + 15] = 0;
  }
  // Set the "current" position and orientation of a bone.
  setBoneQuatPos(A, I, g) {
    const B = A * 16, i = new n.Quaternion(
      this.boneData[B + 0],
      this.boneData[B + 1],
      this.boneData[B + 2],
      this.boneData[B + 3]
    ), e = new n.Vector3(
      this.boneData[B + 4],
      this.boneData[B + 5],
      this.boneData[B + 6]
    ), Q = i.clone().invert(), s = g.clone().sub(e);
    s.applyQuaternion(Q), Q.multiply(I);
    const E = new n.Quaternion(
      s.x,
      s.y,
      s.z,
      0
    ).multiply(i);
    this.boneData[B + 8] = Q.x, this.boneData[B + 9] = Q.y, this.boneData[B + 10] = Q.z, this.boneData[B + 11] = Q.w, this.boneData[B + 12] = 0.5 * E.x, this.boneData[B + 13] = 0.5 * E.y, this.boneData[B + 14] = 0.5 * E.z, this.boneData[B + 15] = 0.5 * E.w;
  }
  // Set up to 4 bone indices and weights for a Gsplat. For fewer than 4 bones,
  // you can set the remaining weights to 0 (and index=0).
  setSplatBones(A, I, g) {
    const B = A * 4;
    this.skinData[B + 0] = Math.min(255, Math.max(0, Math.round(g.x * 255))) + (I.x << 8), this.skinData[B + 1] = Math.min(255, Math.max(0, Math.round(g.y * 255))) + (I.y << 8), this.skinData[B + 2] = Math.min(255, Math.max(0, Math.round(g.z * 255))) + (I.z << 8), this.skinData[B + 3] = Math.min(255, Math.max(0, Math.round(g.w * 255))) + (I.w << 8);
  }
  // Call this to indicate that the bones have changed and the Gsplats need to be
  // re-generated with updated skinning.
  updateBones() {
    this.boneTexture.needsUpdate = !0, this.mesh.needsUpdate = !0;
  }
}
const JQ = { type: "GsplatSkinning" }, HQ = oA(`
  struct GsplatSkinning {
    int numSplats;
    int numBones;
    usampler2DArray skinTexture;
    sampler2D boneTexture;
  };
`), lo = oA(`
  void applyGsplatSkinning(
    int numSplats, int numBones,
    usampler2DArray skinTexture, sampler2D boneTexture,
    int splatIndex, inout vec3 center, inout vec4 quaternion
  ) {
    if ((splatIndex < 0) || (splatIndex >= numSplats)) {
      return;
    }

    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);

    float weights[4];
    weights[0] = float(skinData.x & 0xffu) / 255.0;
    weights[1] = float(skinData.y & 0xffu) / 255.0;
    weights[2] = float(skinData.z & 0xffu) / 255.0;
    weights[3] = float(skinData.w & 0xffu) / 255.0;

    uint boneIndices[4];
    boneIndices[0] = (skinData.x >> 8u) & 0xffu;
    boneIndices[1] = (skinData.y >> 8u) & 0xffu;
    boneIndices[2] = (skinData.z >> 8u) & 0xffu;
    boneIndices[3] = (skinData.w >> 8u) & 0xffu;

    vec4 quat = vec4(0.0);
    vec4 dual = vec4(0.0);
    for (int i = 0; i < 4; i++) {
      if (weights[i] > 0.0) {
        int boneIndex = int(boneIndices[i]);
        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);
        vec4 boneDual = vec4(0.0);
        if (boneIndex < numBones) {
          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);
          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);
        }

        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {
          // Flip sign if next blend is pointing in the opposite direction
          boneQuat = -boneQuat;
          boneDual = -boneDual;
        }
        quat += weights[i] * boneQuat;
        dual += weights[i] * boneDual;
      }
    }

    // Normalize dual quaternion
    float norm = length(quat);
    quat /= norm;
    dual /= norm;
    vec3 translate = vec3(
      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),
      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),
      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)
    );

    center = quatVec(quat, center) + translate;
    quaternion = quatQuat(quat, quaternion);
  }
`);
function uo(t, A) {
  return new W({
    inTypes: { gsplat: _, skinning: JQ },
    outTypes: { gsplat: _ },
    globals: () => [HQ, lo],
    inputs: { gsplat: t, skinning: A },
    statements: ({ inputs: g, outputs: B }) => {
      const { skinning: i } = g, { gsplat: e } = B;
      return UA(`
        ${e} = ${g.gsplat};
        if (isGsplatActive(${e}.flags)) {
          applyGsplatSkinning(
            ${i}.numSplats, ${i}.numBones,
            ${i}.skinTexture, ${i}.boneTexture,
            ${e}.index, ${e}.center, ${e}.quaternion
          );
        }
      `);
    }
  }).outputs.gsplat;
}
function Ir({
  // PackedSplats object to add splats to
  splats: t,
  // min and max box extents of the grid
  extents: A,
  // step size along each grid axis
  stepSize: I = 1,
  // spherical radius of each Gsplat
  pointRadius: g = 0.01,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  pointShadowScale: B = 2,
  // Gsplat opacity
  opacity: i = 1,
  // Gsplat color (THREE.Color) or function to set color for position:
  // ((THREE.Color, THREE.Vector3) => void) (default: RGB-modulated grid)
  color: e
}) {
  const s = new n.Vector3(), E = new n.Vector3(), a = new n.Quaternion(0, 0, 0, 1);
  e == null && (e = (o, r) => o.set(
    0.55 + 0.45 * Math.cos(r.x * 1),
    0.55 + 0.45 * Math.cos(r.y * 1),
    0.55 + 0.45 * Math.cos(r.z * 1)
  ));
  const C = new n.Color();
  for (let o = A.min.z; o < A.max.z + 1e-6; o += I)
    for (let r = A.min.y; r < A.max.y + 1e-6; r += I)
      for (let h = A.min.x; h < A.max.x + 1e-6; h += I) {
        s.set(h, r, o);
        for (let c = 0; c < 2; ++c)
          E.setScalar(g * (c ? 1 : B)), c ? typeof e == "function" ? e(C, s) : C.copy(e) : C.setScalar(0), t.pushSplat(s, E, a, i, C);
      }
}
function gr({
  // PackedSplats object to add splats to
  splats: t,
  // scale (Gsplat scale along axis)
  scale: A = 0.25,
  // radius of the axes (Gsplat scale orthogonal to axis)
  axisRadius: I = 75e-4,
  // relative size of the "shadow copy" of each Gsplat placed behind it
  axisShadowScale: g = 2,
  // origins of the axes (default single axis at origin)
  origins: B = [new n.Vector3()]
}) {
  const i = new n.Vector3(), e = new n.Vector3(), Q = new n.Quaternion(0, 0, 0, 1), s = new n.Color(), E = 1;
  for (const a of B)
    for (let C = 0; C < 3; ++C) {
      i.set(
        a.x + (C === 0 ? A : 0),
        a.y + (C === 1 ? A : 0),
        a.z + (C === 2 ? A : 0)
      );
      for (let o = 0; o < 2; ++o)
        e.set(
          (C === 0 ? A : I) * (o ? 1 : g),
          (C === 1 ? A : I) * (o ? 1 : g),
          (C === 2 ? A : I) * (o ? 1 : g)
        ), s.setRGB(
          o === 0 ? 0 : C === 0 ? 1 : 0,
          o === 0 ? 0 : C === 1 ? 1 : 0,
          o === 0 ? 0 : C === 2 ? 1 : 0
        ), t.pushSplat(i, e, Q, E, s);
    }
}
function Br({
  // PackedSplats object to add splats to
  splats: t,
  // center of the sphere (default: origin)
  origin: A = new n.Vector3(),
  // radius of the sphere
  radius: I = 1,
  // maximum depth of recursion for subdividing the sphere
  // Warning: Gsplat count grows exponentially with depth
  maxDepth: g = 3,
  // filter function to apply to each point, for example to select
  // points in a certain direction or other function ((THREE.Vector3) => boolean)
  // (default: null)
  filter: B = null,
  // radius of each oriented Gsplat
  pointRadius: i = 0.02,
  // flatness of each oriented Gsplat
  pointThickness: e = 1e-3,
  // color of each Gsplat (THREE.Color) or function to set color for point:
  // ((THREE.Color, THREE.Vector3) => void) (default: white)
  color: Q = new n.Color(1, 1, 1)
}) {
  const s = {};
  function E(c) {
    if (B && !B(c))
      return;
    const l = `${c.x},${c.y},${c.z}`;
    s[l] || (s[l] = c);
  }
  function a(c, l, u, D) {
    if (E(l), E(u), E(D), c >= g)
      return;
    const y = new n.Vector3().addVectors(l, u).normalize(), d = new n.Vector3().addVectors(u, D).normalize(), w = new n.Vector3().addVectors(D, l).normalize();
    a(c + 1, l, y, w), a(c + 1, y, u, d), a(c + 1, w, d, D), a(c + 1, y, d, w);
  }
  for (const c of [-1, 1])
    for (const l of [-1, 1])
      for (const u of [-1, 1]) {
        const D = new n.Vector3(c, 0, 0), y = new n.Vector3(0, l, 0), d = new n.Vector3(0, 0, u);
        a(0, D, y, d);
      }
  const C = Object.values(s), o = new n.Vector3(i, i, e), r = new n.Quaternion(), h = typeof Q == "function" ? new n.Color() : Q;
  for (const c of C)
    r.setFromUnitVectors(new n.Vector3(0, 0, -1), c), typeof Q == "function" && Q(h, c), c.multiplyScalar(I), c.add(A), t.pushSplat(c, o, r, 1, h);
}
function ir({
  // text string to display
  text: t,
  // browser font to render text with (default: "Arial")
  font: A,
  // font size in pixels/Gsplats (default: 32)
  fontSize: I,
  // SplatMesh.recolor tint assuming white Gsplats (default: white)
  color: g,
  // Individual Gsplat color (default: white)
  rgb: B,
  // Gsplat radius (default: 0.8 covers 1-unit spacing well)
  dotRadius: i,
  // text alignment: "left", "center", "right", "start", "end" (default: "start")
  textAlign: e,
  // line spacing multiplier, lines delimited by "\n" (default: 1.0)
  lineHeight: Q,
  // Coordinate scale in object-space (default: 1.0)
  objectScale: s
}) {
  A = A ?? "Arial", I = I ?? 32, g = g ?? new n.Color(1, 1, 1), i = i ?? 0.8, e = e ?? "start", Q = Q ?? 1, s = s ?? 1;
  const E = t.split(`
`), a = document.createElement("canvas"), C = a.getContext("2d");
  if (!C)
    throw new Error("Failed to create canvas context");
  C.font = `${I}px ${A}`, C.textAlign = e;
  const o = C.measureText(""), r = o.fontBoundingBoxAscent + o.fontBoundingBoxDescent;
  let h = Number.POSITIVE_INFINITY, c = Number.NEGATIVE_INFINITY, l = Number.POSITIVE_INFINITY, u = Number.NEGATIVE_INFINITY;
  for (let M = 0; M < E.length; ++M) {
    const k = C.measureText(E[M]), U = r * Q * M;
    h = Math.min(h, -k.actualBoundingBoxLeft), c = Math.max(c, k.actualBoundingBoxRight), l = Math.min(l, U - k.actualBoundingBoxAscent), u = Math.max(u, U + k.actualBoundingBoxDescent);
  }
  const D = Math.floor(h), y = Math.floor(l), d = Math.ceil(c) - D, w = Math.ceil(u) - y;
  a.width = d, a.height = w, C.font = `${I}px ${A}`, C.textAlign = e, C.textBaseline = "alphabetic", C.fillStyle = "#FFFFFF";
  for (let M = 0; M < E.length; ++M) {
    const k = r * Q * M - y;
    C.fillText(E[M], -D, k);
  }
  const F = C.getImageData(0, 0, d, w), m = new Uint8Array(F.data.buffer), f = new KA(), p = new n.Vector3(), R = new n.Vector3().setScalar(i * s), S = new n.Quaternion(0, 0, 0, 1);
  B = B ?? new n.Color(1, 1, 1);
  let G = 0;
  for (let M = 0; M < w; ++M)
    for (let k = 0; k < d; ++k) {
      const U = m[G + 3];
      if (U > 0) {
        const J = U / 255;
        p.set(k - 0.5 * (d - 1), 0.5 * (w - 1) - M, 0), p.multiplyScalar(s), f.pushSplat(p, R, S, J, B);
      }
      G += 4;
    }
  const Y = new OA({ packedSplats: f });
  return Y.recolor = g, Y;
}
function er({
  // URL of the image to convert to splats (example: `url: "./image.png"`)
  url: t,
  // Radius of each Gsplat, default covers 1-unit spacing well (default: 0.8)
  dotRadius: A,
  // Subsampling factor for the image. Higher values reduce resolution,
  // for example 2 will halve the width and height by averaging (default: 1)
  subXY: I,
  // Optional callback function to modify each Gsplat before it's added.
  // Return null to skip adding the Gsplat, or a number to set the opacity
  // and add the Gsplat with parameter values in the objects center, rgba etc. were
  // passed into the forEachSplat callback. Ending the callback in `return opacity;`
  // will retain the original opacity.
  // ((width: number, height: number, index: number, center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion, opacity: number, color: THREE.Color) => number | null)
  forEachSplat: g
}) {
  return A = A ?? 0.8, I = Math.max(1, Math.floor(I ?? 1)), new OA({
    constructSplats: async (B) => new Promise((i, e) => {
      const Q = new Image();
      Q.crossOrigin = "anonymous", Q.onerror = e, Q.onload = () => {
        const { width: s, height: E } = Q, a = document.createElement("canvas");
        a.width = s, a.height = E;
        const C = a.getContext("2d");
        if (!C) {
          e(new Error("Failed to create canvas context"));
          return;
        }
        C.imageSmoothingEnabled = !0, C.imageSmoothingQuality = "high";
        const o = Math.round(s / I), r = Math.round(E / I);
        C.drawImage(Q, 0, 0, o, r);
        try {
          const h = C.getImageData(0, 0, o, r), c = new Uint8Array(h.data.buffer), l = new n.Vector3(), u = new n.Vector3().setScalar(A), D = new n.Quaternion(0, 0, 0, 1), y = new n.Color();
          let d = 0;
          for (let w = 0; w < r; ++w)
            for (let F = 0; F < o; ++F) {
              const m = d * 4, f = c[m + 3];
              if (f > 0) {
                let p = f / 255;
                y.set(
                  c[m + 0] / 255,
                  c[m + 1] / 255,
                  c[m + 2] / 255
                ), l.set(
                  F - 0.5 * (o - 1),
                  0.5 * (r - 1) - w,
                  0
                ), u.setScalar(A), D.set(0, 0, 0, 1);
                let R = !0;
                if (g) {
                  const S = g(
                    o,
                    r,
                    d,
                    l,
                    u,
                    D,
                    p,
                    y
                  );
                  p = S ?? p, R = S !== null;
                }
                R && B.pushSplat(l, u, D, p, y);
              }
              d += 1;
            }
          i();
        } catch (h) {
          e(h);
        }
      }, Q.src = t;
    })
  });
}
function Do({
  box: t,
  cells: A,
  dotScale: I,
  color: g,
  opacity: B
}) {
  A.x = Math.max(1, Math.round(A.x)), A.y = Math.max(1, Math.round(A.y)), A.z = Math.max(1, Math.round(A.z)), B = B ?? 1;
  const i = A.x * A.y * A.z, e = q("int", A.x), Q = q("int", A.y);
  q("int", A.z);
  const s = HA(0), E = new cI({
    numSplats: i,
    generator: MA(
      { index: "int" },
      { gsplat: _ },
      ({ index: C }) => {
        if (!C)
          throw new Error("index is undefined");
        const o = kI(C, e), r = AI(C, e), h = kI(r, Q), c = AI(r, Q), l = TA({
          vectorType: "ivec3",
          x: o,
          y: h,
          z: c
        }), u = Ri(s), D = TA({ vectorType: "ivec2", x: C, y: u }), y = Je(D), d = q("vec3", t.min), w = q("vec3", t.max), F = Ft(w, d), m = AI(pA(nt(l), y), q("vec3", A));
        let f, p, R;
        g ? (f = q("float", g.r), p = q("float", g.g), R = q("float", g.b)) : { r: f, g: p, b: R } = pt(m).outputs;
        const S = TA({
          vectorType: "vec4",
          r: f,
          g: p,
          b: R,
          a: q("float", B)
        }), G = pA(d, nA(F, m)), Y = nt(q("float", I)), M = q("vec4", new n.Quaternion(0, 0, 0, 1));
        let k = Bt({
          flags: II("uint", "GSPLAT_FLAG_ACTIVE"),
          index: C,
          center: G,
          scales: Y,
          quaternion: M,
          rgba: S
        });
        return k = a.applyGsplat(k), { gsplat: k };
      },
      {
        globals: () => [NA]
      }
    ),
    update: ({ time: C }) => {
      s.value = C, a.update(E), E.updateVersion();
    }
  }), a = new yt();
  return E;
}
const yo = {
  box: new n.Box3(
    new n.Vector3(-1, -1, -1),
    new n.Vector3(1, 1, 1)
  ),
  density: 100,
  fallDirection: new n.Vector3(-1, -3, 1).normalize(),
  fallVelocity: 0.02,
  wanderScale: 0.04,
  wanderVariance: 2,
  color1: new n.Color(1, 1, 1),
  color2: new n.Color(0.5, 0.5, 1),
  minScale: 1e-3,
  maxScale: 5e-3,
  anisoScale: new n.Vector3(1, 1, 1)
}, wo = {
  box: new n.Box3(
    new n.Vector3(-2, -1, -2),
    new n.Vector3(2, 5, 2)
  ),
  density: 10,
  fallDirection: new n.Vector3(0, -1, 0),
  fallVelocity: 2,
  wanderScale: 0.1,
  wanderVariance: 1,
  color1: new n.Color(1, 1, 1),
  color2: new n.Color(0.25, 0.25, 0.5),
  minScale: 5e-3,
  maxScale: 0.01,
  anisoScale: new n.Vector3(0.1, 1, 0.1)
};
function po({
  // min and max box extents of the snowBox
  box: t,
  // minimum y-coordinate to clamp particle position, which can be used to
  // fake hitting a ground plane and lingering there for a bit
  minY: A,
  // number of Gsplats to generate (default: calculated from box and density)
  numSplats: I,
  // density of Gsplats per unit volume (default: 100)
  density: g,
  // The xyz anisotropic scale of the Gsplat, which can be used for example
  // to elongate rain particles (default: (1, 1, 1))
  anisoScale: B,
  // Minimum Gsplat particle scale (default: 0.001)
  minScale: i,
  // Maximum Gsplat particle scale (default: 0.005)
  maxScale: e,
  // The average direction of fall (default: (0, -1, 0))
  fallDirection: Q,
  // The average speed of the fall (multiplied with fallDirection) (default: 0.02)
  fallVelocity: s,
  // The world scale of wandering overlay motion (default: 0.01)
  wanderScale: E,
  // Controls how uniformly the particles wander in sync, more variance mean
  // more randomness in the motion (default: 2)
  wanderVariance: a,
  // Color 1 of the two colors interpolated between (default: (1, 1, 1))
  color1: C,
  // Color 2 of the two colors interpolated between (default: (0.5, 0.5, 1))
  color2: o,
  // The base opacity of the Gsplats (default: 1)
  opacity: r,
  // Optional callback function to call each frame.
  onFrame: h
}) {
  t = t ?? new n.Box3(new n.Vector3(-1, -1, -1), new n.Vector3(1, 1, 1));
  const c = (t.max.x - t.min.x) * (t.max.y - t.min.y) * (t.max.z - t.min.z);
  g = g ?? 100, I = I ?? Math.max(1, Math.min(1e6, Math.round(c * g)));
  const l = HA(i ?? 1e-3), u = HA(e ?? 5e-3), D = _A(
    ((B == null ? void 0 : B.clone()) ?? new n.Vector3(1, 1, 1)).normalize()
  ), y = _A(
    (Q ?? new n.Vector3(0, -1, 0)).normalize()
  ), d = HA(s ?? 0.02), w = HA(E ?? 0.01), F = HA(a ?? 2), m = _A(C ?? new n.Color(1, 1, 1)), f = _A(o ?? new n.Color(0.5, 0.5, 1)), p = HA(r ?? 1), R = HA(0), S = _A(new n.Vector3(0, 0, 0)), G = _A(t.min), Y = _A(t.max), M = HA(A ?? Number.NEGATIVE_INFINITY), k = Ft(Y, G), U = new cI({
    numSplats: I,
    generator: MA(
      { index: "int" },
      { gsplat: _ },
      ({ index: AA }) => {
        if (!AA)
          throw new Error("index not defined");
        const Z = xI(AA), gA = pt(Z).outputs.w;
        let tA = nt(Z), V = tI(nA(gA, q("float", 100)));
        V = RI(nA(II("float", "PI"), V)), V = pA(l, nA(V, Ft(u, l)));
        const b = nA(V, D), P = tI(nA(gA, q("float", 10))), O = tI(gA), X = LB(m, f, O), L = nA(X, P), DA = xI(
          TA({
            vectorType: "ivec2",
            x: AA,
            y: q("int", 6837)
          })
        );
        let CA = nt(DA), yA = nA(pt(DA).outputs.w, F);
        yA = pA(R, yA), tA = pA(tA, S);
        const wA = UB(
          tA,
          q("vec3", new n.Vector3(1, 1, 1))
        );
        tA = pA(G, nA(k, wA));
        const FA = q("vec4", new n.Quaternion(0, 0, 0, 1));
        CA = RI(pA(nt(yA), CA)), CA = nA(CA, w);
        let rA = pA(tA, CA), YA = pt(rA).outputs.y;
        YA = YB(M, YA), rA = TA({ vector: rA, y: YA });
        let GA = Bt({
          flags: II("uint", "GSPLAT_FLAG_ACTIVE"),
          index: AA,
          center: rA,
          scales: b,
          quaternion: FA,
          rgb: L,
          opacity: p
        });
        return GA = J.applyGsplat(GA), { gsplat: GA };
      },
      {
        globals: () => [NA]
      }
    ),
    update: ({ object: AA, time: Z, deltaTime: gA }) => {
      R.value = Z, J.update(U);
      const tA = y.value.clone().multiplyScalar(d.value * gA);
      S.value.add(tA), AA.visible = p.value > 0, h == null || h({ object: AA, time: Z, deltaTime: gA }), U.updateVersion();
    }
  }), J = new yt();
  return {
    snow: U,
    min: G,
    max: Y,
    minY: M,
    color1: m,
    color2: f,
    opacity: p,
    fallVelocity: d,
    wanderVariance: F,
    wanderScale: w,
    fallDirection: y,
    minScale: l,
    maxScale: u,
    anisoScale: D
  };
}
const Qr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DEFAULT_RAIN: wo,
  DEFAULT_SNOW: yo,
  snowBox: po,
  staticBox: Do
}, Symbol.toStringTag, { value: "Module" }));
function bQ(t) {
  return MA({ gsplat: _ }, { gsplat: _ }, ({ gsplat: A }) => {
    if (!A)
      throw new Error("No gsplat input");
    let I = SI(A);
    const g = t.applyGsplat(A), B = Ct(g).outputs.center, i = SI(g), e = ne(B, i), Q = ri(e, q("float", 0));
    I = VI(Q, OI(I), I);
    const s = pA(
      nA(I, q("float", 0.5)),
      q("float", 0.5)
    );
    return A = Bt({ gsplat: A, rgb: s }), { gsplat: A };
  });
}
function fo(t) {
  t.enableWorldToView = !0, t.worldModifier = bQ(t.context.worldToView), t.updateGenerator();
}
function TQ(t, A, I, g) {
  return MA({ gsplat: _ }, { gsplat: _ }, ({ gsplat: B }) => {
    if (!B)
      throw new Error("No gsplat input");
    let { center: i } = Ct(B).outputs;
    i = t.apply(i);
    const { z: e } = pt(i).outputs;
    let Q = He(OI(e), A, I);
    return Q = VI(g, Ft(q("float", 1), Q), Q), B = Bt({ gsplat: B, r: Q, g: Q, b: Q }), { gsplat: B };
  });
}
function Fo(t, A, I, g) {
  t.enableWorldToView = !0;
  const B = q("float", A), i = q("float", I), e = q("bool", g ?? !1);
  return t.worldModifier = TQ(
    t.context.worldToView,
    B,
    i,
    e
  ), t.updateGenerator(), {
    minDepth: B,
    maxDepth: i,
    reverse: e
  };
}
const sr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  makeDepthColorModifier: TQ,
  makeNormalColorModifier: bQ,
  setDepthColor: Fo,
  setWorldNormalColor: fo
}, Symbol.toStringTag, { value: "Module" })), Lt = class Lt {
  static createButton(A, I = {}) {
    const g = navigator.xr;
    if (!g)
      return null;
    const B = g, i = document.createElement("button");
    A.xr.enabled = !0, A.xr.setReferenceSpaceType("local");
    function e() {
      let C = null;
      async function o(c) {
        console.log("onSessionStarted"), c.addEventListener("end", r), await A.xr.setSession(c), i.textContent = "EXIT VR", C = c;
      }
      function r() {
        console.log("onSessionEnded"), C == null || C.removeEventListener("end", r), i.textContent = "ENTER VR", C = null;
      }
      i.style.display = "", i.style.cursor = "pointer", i.style.left = "calc(50% - 100px)", i.style.width = "200px", i.style.height = "100px", i.textContent = "ENTER VR";
      const h = {
        ...I,
        optionalFeatures: [
          // "local-floor",
          // "bounded-floor",
          // "layers",
          ...I.optionalFeatures || []
        ]
      };
      i.onmouseenter = () => {
        i.style.opacity = "1.0";
      }, i.onmouseleave = () => {
        i.style.opacity = "0.5";
      }, i.onclick = () => {
        C === null ? (console.log("requesting session"), B.requestSession("immersive-vr", h).then(
          o
        )) : (console.log("ending session"), C.end());
      };
    }
    function Q() {
      i.style.display = "none", i.style.cursor = "auto", i.style.left = "calc(50% - 75px)", i.style.width = "150px", i.onmouseenter = null, i.onmouseleave = null, i.onclick = null;
    }
    function s() {
      Q(), i.textContent = "VR NOT SUPPORTED";
    }
    function E(C) {
      Q(), console.warn(
        "Exception when trying to call xr.isSessionSupported",
        C
      ), i.textContent = "VR NOT ALLOWED";
    }
    function a(C) {
      C.style.position = "absolute", C.style.bottom = "20px", C.style.padding = "12px 6px", C.style.border = "1px solid #fff", C.style.borderRadius = "4px", C.style.background = "rgba(0,0,0,0.1)", C.style.color = "#fff", C.style.font = "normal 13px sans-serif", C.style.textAlign = "center", C.style.opacity = "0.5", C.style.outline = "none", C.style.zIndex = "999";
    }
    return i.id = "VRButton", i.style.display = "none", a(i), B.isSessionSupported("immersive-vr").then((C) => {
      C ? e() : s(), C && Lt.xrSessionIsGranted && i.click();
    }).catch(E), i;
  }
  static registerSessionGrantedListener() {
    const A = navigator.xr;
    if (!A)
      return null;
    const I = A;
    /WebXRViewer\//i.test(navigator.userAgent) || I.addEventListener("sessiongranted", () => {
      Lt.xrSessionIsGranted = !0;
    });
  }
};
Lt.xrSessionIsGranted = !1;
let HI = Lt;
HI.registerSessionGrantedListener();
const Go = 0.5, So = 0.5, No = 0;
var XI = /* @__PURE__ */ ((t) => (t.w = "wrist", t.t0 = "thumb-metacarpal", t.t1 = "thumb-phalanx-proximal", t.t2 = "thumb-phalanx-distal", t.t3 = "thumb-tip", t.i0 = "index-finger-metacarpal", t.i1 = "index-finger-phalanx-proximal", t.i2 = "index-finger-phalanx-intermediate", t.i3 = "index-finger-phalanx-distal", t.i4 = "index-finger-tip", t.m0 = "middle-finger-metacarpal", t.m1 = "middle-finger-phalanx-proximal", t.m2 = "middle-finger-phalanx-intermediate", t.m3 = "middle-finger-phalanx-distal", t.m4 = "middle-finger-tip", t.r0 = "ring-finger-metacarpal", t.r1 = "ring-finger-phalanx-proximal", t.r2 = "ring-finger-phalanx-intermediate", t.r3 = "ring-finger-phalanx-distal", t.r4 = "ring-finger-tip", t.p0 = "pinky-finger-metacarpal", t.p1 = "pinky-finger-phalanx-proximal", t.p2 = "pinky-finger-phalanx-intermediate", t.p3 = "pinky-finger-phalanx-distal", t.p4 = "pinky-finger-tip", t))(XI || {});
const KQ = Object.keys(XI), Cr = KQ.length, Er = {
  w: 0,
  t0: 1,
  t1: 2,
  t2: 3,
  t3: 4,
  i0: 5,
  i1: 6,
  i2: 7,
  i3: 8,
  i4: 9,
  m0: 10,
  m1: 11,
  m2: 12,
  m3: 13,
  m4: 14,
  r0: 15,
  r1: 16,
  r2: 17,
  r3: 18,
  r4: 19,
  p0: 20,
  p1: 21,
  p2: 22,
  p3: 23,
  p4: 24
}, jt = {
  w: 0.02,
  t0: 0.02,
  t1: 0.014,
  t2: 0.0115,
  t3: 85e-4,
  i0: 0.022,
  i1: 0.012,
  i2: 85e-4,
  i3: 75e-4,
  i4: 65e-4,
  m0: 0.021,
  m1: 0.012,
  m2: 8e-3,
  m3: 75e-4,
  m4: 65e-4,
  r0: 0.019,
  r1: 0.011,
  r2: 75e-4,
  r3: 7e-3,
  r4: 6e-3,
  p0: 0.012,
  p1: 0.01,
  p2: 7e-3,
  p3: 65e-4,
  p4: 55e-4
}, mo = [
  ["w", "t0", "t1", "t2", "t3"],
  ["w", "i0", "i1", "i2", "i3", "i4"],
  ["w", "m0", "m1", "m2", "m3", "m4"],
  ["w", "r0", "r1", "r2", "r3", "r4"],
  ["w", "p0", "p1", "p2", "p3", "p4"]
], Mo = [
  [8, 10, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6],
  [8, 19, 14, 8, 6]
], ar = ["t3", "i4", "m4", "r4", "p4"], nr = ["i4", "m4", "r4", "p4"];
var qQ = /* @__PURE__ */ ((t) => (t.left = "left", t.right = "right", t))(qQ || {});
const bI = Object.keys(qQ);
class or {
  constructor() {
    this.hands = {}, this.last = {}, this.values = {}, this.tests = {}, this.lastTests = {}, this.updated = !1;
  }
  update({ xr: A, xrFrame: I }) {
    const g = A.getSession();
    if (!g)
      return;
    const B = A.getReferenceSpace();
    if (B && I.getJointPose) {
      this.last = this.hands, this.lastTests = this.tests, this.hands = {}, this.values = {}, this.tests = {};
      for (const i of g.inputSources) {
        if (!i.hand)
          continue;
        const e = i.handedness;
        this.hands[e] = {};
        for (const Q of KQ) {
          const s = i.hand.get(XI[Q]);
          if (s) {
            const E = I.getJointPose(s, B);
            if (E) {
              const { position: a, orientation: C } = E.transform;
              this.hands[e][Q] = {
                position: new JA(a.x, a.y, a.z),
                quaternion: new jI(
                  C.x,
                  C.y,
                  C.z,
                  C.w
                ),
                radius: E.radius || 1e-3
              };
            }
          }
        }
      }
      for (const i of bI)
        for (const { key: e, value: Q } of [
          { key: `${i}AllTips`, value: this.allTipsTouching(i) },
          {
            key: `${i}IndexThumb`,
            value: this.touching(i, "i4", i, "t3")
          },
          {
            key: `${i}MiddleThumb`,
            value: this.touching(i, "m4", i, "t3")
          },
          {
            key: `${i}RingThumb`,
            value: this.touching(i, "r4", i, "t3")
          },
          {
            key: `${i}PinkyThumb`,
            value: this.touching(i, "p4", i, "t3")
          },
          { key: `${i}TriTips`, value: this.triTipsTouching(i) }
        ])
          this.values[e] = Q, this.tests[e] = Q === 1 ? !0 : Q === 0 ? !1 : this.lastTests[e] ?? !1;
    }
  }
  makeGhostMesh() {
    const A = new JA(), I = new JA(0.01, 0.01, 0.01), g = new jI(0, 0, 0, 1), B = new _I(1, 1, 1), i = Math.PI * 3;
    new _I(1, 1, 1);
    let e = 1;
    const Q = new OA({
      onFrame: () => {
        let s = 0;
        for (const E of bI) {
          const a = this.hands[E];
          for (const [C, o] of mo.entries())
            for (let r = 1; r < o.length; ++r) {
              const h = Mo[C][r - 1] * 2, c = r + 1 === o.length, l = a == null ? void 0 : a[o[r - 1]], u = a == null ? void 0 : a[o[r]];
              for (let D = 0; D < h; ++D) {
                const y = (D + 0.5) / h;
                if (e = 0, l && u) {
                  A.copy(l.position).lerp(u.position, y), g.copy(l.quaternion).slerp(u.quaternion, y);
                  const d = jt[o[r - 1]], w = jt[o[r]];
                  let F = (1 - y) * d + y * w;
                  c && y > 0.8 && (F *= Math.sqrt(1 - ((y - 0.8) / 0.2) ** 2)), I.set(0.65 * F, 0.5 * F, 3e-3), B.set(
                    0.55 + 0.45 * Math.sin(A.x * i),
                    0.55 + 0.45 * Math.sin(A.y * i),
                    0.55 + 0.45 * Math.sin(A.z * i)
                  ), E === "right" && B.set(1 - B.r, 1 - B.g, 1 - B.b), e = 0.75;
                }
                Q.packedSplats.setSplat(
                  s,
                  A,
                  I,
                  g,
                  e,
                  B
                ), s += 1;
              }
            }
        }
        Q.packedSplats.numSplats = s, Q.packedSplats.needsUpdate = !0, Q.numSplats = s, Q.updateVersion();
      }
    });
    return Q;
  }
  distance(A, I, g, B, i = !1) {
    const e = i ? this.last[A] : this.hands[A], Q = i ? this.last[g] : this.hands[g], s = e == null ? void 0 : e[I], E = Q == null ? void 0 : Q[B];
    return !s || !E ? Number.POSITIVE_INFINITY : s.position.distanceTo(E.position);
  }
  separation(A, I, g, B, i = !1) {
    const e = this.distance(A, I, g, B, i);
    return e === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : e - jt[I] - jt[B];
  }
  touching(A, I, g, B, i = !1) {
    const e = this.separation(A, I, g, B, i);
    return e === Number.POSITIVE_INFINITY ? Number.POSITIVE_INFINITY : 1 - Math.max(0, Math.min(1, e / 0.01 - No));
  }
  allTipsTouching(A, I = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", I),
      this.touching(A, "i4", A, "m4", I),
      this.touching(A, "m4", A, "r4", I),
      this.touching(A, "r4", A, "p4", I)
      // this.touching(hand, "p4", hand, "t3", last),
    );
  }
  triTipsTouching(A, I = !1) {
    return Math.min(
      this.touching(A, "t3", A, "i4", I),
      this.touching(A, "i4", A, "m4", I),
      this.touching(A, "m4", A, "t3", I)
    );
  }
}
class rr {
  constructor({
    xrHands: A,
    control: I,
    moveInertia: g,
    rotateInertia: B
  }) {
    this.lastGrip = {}, this.lastPivot = new JA(), this.rotateVelocity = 0, this.velocity = new JA(), this.xrHands = A, this.control = I, this.moveInertia = g ?? Go, this.rotateInertia = B ?? So;
  }
  update(A) {
    var i, e, Q, s, E;
    const I = {};
    for (const a of bI) {
      const C = this.xrHands.hands[a];
      C && this.xrHands.tests[`${a}MiddleThumb`] && (I[a] = new JA().add(((i = C.t3) == null ? void 0 : i.position) ?? new JA()).add(((e = C.i4) == null ? void 0 : e.position) ?? new JA()).add(((Q = C.m4) == null ? void 0 : Q.position) ?? new JA()).add(((s = C.r4) == null ? void 0 : s.position) ?? new JA()).add(((E = C.p4) == null ? void 0 : E.position) ?? new JA()).multiplyScalar(1 / 5));
    }
    if (I.left && I.right && this.lastGrip.left && this.lastGrip.right) {
      const a = I.left.clone().add(I.right).multiplyScalar(0.5), C = this.lastGrip.left.clone().add(this.lastGrip.right).multiplyScalar(0.5);
      this.lastPivot = a;
      const o = a.clone().applyMatrix4(this.control.matrix);
      o.sub(C.clone().applyMatrix4(this.control.matrix)), o.multiplyScalar(1 / A), this.velocity.lerp(o, 1 - Math.exp(-20 * A));
      const r = Math.atan2(I.left.z - a.z, I.left.x - a.x), h = Math.atan2(
        this.lastGrip.left.z - C.z,
        this.lastGrip.left.x - C.x
      );
      let c = r - h;
      c > Math.PI ? c -= Math.PI * 2 : c < -Math.PI && (c += Math.PI * 2);
      const l = c / A, u = Math.exp(-20 * A);
      this.rotateVelocity = this.rotateVelocity * u + l * (1 - u);
    } else if (this.rotateVelocity *= Math.exp(-A / this.rotateInertia), I.left && this.lastGrip.left) {
      const a = I.left.clone().applyMatrix4(this.control.matrix);
      a.sub(this.lastGrip.left.clone().applyMatrix4(this.control.matrix)), a.multiplyScalar(1 / A), this.velocity.lerp(a, 1 - Math.exp(-20 * A));
    } else if (I.right && this.lastGrip.right) {
      const a = I.right.clone().applyMatrix4(this.control.matrix);
      a.sub(
        this.lastGrip.right.clone().applyMatrix4(this.control.matrix)
      ), a.multiplyScalar(1 / A), this.velocity.lerp(a, 1 - Math.exp(-20 * A));
    } else
      this.velocity.multiplyScalar(Math.exp(-A / this.moveInertia));
    const g = this.lastPivot.clone().negate(), B = new wI().makeTranslation(g).premultiply(new wI().makeRotationY(this.rotateVelocity * A)).premultiply(new wI().makeTranslation(this.lastPivot));
    this.control.matrix.multiply(B), this.control.matrix.decompose(
      this.control.position,
      this.control.quaternion,
      this.control.scale
    ), this.control.updateMatrixWorld(!0), this.control.position.sub(this.velocity.clone().multiplyScalar(A)), this.lastGrip = I;
  }
}
const ko = 1, xo = 2, Ro = 2e-3, Uo = 6e-3, Yo = 15e-4, Lo = 0.15, Jo = 0.15, Ho = 0.1, bo = 2, To = 1, Ko = 200, qo = 400, vo = 50, Zo = {
  KeyW: new n.Vector3(0, 0, -1),
  KeyS: new n.Vector3(0, 0, 1),
  KeyA: new n.Vector3(-1, 0, 0),
  KeyD: new n.Vector3(1, 0, 0),
  KeyR: new n.Vector3(0, 1, 0),
  KeyF: new n.Vector3(0, -1, 0)
}, zo = {
  ArrowUp: new n.Vector3(0, 0, -1),
  ArrowDown: new n.Vector3(0, 0, 1),
  ArrowLeft: new n.Vector3(-1, 0, 0),
  ArrowRight: new n.Vector3(1, 0, 0),
  PageUp: new n.Vector3(0, 1, 0),
  PageDown: new n.Vector3(0, -1, 0)
}, Wo = {
  KeyQ: new n.Vector3(0, 0, 1),
  KeyE: new n.Vector3(0, 0, -1)
}, Oo = {
  Home: new n.Vector3(0, -1, 0),
  End: new n.Vector3(0, 1, 0),
  Insert: new n.Vector3(-1, 0, 0),
  Delete: new n.Vector3(1, 0, 0)
};
class cr {
  constructor({ canvas: A }) {
    this.lastTime = 0, this.fpsMovement = new Vo({}), this.pointerControls = new Po({ canvas: A });
  }
  update(A) {
    const I = performance.now(), g = (I - (this.lastTime || I)) / 1e3;
    this.lastTime = I, this.fpsMovement.update(g, A), this.pointerControls.update(g, A);
  }
}
class Vo {
  constructor({
    moveSpeed: A,
    rollSpeed: I,
    stickThreshold: g,
    rotateSpeed: B,
    keycodeMoveMapping: i,
    keycodeRotateMapping: e,
    gamepadMapping: Q,
    capsMultiplier: s,
    shiftMultiplier: E,
    ctrlMultiplier: a,
    xr: C
  } = {}) {
    this.enable = !0, this.moveSpeed = A ?? ko, this.rollSpeed = I ?? xo, this.stickThreshold = g ?? Ho, this.rotateSpeed = B ?? bo, this.keycodeMoveMapping = i ?? {
      ...Zo,
      ...zo
    }, this.keycodeRotateMapping = e ?? {
      ...Wo,
      ...Oo
    }, this.gamepadMapping = Q ?? {
      4: "rollLeft",
      5: "rollRight",
      6: "ctrl",
      7: "shift"
    }, this.capsMultiplier = s ?? 10, this.shiftMultiplier = E ?? 5, this.ctrlMultiplier = a ?? 1 / 5, this.xr = C, this.keydown = {}, this.keycode = {}, document.addEventListener("keydown", (o) => {
      this.keydown[o.key] = !0, this.keycode[o.code] = !0;
    }), document.addEventListener("keyup", (o) => {
      this.keydown[o.key] = !1, this.keycode[o.code] = !1;
    }), window.addEventListener("blur", () => {
      this.keydown = {}, this.keycode = {};
    });
  }
  // Call this method in your render loop with `control` set to the object to control
  // (`THREE.Camera` or a `THREE.Object3D` that contains it), with `deltaTime`
  // in seconds since the last update.
  update(A, I) {
    var a, C;
    if (!this.enable)
      return;
    const g = [new n.Vector2(), new n.Vector2()], B = navigator.getGamepads()[0];
    B && (g[0].set(B.axes[0], B.axes[1]), g[1].set(B.axes[2], B.axes[3]));
    const i = (B == null ? void 0 : B.buttons.map((o) => o.pressed)) || [], e = Array.from(((C = (a = this.xr) == null ? void 0 : a.getSession()) == null ? void 0 : C.inputSources) ?? []);
    for (const o of e) {
      const r = o.gamepad;
      if (r)
        switch (o.handedness) {
          case "none": {
            g[0].x += r.axes[0], g[0].y += r.axes[1], g[1].x += r.axes[2], g[1].y += r.axes[3];
            break;
          }
          case "left": {
            g[0].x += r.axes[2], g[0].y += r.axes[3];
            break;
          }
          case "right": {
            g[1].x += r.axes[2], g[1].y += r.axes[3];
            break;
          }
        }
    }
    for (const o of g)
      o.x = Math.abs(o.x) >= this.stickThreshold ? o.x : 0, o.y = Math.abs(o.y) >= this.stickThreshold ? o.y : 0;
    const Q = new n.Vector3(
      g[1].x,
      g[1].y,
      0
    ).multiplyScalar(this.rotateSpeed);
    for (const [o, r] of Object.entries(this.keycodeRotateMapping))
      this.keycode[o] && Q.add(r);
    for (const o in this.gamepadMapping)
      if (i[Number.parseInt(o)])
        switch (this.gamepadMapping[o]) {
          case "rollLeft":
            Q.z += 1;
            break;
          case "rollRight":
            Q.z -= 1;
            break;
        }
    if (Q.multiply(
      new n.Vector3(this.rotateSpeed, this.rotateSpeed, this.rollSpeed)
    ), Q.manhattanLength() > 0) {
      Q.multiplyScalar(A);
      const o = new n.Euler().setFromQuaternion(
        I.quaternion,
        "YXZ"
      );
      o.y -= Q.x, o.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, o.x - Q.y)
      ), o.z = Math.max(-Math.PI, Math.min(Math.PI, o.z + Q.z)), I.quaternion.setFromEuler(o);
    }
    const s = new n.Vector3(g[0].x, 0, g[0].y);
    for (const [o, r] of Object.entries(this.keycodeMoveMapping))
      this.keycode[o] && s.add(r);
    let E = 1;
    this.keydown.CapsLock && (E *= this.capsMultiplier), (this.keycode.ShiftLeft || this.keycode.ShiftRight) && (E *= this.shiftMultiplier), (this.keycode.ControlLeft || this.keycode.ControlRight) && (E *= this.ctrlMultiplier);
    for (const o in this.gamepadMapping)
      if (i[Number.parseInt(o)])
        switch (this.gamepadMapping[o]) {
          case "shift":
            E *= this.shiftMultiplier;
            break;
          case "ctrl":
            E *= this.ctrlMultiplier;
            break;
        }
    s.applyQuaternion(I.quaternion), I.position.add(
      s.multiplyScalar(this.moveSpeed * E * A)
    );
  }
}
class Po {
  constructor({
    // The HTML canvas element to attach pointer events to
    canvas: A,
    // Speed of rotation (default DEFAULT_ROTATE_SPEED)
    rotateSpeed: I,
    // Speed of sliding when dragging with right/middle mouse button or two fingers
    // (default DEFAULT_SLIDE_SPEED)
    slideSpeed: g,
    // Speed of movement when using mouse scroll wheel (default DEFAULT_SCROLL_SPEED)
    scrollSpeed: B,
    // Swap the direction of rotation and sliding (default: false)
    swapRotateSlide: i,
    // Reverse the direction of rotation (default: false)
    reverseRotate: e,
    // Reverse the direction of sliding (default: false)
    reverseSlide: Q,
    // Reverse the direction of swipe gestures (default: false)
    reverseSwipe: s,
    // Reverse the direction of scroll wheel movement (default: false)
    reverseScroll: E,
    // Inertia factor for movement (default: DEFAULT_MOVE_INERTIA)
    moveInertia: a,
    // Inertia factor for rotation (default: DEFAULT_ROTATE_INERTIA)
    rotateInertia: C,
    // Pointer rolling scale factor (default: DEFAULT_POINTER_ROLL_SCALE)
    pointerRollScale: o,
    // Callback for double press events (default: () => {})
    doublePress: r
  }) {
    this.enable = !0, this.canvas = A, this.rotateSpeed = I ?? Ro, this.slideSpeed = g ?? Uo, this.scrollSpeed = B ?? Yo, this.swapRotateSlide = i ?? !1, this.reverseRotate = e ?? !1, this.reverseSlide = Q ?? !1, this.reverseSwipe = s ?? !1, this.reverseScroll = E ?? !1, this.moveInertia = a ?? Jo, this.rotateInertia = C ?? Lo, this.pointerRollScale = o ?? To, this.doublePress = r ?? (() => {
    }), this.doublePressLimitMs = qo, this.doublePressDistance = vo, this.lastUp = null, this.rotating = null, this.sliding = null, this.dualPress = !1, this.scroll = new n.Vector3(), this.rotateVelocity = new n.Vector3(), this.moveVelocity = new n.Vector3(), A.addEventListener("pointerdown", (c) => {
      const l = this.getPointerPosition(c), u = l.clone(), D = l.clone(), y = !this.swapRotateSlide && !this.rotating && (c.pointerType !== "mouse" || c.button === 0) || this.swapRotateSlide && this.sliding && !this.rotating && (c.pointerType !== "mouse" || c.button === 1), { pointerId: d, timeStamp: w } = c;
      if (y)
        this.rotating = { initial: u, last: D, position: l, pointerId: d, timeStamp: w }, A.setPointerCapture(c.pointerId), this.dualPress = !1;
      else if (!this.sliding) {
        const F = c.pointerType === "mouse" ? c.button : void 0;
        this.sliding = {
          initial: u,
          last: D,
          position: l,
          pointerId: d,
          button: F,
          timeStamp: w
        }, A.setPointerCapture(c.pointerId), this.dualPress = this.rotating != null && w - this.rotating.timeStamp < Ko;
      }
    });
    const h = (c) => {
      var D, y;
      ((D = this.rotating) == null ? void 0 : D.pointerId) === c.pointerId ? (this.rotating = null, A.releasePointerCapture(c.pointerId), this.dualPress && this.sliding && (A.releasePointerCapture(this.sliding.pointerId), this.sliding = null)) : ((y = this.sliding) == null ? void 0 : y.pointerId) === c.pointerId && (this.sliding = null, A.releasePointerCapture(c.pointerId), this.dualPress && this.rotating && (A.releasePointerCapture(this.rotating.pointerId), this.rotating = null));
      const l = this.getPointerPosition(c), u = this.lastUp;
      if (this.lastUp = { position: l, time: c.timeStamp }, u && u.position.distanceTo(l) < this.doublePressDistance) {
        const w = c.timeStamp - u.time;
        w < this.doublePressLimitMs && (this.lastUp = null, this.doublePress({ position: l, intervalMs: w }));
      }
    };
    document.addEventListener("pointerup", h), document.addEventListener("pointercancel", h), document.addEventListener("pointermove", (c) => {
      var l, u;
      ((l = this.rotating) == null ? void 0 : l.pointerId) === c.pointerId ? this.rotating.position = this.getPointerPosition(c) : ((u = this.sliding) == null ? void 0 : u.pointerId) === c.pointerId && (this.sliding.position = this.getPointerPosition(c));
    }), A.addEventListener("contextmenu", (c) => {
      c.preventDefault();
    }), A.addEventListener("wheel", (c) => {
      this.scroll.add(
        new n.Vector3(c.deltaX, c.deltaY, c.deltaZ)
      ), c.preventDefault();
    });
  }
  getPointerPosition(A) {
    const I = this.canvas.getBoundingClientRect();
    return new n.Vector2(
      A.clientX - I.left,
      A.clientY - I.top
    );
  }
  update(A, I) {
    if (!this.enable)
      return;
    if (this.dualPress && this.rotating && this.sliding) {
      const B = [
        this.rotating.position.clone().sub(this.rotating.last),
        this.sliding.position.clone().sub(this.sliding.last)
      ], i = B[0].dot(B[1]);
      if (i >= 0.2) {
        const e = B[0].clone().add(B[1]), Q = new n.Vector3(e.x, -e.y, 0);
        Q.multiplyScalar(this.slideSpeed * (this.reverseSwipe ? 1 : -1)), Q.applyQuaternion(I.quaternion), I.position.add(Q), this.moveVelocity = Q.clone().multiplyScalar(1 / A);
      } else if (i <= -0.2) {
        const e = this.sliding.last.clone().sub(this.rotating.last), Q = e.length();
        e.multiplyScalar(1 / Q).normalize();
        const s = new n.Vector2(-e.y, e.x), E = [B[0].dot(e), B[1].dot(e)], a = [B[0].dot(s), B[1].dot(s)], C = this.rotating.last.clone().add(this.sliding.last).multiplyScalar(0.5);
        let o = new n.Vector3();
        if (I instanceof n.Camera) {
          const D = new n.Vector2(
            C.x / this.canvas.clientWidth * 2 - 1,
            -(C.y / this.canvas.clientHeight) * 2 + 1
          ), y = new n.Raycaster();
          y.setFromCamera(D, I), o = y.ray.direction;
        }
        const r = E[1] - E[0], h = o.multiplyScalar(r * this.slideSpeed);
        I.position.add(h), this.moveVelocity = h.clone().multiplyScalar(1 / A);
        const c = [
          Math.atan(a[0] / (-0.5 * Q)),
          Math.atan(a[1] / (0.5 * Q))
        ], l = 0.5 * (c[0] + c[1]) * this.pointerRollScale, u = new n.Euler().setFromQuaternion(
          I.quaternion,
          "YXZ"
        );
        u.z = Math.max(
          -Math.PI,
          Math.min(Math.PI, u.z + 0.5 * l)
        ), I.quaternion.setFromEuler(u);
      }
      this.rotating.last.copy(this.rotating.position), this.sliding.last.copy(this.sliding.position);
    } else {
      const B = new n.Vector3();
      if (this.rotating && !this.dualPress) {
        const e = this.rotating.position.clone().sub(this.rotating.last);
        this.rotating.last.copy(this.rotating.position), B.set(e.x, e.y, 0), B.multiplyScalar(this.rotateSpeed * (this.reverseRotate ? -1 : 1)), this.rotateVelocity = B.clone().multiplyScalar(1 / A);
      } else
        this.rotateVelocity.multiplyScalar(
          Math.exp(-A / this.rotateInertia)
        ), B.addScaledVector(this.rotateVelocity, A);
      const i = new n.Euler().setFromQuaternion(
        I.quaternion,
        "YXZ"
      );
      if (i.y -= B.x, i.x = Math.max(
        -Math.PI / 2,
        Math.min(Math.PI / 2, i.x - B.y)
      ), i.z *= Math.exp(-0 * A), I.quaternion.setFromEuler(i), this.sliding && !this.dualPress) {
        const e = this.sliding.position.clone().sub(this.sliding.last);
        this.sliding.last.copy(this.sliding.position);
        const Q = this.sliding.button !== 2 ? new n.Vector3(e.x, 0, e.y) : new n.Vector3(e.x, -e.y, 0);
        Q.multiplyScalar(this.slideSpeed * (this.reverseSlide ? -1 : 1)), Q.applyQuaternion(I.quaternion), I.position.add(Q), this.moveVelocity = Q.clone().multiplyScalar(1 / A);
      } else
        this.moveVelocity.multiplyScalar(
          Math.exp(-A / this.moveInertia)
        ), I.position.addScaledVector(this.moveVelocity, A);
    }
    const g = this.scroll.multiplyScalar(this.scrollSpeed);
    g.set(g.x, g.z, g.y), this.reverseScroll && g.multiplyScalar(-1), g.applyQuaternion(I.quaternion), I.position.add(g), this.scroll.set(0, 0, 0);
  }
}
export {
  nr as FINGER_TIPS,
  Vo as FpsMovement,
  bI as HANDS,
  qQ as Hand,
  rr as HandMovement,
  KQ as JOINT_IDS,
  Er as JOINT_INDEX,
  jt as JOINT_RADIUS,
  mo as JOINT_SEGMENTS,
  Mo as JOINT_SEGMENT_STEPS,
  ar as JOINT_TIPS,
  XI as JointEnum,
  Cr as NUM_JOINTS,
  KA as PackedSplats,
  QI as PlyReader,
  Po as PointerControls,
  iI as Readback,
  yC as Sint8ToFloat,
  cr as SparkControls,
  EI as SparkRenderer,
  CI as SparkViewpoint,
  FI as SplatAccumulator,
  eI as SplatEdit,
  xn as SplatEditRgbaBlendMode,
  Un as SplatEditSdf,
  Mn as SplatEditSdfType,
  Yn as SplatEdits,
  Rt as SplatFileType,
  cI as SplatGenerator,
  Xn as SplatLoader,
  OA as SplatMesh,
  Jn as SplatModifier,
  tr as SplatSkinning,
  yt as SplatTransformer,
  oo as SpzReader,
  $A as SpzWriter,
  DC as Uint8ToFloat,
  HI as VRButton,
  or as XrHands,
  gr as constructAxes,
  Ir as constructGrid,
  Br as constructSpherePoints,
  _o as dyno,
  TC as flipPixels,
  $t as floatToSint8,
  mA as floatToUint8,
  dA as fromHalf,
  Qr as generators,
  mQ as getSplatFileType,
  er as imageSplats,
  HC as isAndroid,
  JC as isMobile,
  bC as isOculus,
  $o as isPcSogs,
  sr as modifiers,
  KC as pixelsToPngUrl,
  mI as setPackedSplat,
  ir as textSplats,
  at as toHalf,
  Ar as transcodeSpz,
  MI as unpackSplat,
  xQ as unpackSplats,
  jo as utils
};
//# sourceMappingURL=spark.module.min.js.map
